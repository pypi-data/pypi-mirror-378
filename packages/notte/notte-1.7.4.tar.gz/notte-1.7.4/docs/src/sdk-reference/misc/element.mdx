---
title: "Element"
description: "`Element` is the superclass to all specific elements"
---



Elements contain attributes and child nodes.
They can be described as a cross between a list and a dictionary.

Elements emulate dictionaries for external [#]_ attributes, indexing by
attribute name (a string). To set the attribute 'att' to 'value', do::

    element['att'] = 'value'

.. [#] External attributes correspond to the XML element attributes.
   From its `Node` superclass, Element also inherits "internal"
   class attributes that are accessed using the standard syntax, e.g.
   ``element.parent``.

There are two special attributes: 'ids' and 'names'.  Both are
lists of unique identifiers: 'ids' conform to the regular expression
``[a-z](-?[a-z0-9]+)*`` (see the make_id() function for rationale and
details). 'names' serve as user-friendly interfaces to IDs; they are
case- and whitespace-normalized (see the fully_normalize_name() function).

Elements emulate lists for child nodes (element nodes and/or text
nodes), indexing by integer.  To get the first child node, use::

    element[0]

to iterate over the child nodes (without descending), use::

    for child in element:
        ...

Elements may be constructed using the ``+=`` operator.  To add one new
child node to element, do::

    element += node

This is equivalent to ``element.append(node)``.

To add a list of multiple child nodes at once, use the same ``+=``
operator::

    element += [node1, node2]

This is equivalent to ``element.extend([node1, node2])``

## Methods

### is_not_known_attribute

```python
is_not_known_attribute(attr)
```

Returns True if and only if the given attribute is NOT recognized by
this class

---

### is_not_list_attribute

```python
is_not_list_attribute(attr)
```

Returns True if and only if the given attribute is NOT one of the
basic list attributes defined for all Elements

---

### append

```python
append(item)
```

---

### append_attr_list

```python
append_attr_list(attr, values)
```

For each element in values, if it does not exist in self[attr], append
it

---

### asdom

```python
asdom(dom = None)
```

Return a DOM **fragment** representation of this Node

---

### astext

```python
astext()
```

Return a string representation of this Node

---

### attlist

```python
attlist()
```

---

### clear

```python
clear()
```

---

### coerce_append_attr_list

```python
coerce_append_attr_list(attr, value)
```

First, convert both self[attr] and value to a non-string sequence
type; if either is not already a sequence, convert it to a list of one
element

---

### copy

```python
copy(el: Element) -> Element
```

Monkey-patch ```nodes

**Returns:**

[`Element`](/sdk-reference/misc/element)

---

### copy_attr_coerce

```python
copy_attr_coerce(attr, value, replace)
```

If attr is an attribute of self and either self[attr] or value is a
list, convert all non-sequence values to a sequence of 1 element and
then concatenate the two sequence, setting the result to self[attr]

---

### copy_attr_concatenate

```python
copy_attr_concatenate(attr, value, replace)
```

If attr is an attribute of self and both self[attr] and value are
lists, concatenate the two sequences, setting the result to
self[attr]

---

### copy_attr_consistent

```python
copy_attr_consistent(attr, value, replace)
```

If replace is True or self[attr] is None, replace self[attr] with
value

---

### copy_attr_convert

```python
copy_attr_convert(attr, value, replace = True)
```

If attr is an attribute of self, set self[attr] to
[self[attr], value], otherwise set self[attr] to value

---

### deepcopy

```python
deepcopy(el: Element) -> Element
```

Monkey-patch ```nodes

**Returns:**

[`Element`](/sdk-reference/misc/element)

---

### delattr

```python
delattr(attr)
```

---

### emptytag

```python
emptytag()
```

---

### endtag

```python
endtag()
```

---

### extend

```python
extend(item)
```

---

### findall

```python
findall(condition = None, include_self = True, descend = True, siblings = False, ascend = False)
```

Return an iterator yielding nodes following `self`:

* self (if `include_self` is true)
* all descendants in tree traversal order (if `descend` is true)
* the following siblings (if `siblings` is true) and their
  descendants (if also `descend` is true)
* the following siblings of the parent (if `ascend` is true) and
  their descendants (if also `descend` is true), and so on

---

### first_child_matching_class

```python
first_child_matching_class(childclass, start = 0, end = 9223372036854775807)
```

Return the index of the first child whose class exactly matches

---

### first_child_not_matching_class

```python
first_child_not_matching_class(childclass, start = 0, end = 9223372036854775807)
```

Return the index of the first child whose class does *not* match

---

### get

```python
get(key, failobj = None)
```

---

### get_language_code

```python
get_language_code(fallback = )
```

Return node's language tag

---

### has_key

```python
has_key(attr)
```

---

### hasattr

```python
hasattr(attr)
```

---

### index

```python
index(item, start = 0, stop = 9223372036854775807)
```

---

### insert

```python
insert(index, item)
```

---

### is_not_default

```python
is_not_default(key)
```

---

### next_node

```python
next_node(condition = None, include_self = False, descend = True, siblings = False, ascend = False)
```

Return the first node in the iterator returned by findall(),
or None if the iterable is empty

---

### non_default_attributes

```python
non_default_attributes()
```

---

### note_referenced_by

```python
note_referenced_by(name = None, id = None)
```

Note that this Element has been referenced by its name
`name` or id `id`

---

### pformat

```python
pformat(indent =     , level = 0)
```

Return an indented pseudo-XML representation, for test purposes

---

### pop

```python
pop(i = -1)
```

---

### previous_sibling

```python
previous_sibling()
```

Return preceding sibling node or ``None``

---

### remove

```python
remove(item)
```

---

### replace

```python
replace(old, new)
```

Replace one child `Node` with another child or children

---

### replace_attr

```python
replace_attr(attr, value, force = True)
```

If self[attr] does not exist or force is True or omitted, set
self[attr] to value, otherwise do nothing

---

### replace_self

```python
replace_self(new)
```

Replace `self` node with `new`, where `new` is a node or a
list of nodes

---

### set_class

```python
set_class(name)
```

Add a new class to the "classes" attribute

---

### setdefault

```python
setdefault(key, failobj = None)
```

---

### setup_child

```python
setup_child(child)
```

---

### shortrepr

```python
shortrepr()
```

---

### starttag

```python
starttag(quoteattr = None)
```

---

### traverse

```python
traverse(condition = None, include_self = True, descend = True, siblings = False, ascend = False)
```

Return list of nodes following `self`

---

### update_all_atts

```python
update_all_atts(dict_, update_fun = <function Element.copy_attr_consistent at 0x100aede40>, replace = True, and_source = False)
```

Updates all attributes from node or dictionary `dict_`

---

### update_all_atts_coercion

```python
update_all_atts_coercion(dict_, replace = True, and_source = False)
```

Updates all attributes from node or dictionary `dict_`

---

### update_all_atts_concatenating

```python
update_all_atts_concatenating(dict_, replace = True, and_source = False)
```

Updates all attributes from node or dictionary `dict_`

---

### update_all_atts_consistantly

```python
update_all_atts_consistantly(dict_, replace = True, and_source = False)
```

Updates all attributes from node or dictionary `dict_`

---

### update_all_atts_convert

```python
update_all_atts_convert(dict_, and_source = False)
```

Updates all attributes from node or dictionary `dict_`

---

### update_basic_atts

```python
update_basic_atts(dict_)
```

Update basic attributes ('ids', 'names', 'classes',
'dupnames', but not 'source') from node or dictionary `dict_`

---

### walk

```python
walk(visitor)
```

Traverse a tree of `Node` objects, calling the
`dispatch_visit()` method of `visitor` when entering each
node

---

### walkabout

```python
walkabout(visitor)
```

Perform a tree traversal similarly to `Node

---


## Inheritance

Inherits from: Node


## Module

`docutils.nodes`
