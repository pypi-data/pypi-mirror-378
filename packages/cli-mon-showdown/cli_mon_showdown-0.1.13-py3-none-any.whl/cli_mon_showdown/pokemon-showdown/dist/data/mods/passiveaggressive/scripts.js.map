{
  "version": 3,
  "sources": ["../../../../data/mods/passiveaggressive/scripts.ts"],
  "sourcesContent": ["export const Scripts: ModdedBattleScriptsData = {\n\tgen: 9,\n\tactions: {\n\t\thitStepMoveHitLoop(targets, pokemon, move) { // Temporary name\n\t\t\tlet damage: (number | boolean | undefined)[] = [];\n\t\t\tfor (const i of targets.keys()) {\n\t\t\t\tdamage[i] = 0;\n\t\t\t}\n\t\t\tmove.totalDamage = 0;\n\t\t\tpokemon.lastDamage = 0;\n\t\t\tlet targetHits = move.multihit || 1;\n\t\t\tif (Array.isArray(targetHits)) {\n\t\t\t\t// yes, it's hardcoded... meh\n\t\t\t\tif (targetHits[0] === 2 && targetHits[1] === 5) {\n\t\t\t\t\tif (this.battle.gen >= 5) {\n\t\t\t\t\t\t// 35-35-15-15 out of 100 for 2-3-4-5 hits\n\t\t\t\t\t\ttargetHits = this.battle.sample([2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 5, 5, 5]);\n\t\t\t\t\t\tif (targetHits < 4 && pokemon.hasItem('loadeddice')) {\n\t\t\t\t\t\t\ttargetHits = 5 - this.battle.random(2);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttargetHits = this.battle.sample([2, 2, 2, 3, 3, 3, 4, 5]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttargetHits = this.battle.random(targetHits[0], targetHits[1] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (targetHits === 10 && pokemon.hasItem('loadeddice')) targetHits -= this.battle.random(7);\n\t\t\ttargetHits = Math.floor(targetHits);\n\t\t\tlet nullDamage = true;\n\t\t\tlet moveDamage: (number | boolean | undefined)[] = [];\n\t\t\t// There is no need to recursively check the \u00B4sleepUsable\u00B4 flag as Sleep Talk can only be used while asleep.\n\t\t\tconst isSleepUsable = move.sleepUsable || this.dex.moves.get(move.sourceEffect).sleepUsable;\n\n\t\t\tlet targetsCopy: (Pokemon | false | null)[] = targets.slice(0);\n\t\t\tlet hit: number;\n\t\t\tfor (hit = 1; hit <= targetHits; hit++) {\n\t\t\t\tif (damage.includes(false)) break;\n\t\t\t\tif (hit > 1 && pokemon.status === 'slp' && (!isSleepUsable || this.battle.gen === 4)) break;\n\t\t\t\tif (targets.every(target => !target?.hp)) break;\n\t\t\t\tmove.hit = hit;\n\t\t\t\tif (move.smartTarget && targets.length > 1) {\n\t\t\t\t\ttargetsCopy = [targets[hit - 1]];\n\t\t\t\t\tdamage = [damage[hit - 1]];\n\t\t\t\t} else {\n\t\t\t\t\ttargetsCopy = targets.slice(0);\n\t\t\t\t}\n\t\t\t\tconst target = targetsCopy[0]; // some relevant-to-single-target-moves-only things are hardcoded\n\t\t\t\tif (target && typeof move.smartTarget === 'boolean') {\n\t\t\t\t\tif (hit > 1) {\n\t\t\t\t\t\tthis.battle.addMove('-anim', pokemon, move.name, target);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.battle.retargetLastMove(target);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// like this (Triple Kick)\n\t\t\t\tif (target && move.multiaccuracy && hit > 1) {\n\t\t\t\t\tlet accuracy = move.accuracy;\n\t\t\t\t\tconst boostTable = [1, 4 / 3, 5 / 3, 2, 7 / 3, 8 / 3, 3];\n\t\t\t\t\tif (accuracy !== true) {\n\t\t\t\t\t\tif (!move.ignoreAccuracy) {\n\t\t\t\t\t\t\tconst boosts = this.battle.runEvent('ModifyBoost', pokemon, null, null, { ...pokemon.boosts });\n\t\t\t\t\t\t\tconst boost = this.battle.clampIntRange(boosts['accuracy'], -6, 6);\n\t\t\t\t\t\t\tif (boost > 0) {\n\t\t\t\t\t\t\t\taccuracy *= boostTable[boost];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\taccuracy /= boostTable[-boost];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!move.ignoreEvasion) {\n\t\t\t\t\t\t\tconst boosts = this.battle.runEvent('ModifyBoost', target, null, null, { ...target.boosts });\n\t\t\t\t\t\t\tconst boost = this.battle.clampIntRange(boosts['evasion'], -6, 6);\n\t\t\t\t\t\t\tif (boost > 0) {\n\t\t\t\t\t\t\t\taccuracy /= boostTable[boost];\n\t\t\t\t\t\t\t} else if (boost < 0) {\n\t\t\t\t\t\t\t\taccuracy *= boostTable[-boost];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\taccuracy = this.battle.runEvent('ModifyAccuracy', target, pokemon, move, accuracy);\n\t\t\t\t\tif (!move.alwaysHit) {\n\t\t\t\t\t\taccuracy = this.battle.runEvent('Accuracy', target, pokemon, move, accuracy);\n\t\t\t\t\t\tif (accuracy !== true && !this.battle.randomChance(accuracy, 100)) break;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst moveData = move;\n\t\t\t\tif (!moveData.flags) moveData.flags = {};\n\n\t\t\t\tlet moveDamageThisHit;\n\t\t\t\t// Modifies targetsCopy (which is why it's a copy)\n\t\t\t\t[moveDamageThisHit, targetsCopy] = this.spreadMoveHit(targetsCopy, pokemon, move, moveData);\n\t\t\t\t// When Dragon Darts targets two different pokemon, targetsCopy is a length 1 array each hit\n\t\t\t\t// so spreadMoveHit returns a length 1 damage array\n\t\t\t\tif (move.smartTarget) {\n\t\t\t\t\tmoveDamage.push(...moveDamageThisHit);\n\t\t\t\t} else {\n\t\t\t\t\tmoveDamage = moveDamageThisHit;\n\t\t\t\t}\n\n\t\t\t\tif (!moveDamage.some(val => val !== false)) break;\n\t\t\t\tnullDamage = false;\n\n\t\t\t\tfor (const [i, md] of moveDamage.entries()) {\n\t\t\t\t\tif (move.smartTarget && i !== hit - 1) continue;\n\t\t\t\t\t// Damage from each hit is individually counted for the\n\t\t\t\t\t// purposes of Counter, Metal Burst, and Mirror Coat.\n\t\t\t\t\tdamage[i] = md === true || !md ? 0 : md;\n\t\t\t\t\t// Total damage dealt is accumulated for the purposes of recoil (Parental Bond).\n\t\t\t\t\tmove.totalDamage += damage[i];\n\t\t\t\t}\n\t\t\t\tif (move.mindBlownRecoil) {\n\t\t\t\t\tconst hpBeforeRecoil = pokemon.hp;\n\t\t\t\t\tconst calc = calculate(this.battle, pokemon, pokemon, move.id);\n\t\t\t\t\tthis.battle.damage(Math.round(calc * pokemon.maxhp / 2), pokemon, pokemon, this.dex.conditions.get(move.id), true);\n\t\t\t\t\tmove.mindBlownRecoil = false;\n\t\t\t\t\tif (pokemon.hp <= pokemon.maxhp / 2 && hpBeforeRecoil > pokemon.maxhp / 2) {\n\t\t\t\t\t\tthis.battle.runEvent('EmergencyExit', pokemon, pokemon);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.battle.eachEvent('Update');\n\t\t\t\tif (!pokemon.hp && targets.length === 1) {\n\t\t\t\t\thit++; // report the correct number of hits for multihit moves\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// hit is 1 higher than the actual hit count\n\t\t\tif (hit === 1) return damage.fill(false);\n\t\t\tif (nullDamage) damage.fill(false);\n\t\t\tthis.battle.faintMessages(false, false, !pokemon.hp);\n\t\t\tif (move.multihit && typeof move.smartTarget !== 'boolean') {\n\t\t\t\tthis.battle.add('-hitcount', targets[0], hit - 1);\n\t\t\t}\n\n\t\t\tif ((move.recoil || move.id === 'chloroblast') && move.totalDamage) {\n\t\t\t\tconst hpBeforeRecoil = pokemon.hp;\n\t\t\t\tconst recoilDamage = this.calcRecoilDamage(move.totalDamage, move, pokemon);\n\t\t\t\tif (recoilDamage !== 1.1) this.battle.damage(recoilDamage, pokemon, pokemon, 'recoil');\n\t\t\t\tif (pokemon.hp <= pokemon.maxhp / 2 && hpBeforeRecoil > pokemon.maxhp / 2) {\n\t\t\t\t\tthis.battle.runEvent('EmergencyExit', pokemon, pokemon);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (move.struggleRecoil) {\n\t\t\t\tconst hpBeforeRecoil = pokemon.hp;\n\t\t\t\tlet recoilDamage;\n\t\t\t\tif (this.dex.gen >= 5) {\n\t\t\t\t\trecoilDamage = this.battle.clampIntRange(Math.round(pokemon.baseMaxhp / 4), 1);\n\t\t\t\t} else {\n\t\t\t\t\trecoilDamage = this.battle.clampIntRange(this.battle.trunc(pokemon.maxhp / 4), 1);\n\t\t\t\t}\n\t\t\t\tthis.battle.directDamage(recoilDamage, pokemon, pokemon, { id: 'strugglerecoil' } as Condition);\n\t\t\t\tif (pokemon.hp <= pokemon.maxhp / 2 && hpBeforeRecoil > pokemon.maxhp / 2) {\n\t\t\t\t\tthis.battle.runEvent('EmergencyExit', pokemon, pokemon);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// smartTarget messes up targetsCopy, but smartTarget should in theory ensure that targets will never fail, anyway\n\t\t\tif (move.smartTarget) {\n\t\t\t\ttargetsCopy = targets.slice(0);\n\t\t\t}\n\n\t\t\tfor (const [i, target] of targetsCopy.entries()) {\n\t\t\t\tif (target && pokemon !== target) {\n\t\t\t\t\ttarget.gotAttacked(move, moveDamage[i] as number | false | undefined, pokemon);\n\t\t\t\t\tif (typeof moveDamage[i] === 'number') {\n\t\t\t\t\t\ttarget.timesAttacked += move.smartTarget ? 1 : hit - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (move.ohko && !targets[0].hp) this.battle.add('-ohko');\n\n\t\t\tif (!damage.some(val => !!val || val === 0)) return damage;\n\n\t\t\tthis.battle.eachEvent('Update');\n\n\t\t\tthis.afterMoveSecondaryEvent(targetsCopy.filter(val => !!val), pokemon, move);\n\n\t\t\tif (!(move.hasSheerForce && pokemon.hasAbility('sheerforce'))) {\n\t\t\t\tfor (const [i, d] of damage.entries()) {\n\t\t\t\t\t// There are no multihit spread moves, so it's safe to use move.totalDamage for multihit moves\n\t\t\t\t\t// The previous check was for `move.multihit`, but that fails for Dragon Darts\n\t\t\t\t\tconst curDamage = targets.length === 1 ? move.totalDamage : d;\n\t\t\t\t\tif (typeof curDamage === 'number' && targets[i].hp) {\n\t\t\t\t\t\tconst targetHPBeforeDamage = (targets[i].hurtThisTurn || 0) + curDamage;\n\t\t\t\t\t\tif (targets[i].hp <= targets[i].maxhp / 2 && targetHPBeforeDamage > targets[i].maxhp / 2) {\n\t\t\t\t\t\t\tthis.battle.runEvent('EmergencyExit', targets[i], pokemon);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn damage;\n\t\t},\n\t\tcalcRecoilDamage(damageDealt, move, pokemon): number {\n\t\t\tconst calc = calculate(this.battle, pokemon, pokemon, move.id);\n\t\t\tif (calc === 0) return 1.1;\n\t\t\tif (move.id === 'chloroblast') return Math.round(calc * pokemon.maxhp / 2);\n\t\t\tconst recoil = Math.round(damageDealt * calc * move.recoil![0] / move.recoil![1]);\n\t\t\treturn this.battle.clampIntRange(recoil, 1);\n\t\t},\n\t},\n};\n\nfunction calculate(battle: Battle, source: Pokemon, pokemon: Pokemon, moveid = 'tackle') {\n\tconst move = battle.dex.getActiveMove(moveid);\n\tmove.type = source.getTypes()[0];\n\tconst typeMod = 2 ** battle.clampIntRange(pokemon.runEffectiveness(move), -6, 6);\n\tif (!pokemon.runImmunity(move)) return 0;\n\treturn typeMod;\n}\n"],
  "mappings": "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",
  "names": ["target"]
}
