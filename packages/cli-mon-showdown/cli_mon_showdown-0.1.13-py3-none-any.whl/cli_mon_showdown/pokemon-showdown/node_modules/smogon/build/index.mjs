// index.ts
var latest = import("./latest-DHRRMYRV.mjs");
var LATEST = latest;
var GENS = ["rb", "gs", "rs", "dp", "bw", "xy", "sm", "ss", "sv"];
var PARSE_REGEX = /dexSettings = ({.*})/;
function toID(text) {
  return ("" + text).toLowerCase().replace(/[^a-z0-9]+/g, "");
}
function toAlias(text) {
  return ("" + text).toLowerCase().replace(/[ _]+/, "-").replace(/[^a-z0-9-]+/g, "");
}
function toPokemonAlias(text) {
  const alias = toAlias(text);
  return alias === "meowstic" ? "meowstic-m" : alias;
}
var Analyses = new class {
  constructor() {
    this.URL = "https://www.smogon.com/dex/";
    this.RPC = "_rpc/dump-pokemon";
  }
  /**
   * Returns the Analysis URL for a given pokemon and gen.
   * @deprecated use Analyses.request
   */
  url(pokemon, gen = 9) {
    return `${Analyses.URL}${Analyses.gen(gen)}/pokemon/${toPokemonAlias(pokemon)}/`;
  }
  /**
   * Returns the Analysis RPC URL and request configuration for a given pokemon and gen.
   */
  request(pokemon, gen = 9, language = "en") {
    return {
      url: `${Analyses.URL}${Analyses.RPC}`,
      init: {
        method: "POST",
        headers: {
          "content-type": "application/json"
        },
        body: JSON.stringify({ gen: Analyses.gen(gen), alias: toPokemonAlias(pokemon), language })
      }
    };
  }
  /**
   * Parses out the DexSettings object embedded in the raw HTML retrieved from the Smogon dex.
   */
  parse(raw) {
    const match = PARSE_REGEX.exec(raw);
    if (!match)
      return void 0;
    return JSON.parse(match[1]);
  }
  /**
   * Given either the raw HTML retrieved from the Smogon dex, the parsed DexSettings object, or
   * an RPC response, returns a map of Analysis objects keyed by format or undefined if its input
   * was invalid.
   */
  process(ds) {
    var _a, _b;
    const parsed = typeof ds === "string" ? Analyses.parse(ds) : ds;
    if (!parsed)
      return void 0;
    let strategies;
    if ("injectRpcs" in parsed) {
      const valid = (_b = (_a = parsed.injectRpcs[2]) == null ? void 0 : _a[1]) == null ? void 0 : _b["strategies"];
      if (!valid)
        return void 0;
      strategies = valid;
    } else {
      strategies = parsed.strategies;
    }
    const analysesByFormat = /* @__PURE__ */ new Map();
    for (const analysis of strategies) {
      let analyses = analysesByFormat.get(analysis.format);
      if (!analyses) {
        analyses = [];
        analysesByFormat.set(analysis.format, analyses);
      }
      analyses.push(analysis);
    }
    return analysesByFormat;
  }
  /**
   * Returns Smogon's display representation of the given gen.
   */
  gen(gen) {
    return GENS[gen - 1];
  }
}();
var LEGACY = /* @__PURE__ */ new Set([
  "1v1",
  "anythinggoes",
  "battlespotdoubles",
  "battlespotsingles",
  "battlespottriples",
  "cap",
  "lc",
  "monotype",
  "nu",
  "ou",
  "pu",
  "randombattle",
  "ru",
  "ubers",
  "uu",
  "balancedhackmons",
  "doublesou",
  "doublesuu",
  "battlefactory",
  "mixandmega",
  "vgc2016",
  "ounoteampreview",
  "customgame",
  "doublescustomgame",
  "triplescustomgame",
  "purehackmons",
  "almostanyability"
]);
var Statistics = new class {
  constructor() {
    this.URL = "https://www.smogon.com/stats/";
  }
  /**
   * Given the HTML page returned from querying the Statistics.URL, returns the most recent
   * date stats are available for. This should usually be the beginning of the current month,
   * but this approach is more robust due to timezone differences and delays in publishing.
   */
  latest(page) {
    const lines = page.split("\n");
    let i = lines.length;
    while (i--) {
      const line = lines[i];
      if (line.startsWith("<a href=")) {
        return line.slice(9, 16);
      }
    }
    throw new Error("Unexpected format for index");
  }
  /**
   * Given the HTML page returned from querying a URL listing available reports, returns the list of
   * available formats.
   */
  formats(page) {
    const lines = page.split("\n");
    const formats = [];
    for (const line of lines) {
      if (line.startsWith("<a href=")) {
        const quote = line.indexOf('"', 9);
        const split = line.slice(9, quote).split("-");
        if (split.length !== 2)
          continue;
        if (!formats.length || formats[formats.length - 1] !== split[0])
          formats.push(split[0]);
      }
    }
    return formats;
  }
  /**
   * Returns the URL of the reports for the given date and format, defaulting to providing the
   * highest detailed ('chaos') weighted stats available for the format in question. Unweighted
   * stats or stats of a specific weight or alternative reports may also be requested, though may be
   * absent depending on the date and format.
   */
  url(date, format, weighted = true, report = "chaos") {
    let formatid = toID(format);
    if (!(date === "2016-12" && ["gen6randombattle", "randombattle"].includes(formatid))) {
      formatid = formatFor(formatid, date);
    }
    const rating = weighted ? typeof weighted === "number" ? weighted : weightFor(formatid, date) : 0;
    if (report === "usage")
      return `${Statistics.URL}${date}/${formatid}-${rating}.txt`;
    const ext = report === "chaos" ? "json" : "txt";
    return `${Statistics.URL}${date}/${report}/${formatid}-${rating}.${ext}`;
  }
  /**
   * Returns the date and count of the latest stats available for the given format at the time
   * this package was published. If best is provided, it will return the date and count for the
   * most recent month where a substantial enough amount of data was gathered. Returns undefined
   * if there is no data present. Note the accuracy of this function depends on the data in
   * latest.json being kept up to date.
   */
  async latestDate(format, best = false) {
    format = Statistics.canonicalize(toID(format));
    const data = (await LATEST)[format];
    if (!data)
      return void 0;
    const [date, count] = Array.isArray(data[0]) ? data[+best] : data;
    return { date, count };
  }
  /**
   * Returns the canconical format name for the given format.
   */
  canonicalize(format) {
    return LEGACY.has(format) ? `gen6${format}` : format;
  }
  /**
   * Processes what was fetched from the URL returned by Statistics.url into UsageStatistics.
   */
  process(raw) {
    return JSON.parse(raw);
  }
}();
var POPULAR = {
  6: [
    "ou",
    "oususpecttest",
    "doublesou",
    "randombattle",
    "smogondoubles",
    "doublesou",
    "doublesoususpecttest"
  ],
  7: [
    "gen7ou",
    "gen7oususpecttest",
    "gen7doublesou",
    "gen7doublesoususpecttest",
    "gen7pokebankou",
    "gen7pokebankoususpecttest",
    "gen7pokebankdoublesou"
  ],
  8: ["gen8doublesou", "gen8doublesoususpect", "gen8ou", "gen8oususpecttest"],
  9: ["gen9doublesou", "gen9doublesoususpect", "gen9ou", "gen9oususpecttest"]
};
function weightFor(format, date) {
  if (POPULAR[6].includes(format))
    return 1695;
  if (format === "gen7doublesou" && date < "2017-02")
    return 1630;
  if (POPULAR[7].includes(format))
    return date > "2020-01" ? 1630 : 1695;
  if (format === "smogondoublessuspecttest" && date === "2015-04")
    return 1695;
  if (POPULAR[8].includes(format))
    return date > "2022-10" ? 1630 : 1695;
  return POPULAR[9].includes(format) ? 1695 : 1630;
}
var LATE = ["1v1", "cap", "monotype", "balancedhackmons", "mixandmega"];
var FORMAT_REGEX = /gen(\d)(.*)/;
function formatFor(format, date) {
  if (["gen6randombattle", "randombattle"].includes(format) && date > "2016-12") {
    return "gen6randombattle";
  }
  const m = FORMAT_REGEX.exec(format);
  if (m && m[1] !== "6")
    return format;
  if (m && !LEGACY.has(m[2]))
    return m[2];
  if (m) {
    return date < "2017-07" || date < "2018-01" && LATE.includes(m[2]) ? m[2] : format;
  } else {
    return date > "2017-12" || date > "2017-06" && !LATE.includes(format) ? `gen6${format}` : format;
  }
}
export {
  Analyses,
  Statistics
};
//# sourceMappingURL=index.mjs.map