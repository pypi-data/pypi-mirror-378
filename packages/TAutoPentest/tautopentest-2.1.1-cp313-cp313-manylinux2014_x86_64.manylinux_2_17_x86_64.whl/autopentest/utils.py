"""
Utility functions for AI Powered Auto-PenTester
===============================================

Copyright (c) 2025/1404 D3F417 - Iran
All rights reserved.

This software is proprietary and confidential.
Unauthorized copying, distribution, modification, or use is strictly prohibited.
For licensing inquiries, contact the author.

Contains common functions for command execution, logging, and file operations.

Author: D3F417
License: Proprietary - All Rights Reserved
"""

import os
import re
import subprocess
import time
from datetime import datetime
from pathlib import Path
from typing import Tuple, List

try:
    from colorama import init, Fore, Style
    init(autoreset=True)
except ImportError:
    print("Error: colorama not installed. Run: pip install colorama")
    exit(1)

from config import COLORS, REPORTS_DIR


class Logger:
    """Handles logging and colored output for the application."""
    
    def __init__(self):
        """Initialize the logger with an empty session log."""
        self.session_log = []
    
    def color_print(self, message: str, color: str = "white") -> None:
        """
        Print colored messages to console and log them.
        
        Args:
            message (str): Message to print
            color (str): Color name from config.COLORS
        """
        color_map = {
            "blue": Fore.BLUE,
            "green": Fore.GREEN,
            "yellow": Fore.YELLOW,
            "red": Fore.RED,
            "white": Fore.WHITE,
            "cyan": Fore.CYAN,
            "magenta": Fore.MAGENTA,
            "bright_blue": Fore.LIGHTBLUE_EX,
            "bright_green": Fore.LIGHTGREEN_EX,
            "bright_yellow": Fore.LIGHTYELLOW_EX,
            "bright_red": Fore.LIGHTRED_EX,
            "bright_cyan": Fore.LIGHTCYAN_EX,
            "bright_magenta": Fore.LIGHTMAGENTA_EX,
            "orange": Fore.LIGHTYELLOW_EX,
            "purple": Fore.LIGHTMAGENTA_EX,
            "gray": Fore.LIGHTBLACK_EX
        }
        
        colored_msg = f"{color_map.get(color, Fore.WHITE)}{message}{Style.RESET_ALL}"
        print(colored_msg)
        
        # Log without ANSI codes
        clean_msg = self.strip_ansi_codes(message)
        timestamp = datetime.now().strftime("%H:%M:%S")
        self.session_log.append(f"[{timestamp}] {clean_msg}")
    
    def strip_ansi_codes(self, text: str) -> str:
        """
        Remove ANSI color codes from text.
        
        Args:
            text (str): Text with potential ANSI codes
            
        Returns:
            str: Clean text without ANSI codes
        """
        ansi_escape = re.compile(r'\x1b\[[0-9;]*m')
        return ansi_escape.sub('', text)
    
    def get_session_log(self) -> List[str]:
        """
        Get the current session log.
        
        Returns:
            List[str]: List of log entries
        """
        return self.session_log.copy()
    
    def success(self, message: str) -> None:
        """Print success message in green."""
        self.color_print(message, "green")
    
    def info(self, message: str) -> None:
        """Print info message in blue."""
        self.color_print(message, "blue")
    
    def warning(self, message: str) -> None:
        """Print warning message in yellow."""
        self.color_print(message, "yellow")
    
    def error(self, message: str) -> None:
        """Print error message in red."""
        self.color_print(message, "red")


class CommandExecutor:
    """Handles safe command execution with error handling."""
    
    def __init__(self, logger: Logger):
        """
        Initialize command executor with logger.
        
        Args:
            logger (Logger): Logger instance for output
        """
        self.logger = logger
    
    def run_command(self, command: str, timeout: int = 300) -> Tuple[bool, str, str]:
        """
        Execute system commands safely with error handling.
        
        Args:
            command (str): Command to execute
            timeout (int): Command timeout in seconds
            
        Returns:
            Tuple[bool, str, str]: (success, stdout, stderr)
        """
        try:
            self.logger.color_print(f"Executing: {command}", "cyan")
            
            process = subprocess.Popen(
                command,
                shell=True,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                universal_newlines=True
            )
            
            stdout, stderr = process.communicate(timeout=timeout)
            success = process.returncode == 0
            
            return success, stdout, stderr
            
        except subprocess.TimeoutExpired:
            process.kill()
            error_msg = f"Command timed out after {timeout} seconds"
            self.logger.color_print(error_msg, "yellow")
            return False, "", error_msg
            
        except Exception as e:
            error_msg = f"Command execution failed: {str(e)}"
            self.logger.color_print(error_msg, "red")
            return False, "", error_msg


class FileManager:
    """Handles file operations and report generation."""
    
    def __init__(self, logger: Logger):
        """
        Initialize file manager with logger.
        
        Args:
            logger (Logger): Logger instance for output
        """
        self.logger = logger
        self.reports_dir = Path(REPORTS_DIR)
        self.ensure_reports_directory()
    
    def ensure_reports_directory(self) -> None:
        """Create reports directory if it doesn't exist."""
        try:
            self.reports_dir.mkdir(exist_ok=True)
            self.logger.color_print(f"Reports directory ready: {self.reports_dir}", "blue")
        except Exception as e:
            self.logger.color_print(f"Failed to create reports directory: {str(e)}", "red")
    
    def save_report(self, content: str, filename_prefix: str = "autopentest") -> str:
        """
        Save report content to timestamped file.
        
        Args:
            content (str): Report content to save
            filename_prefix (str): Prefix for the filename
            
        Returns:
            str: Path to saved report file
        """
        timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
        filename = f"{filename_prefix}_{timestamp}.txt"
        filepath = self.reports_dir / filename
        
        try:
            with open(filepath, 'w', encoding='utf-8') as f:
                f.write(content)
            
            self.logger.color_print(f"Report saved to: {filepath}", "green")
            return str(filepath)
            
        except Exception as e:
            self.logger.color_print(f"Failed to save report: {str(e)}", "red")
            return ""
    
    def create_temp_file(self, content: str, filename: str, temp_dir: str = "/tmp") -> str:
        """
        Create a temporary file with given content.
        
        Args:
            content (str): Content to write to file
            filename (str): Name of the temporary file
            temp_dir (str): Temporary directory path
            
        Returns:
            str: Path to created temporary file
        """
        filepath = os.path.join(temp_dir, filename)
        
        try:
            with open(filepath, 'w', encoding='utf-8') as f:
                f.write(content)
            return filepath
        except Exception as e:
            self.logger.color_print(f"Failed to create temp file: {str(e)}", "red")
            return ""
    
    def cleanup_temp_file(self, filepath: str) -> None:
        """
        Remove temporary file safely.
        
        Args:
            filepath (str): Path to file to remove
        """
        try:
            if os.path.exists(filepath):
                os.remove(filepath)
                self.logger.color_print(f"Cleaned up temp file: {filepath}", "blue")
        except Exception as e:
            self.logger.color_print(f"Failed to cleanup temp file: {str(e)}", "yellow")


class ReportGenerator:
    """Generates comprehensive penetration testing reports."""
    
    def __init__(self, logger: Logger):
        """
        Initialize report generator with logger.
        
        Args:
            logger (Logger): Logger instance for output
        """
        self.logger = logger
    
    def generate_full_report(self, target: str, nmap_output: str, ai_analysis: str,
                           exploit_module: str, exploit_output: str, session_log: List[str]) -> str:
        """
        Generate comprehensive penetration testing report.
        
        Args:
            target (str): Target IP/hostname
            nmap_output (str): Nmap scan results
            ai_analysis (str): AI vulnerability analysis
            exploit_module (str): Used Metasploit module
            exploit_output (str): Exploitation results
            session_log (List[str]): Session log entries
            
        Returns:
            str: Formatted report content
        """
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        report_sections = [
            self._generate_header(target, timestamp),
            self._generate_nmap_section(nmap_output),
            self._generate_ai_section(ai_analysis),
            self._generate_exploit_section(exploit_module, exploit_output),
            self._generate_log_section(session_log),
            self._generate_footer()
        ]
        
        return "\n".join(report_sections)
    
    def generate_report(self, report_data: dict, report_format: str = "txt") -> str:
        """
        Generate report from structured data and save to file.
        
        Args:
            report_data (dict): Report data containing target, scan_results, ai_analysis, etc.
            report_format (str): Format of the report ('txt' or 'html')
            
        Returns:
            str: Path to generated report file
        """
        try:
            target = report_data.get('target', 'Unknown')
            timestamp = report_data.get('timestamp', datetime.now().strftime("%Y-%m-%d %H:%M:%S"))
            scan_results = report_data.get('scan_results', '')
            ai_analysis = report_data.get('ai_analysis', '')
            session_id = report_data.get('session_id', str(int(time.time())))
            
            # Ensure target is a string for filename
            if not isinstance(target, str):
                target = str(target)
            
            # Ensure ai_analysis is always a string
            if isinstance(ai_analysis, dict):
                ai_analysis = str(ai_analysis)
            elif not isinstance(ai_analysis, str):
                ai_analysis = str(ai_analysis) if ai_analysis else "AI analysis was not available"
            
            if report_format.lower() == 'html':
                # Generate HTML report
                report_content = self._generate_html_report(target, timestamp, scan_results, ai_analysis)
                filename = f"pentest_report_{target.replace('.', '_')}_{session_id}.html"
            else:
                # Generate TXT report
                report_content = self._generate_txt_report(target, timestamp, scan_results, ai_analysis)
                filename = f"pentest_report_{target.replace('.', '_')}_{session_id}.txt"
            
            # Save report to file
            filepath = os.path.join(os.getcwd(), filename)
            
            with open(filepath, 'w', encoding='utf-8') as f:
                f.write(report_content)
            
            self.logger.success(f"📄 {report_format.upper()} Report saved to: {filepath}")
            return filepath
            
        except Exception as e:
            self.logger.error(f"Failed to generate report: {str(e)}")
            return None
    
    def _generate_txt_report(self, target: str, timestamp: str, scan_results: str, ai_analysis) -> str:
        """Generate TXT format report."""
        # Handle scan_results - ensure it's a string
        if isinstance(scan_results, dict):
            scan_results_str = str(scan_results)
        elif isinstance(scan_results, str):
            scan_results_str = scan_results
        else:
            scan_results_str = str(scan_results) if scan_results else ""
            
        # Handle ai_analysis - it might be string or dict
        if isinstance(ai_analysis, dict):
            ai_analysis_text = str(ai_analysis)
        elif isinstance(ai_analysis, str) and ai_analysis:
            ai_analysis_text = ai_analysis
        else:
            ai_analysis_text = "AI analysis was not available"
            
        # Ensure ai_analysis_text is a valid string
        if not ai_analysis_text or not isinstance(ai_analysis_text, str):
            ai_analysis_text = "AI analysis was not available"
            
        return f"""
{'='*80}
AI POWERED AUTO-PENETRATION TEST REPORT
{'='*80}

Target: {target}
Date: {timestamp}
Tool: TAuto Pentest v2.0 by Tehran Community Team (tcommunity.pro)

{'='*80}
EXECUTIVE SUMMARY
{'='*80}

This report contains the results of an automated penetration test conducted
against {target} using AI-powered vulnerability analysis and automated
exploitation techniques.

{'='*80}
SCAN RESULTS
{'='*80}

{scan_results_str if scan_results_str else "No scan results available"}

{'='*80}
AI VULNERABILITY ANALYSIS
{'='*80}

{ai_analysis_text if ai_analysis_text else "AI analysis was not available"}

{'='*80}
RECOMMENDATIONS
{'='*80}

Based on the AI analysis above, please review the identified vulnerabilities
and implement appropriate security measures.

{'='*80}
DISCLAIMER
{'='*80}

This report is for authorized testing purposes only. The findings should be
used to improve security posture and not for malicious activities.

Report generated by TAuto Pentest v2.0
"""
    
    def _generate_html_report(self, target: str, timestamp: str, scan_results: str, ai_analysis) -> str:
        """Generate beautiful cyber-themed HTML report."""
        # Escape HTML characters in content
        # Ensure scan_results is a string
        if isinstance(scan_results, dict):
            scan_results_str = str(scan_results)
        elif isinstance(scan_results, str):
            scan_results_str = scan_results
        else:
            scan_results_str = str(scan_results) if scan_results else ""
            
        scan_results_html = scan_results_str.replace('<', '&lt;').replace('>', '&gt;').replace('\n', '<br>') if scan_results_str else "No scan results available"
        
        # Handle ai_analysis - it might be string or dict
        if isinstance(ai_analysis, dict):
            ai_analysis_text = str(ai_analysis)
        elif isinstance(ai_analysis, str) and ai_analysis:
            ai_analysis_text = ai_analysis
        else:
            ai_analysis_text = "AI analysis was not available"
            
        # Ensure ai_analysis_text is not None or empty before applying replace
        if ai_analysis_text and isinstance(ai_analysis_text, str):
            ai_analysis_html = ai_analysis_text.replace('<', '&lt;').replace('>', '&gt;').replace('\n', '<br>')
        else:
            ai_analysis_html = "AI analysis was not available"
        
        return f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TAuto Pentest Report - {target}</title>
    <style>
        * {{
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }}
        
        body {{
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f8fafc;
            color: #334155;
            line-height: 1.6;
        }}
        
        .container {{
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
        }}
        
        .header {{
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px;
            border-radius: 12px;
            text-align: center;
            margin-bottom: 30px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
        }}
        
        .header h1 {{
            font-size: 2.2em;
            font-weight: 700;
            margin-bottom: 10px;
        }}
        
        .header p {{
            font-size: 1.1em;
            opacity: 0.9;
        }}
        
        .info-grid {{
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }}
        
        .info-card {{
            background: white;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
            border-left: 4px solid #667eea;
        }}
        
        .info-card h3 {{
            color: #475569;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
            font-weight: 600;
        }}
        
        .info-card p {{
            font-size: 1.1em;
            font-weight: 600;
            color: #1e293b;
        }}
        
        .section {{
            background: white;
            border-radius: 12px;
            margin-bottom: 25px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
            overflow: hidden;
        }}
        
        .section-header {{
            background: #f1f5f9;
            padding: 20px 25px;
            border-bottom: 1px solid #e2e8f0;
        }}
        
        .section-header h2 {{
            color: #1e293b;
            font-size: 1.3em;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }}
        
        .section-content {{
            padding: 25px;
        }}
        
        .results-container {{
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 20px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.9em;
            line-height: 1.5;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-x: auto;
            max-height: 500px;
            overflow-y: auto;
        }}
        
        .analysis-container {{
            background: #fefefe;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 20px;
            line-height: 1.7;
        }}
        
        .summary-text {{
            font-size: 1.05em;
            line-height: 1.7;
            color: #475569;
        }}
        
        .recommendations {{
            background: #f0f9ff;
            border: 1px solid #bae6fd;
            border-radius: 8px;
            padding: 20px;
        }}
        
        .recommendations ul {{
            margin-left: 20px;
            margin-top: 15px;
        }}
        
        .recommendations li {{
            margin-bottom: 8px;
            color: #0f172a;
        }}
        
        .disclaimer {{
            background: #fef3c7;
            border: 1px solid #fbbf24;
            color: #92400e;
            padding: 20px;
            border-radius: 8px;
            margin: 30px 0;
        }}
        
        .disclaimer strong {{
            color: #78350f;
        }}
        
        .footer {{
            text-align: center;
            margin-top: 40px;
            padding: 25px;
            color: #64748b;
            border-top: 1px solid #e2e8f0;
        }}
        
        .badge {{
            display: inline-block;
            background: #667eea;
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8em;
            font-weight: 500;
            margin-left: 10px;
        }}
        
        @media (max-width: 768px) {{
            .container {{
                padding: 15px;
            }}
            
            .header {{
                padding: 30px 20px;
            }}
            
            .header h1 {{
                font-size: 1.8em;
            }}
            
            .info-grid {{
                grid-template-columns: 1fr;
            }}
            
            .section-content {{
                padding: 20px;
            }}
        }}
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🛡️ TAuto Pentest Report</h1>
            <p>Automated Penetration Testing & Vulnerability Analysis</p>
        </div>
        
        <div class="info-grid">
            <div class="info-card">
                <h3>Target System</h3>
                <p>{target}</p>
            </div>
            <div class="info-card">
                <h3>Assessment Date</h3>
                <p>{timestamp}</p>
            </div>
            <div class="info-card">
                <h3>Tool Version</h3>
                <p>TAuto Pentest v2.0</p>
            </div>
            <div class="info-card">
                <h3>Analysis Type</h3>
                <p>AI-Powered <span class="badge">Advanced</span></p>
            </div>
        </div>
        
        <div class="section">
            <div class="section-header">
                <h2>📋 Executive Summary</h2>
            </div>
            <div class="section-content">
                <div class="summary-text">
                    <p>This comprehensive TAuto Pentest was conducted against <strong>{target}</strong> using automated penetration testing tools combined with artificial intelligence analysis.</p>
                    <br>
                    <p>The assessment includes network scanning, vulnerability identification, and AI-powered risk analysis to provide actionable security insights.</p>
                </div>
            </div>
        </div>
        
        <div class="section">
            <div class="section-header">
                <h2>🔍 Technical Scan Results</h2>
            </div>
            <div class="section-content">
                <div class="results-container">{scan_results_html}</div>
            </div>
        </div>
        
        <div class="section">
            <div class="section-header">
                <h2>🤖 AI Security Analysis</h2>
            </div>
            <div class="section-content">
                <div class="analysis-container">{ai_analysis_html}</div>
            </div>
        </div>
        
        <div class="section">
            <div class="section-header">
                <h2>💡 Security Recommendations</h2>
            </div>
            <div class="section-content">
                <div class="recommendations">
                    <p><strong>Based on the analysis above, implement the following security measures:</strong></p>
                    <ul>
                        <li>Address all critical and high-severity vulnerabilities immediately</li>
                        <li>Implement proper network segmentation and access controls</li>
                        <li>Ensure all systems and software are updated to latest versions</li>
                        <li>Deploy comprehensive monitoring and logging solutions</li>
                        <li>Conduct regular TAuto Pentest assessments and penetration testing</li>
                        <li>Implement multi-factor authentication where applicable</li>
                        <li>Review and strengthen password policies</li>
                    </ul>
                </div>
            </div>
        </div>
        
        <div class="disclaimer">
            <strong>⚠️ Important Disclaimer:</strong> This TAuto Pentest assessment is conducted for authorized testing purposes only. All findings should be used to improve the security posture of the target system. Unauthorized penetration testing activities are strictly prohibited and may be illegal.
        </div>
        
        <div class="footer">
            <p><strong>TAuto Pentest v2.0</strong> | AI-Powered Security Assessment Tool</p>
            <p>Report generated automatically | © 2025tehranCommunity Team (tcommunity.pro)</p>
        </div>
    </div>
</body>
</html>"""
    
    def _generate_header(self, target: str, timestamp: str) -> str:
        """Generate report header section."""
        return f"""
{'='*80}
AI POWERED AUTO-PENETRATION TEST REPORT
{'='*80}

Target: {target}
Date: {timestamp}
Tool: TAuto Pentest v2.0

{'='*80}
EXECUTIVE SUMMARY
{'='*80}

This report contains the results of an automated penetration test conducted
against {target} using AI-powered vulnerability analysis and automated
exploitation techniques.
"""
    
    def _generate_nmap_section(self, nmap_output: str) -> str:
        """Generate Nmap results section."""
        return f"""
{'='*80}
NMAP SCAN RESULTS
{'='*80}

{nmap_output}
"""
    
    def _generate_ai_section(self, ai_analysis: str) -> str:
        """Generate AI analysis section."""
        return f"""
{'='*80}
AI VULNERABILITY ANALYSIS
{'='*80}

{ai_analysis if ai_analysis else "AI analysis was not available"}
"""
    
    def _generate_exploit_section(self, exploit_module: str, exploit_output: str) -> str:
        """Generate exploitation section."""
        return f"""
{'='*80}
EXPLOITATION ATTEMPT
{'='*80}

Module Used: {exploit_module if exploit_module else "No module selected"}

Results:
{exploit_output if exploit_output else "No exploitation was performed"}
"""
    
    def _generate_log_section(self, session_log: List[str]) -> str:
        """Generate session log section."""
        log_content = "\n".join(session_log)
        return f"""
{'='*80}
SESSION LOG
{'='*80}

{log_content}
"""
    
    def _generate_footer(self) -> str:
        """Generate report footer."""
        return f"""
{'='*80}
END OF REPORT
{'='*80}
"""


def validate_target(target: str) -> bool:
    """
    Validate target IP address or hostname.
    
    Args:
        target (str): Target to validate
        
    Returns:
        bool: True if valid, False otherwise
    """
    if not target or not target.strip():
        return False
    
    target = target.strip()
    
    ip_pattern = r'^(\d{1,3}\.){3}\d{1,3}$'
    if re.match(ip_pattern, target):
        parts = target.split('.')
        return all(0 <= int(part) <= 255 for part in parts)
    
    hostname_pattern = r'^[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?)*$'
    return bool(re.match(hostname_pattern, target))


def format_banner() -> str:
    """
    Get formatted banner for the application.
    
    Returns:
        str: Formatted banner with colors
    """
    return f"""
{Fore.CYAN}
╔══════════════════════════════════════════════════════════════╗
║                   AI POWERED AUTO-PENTESTER                 ║
║                        Version 1.0                          ║
║              For Authorized Testing Only                     ║
╚══════════════════════════════════════════════════════════════╝
{Style.RESET_ALL}
"""