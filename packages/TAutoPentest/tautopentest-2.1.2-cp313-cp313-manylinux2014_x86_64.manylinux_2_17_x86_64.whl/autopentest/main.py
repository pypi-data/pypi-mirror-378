#!/usr/bin/env python3
"""
AI-Powered Auto-PenTester - Main Entry Point
============================================

Copyright (c) 2025/1404 D3F417 - Iran
All rights reserved.

This software is proprietary and confidential.
Unauthorized copying, distribution, modification, or use is strictly prohibited.
For licensing inquiries, contact the author.

A comprehensive automated penetration testing tool that combines:
- Network reconnaissance with Nmap
- AI-powered vulnerability analysis via Pollinations.ai
- Automated exploitation with Metasploit
- Professional reporting

Usage:
    python main.py                    # Interactive mode
    python main.py <target>           # Direct target mode
    python main.py --help             # Show help

Author: D3F417
Version: 1.0
License: Proprietary - All Rights Reserved
"""

import sys
import argparse
import os
from typing import Optional

sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

try:
    from config import Config
    from autopentest_core import TAutoPentest
    from utils import Logger
except ImportError as e:
    print(f"❌ Import Error: {e}")
    print("🔧 Make sure all required modules are in the same directory:")
    print("   - config.py")
    print("   - autopentest_core.py") 
    print("   - utils.py")
    print("   - ai_analyzer.py")
    sys.exit(1)


def display_banner():
    """Display the application banner with enhanced colors."""
    from colorama import Fore, Style
    
    print(f"{Fore.LIGHTCYAN_EX}{Config.BANNER}{Style.RESET_ALL}")
    
    print(f"{Fore.LIGHTBLUE_EX}🤖 AI-Powered Automated Penetration Testing Tool{Style.RESET_ALL}")
    print(f"{Fore.LIGHTYELLOW_EX}⚠️  For Educational and Authorized Testing Only{Style.RESET_ALL}")
    print(f"{Fore.LIGHTMAGENTA_EX}{'=' * 80}{Style.RESET_ALL}")
    print()


def validate_target(target: str) -> bool:
    """
    Validate target format.
    
    Args:
        target: Target IP address or hostname
        
    Returns:
        bool: True if valid, False otherwise
    """
    if not target or not target.strip():
        return False
    
    target = target.strip()
    
    if target.startswith(('http://', 'https://')):
        target = target.split('://', 1)[1]
    
    allowed_chars = set('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.-_/')
    if not all(c in allowed_chars for c in target):
        return False
    
    return True


def get_scan_mode_interactive() -> str:
    """
    Get scan mode from user interactively.
    
    Returns:
        str: Selected scan mode ('quick' or 'advanced')
    """
    from config import Config
    
    print("\n⚡ Scan Mode Selection")
    print("-" * 25)
    
    for mode_key, mode_info in Config.SCAN_MODES.items():
        print(f"  {mode_key.upper()}: {mode_info['name']}")
        print(f"    📝 {mode_info['description']}")
        print(f"    🛠️  Tools: {', '.join(mode_info['tools'])}")
        print(f"    ⏱️  Timeout: {mode_info['timeout']}s")
        print()
    
    while True:
        try:
            choice = input("Select scan mode [quick/advanced] (default: quick): ").strip().lower()
            
            if not choice:
                choice = "quick"
            
            if choice in Config.SCAN_MODES:
                print(f"✅ Selected: {Config.SCAN_MODES[choice]['name']}")
                return choice
            else:
                print("❌ Invalid choice. Please enter 'quick' or 'advanced'.")
                
        except (EOFError, KeyboardInterrupt):
            print("\n👋 Operation cancelled.")
            return "quick"


def get_report_format_interactive() -> str:
    """
    Get report format from user interactively.
    
    Returns:
        str: Selected report format ('html' or 'txt')
    """
    print("\n📄 Report Format Selection")
    print("-" * 30)
    print("  HTML: 🌐 Beautiful web-based report with cyberpunk theme (Recommended)")
    print("    📱 Responsive design, interactive elements")
    print("    🎨 Modern UI with dark cyberpunk styling")
    print("    📊 Enhanced data visualization")
    print()
    print("  TXT:  📝 Simple text-based report")
    print("    📄 Plain text format for basic viewing")
    print("    💾 Lightweight and compatible")
    print()
    
    while True:
        try:
            choice = input("Select report format [html/txt] (default: html): ").strip().lower()
            
            if not choice:
                choice = "html"
            
            if choice in ['html', 'txt']:
                format_name = "HTML Web Report" if choice == "html" else "Text Report"
                print(f"✅ Selected: {format_name}")
                return choice
            else:
                print("❌ Invalid choice. Please enter 'html' or 'txt'.")
                
        except (EOFError, KeyboardInterrupt):
            print("\n👋 Operation cancelled.")
            return "html"


def get_target_interactive() -> Optional[str]:
    """
    Get target from user interactively.
    
    Returns:
        str: Target address or None if cancelled
    """
    print("\n🎯 Target Selection")
    print("-" * 20)
    print("Enter target IP address, hostname, or CIDR range")
    print("Examples:")
    print("  • 192.168.1.1")
    print("  • example.com")
    print("  • 192.168.1.0/24")
    print("  • 10.0.0.1-10")
    print()
    
    while True:
        try:
            target = input("🎯 Target: ").strip()
            
            if not target:
                print("❌ No target entered. Please try again.")
                continue
            
            if target.lower() in ['quit', 'exit', 'q']:
                print("👋 Goodbye!")
                return None
            
            if validate_target(target):
                return target
            else:
                print("❌ Invalid target format. Please try again.")
                print("💡 Tip: Use IP addresses, hostnames, or CIDR notation")
                
        except KeyboardInterrupt:
            print("\n👋 Operation cancelled by user.")
            return None
        except EOFError:
            print("\n👋 Goodbye!")
            return None


def show_pre_scan_info(target: str, scan_mode: str = "quick"):
    """Show information before starting the scan."""
    from config import Config
    
    mode_info = Config.SCAN_MODES.get(scan_mode, Config.SCAN_MODES["quick"])
    
    print(f"\n🚀 Starting penetration test against: {target}")
    print(f"⚡ Scan Mode: {mode_info['name']}")
    print(f"📝 Description: {mode_info['description']}")
    print(f"🛠️  Tools: {', '.join(mode_info['tools'])}")
    print(f"⏱️  Estimated time: ~{mode_info['timeout']}s")
    print()
    print("📋 Test Plan:")
    print("   1. 🔍 Network reconnaissance")
    print("   2. 🤖 AI vulnerability analysis (Pollinations.ai)")
    if scan_mode == "advanced":
        print("   3. 🌐 Web vulnerability scanning (Nikto)")
        print("   4. 🔍 Technology detection (WhatWeb)")
        print("   5. 📁 Directory enumeration (Gobuster)")
        print("   6. 📄 Report generation")
    else:
        print("   3. 📄 Report generation")
    print()
    
    print("⚠️  IMPORTANT LEGAL NOTICE:")
    print("   • Only test systems you own or have explicit permission to test")
    print("   • Unauthorized penetration testing is illegal")
    print("   • This tool is for educational purposes only")
    print()
    
    try:
        confirm = input("🤔 Do you want to continue? (y/N): ").strip().lower()
        if confirm not in ['y', 'yes']:
            print("👋 Operation cancelled.")
            sys.exit(0)
    except KeyboardInterrupt:
        print("\n👋 Operation cancelled by user.")
        sys.exit(0)


def check_dependencies():
    """Check if required dependencies are available."""
    logger = Logger()
    
    print("🔧 Checking dependencies...")
    
    if sys.version_info < (3, 9):
        logger.error("❌ Python 3.9+ required")
        return False
    
    required_modules = ['requests', 'colorama']
    missing_modules = []
    
    for module in required_modules:
        try:
            __import__(module)
        except ImportError:
            missing_modules.append(module)
    
    if missing_modules:
        logger.error(f"❌ Missing Python modules: {', '.join(missing_modules)}")
        logger.info("💡 Install with: pip install " + " ".join(missing_modules))
        return False
    
    external_tools = ['nmap', 'msfconsole']
    for tool in external_tools:
        try:
            import subprocess
            result = subprocess.run([tool, '--version'], 
                                  capture_output=True, 
                                  timeout=5)
            if result.returncode == 0:
                logger.success(f"✅ {tool} found")
            else:
                logger.warning(f"⚠️ {tool} not found or not working")
        except (subprocess.TimeoutExpired, FileNotFoundError):
            logger.warning(f"⚠️ {tool} not found in PATH")
    
    logger.success("✅ Dependency check completed")
    return True


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="AI-Powered Automated Penetration Testing Tool",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python main.py                    # Interactive mode
  python main.py 192.168.1.1       # Test specific target
  python main.py example.com        # Test hostname
  python main.py 192.168.1.0/24    # Test network range

Legal Notice:
  This tool is for educational and authorized testing only.
  Only use on systems you own or have explicit permission to test.
  Unauthorized penetration testing is illegal.
        """
    )
    
    parser.add_argument(
        'target',
        nargs='?',
        help='Target IP address, hostname, or CIDR range'
    )
    
    parser.add_argument(
        '--no-banner',
        action='store_true',
        help='Skip banner display'
    )
    
    parser.add_argument(
        '--skip-deps',
        action='store_true',
        help='Skip dependency check'
    )
    
    parser.add_argument(
        '--scan-mode',
        choices=['quick', 'advanced'],
        default='quick',
        help='Scan mode: quick (fast Nmap-only) or advanced (comprehensive with multiple tools)'
    )
    
    parser.add_argument(
        '--report-format',
        choices=['html', 'txt'],
        default='html',
        help='Report format: html (beautiful web report) or txt (simple text report)'
    )
    
    parser.add_argument(
        '--version',
        action='version',
        version='TAuto Pentest v2.0 by Tehran Community Team (tcommunity.pro)'
    )
    
    args = parser.parse_args()
    
    try:
        if not args.no_banner:
            display_banner()
        
        if not args.skip_deps:
            if not check_dependencies():
                print("\n❌ Dependency check failed. Use --skip-deps to bypass.")
                sys.exit(1)
        
        target = None
        scan_mode = args.scan_mode
        report_format = args.report_format
        
        if args.target:
            if validate_target(args.target):
                target = args.target.strip()
            else:
                print(f"❌ Invalid target format: {args.target}")
                sys.exit(1)
        else:
            target = get_target_interactive()
            if target:
                scan_mode = get_scan_mode_interactive()
                report_format = get_report_format_interactive()
            
        if not target:
            sys.exit(0)
        
        show_pre_scan_info(target, scan_mode)
        
        print("🚀 Initializing TAuto Pentest...")
        pentest = TAutoPentest()
        
        print(f"🎯 Starting penetration test against: {target}")
        print(f"⚡ Scan mode: {scan_mode}")
        print(f"📄 Report format: {report_format.upper()}")
        success = pentest.run(target, scan_mode=scan_mode, report_format=report_format)
        
        print("\n" + "="*60)
        if success:
            print("🎉 Penetration testing completed successfully!")
            print("📄 Check the generated report for detailed results.")
        else:
            print("❌ Penetration testing failed.")
            print("🔍 Check the logs for error details.")
        print("="*60)
        
        sys.exit(0 if success else 1)
        
    except KeyboardInterrupt:
        print("\n🛑 Operation cancelled by user.")
        sys.exit(130)
    except Exception as e:
        print(f"\n❌ Unexpected error: {e}")
        print("🐛 This might be a bug. Please check your configuration.")
        sys.exit(1)


if __name__ == "__main__":
    main()