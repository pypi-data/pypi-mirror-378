# -*- coding: utf-8 -*-
"""
This file primarily contains utility functions,
such as those for obtaining the current time,
ensuring the existence of a specified directory,
saving and loading S2 data,
and performing two different normalization operations.

Created on 2025/08/23 17:09:18
@author: Whenxuan Wang
@email: wwhenxuan@gmail.com
@url: https://github.com/wwhenxuan/S2Generator
"""
__all__ = [
    "get_time_now",
    "ensure_directory_exists",
    "save_s2data",
    "save_npy",
    "save_npz",
    "load_s2data",
    "load_npz",
    "load_npy",
    "is_all_zeros",
    "z_score_normalization",
    "max_min_normalization",
    "fft",
    "ifft",
    "fftshift",
    "ifftshift",
]

import os
from os import path
from datetime import datetime
import numpy as np
from numpy import bool_
from numpy import fft as np_fft

from typing import Optional, Dict, Union, Tuple

from S2Generator import Node, NodeList


def get_time_now():
    """Get current time to string"""
    return datetime.now().strftime("%Y-%m-%d %H:%M:%S")


def ensure_directory_exists(file_path: str) -> str:
    """
    Ensures the directory in the given file path exists, creating it if necessary.

    This function handles both file paths and directory paths:
    - For file paths (ending with .npy, .npz, or .json), ensures the parent directory exists
    - For directory paths, ensures the directory itself exists

    :param file_path: Complete path including filename or directory path
    :return: Full path to the file that should be used for saving
    """
    # Determine if path ends with a file extension
    if (
        file_path.endswith(".npy")
        or file_path.endswith(".npz")
        or file_path.endswith(".json")
    ):
        # Extract directory from file path
        directory = os.path.dirname(file_path)
        return_path = file_path
    else:
        # Treat as directory path
        directory = file_path
        return_path = os.path.join(file_path, "s2data.npz")

    # Create directory if it doesn't exist
    if directory and not path.exists(directory):
        os.makedirs(directory)

    return return_path


def save_s2data(
    symbol: Union[str, "Node", "NodeList"],
    excitation: Union[int, bool, float, np.ndarray],
    response: Union[int, bool, float, np.ndarray],
    save_path: str = None,
) -> bool:
    """
    Saves S2 data (symbolic expressions and time series) to the specified location.

    This function works with load_s2data to provide a complete save/load workflow.
    Supports multiple file formats (.npy, .npz) and handles directory creation.

    :param symbol: Symbolic expression data generated by S2Generator (Node, NodeList, or str)
    :param excitation: Input excitation time series data
    :param response: Response time series data obtained from the system
    :param save_path: Save location with two input options:
                     - Directory path: data will be saved as 's2data.npz' in this directory
                     - Full file path: must end with .npy or .npz extension
    :return: Boolean indicating success status of the save operation.
    """
    # Ensure directory exists and get final save path
    save_path = ensure_directory_exists(file_path=save_path)

    # Save based on file extension
    if save_path.endswith(".npy"):
        status = save_npy(
            data={
                "symbol": str(symbol),
                "excitation": excitation,
                "response": response,
            },
            save_path=save_path,
        )
    elif save_path.endswith(".npz"):
        status = save_npz(
            data={
                "symbol": str(symbol),
                "excitation": excitation,
                "response": response,
            },
            save_path=save_path,
        )
    else:
        raise TypeError("save_path must have '.npy' or '.npz' extension.")

    return status


def save_npz(
    data: Union[Dict[str, Union[str, "Node", "NodeList", np.ndarray]], np.ndarray],
    save_path: str,
) -> bool:
    """
    Saves a dictionary of numpy arrays to an NPZ file on disk.

    :param data: Dictionary containing 'symbol', 'excitation', and 'response' key-value pairs
    :param save_path: Full path to the destination file
    :return: Boolean indicating success status of the save operation
    """
    try:
        np.savez(save_path, **data)
        return True
    except Exception as e:
        print(f"Error saving NPZ file: {e}")
        return False


def save_npy(
    data: Union[Dict[str, Union[str, "Node", "NodeList", np.ndarray]], np.ndarray],
    save_path: str,
) -> bool:
    """
    Saves data to an NPY file on disk.

    :param data: Dictionary containing 'symbol', 'excitation', and 'response' key-value pairs
    :param save_path: Full path to the destination file
    :return: Boolean indicating success status of the save operation
    """
    try:
        np.save(file=save_path, arr=data)
        return True
    except Exception as e:
        print(f"Error saving NPY file: {e}")
        return False


def load_s2data(
    data_path: str,
) -> Union[
    Tuple[
        Union[str, "Node", "NodeList"],
        Union[int, bool, float, np.ndarray],
        Union[int, bool, float, np.ndarray],
    ],
    None,
]:
    """
    Loads S2 data (symbolic expressions and time series) previously saved with save_s2data.

    :param data_path: Path to the data file or directory containing 's2data.npz'
    :return: Tuple containing (symbol, excitation, response) or None if loading fails
    :raises FileNotFoundError: If the specified file or directory doesn't exist
    :raises TypeError: If the file format is not supported
    """
    # Check if path exists
    if not path.exists(data_path):
        raise FileNotFoundError(f"File {data_path} not found.")

    # Load based on file type
    if data_path.endswith(".npy"):
        data = load_npy(data_path)
    elif data_path.endswith(".npz"):
        data = load_npz(data_path)
    elif path.isdir(data_path):
        # Handle directory input
        data_path = path.join(data_path, "s2data.npz")
        if path.exists(data_path):
            data = load_npz(data_path)
        else:
            raise FileNotFoundError(f"File {data_path} not found.")
    else:
        raise TypeError(
            "data_path must have '.npy' or '.npz' extension or be a directory."
        )

    if data is None:
        return None

    return data["symbol"], data["excitation"], data["response"]


def load_npy(
    data_path: str,
) -> Union[Dict[str, Union[str, "Node", "NodeList", np.ndarray]], None]:
    """
    Loads data from an NPY file.

    :param data_path: Path to the NPY file
    :return: Dictionary containing the loaded data or None if loading fails
    """
    try:
        data = np.load(data_path, allow_pickle=True)
        return data.tolist()
    except Exception as e:
        print(f"Error loading NPY file: {e}")
        return None


def load_npz(
    data_path: str,
) -> Union[Dict[str, Union[str, "Node", "NodeList", np.ndarray]], None]:
    """
    Loads data from an NPZ file.

    :param data_path: Path to the NPZ file
    :return: Dictionary containing the loaded data or None if loading fails
    """
    try:
        data = np.load(data_path)
        return data
    except Exception as e:
        print(f"Error loading NPZ file: {e}")
        return None


def is_all_zeros(arr: np.ndarray) -> Union[bool, bool_, None, np.ndarray]:
    """
    Determine whether the input array is all 0.

    :param arr: Array to be checked.
    :return: Boolean indicating success status of the check.
    """
    return np.all(arr == 0)


def z_score_normalization(x: np.ndarray) -> np.ndarray | None:
    """
    Perform Z-score normalization on the input time series.

    :param x: Input two-dimensional time series with [n_points, n_dims] in NumPy.
    :return: Normalized time series with origin shape.
    """
    if is_all_zeros(x):
        # Make sure the input array is not all 0
        return None
    elif np.isinf(x).any():
        # Make sure the input array does not contain infinity
        return None
    elif np.isnan(x).any():
        # Ensure that the input array does not contain NaN values
        return None
    else:
        # Normalize array alignment for normal value range
        return (x - np.mean(x, axis=0, keepdims=True)) / np.std(
            x, axis=0, keepdims=True
        )


def max_min_normalization(x: np.ndarray) -> np.ndarray | None:
    """
    Perform min-max normalization on the input time series.

    :param x: Input two-dimensional time series with [n_points, n_dims] in NumPy.
    :return: Normalized time series with origin shape.
    """
    if is_all_zeros(x):
        # Make sure the input array is not all 0
        return None
    elif np.isinf(x).any():
        # Make sure the input array does not contain infinity
        return None
    elif np.isnan(x).any():
        # Ensure that the input array does not contain NaN values
        return None
    else:
        # Normalize array alignment for normal value range
        return (x - np.min(x, axis=0, keepdims=True)) / (
            np.max(x, axis=0, keepdims=True) - np.min(x, axis=0, keepdims=True)
        )


def fft(
    array: np.ndarray, axis: Optional[int] = None, norm: Optional[str] = "backward"
) -> np.ndarray:
    """
    Performs a Fast Fourier Transform on the input time series data.

    :param array: Input two-dimensional time series with [n_points, n_dims].
    :param axis: Axis over which to compute the FFT.  If not given, the last axis is.
    :param norm: Normalization method to use.  Can be "backward", "forward" or "ortho".

    :return: The transformed results for the input time series in freq domain.
    """
    # Handling data types
    array = np.asarray(array)

    # If the user specifies the dimensions of the operation
    if axis is not None:
        return np_fft.fft(array, axis=axis, norm=norm)

    else:
        # Determine the dimension of the data
        shape = array.shape
        if len(shape) == 2:
            # Input data is a multi-channel time series
            return np_fft.fft(array, axis=0, norm=norm)
        elif len(shape) == 1:
            # The input data is a single-channel time series
            return np_fft.fft(array, norm=norm)
        else:
            raise NotImplementedError


def ifft(
    array: np.ndarray, axis: Optional[int] = None, norm: Optional[str] = "backward"
) -> np.ndarray:
    """
    Perform inverse fast Fourier transform on the input frequency domain signal.

    :param array: Input two-dimensional time series with [n_points, n_dims] in freq domain.
    :param axis: Axis over which to compute the FFT.  If not given, the last axis is.
    :param norm: Normalization method to use.  Can be "backward", "forward" or "ortho".

    :return: The transformed results for the input time series in time domain.
    """
    # Handling data types
    array = np.asarray(array)

    # If the user specifies the dimensions of the operation
    if axis is not None:
        return np_fft.ifft(array, axis=axis, norm=norm)

    else:
        # Determine the dimension of the data
        shape = array.shape
        if len(shape) == 2:
            # Input data is a multi-channel time series
            return np_fft.ifft(array, axis=0, norm=norm)
        elif len(shape) == 1:
            # The input data is a single-channel time series
            return np_fft.ifft(array, norm=norm)
        else:
            raise NotImplementedError


def fftshift(array: np.ndarray) -> np.ndarray:
    """
    Decenter the result in the frequency domain before inverse fast Fourier transform.

    :param array: The results of the FFT.

    :return: Frequency domain result after fast Fourier transform centering.
    """
    return np_fft.fftshift(array)


def ifftshift(array: np.ndarray) -> np.ndarray:
    """
    Decenter the result in the frequency domain before inverse fast Fourier transform.

    :param array: The inputs before the iFFT.

    :return: Frequency domain representation after decentralized restoration.
    """
    return np_fft.ifftshift(array)
