{"signature": "classscvi.model.SCVI(adata=None,registry=None,n_hidden=128,n_latent=10,n_layers=1,dropout_rate=0.1,dispersion='gene',gene_likelihood='zinb',use_observed_lib_size=True,latent_distribution='normal',**kwargs)", "embedding": "Probabilistic VAE for scRNA-seq counts that learns a low-dimensional latent space, corrects batch effects, and models gene expression with (Z)INB/Poisson; provides normalized expression, latent embeddings, and DE utilities. This model is designed for single-cell data and effectively captures biological variability while minimizing technical noise. It supports downstream analyses including clustering, trajectory inference, and differential expression. The latent space representation allows for integration of multiple datasets across batches. Additionally, the framework offers flexible likelihood models and priors for various experimental designs."}
{"signature": "classscvi.model.SCANVI(adata=None,registry=None,n_hidden=128,n_latent=10,n_layers=1,dropout_rate=0.1,dispersion='gene',gene_likelihood='zinb',use_observed_lib_size=True,linear_classifier=False,datamodule=None,**model_kwargs)", "embedding": "Semi-supervised extension of SCVI for label transfer/annotation: learns a label-aware latent space from partially labeled data and trains an integrated classifier (optionally linear) to predict cell types. SCANVI can incorporate known labels while still modeling unlabeled cells. The method improves annotation accuracy by leveraging shared structure in the latent space. It allows flexible classifier options for different prediction tasks. The model is compatible with batch-corrected embeddings and can scale to large single-cell datasets."}
{"signature": "rapids_singlecell.pp.calculate_qc_metrics(adata,*,expr_type='counts',var_type='genes',qc_vars=None,log1p=True,layer=None)", "embedding": "Computes basic QC metrics (e.g., n_genes_by_counts, total_counts, % in gene sets like mitochondria) and writes results to .obs/.var; supports specifying a layer and optional log1p. These metrics help identify low-quality cells or features before downstream analysis. Users can customize which QC variables to include for dataset-specific needs. The function ensures consistent data preprocessing across studies. Outputs are stored directly in the AnnData object for seamless integration with later steps."}
{"signature": "rapids_singlecell.pp.filter_cells(data,*,min_counts=None,min_genes=None,max_counts=None,max_genes=None,inplace=True,verbose=True)", "embedding": "Filters cells by total counts and/or detected genes; removes outliers or returns a filtered copy and records selection masks when inplace=False. This step ensures high-quality cells are retained for analysis. Thresholds can be adjusted to remove extremely low or high-count cells. Users can inspect removed cells for quality assessment. The function integrates cleanly with downstream normalization and feature selection."}
{"signature": "rapids_singlecell.pp.filter_genes(data,*,min_counts=None,min_cells=None,max_counts=None,max_cells=None,inplace=True,verbose=True)", "embedding": "Filters genes by total counts or number of cells expressed; keeps informative genes and drops rarely/overly abundant features. This helps reduce noise and computational burden. Users can set thresholds to retain biologically relevant features. The function maintains consistent gene sets for analysis pipelines. It outputs either a filtered dataset or applies changes in place based on preference."}
{"signature": "rapids_singlecell.pp.normalize_total(adata,*,target_sum=None,layer=None,inplace=True,copy=False)", "embedding": "Library-size normalizes per-cell counts so each cell sums to target_sum (e.g., 1e4); applies to X or a specified layer. Normalization reduces biases from differing sequencing depth. The method prepares data for downstream analyses like PCA and clustering. Users can apply it selectively to layers without affecting raw counts. This step is standard for consistent single-cell data preprocessing."}
{"signature": "rapids_singlecell.pp.log1p(adata,*,layer=None,obsm=None,inplace=True,copy=False)", "embedding": "Applies log1p transformation to expression values in X or a given layer/obsm for variance stabilization prior to HVG/PCA. The transformation reduces skewness in count data. It allows better detection of highly variable genes. The method is compatible with GPU acceleration for large datasets. Log-transformed data improves clustering and visualization quality."}
{"signature": "rapids_singlecell.pp.highly_variable_genes(adata,*,layer=None,min_mean=0.0125,max_mean=3,min_disp=0.5,max_disp=inf,n_top_genes=None,flavor='seurat',n_bins=20,span=0.3,check_values=True,theta=100,clip=None,chunksize=1000,n_samples=10000,batch_key=None)", "embedding": "Identifies highly variable genes (HVGs) using Scanpy/Seurat-style or residual-based methods; supports counts vs log inputs and batch-aware selection. HVGs capture meaningful biological variation. The method can operate across batches for integrated analyses. Users can select top genes for downstream dimensionality reduction. Results are stored in .var for easy filtering and visualization."}
{"signature": "rapids_singlecell.pp.regress_out(adata,keys,*,layer=None,inplace=True,batchsize=None,verbose=False)", "embedding": "Regresses out confounders (e.g., total_counts, pct_counts_mt, cell cycle scores) per gene via linear models to reduce unwanted variation. This ensures that technical effects do not dominate the signal. Users can target specific variables for removal. The method supports batch processing for large datasets. Residuals can be used for downstream PCA or clustering."}
{"signature": "rapids_singlecell.pp.scale(adata,*,zero_center=True,max_value=None,copy=False,layer=None,obsm=None,mask_obs=None,inplace=True)", "embedding": "Standardizes genes to zero mean and unit variance (optionally clipping to max_value); can target X, a layer, or obsm and subset cells via mask. Scaling ensures comparability across genes. Optional clipping prevents extreme values from dominating. The method prepares data for PCA and other algorithms sensitive to variance. Users can apply it selectively to layers or subsets of cells."}
{"signature": "rapids_singlecell.pp.pca(adata,n_comps=None,*,layer=None,zero_center=True,svd_solver=None,random_state=0,mask_var=_empty,use_highly_variable=None,dtype='float32',chunked=False,chunk_size=None,key_added=None,copy=False)", "embedding": "Runs GPU-accelerated PCA (cuML), storing loadings/scores in .varm/.obsm (e.g., 'X_pca'); supports using HVGs and alternative layers. PCA reduces dimensionality for visualization and clustering. The method can operate on selected features for efficiency. GPU acceleration allows large datasets to be processed quickly. Results integrate seamlessly with downstream embedding methods like UMAP."}
{"signature": "rapids_singlecell.pp.normalize_pearson_residuals(adata,*,theta=100,clip=None,check_values=True,layer=None,inplace=True)", "embedding": "Computes analytic Pearson residuals under an NB model for variance normalization (useful for HVG selection and downstream PCA); optional clipping. This method helps stabilize variance across genes with different expression levels. It is particularly effective for preparing data for PCA or clustering. Users can control the clipping threshold to avoid extreme residuals. The resulting normalized data improves the reliability of downstream analyses."}
{"signature": "rapids_singlecell.pp.flag_gene_family(adata,*,gene_family_name,gene_family_prefix=None,gene_list=None)", "embedding": "Adds boolean flags in .var for gene families (e.g., mitochondrial, ribosomal) using a prefix or explicit gene list for easy QC filtering. This allows easy identification of genes belonging to specific functional groups. It supports both automated prefix-based and manual gene-list approaches. The flags are helpful for filtering or annotating genes during preprocessing. It simplifies downstream quality control and analysis workflows."}
{"signature": "rapids_singlecell.pp.filter_highly_variable(adata)", "embedding": "Subsets the AnnData object to genes where .var['highly_variable'] is True; a convenience wrapper after HVG detection. This reduces data dimensionality for faster computation. It ensures downstream analyses focus on informative genes. The method maintains compatibility with all standard AnnData structures. It is commonly used after HVG identification to streamline analysis."}
{"signature": "rapids_singlecell.pp.harmony_integrate(adata,key,*,basis='X_pca',adjusted_basis='X_pca_harmony',dtype=<class'numpy.float64'>,correction_method='original',use_gemm=False,colsum_algo=None,**kwargs)", "embedding": "Applies Harmony batch correction on a chosen basis (e.g., PCA), writing an adjusted embedding (e.g., 'X_pca_harmony') that mixes batches while preserving structure. This corrects for batch-specific variation in multi-sample datasets. It integrates multiple experiments into a common latent space. The method preserves biological signal while reducing technical noise. Harmony-adjusted embeddings improve clustering and visualization outcomes."}
{"signature": "rapids_singlecell.pp.scrublet(adata,adata_sim=None,*,batch_key=None,sim_doublet_ratio=2.0,expected_doublet_rate=0.05,stdev_doublet_rate=0.02,synthetic_doublet_umi_subsampling=1.0,knn_dist_metric='euclidean',normalize_variance=True,log_transform=False,mean_center=True,n_prin_comps=30,use_approx_neighbors=True,get_doublet_neighbor_parents=False,n_neighbors=None,threshold=None,verbose=True,copy=False,random_state=0)", "embedding": "Runs Scrublet to score and call doublets; writes per-cell doublet scores and predictions, with options for batch-aware processing and neighbor computation. It identifies potential doublet cells that may arise during single-cell capture. Users can adjust thresholds and neighbor parameters for sensitivity. Scrublet outputs help remove confounding doublets from downstream analysis. This ensures higher accuracy in clustering and differential expression studies."}
{"signature": "rapids_singlecell.pp.scrublet_simulate_doublets(adata,*,layer=None,sim_doublet_ratio=2.0,synthetic_doublet_umi_subsampling=1.0,random_seed=0)", "embedding": "Generates synthetic doublets by summing random cell profiles to support Scrublet calibration and thresholding. Synthetic doublets help train the model to distinguish real from artificial doublets. Users can control the simulation ratio and subsampling for flexibility. This step improves doublet detection accuracy. It is a preparatory step for robust quality control in single-cell analysis."}
{"signature": "rapids_singlecell.pp.neighbors(adata,n_neighbors=15,n_pcs=None,*,use_rep=None,random_state=0,algorithm='brute',metric='euclidean',metric_kwds=mappingproxy({}),algorithm_kwds=mappingproxy({}),key_added=None,copy=False)", "embedding": "Builds GPU-accelerated KNN graphs (connectivities/distances) from a chosen representation (e.g., PCA); results stored in .obsp and used by UMAP/Leiden. The neighbor graph captures local cell similarities for downstream analysis. Users can specify the number of neighbors and representation type. The output supports visualization and clustering methods. GPU acceleration ensures fast computation on large datasets."}
{"signature": "rapids_singlecell.pp.bbknn(adata,neighbors_within_batch=3,n_pcs=None,*,batch_key=None,use_rep=None,random_state=0,algorithm='brute',metric='euclidean',metric_kwds=mappingproxy({}),algorithm_kwds=mappingproxy({}),trim=None,key_added=None,copy=False)", "embedding": "Constructs a batch-balanced KNN graph by drawing neighbors per batch and merging them to reduce batch effects before embedding/clustering. This method ensures fair representation from each batch. It minimizes batch-driven artifacts in clustering. Users can adjust neighbors within batch for flexibility. The graph improves downstream embedding accuracy and integration."}
{"signature": "rapids_singlecell.tl.umap(adata,*,min_dist=0.5,spread=1.0,n_components=2,maxiter=None,alpha=1.0,negative_sample_rate=5,init_pos='auto',random_state=0,a=None,b=None,key_added=None,neighbors_key=None,copy=False)", "embedding": "Computes UMAP embeddings on the neighbor graph using cuML; writes 2D/3D coordinates to .obsm (e.g., 'X_umap'). UMAP preserves local and global structure in low-dimensional space. It is widely used for visualization of single-cell data. Parameters like min_dist and spread control cluster compactness. The method is GPU-accelerated for speed on large datasets."}
{"signature": "rapids_singlecell.tl.tsne(adata,n_pcs=None,*,use_rep=None,perplexity=30,early_exaggeration=12,learning_rate=200,method='barnes_hut',metric='euclidean',key_added=None,copy=False)", "embedding": "Computes t-SNE with GPU acceleration (cuML) from a selected representation; stores coordinates in .obsm (e.g., 'X_tsne'). t-SNE emphasizes local neighborhood relationships for visualization. Perplexity and learning rate can be tuned for cluster resolution. The output is often used alongside UMAP for complementary views. GPU acceleration enables handling of large single-cell datasets efficiently."}
{"signature": "rapids_singlecell.tl.diffmap(adata,n_comps=15,*,neighbors_key=None,sort='decrease',density_normalize=True)", "embedding": "Computes diffusion map components from the neighbor graph for manifold/trajectory structure; stores in .obsm (e.g., 'X_diffmap'). Diffusion maps capture continuous cell transitions. They are useful for trajectory inference and lineage analysis. Users can select the number of components for downstream applications. The method helps reveal developmental or dynamic processes in the data."}
{"signature": "rapids_singlecell.tl.draw_graph(adata,*,init_pos=None,max_iter=500)", "embedding": "Generates a force-directed graph layout (ForceAtlas2 via cuGraph) of the KNN graph for visualization; writes to .obsm (e.g., 'X_draw_graph_fa'). This layout emphasizes neighborhood relationships visually. It is helpful for exploring global structure. Initialization and iteration parameters can be customized. The resulting graph supports interactive visualization and cluster interpretation."}
{"signature": "rapids_singlecell.tl.mde(adata,*,device=None,n_neighbors=15,n_pcs=None,use_rep=None,**kwargs)", "embedding": "Computes a Minimum-Distortion Embedding (MDE) that preserves neighborhood structure; returns a clean visualization alternative to UMAP/t-SNE. MDE emphasizes minimal distortion of distances in low-dimensional space. It provides interpretable visual layouts of cell populations. Users can specify neighbors and representation type. MDE is useful for downstream analysis and comparison of embeddings."}
{"signature": "rapids_singlecell.tl.embedding_density(adata,basis='umap',*,groupby=None,key_added=None,batchsize=10000,components=None)", "embedding": "Estimates local cell density over an existing embedding (e.g., UMAP) and stores per-cell density values for shading/normalization across plots. This allows visualization of dense vs sparse regions. Density estimates can inform cluster interpretation. Users can group cells by metadata for comparison. The method improves visual clarity and downstream analysis insights."}
{"signature": "rapids_singlecell.tl.louvain(adata,resolution=1.0,*,restrict_to=None,key_added='louvain',adjacency=None,n_iterations=100,threshold=1e-07,use_weights=True,neighbors_key=None,obsp=None,dtype=<class'numpy.float32'>,copy=False)", "embedding": "Runs Louvain community detection (cuGraph) on the neighbor graph; writes cluster labels to .obs[key_added]. Louvain identifies modular structure in single-cell data. Resolution controls the granularity of clusters. Weighted edges and iterations refine clustering stability. The output is widely used for downstream annotation and visualization."}
{"signature": "rapids_singlecell.tl.leiden(adata,resolution=1.0,*,random_state=0,theta=1.0,restrict_to=None,key_added='leiden',adjacency=None,n_iterations=100,use_weights=True,neighbors_key=None,obsp=None,dtype=<class'numpy.float32'>,copy=False)", "embedding": "Runs Leiden clustering (cuGraph) on the neighbor graph with tunable resolution; outputs labels in .obs[key_added]. Leiden improves on Louvain by guaranteeing well-connected clusters. Resolution affects cluster size and number. Users can control random seed for reproducibility. Clusters are suitable for downstream analysis and visualization."}
{"signature": "rapids_singlecell.tl.kmeans(adata,n_clusters=8,n_pcs=50,*,use_rep='X_pca',n_init=1,random_state=42,key_added='kmeans',copy=False,**kwargs)", "embedding": "Performs K-means on a chosen representation (default PCA) and stores cluster IDs in .obs[key_added]; GPU-accelerated. K-means partitions cells into a fixed number of clusters. Initialization and n_init control clustering stability. The method is suitable for large-scale datasets. Cluster labels can be used for annotation or downstream analysis."}
{"signature": "rapids_singlecell.tl.score_genes(adata,gene_list,*,ctrl_as_ref=True,ctrl_size=50,gene_pool=None,n_bins=25,score_name='score',random_state=0,copy=False,use_raw=None,layer=None)", "embedding": "Computes per-cell signature scores for a gene list using control genes matched by expression bins; writes scores to .obs[score_name]. This method allows quantifying activity of gene sets per cell. Control genes help normalize for expression biases. Scores can be used for visualization, clustering, or differential analysis. The output supports downstream statistical and plotting workflows."}
{"signature": "rapids_singlecell.tl.score_genes_cell_cycle(adata,*,s_genes,g2m_genes,copy=False,**kwargs)", "embedding": "Scores S and G2M phases and assigns cell-cycle phase per cell based on canonical gene sets; stores scores and phase in .obs. This enables identification of proliferating vs quiescent cells. Scores can be used for regression or visualization. Users can provide custom gene sets for different species or experiments. The method aids in removing cell-cycle effects from downstream analysis."}
{"signature": "rapids_singlecell.tl.rank_genes_groups_logreg(adata,groupby,*,groups='all',use_raw=None,reference='rest',n_genes=None,layer=None,**kwds)", "embedding": "Performs one-vs-rest logistic regression DE across groups (e.g., clusters) and writes results to .uns['rank_genes_groups']; GPU-accelerated backend. This identifies marker genes per cluster efficiently. Users can specify reference groups or number of top genes. Results are used for annotation and interpretation. The method is scalable to large single-cell datasets."}
{"signature": "rapids_singlecell.get.aggregate(adata,by,func,*,axis=None,mask=None,dof=1,layer=None,obsm=None,varm=None,return_sparse=False,**kwargs)", "embedding": "Aggregates expression by groups (e.g., mean/sum per cluster, sample, or batch) across obs/var; supports layers/obsm/varm and sparse returns for pseudobulk-like summaries. This provides summarized profiles for downstream analysis. Users can apply custom aggregation functions. Sparse return reduces memory usage for large datasets. The method supports flexible grouping strategies for exploratory or comparative analysis."}
{"signature": "rapids_singlecell.get.anndata_to_GPU(adata,layer=None,convert_all=False,copy=False)", "embedding": "Converts AnnData arrays (X/layers/obsm as selected) to GPU (CuPy/cuDF) to enable RAPIDS-accelerated ops; optionally returns a copy. This allows faster computation for large datasets. Users can select which layers or arrays to transfer. The conversion preserves metadata and structure. It is essential for leveraging GPU acceleration in preprocessing and analysis."}
{"signature": "rapids_singlecell.get.anndata_to_CPU(adata,layer=None,convert_all=False,copy=False)", "embedding": "Converts AnnData arrays back to CPU (NumPy/SciPy/pandas) from GPU representations; optionally returns a copy. This enables interoperability with standard CPU-based workflows. Users can select specific layers or arrays. Conversion maintains consistency of metadata and data structures. It allows seamless transition between GPU and CPU analyses."}
{"signature": "rapids_singlecell.get.X_to_GPU(X,warning='X')", "embedding": "Utility to convert a numpy/scipy matrix or array to its GPU (CuPy/sparse) equivalent, emitting a contextual warning label if provided. It ensures the data is compatible with RAPIDS GPU operations. The warning helps track which arrays were transferred. Supports dense and sparse formats for flexibility. Conversion accelerates computation on large-scale data."}
{"signature": "rapids_singlecell.get.X_to_CPU(X)", "embedding": "Utility to convert a CuPy/cusparse array back to CPU (NumPy/SciPy) for compatibility with non-GPU workflows. This enables analysis in CPU-only environments. The method preserves data format and structure. Conversion supports both dense and sparse matrices. It allows users to move between GPU and CPU seamlessly."}
{"signature": "celltypist.train(X=None,labels:str|list|tuple|ndarray|Series|Index|None=None,genes:str|list|tuple|ndarray|Series|Index|None=None,transpose_input:bool=False,with_mean:bool=True,check_expression:bool=True,C:float=1.0,solver:str|None=None,max_iter:int|None=None,n_jobs:int|None=None,use_SGD:bool=False,alpha:float=0.0001,use_GPU:bool=False,mini_batch:bool=False,batch_number:int=100,batch_size:int=1000,epochs:int=10,balance_cell_type:bool=False,feature_selection:bool=False,top_genes:int=300,date:str='',details:str='',url:str='',source:str='',version:str='',**kwargs)\u2192Model[source]\uf0c1", "embedding": "Trains a CellTypist logistic-regression classifier (batch/mini-batch options, optional GPU) from expression and labels, returning a portable Model object. It handles preprocessing, feature selection, and scaling internally. The model supports large datasets with mini-batch and GPU acceleration. Training results in a reproducible model for cell-type prediction. The output can be saved, shared, and applied to new datasets."}
{"signature": "celltypist.annotate(filename:AnnData|str='',model:str|Model|None=None,transpose_input:bool=False,gene_file:str|None=None,cell_file:str|None=None,mode:str='bestmatch',p_thres:float=0.5,majority_voting:bool=False,over_clustering:str|list|tuple|ndarray|Series|Index|None=None,use_GPU:bool=False,min_prop:float=0)\u2192AnnotationResult[source]\uf0c1", "embedding": "Applies a pretrained CellTypist model to annotate cells, returning labels and probabilities; supports cluster-level majority voting and optional GPU. It maps expression profiles to known cell types. Probabilities provide confidence scores for each prediction. Majority voting can improve annotation robustness. Results can be used for visualization and downstream analysis."}
{"signature": "celltypist.dotplot(predictions:AnnotationResult,use_as_reference:str|list|tuple|ndarray|Series|Index,use_as_prediction:str='majority_voting',prediction_order:str|list|tuple|ndarray|Series|Index|None=None,reference_order:str|list|tuple|ndarray|Series|Index|None=None,filter_prediction:float=0.0,cmap:str='RdBu_r',vmin:float|None=0.0,vmax:float|None=1.0,colorbar_title:str|None='Meanprobability',dot_min:float|None=0.0,dot_max:float|None=1.0,smallest_dot:float|None=0.0,size_title:str|None='Fractionofcells(%)',swap_axes:bool|None=False,title:str|None='CellTypistlabeltransfer',figsize:tuple|None=None,show:bool|None=None,save:str|bool|None=None,ax:_AxesSubplot|None=None,return_fig:bool|None=False,**kwds)\u2192DotPlot|dict|None[source]\uf0c1", "embedding": "Creates a dot plot comparing reference vs predicted labels from CellTypist, showing mean probabilities (color) and cell fractions (dot size); customizable ordering and display. It visually summarizes the accuracy and confidence of predictions. Axes and orders can be adjusted for clarity. The plot helps identify well-classified vs ambiguous cell types. Dot size and color are informative for interpreting cell-type proportions and certainty."}
{"signature": "celltypist.models.download_models(force_update:bool=False,model:str|list|tuple|None=None)\u2192None[source]\uf0c1", "embedding": "Downloads one or more pretrained CellTypist models (or refreshes them) for local use in annotation and benchmarking. It ensures the latest models are available. Users can select specific models or all models. The method facilitates reproducibility and comparison across studies. Downloaded models are stored locally for fast access during annotation."}
{"signature": "celltypist.samples.downsample_adata(adata:AnnData,mode:str='total',n_cells:int|None=None,by:str|None=None,balance_cell_type:bool=False,random_state:int=0,return_index:bool=True)\u2192AnnData|ndarray[source]\uf0c1", "embedding": "Downsamples an AnnData object by total cells or stratified by a category (e.g., sample/cluster); can return the subset or just selected indices. This allows balancing datasets for analysis or training. Stratification ensures representative sampling across categories. Random seed ensures reproducibility. Downsampling reduces computation time while maintaining biological diversity."}
{"signature": "classcelltypist.classifier.AnnotationResult(labels:DataFrame,decision_mat:DataFrame,prob_mat:DataFrame,adata:AnnData)[source]\uf0c1", "embedding": "Container for CellTypist predictions: per-cell labels, decision/probability matrices, and the associated AnnData; used for plotting and evaluation. It provides structured access to predictions. Probabilities can be analyzed for confidence metrics. Decision matrices allow in-depth interpretation of classification. The container supports integration with downstream analysis pipelines."}
{"signature": "classcelltypist.classifier.Classifier(filename:AnnData|str='',model:Model|str='',transpose:bool=False,gene_file:str|None=None,cell_file:str|None=None)[source]\uf0c1", "embedding": "High-level predictor that loads a CellTypist Model and harmonizes genes/cells to produce annotations; wraps I/O and mapping utilities. It abstracts preprocessing, mapping, and prediction into a single interface. The class supports file and in-memory AnnData inputs. It ensures gene matching and optional transposition. Predictions can be saved or passed."}
{"signature": "classcelltypist.models.Model(clf,scaler,description)[source]\uf0c1", "embedding": "Serialized CellTypist model bundle (classifier + scaler + metadata) used for fast, reproducible cell-type prediction across datasets. The model encapsulates preprocessing steps and learned weights. It allows consistent predictions on new data without retraining. Metadata provides context for model provenance and versioning. The bundle can be saved, shared, and reloaded for reproducible analyses."}
