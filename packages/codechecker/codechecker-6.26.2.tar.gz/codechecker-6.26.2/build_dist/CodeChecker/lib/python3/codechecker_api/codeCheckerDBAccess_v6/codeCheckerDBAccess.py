#
# Autogenerated by Thrift Compiler (0.22.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec
from uuid import UUID

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    def getRunData(self, runFilter, limit, offset, sortMode):
        """
        Parameters:
         - runFilter
         - limit
         - offset
         - sortMode

        """
        pass

    def getRunCount(self, runFilter):
        """
        Parameters:
         - runFilter

        """
        pass

    def getCheckCommand(self, runHistoryId, runId):
        """
        Parameters:
         - runHistoryId
         - runId

        """
        pass

    def getAnalysisInfo(self, analysisInfoFilter, limit, offset):
        """
        Parameters:
         - analysisInfoFilter
         - limit
         - offset

        """
        pass

    def getRunHistory(self, runIds, limit, offset, runHistoryFilter):
        """
        Parameters:
         - runIds
         - limit
         - offset
         - runHistoryFilter

        """
        pass

    def getRunHistoryCount(self, runIds, runHistoryFilter):
        """
        Parameters:
         - runIds
         - runHistoryFilter

        """
        pass

    def getDiffResultsHash(self, runIds, reportHashes, diffType, skipDetectionStatuses, tagIds):
        """
        Parameters:
         - runIds
         - reportHashes
         - diffType
         - skipDetectionStatuses
         - tagIds

        """
        pass

    def getReport(self, reportId):
        """
        Parameters:
         - reportId

        """
        pass

    def getRunResults(self, runIds, limit, offset, sortType, reportFilter, cmpData, getDetails):
        """
        Parameters:
         - runIds
         - limit
         - offset
         - sortType
         - reportFilter
         - cmpData
         - getDetails

        """
        pass

    def getReportAnnotations(self, runIds, reportFilter, cmpData):
        """
        Parameters:
         - runIds
         - reportFilter
         - cmpData

        """
        pass

    def getRunReportCounts(self, runIds, reportFilter, limit, offset):
        """
        Parameters:
         - runIds
         - reportFilter
         - limit
         - offset

        """
        pass

    def getRunResultCount(self, runIds, reportFilter, cmpData):
        """
        Parameters:
         - runIds
         - reportFilter
         - cmpData

        """
        pass

    def getFailedFilesCount(self, runIds):
        """
        Parameters:
         - runIds

        """
        pass

    def getFailedFiles(self, runIds):
        """
        Parameters:
         - runIds

        """
        pass

    def getReportDetails(self, reportId):
        """
        Parameters:
         - reportId

        """
        pass

    def getSourceFileData(self, fileId, fileContent, encoding):
        """
        Parameters:
         - fileId
         - fileContent
         - encoding

        """
        pass

    def getBlameInfo(self, fileId):
        """
        Parameters:
         - fileId

        """
        pass

    def getLinesInSourceFileContents(self, linesInFilesRequested, encoding):
        """
        Parameters:
         - linesInFilesRequested
         - encoding

        """
        pass

    def isReviewStatusChangeDisabled(self):
        pass

    def changeReviewStatus(self, reportId, status, message):
        """
        Parameters:
         - reportId
         - status
         - message

        """
        pass

    def getReviewStatusRules(self, filter, sortMode, limit, offset):
        """
        Parameters:
         - filter
         - sortMode
         - limit
         - offset

        """
        pass

    def getReviewStatusRulesCount(self, filter):
        """
        Parameters:
         - filter

        """
        pass

    def removeReviewStatusRules(self, filter):
        """
        Parameters:
         - filter

        """
        pass

    def addReviewStatusRule(self, reportHash, status, message):
        """
        Parameters:
         - reportHash
         - status
         - message

        """
        pass

    def getComments(self, reportId):
        """
        Parameters:
         - reportId

        """
        pass

    def getCommentCount(self, reportId):
        """
        Parameters:
         - reportId

        """
        pass

    def addComment(self, reportId, comment):
        """
        Parameters:
         - reportId
         - comment

        """
        pass

    def updateComment(self, commentId, newMessage):
        """
        Parameters:
         - commentId
         - newMessage

        """
        pass

    def removeComment(self, commentId):
        """
        Parameters:
         - commentId

        """
        pass

    def getCheckerDoc(self, checkerId):
        """
        Parameters:
         - checkerId

        """
        pass

    def getCheckerLabels(self, checkers):
        """
        Parameters:
         - checkers

        """
        pass

    def getGuidelineRules(self, guidelines):
        """
        Parameters:
         - guidelines

        """
        pass

    def getPackageVersion(self):
        pass

    def removeRunResults(self, runIds):
        """
        Parameters:
         - runIds

        """
        pass

    def removeRunReports(self, runIds, reportFilter, cmpData):
        """
        Parameters:
         - runIds
         - reportFilter
         - cmpData

        """
        pass

    def removeRun(self, runId, runFilter):
        """
        Parameters:
         - runId
         - runFilter

        """
        pass

    def updateRunData(self, runId, newRunName):
        """
        Parameters:
         - runId
         - newRunName

        """
        pass

    def getSuppressFile(self):
        pass

    def getSeverityCounts(self, runIds, reportFilter, cmpData):
        """
        Parameters:
         - runIds
         - reportFilter
         - cmpData

        """
        pass

    def getCheckerMsgCounts(self, runIds, reportFilter, cmpData, limit, offset):
        """
        Parameters:
         - runIds
         - reportFilter
         - cmpData
         - limit
         - offset

        """
        pass

    def getReportStatusCounts(self, runIds, reportFilter, cmpData):
        """
        Parameters:
         - runIds
         - reportFilter
         - cmpData

        """
        pass

    def getReviewStatusCounts(self, runIds, reportFilter, cmpData):
        """
        Parameters:
         - runIds
         - reportFilter
         - cmpData

        """
        pass

    def getDetectionStatusCounts(self, runIds, reportFilter, cmpData):
        """
        Parameters:
         - runIds
         - reportFilter
         - cmpData

        """
        pass

    def getFileCounts(self, runIds, reportFilter, cmpData, limit, offset):
        """
        Parameters:
         - runIds
         - reportFilter
         - cmpData
         - limit
         - offset

        """
        pass

    def getCheckerCounts(self, runIds, reportFilter, cmpData, limit, offset):
        """
        Parameters:
         - runIds
         - reportFilter
         - cmpData
         - limit
         - offset

        """
        pass

    def getCheckerStatusVerificationDetails(self, runIds, reportFilter):
        """
        Parameters:
         - runIds
         - reportFilter

        """
        pass

    def getRunHistoryTagCounts(self, runIds, reportFilter, cmpData, limit, offset):
        """
        Parameters:
         - runIds
         - reportFilter
         - cmpData
         - limit
         - offset

        """
        pass

    def getAnalyzerNameCounts(self, runIds, reportFilter, cmpData, limit, offset):
        """
        Parameters:
         - runIds
         - reportFilter
         - cmpData
         - limit
         - offset

        """
        pass

    def addSourceComponent(self, name, value, description):
        """
        Parameters:
         - name
         - value
         - description

        """
        pass

    def getSourceComponents(self, sourceComponentFilter):
        """
        Parameters:
         - sourceComponentFilter

        """
        pass

    def removeSourceComponent(self, name):
        """
        Parameters:
         - name

        """
        pass

    def getMissingContentHashes(self, fileHashes):
        """
        Parameters:
         - fileHashes

        """
        pass

    def getMissingContentHashesForBlameInfo(self, fileHashes):
        """
        Parameters:
         - fileHashes

        """
        pass

    def massStoreRun(self, runName, tag, version, zipfile, force, trimPathPrefixes, description):
        """
        Parameters:
         - runName
         - tag
         - version
         - zipfile
         - force
         - trimPathPrefixes
         - description

        """
        pass

    def allowsStoringAnalysisStatistics(self):
        pass

    def getAnalysisStatisticsLimits(self):
        pass

    def storeAnalysisStatistics(self, runName, zipfile):
        """
        Parameters:
         - runName
         - zipfile

        """
        pass

    def getAnalysisStatistics(self, runId, runHistoryId):
        """
        Parameters:
         - runId
         - runHistoryId

        """
        pass

    def exportData(self, runFilter):
        """
        Parameters:
         - runFilter

        """
        pass

    def importData(self, exportData):
        """
        Parameters:
         - exportData

        """
        pass

    def addCleanupPlan(self, name, description, dueDate):
        """
        Parameters:
         - name
         - description
         - dueDate

        """
        pass

    def updateCleanupPlan(self, id, name, description, dueDate):
        """
        Parameters:
         - id
         - name
         - description
         - dueDate

        """
        pass

    def getCleanupPlans(self, filter):
        """
        Parameters:
         - filter

        """
        pass

    def removeCleanupPlan(self, cleanupPlanId):
        """
        Parameters:
         - cleanupPlanId

        """
        pass

    def closeCleanupPlan(self, cleanupPlanId):
        """
        Parameters:
         - cleanupPlanId

        """
        pass

    def reopenCleanupPlan(self, cleanupPlanId):
        """
        Parameters:
         - cleanupPlanId

        """
        pass

    def setCleanupPlan(self, cleanupPlanId, reportHashes):
        """
        Parameters:
         - cleanupPlanId
         - reportHashes

        """
        pass

    def unsetCleanupPlan(self, cleanupPlanId, reportHashes):
        """
        Parameters:
         - cleanupPlanId
         - reportHashes

        """
        pass


class Client(Iface):
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def getRunData(self, runFilter, limit, offset, sortMode):
        """
        Parameters:
         - runFilter
         - limit
         - offset
         - sortMode

        """
        self.send_getRunData(runFilter, limit, offset, sortMode)
        return self.recv_getRunData()

    def send_getRunData(self, runFilter, limit, offset, sortMode):
        self._oprot.writeMessageBegin('getRunData', TMessageType.CALL, self._seqid)
        args = getRunData_args()
        args.runFilter = runFilter
        args.limit = limit
        args.offset = offset
        args.sortMode = sortMode
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getRunData(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getRunData_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getRunData failed: unknown result")

    def getRunCount(self, runFilter):
        """
        Parameters:
         - runFilter

        """
        self.send_getRunCount(runFilter)
        return self.recv_getRunCount()

    def send_getRunCount(self, runFilter):
        self._oprot.writeMessageBegin('getRunCount', TMessageType.CALL, self._seqid)
        args = getRunCount_args()
        args.runFilter = runFilter
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getRunCount(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getRunCount_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getRunCount failed: unknown result")

    def getCheckCommand(self, runHistoryId, runId):
        """
        Parameters:
         - runHistoryId
         - runId

        """
        self.send_getCheckCommand(runHistoryId, runId)
        return self.recv_getCheckCommand()

    def send_getCheckCommand(self, runHistoryId, runId):
        self._oprot.writeMessageBegin('getCheckCommand', TMessageType.CALL, self._seqid)
        args = getCheckCommand_args()
        args.runHistoryId = runHistoryId
        args.runId = runId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getCheckCommand(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getCheckCommand_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getCheckCommand failed: unknown result")

    def getAnalysisInfo(self, analysisInfoFilter, limit, offset):
        """
        Parameters:
         - analysisInfoFilter
         - limit
         - offset

        """
        self.send_getAnalysisInfo(analysisInfoFilter, limit, offset)
        return self.recv_getAnalysisInfo()

    def send_getAnalysisInfo(self, analysisInfoFilter, limit, offset):
        self._oprot.writeMessageBegin('getAnalysisInfo', TMessageType.CALL, self._seqid)
        args = getAnalysisInfo_args()
        args.analysisInfoFilter = analysisInfoFilter
        args.limit = limit
        args.offset = offset
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getAnalysisInfo(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getAnalysisInfo_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getAnalysisInfo failed: unknown result")

    def getRunHistory(self, runIds, limit, offset, runHistoryFilter):
        """
        Parameters:
         - runIds
         - limit
         - offset
         - runHistoryFilter

        """
        self.send_getRunHistory(runIds, limit, offset, runHistoryFilter)
        return self.recv_getRunHistory()

    def send_getRunHistory(self, runIds, limit, offset, runHistoryFilter):
        self._oprot.writeMessageBegin('getRunHistory', TMessageType.CALL, self._seqid)
        args = getRunHistory_args()
        args.runIds = runIds
        args.limit = limit
        args.offset = offset
        args.runHistoryFilter = runHistoryFilter
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getRunHistory(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getRunHistory_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getRunHistory failed: unknown result")

    def getRunHistoryCount(self, runIds, runHistoryFilter):
        """
        Parameters:
         - runIds
         - runHistoryFilter

        """
        self.send_getRunHistoryCount(runIds, runHistoryFilter)
        return self.recv_getRunHistoryCount()

    def send_getRunHistoryCount(self, runIds, runHistoryFilter):
        self._oprot.writeMessageBegin('getRunHistoryCount', TMessageType.CALL, self._seqid)
        args = getRunHistoryCount_args()
        args.runIds = runIds
        args.runHistoryFilter = runHistoryFilter
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getRunHistoryCount(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getRunHistoryCount_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getRunHistoryCount failed: unknown result")

    def getDiffResultsHash(self, runIds, reportHashes, diffType, skipDetectionStatuses, tagIds):
        """
        Parameters:
         - runIds
         - reportHashes
         - diffType
         - skipDetectionStatuses
         - tagIds

        """
        self.send_getDiffResultsHash(runIds, reportHashes, diffType, skipDetectionStatuses, tagIds)
        return self.recv_getDiffResultsHash()

    def send_getDiffResultsHash(self, runIds, reportHashes, diffType, skipDetectionStatuses, tagIds):
        self._oprot.writeMessageBegin('getDiffResultsHash', TMessageType.CALL, self._seqid)
        args = getDiffResultsHash_args()
        args.runIds = runIds
        args.reportHashes = reportHashes
        args.diffType = diffType
        args.skipDetectionStatuses = skipDetectionStatuses
        args.tagIds = tagIds
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDiffResultsHash(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDiffResultsHash_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getDiffResultsHash failed: unknown result")

    def getReport(self, reportId):
        """
        Parameters:
         - reportId

        """
        self.send_getReport(reportId)
        return self.recv_getReport()

    def send_getReport(self, reportId):
        self._oprot.writeMessageBegin('getReport', TMessageType.CALL, self._seqid)
        args = getReport_args()
        args.reportId = reportId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getReport(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getReport_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getReport failed: unknown result")

    def getRunResults(self, runIds, limit, offset, sortType, reportFilter, cmpData, getDetails):
        """
        Parameters:
         - runIds
         - limit
         - offset
         - sortType
         - reportFilter
         - cmpData
         - getDetails

        """
        self.send_getRunResults(runIds, limit, offset, sortType, reportFilter, cmpData, getDetails)
        return self.recv_getRunResults()

    def send_getRunResults(self, runIds, limit, offset, sortType, reportFilter, cmpData, getDetails):
        self._oprot.writeMessageBegin('getRunResults', TMessageType.CALL, self._seqid)
        args = getRunResults_args()
        args.runIds = runIds
        args.limit = limit
        args.offset = offset
        args.sortType = sortType
        args.reportFilter = reportFilter
        args.cmpData = cmpData
        args.getDetails = getDetails
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getRunResults(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getRunResults_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getRunResults failed: unknown result")

    def getReportAnnotations(self, runIds, reportFilter, cmpData):
        """
        Parameters:
         - runIds
         - reportFilter
         - cmpData

        """
        self.send_getReportAnnotations(runIds, reportFilter, cmpData)
        return self.recv_getReportAnnotations()

    def send_getReportAnnotations(self, runIds, reportFilter, cmpData):
        self._oprot.writeMessageBegin('getReportAnnotations', TMessageType.CALL, self._seqid)
        args = getReportAnnotations_args()
        args.runIds = runIds
        args.reportFilter = reportFilter
        args.cmpData = cmpData
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getReportAnnotations(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getReportAnnotations_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getReportAnnotations failed: unknown result")

    def getRunReportCounts(self, runIds, reportFilter, limit, offset):
        """
        Parameters:
         - runIds
         - reportFilter
         - limit
         - offset

        """
        self.send_getRunReportCounts(runIds, reportFilter, limit, offset)
        return self.recv_getRunReportCounts()

    def send_getRunReportCounts(self, runIds, reportFilter, limit, offset):
        self._oprot.writeMessageBegin('getRunReportCounts', TMessageType.CALL, self._seqid)
        args = getRunReportCounts_args()
        args.runIds = runIds
        args.reportFilter = reportFilter
        args.limit = limit
        args.offset = offset
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getRunReportCounts(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getRunReportCounts_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getRunReportCounts failed: unknown result")

    def getRunResultCount(self, runIds, reportFilter, cmpData):
        """
        Parameters:
         - runIds
         - reportFilter
         - cmpData

        """
        self.send_getRunResultCount(runIds, reportFilter, cmpData)
        return self.recv_getRunResultCount()

    def send_getRunResultCount(self, runIds, reportFilter, cmpData):
        self._oprot.writeMessageBegin('getRunResultCount', TMessageType.CALL, self._seqid)
        args = getRunResultCount_args()
        args.runIds = runIds
        args.reportFilter = reportFilter
        args.cmpData = cmpData
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getRunResultCount(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getRunResultCount_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getRunResultCount failed: unknown result")

    def getFailedFilesCount(self, runIds):
        """
        Parameters:
         - runIds

        """
        self.send_getFailedFilesCount(runIds)
        return self.recv_getFailedFilesCount()

    def send_getFailedFilesCount(self, runIds):
        self._oprot.writeMessageBegin('getFailedFilesCount', TMessageType.CALL, self._seqid)
        args = getFailedFilesCount_args()
        args.runIds = runIds
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getFailedFilesCount(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getFailedFilesCount_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getFailedFilesCount failed: unknown result")

    def getFailedFiles(self, runIds):
        """
        Parameters:
         - runIds

        """
        self.send_getFailedFiles(runIds)
        return self.recv_getFailedFiles()

    def send_getFailedFiles(self, runIds):
        self._oprot.writeMessageBegin('getFailedFiles', TMessageType.CALL, self._seqid)
        args = getFailedFiles_args()
        args.runIds = runIds
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getFailedFiles(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getFailedFiles_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getFailedFiles failed: unknown result")

    def getReportDetails(self, reportId):
        """
        Parameters:
         - reportId

        """
        self.send_getReportDetails(reportId)
        return self.recv_getReportDetails()

    def send_getReportDetails(self, reportId):
        self._oprot.writeMessageBegin('getReportDetails', TMessageType.CALL, self._seqid)
        args = getReportDetails_args()
        args.reportId = reportId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getReportDetails(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getReportDetails_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getReportDetails failed: unknown result")

    def getSourceFileData(self, fileId, fileContent, encoding):
        """
        Parameters:
         - fileId
         - fileContent
         - encoding

        """
        self.send_getSourceFileData(fileId, fileContent, encoding)
        return self.recv_getSourceFileData()

    def send_getSourceFileData(self, fileId, fileContent, encoding):
        self._oprot.writeMessageBegin('getSourceFileData', TMessageType.CALL, self._seqid)
        args = getSourceFileData_args()
        args.fileId = fileId
        args.fileContent = fileContent
        args.encoding = encoding
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getSourceFileData(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getSourceFileData_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getSourceFileData failed: unknown result")

    def getBlameInfo(self, fileId):
        """
        Parameters:
         - fileId

        """
        self.send_getBlameInfo(fileId)
        return self.recv_getBlameInfo()

    def send_getBlameInfo(self, fileId):
        self._oprot.writeMessageBegin('getBlameInfo', TMessageType.CALL, self._seqid)
        args = getBlameInfo_args()
        args.fileId = fileId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getBlameInfo(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getBlameInfo_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getBlameInfo failed: unknown result")

    def getLinesInSourceFileContents(self, linesInFilesRequested, encoding):
        """
        Parameters:
         - linesInFilesRequested
         - encoding

        """
        self.send_getLinesInSourceFileContents(linesInFilesRequested, encoding)
        return self.recv_getLinesInSourceFileContents()

    def send_getLinesInSourceFileContents(self, linesInFilesRequested, encoding):
        self._oprot.writeMessageBegin('getLinesInSourceFileContents', TMessageType.CALL, self._seqid)
        args = getLinesInSourceFileContents_args()
        args.linesInFilesRequested = linesInFilesRequested
        args.encoding = encoding
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getLinesInSourceFileContents(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getLinesInSourceFileContents_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getLinesInSourceFileContents failed: unknown result")

    def isReviewStatusChangeDisabled(self):
        self.send_isReviewStatusChangeDisabled()
        return self.recv_isReviewStatusChangeDisabled()

    def send_isReviewStatusChangeDisabled(self):
        self._oprot.writeMessageBegin('isReviewStatusChangeDisabled', TMessageType.CALL, self._seqid)
        args = isReviewStatusChangeDisabled_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_isReviewStatusChangeDisabled(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = isReviewStatusChangeDisabled_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "isReviewStatusChangeDisabled failed: unknown result")

    def changeReviewStatus(self, reportId, status, message):
        """
        Parameters:
         - reportId
         - status
         - message

        """
        self.send_changeReviewStatus(reportId, status, message)
        return self.recv_changeReviewStatus()

    def send_changeReviewStatus(self, reportId, status, message):
        self._oprot.writeMessageBegin('changeReviewStatus', TMessageType.CALL, self._seqid)
        args = changeReviewStatus_args()
        args.reportId = reportId
        args.status = status
        args.message = message
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_changeReviewStatus(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = changeReviewStatus_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "changeReviewStatus failed: unknown result")

    def getReviewStatusRules(self, filter, sortMode, limit, offset):
        """
        Parameters:
         - filter
         - sortMode
         - limit
         - offset

        """
        self.send_getReviewStatusRules(filter, sortMode, limit, offset)
        return self.recv_getReviewStatusRules()

    def send_getReviewStatusRules(self, filter, sortMode, limit, offset):
        self._oprot.writeMessageBegin('getReviewStatusRules', TMessageType.CALL, self._seqid)
        args = getReviewStatusRules_args()
        args.filter = filter
        args.sortMode = sortMode
        args.limit = limit
        args.offset = offset
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getReviewStatusRules(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getReviewStatusRules_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getReviewStatusRules failed: unknown result")

    def getReviewStatusRulesCount(self, filter):
        """
        Parameters:
         - filter

        """
        self.send_getReviewStatusRulesCount(filter)
        return self.recv_getReviewStatusRulesCount()

    def send_getReviewStatusRulesCount(self, filter):
        self._oprot.writeMessageBegin('getReviewStatusRulesCount', TMessageType.CALL, self._seqid)
        args = getReviewStatusRulesCount_args()
        args.filter = filter
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getReviewStatusRulesCount(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getReviewStatusRulesCount_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getReviewStatusRulesCount failed: unknown result")

    def removeReviewStatusRules(self, filter):
        """
        Parameters:
         - filter

        """
        self.send_removeReviewStatusRules(filter)
        return self.recv_removeReviewStatusRules()

    def send_removeReviewStatusRules(self, filter):
        self._oprot.writeMessageBegin('removeReviewStatusRules', TMessageType.CALL, self._seqid)
        args = removeReviewStatusRules_args()
        args.filter = filter
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_removeReviewStatusRules(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = removeReviewStatusRules_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "removeReviewStatusRules failed: unknown result")

    def addReviewStatusRule(self, reportHash, status, message):
        """
        Parameters:
         - reportHash
         - status
         - message

        """
        self.send_addReviewStatusRule(reportHash, status, message)
        return self.recv_addReviewStatusRule()

    def send_addReviewStatusRule(self, reportHash, status, message):
        self._oprot.writeMessageBegin('addReviewStatusRule', TMessageType.CALL, self._seqid)
        args = addReviewStatusRule_args()
        args.reportHash = reportHash
        args.status = status
        args.message = message
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_addReviewStatusRule(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = addReviewStatusRule_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "addReviewStatusRule failed: unknown result")

    def getComments(self, reportId):
        """
        Parameters:
         - reportId

        """
        self.send_getComments(reportId)
        return self.recv_getComments()

    def send_getComments(self, reportId):
        self._oprot.writeMessageBegin('getComments', TMessageType.CALL, self._seqid)
        args = getComments_args()
        args.reportId = reportId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getComments(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getComments_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getComments failed: unknown result")

    def getCommentCount(self, reportId):
        """
        Parameters:
         - reportId

        """
        self.send_getCommentCount(reportId)
        return self.recv_getCommentCount()

    def send_getCommentCount(self, reportId):
        self._oprot.writeMessageBegin('getCommentCount', TMessageType.CALL, self._seqid)
        args = getCommentCount_args()
        args.reportId = reportId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getCommentCount(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getCommentCount_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getCommentCount failed: unknown result")

    def addComment(self, reportId, comment):
        """
        Parameters:
         - reportId
         - comment

        """
        self.send_addComment(reportId, comment)
        return self.recv_addComment()

    def send_addComment(self, reportId, comment):
        self._oprot.writeMessageBegin('addComment', TMessageType.CALL, self._seqid)
        args = addComment_args()
        args.reportId = reportId
        args.comment = comment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_addComment(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = addComment_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "addComment failed: unknown result")

    def updateComment(self, commentId, newMessage):
        """
        Parameters:
         - commentId
         - newMessage

        """
        self.send_updateComment(commentId, newMessage)
        return self.recv_updateComment()

    def send_updateComment(self, commentId, newMessage):
        self._oprot.writeMessageBegin('updateComment', TMessageType.CALL, self._seqid)
        args = updateComment_args()
        args.commentId = commentId
        args.newMessage = newMessage
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_updateComment(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = updateComment_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "updateComment failed: unknown result")

    def removeComment(self, commentId):
        """
        Parameters:
         - commentId

        """
        self.send_removeComment(commentId)
        return self.recv_removeComment()

    def send_removeComment(self, commentId):
        self._oprot.writeMessageBegin('removeComment', TMessageType.CALL, self._seqid)
        args = removeComment_args()
        args.commentId = commentId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_removeComment(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = removeComment_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "removeComment failed: unknown result")

    def getCheckerDoc(self, checkerId):
        """
        Parameters:
         - checkerId

        """
        self.send_getCheckerDoc(checkerId)
        return self.recv_getCheckerDoc()

    def send_getCheckerDoc(self, checkerId):
        self._oprot.writeMessageBegin('getCheckerDoc', TMessageType.CALL, self._seqid)
        args = getCheckerDoc_args()
        args.checkerId = checkerId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getCheckerDoc(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getCheckerDoc_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getCheckerDoc failed: unknown result")

    def getCheckerLabels(self, checkers):
        """
        Parameters:
         - checkers

        """
        self.send_getCheckerLabels(checkers)
        return self.recv_getCheckerLabels()

    def send_getCheckerLabels(self, checkers):
        self._oprot.writeMessageBegin('getCheckerLabels', TMessageType.CALL, self._seqid)
        args = getCheckerLabels_args()
        args.checkers = checkers
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getCheckerLabels(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getCheckerLabels_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getCheckerLabels failed: unknown result")

    def getGuidelineRules(self, guidelines):
        """
        Parameters:
         - guidelines

        """
        self.send_getGuidelineRules(guidelines)
        return self.recv_getGuidelineRules()

    def send_getGuidelineRules(self, guidelines):
        self._oprot.writeMessageBegin('getGuidelineRules', TMessageType.CALL, self._seqid)
        args = getGuidelineRules_args()
        args.guidelines = guidelines
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getGuidelineRules(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getGuidelineRules_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getGuidelineRules failed: unknown result")

    def getPackageVersion(self):
        self.send_getPackageVersion()
        return self.recv_getPackageVersion()

    def send_getPackageVersion(self):
        self._oprot.writeMessageBegin('getPackageVersion', TMessageType.CALL, self._seqid)
        args = getPackageVersion_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getPackageVersion(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getPackageVersion_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getPackageVersion failed: unknown result")

    def removeRunResults(self, runIds):
        """
        Parameters:
         - runIds

        """
        self.send_removeRunResults(runIds)
        return self.recv_removeRunResults()

    def send_removeRunResults(self, runIds):
        self._oprot.writeMessageBegin('removeRunResults', TMessageType.CALL, self._seqid)
        args = removeRunResults_args()
        args.runIds = runIds
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_removeRunResults(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = removeRunResults_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "removeRunResults failed: unknown result")

    def removeRunReports(self, runIds, reportFilter, cmpData):
        """
        Parameters:
         - runIds
         - reportFilter
         - cmpData

        """
        self.send_removeRunReports(runIds, reportFilter, cmpData)
        return self.recv_removeRunReports()

    def send_removeRunReports(self, runIds, reportFilter, cmpData):
        self._oprot.writeMessageBegin('removeRunReports', TMessageType.CALL, self._seqid)
        args = removeRunReports_args()
        args.runIds = runIds
        args.reportFilter = reportFilter
        args.cmpData = cmpData
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_removeRunReports(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = removeRunReports_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "removeRunReports failed: unknown result")

    def removeRun(self, runId, runFilter):
        """
        Parameters:
         - runId
         - runFilter

        """
        self.send_removeRun(runId, runFilter)
        return self.recv_removeRun()

    def send_removeRun(self, runId, runFilter):
        self._oprot.writeMessageBegin('removeRun', TMessageType.CALL, self._seqid)
        args = removeRun_args()
        args.runId = runId
        args.runFilter = runFilter
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_removeRun(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = removeRun_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "removeRun failed: unknown result")

    def updateRunData(self, runId, newRunName):
        """
        Parameters:
         - runId
         - newRunName

        """
        self.send_updateRunData(runId, newRunName)
        return self.recv_updateRunData()

    def send_updateRunData(self, runId, newRunName):
        self._oprot.writeMessageBegin('updateRunData', TMessageType.CALL, self._seqid)
        args = updateRunData_args()
        args.runId = runId
        args.newRunName = newRunName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_updateRunData(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = updateRunData_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "updateRunData failed: unknown result")

    def getSuppressFile(self):
        self.send_getSuppressFile()
        return self.recv_getSuppressFile()

    def send_getSuppressFile(self):
        self._oprot.writeMessageBegin('getSuppressFile', TMessageType.CALL, self._seqid)
        args = getSuppressFile_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getSuppressFile(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getSuppressFile_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getSuppressFile failed: unknown result")

    def getSeverityCounts(self, runIds, reportFilter, cmpData):
        """
        Parameters:
         - runIds
         - reportFilter
         - cmpData

        """
        self.send_getSeverityCounts(runIds, reportFilter, cmpData)
        return self.recv_getSeverityCounts()

    def send_getSeverityCounts(self, runIds, reportFilter, cmpData):
        self._oprot.writeMessageBegin('getSeverityCounts', TMessageType.CALL, self._seqid)
        args = getSeverityCounts_args()
        args.runIds = runIds
        args.reportFilter = reportFilter
        args.cmpData = cmpData
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getSeverityCounts(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getSeverityCounts_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getSeverityCounts failed: unknown result")

    def getCheckerMsgCounts(self, runIds, reportFilter, cmpData, limit, offset):
        """
        Parameters:
         - runIds
         - reportFilter
         - cmpData
         - limit
         - offset

        """
        self.send_getCheckerMsgCounts(runIds, reportFilter, cmpData, limit, offset)
        return self.recv_getCheckerMsgCounts()

    def send_getCheckerMsgCounts(self, runIds, reportFilter, cmpData, limit, offset):
        self._oprot.writeMessageBegin('getCheckerMsgCounts', TMessageType.CALL, self._seqid)
        args = getCheckerMsgCounts_args()
        args.runIds = runIds
        args.reportFilter = reportFilter
        args.cmpData = cmpData
        args.limit = limit
        args.offset = offset
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getCheckerMsgCounts(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getCheckerMsgCounts_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getCheckerMsgCounts failed: unknown result")

    def getReportStatusCounts(self, runIds, reportFilter, cmpData):
        """
        Parameters:
         - runIds
         - reportFilter
         - cmpData

        """
        self.send_getReportStatusCounts(runIds, reportFilter, cmpData)
        return self.recv_getReportStatusCounts()

    def send_getReportStatusCounts(self, runIds, reportFilter, cmpData):
        self._oprot.writeMessageBegin('getReportStatusCounts', TMessageType.CALL, self._seqid)
        args = getReportStatusCounts_args()
        args.runIds = runIds
        args.reportFilter = reportFilter
        args.cmpData = cmpData
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getReportStatusCounts(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getReportStatusCounts_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getReportStatusCounts failed: unknown result")

    def getReviewStatusCounts(self, runIds, reportFilter, cmpData):
        """
        Parameters:
         - runIds
         - reportFilter
         - cmpData

        """
        self.send_getReviewStatusCounts(runIds, reportFilter, cmpData)
        return self.recv_getReviewStatusCounts()

    def send_getReviewStatusCounts(self, runIds, reportFilter, cmpData):
        self._oprot.writeMessageBegin('getReviewStatusCounts', TMessageType.CALL, self._seqid)
        args = getReviewStatusCounts_args()
        args.runIds = runIds
        args.reportFilter = reportFilter
        args.cmpData = cmpData
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getReviewStatusCounts(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getReviewStatusCounts_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getReviewStatusCounts failed: unknown result")

    def getDetectionStatusCounts(self, runIds, reportFilter, cmpData):
        """
        Parameters:
         - runIds
         - reportFilter
         - cmpData

        """
        self.send_getDetectionStatusCounts(runIds, reportFilter, cmpData)
        return self.recv_getDetectionStatusCounts()

    def send_getDetectionStatusCounts(self, runIds, reportFilter, cmpData):
        self._oprot.writeMessageBegin('getDetectionStatusCounts', TMessageType.CALL, self._seqid)
        args = getDetectionStatusCounts_args()
        args.runIds = runIds
        args.reportFilter = reportFilter
        args.cmpData = cmpData
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDetectionStatusCounts(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDetectionStatusCounts_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getDetectionStatusCounts failed: unknown result")

    def getFileCounts(self, runIds, reportFilter, cmpData, limit, offset):
        """
        Parameters:
         - runIds
         - reportFilter
         - cmpData
         - limit
         - offset

        """
        self.send_getFileCounts(runIds, reportFilter, cmpData, limit, offset)
        return self.recv_getFileCounts()

    def send_getFileCounts(self, runIds, reportFilter, cmpData, limit, offset):
        self._oprot.writeMessageBegin('getFileCounts', TMessageType.CALL, self._seqid)
        args = getFileCounts_args()
        args.runIds = runIds
        args.reportFilter = reportFilter
        args.cmpData = cmpData
        args.limit = limit
        args.offset = offset
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getFileCounts(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getFileCounts_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getFileCounts failed: unknown result")

    def getCheckerCounts(self, runIds, reportFilter, cmpData, limit, offset):
        """
        Parameters:
         - runIds
         - reportFilter
         - cmpData
         - limit
         - offset

        """
        self.send_getCheckerCounts(runIds, reportFilter, cmpData, limit, offset)
        return self.recv_getCheckerCounts()

    def send_getCheckerCounts(self, runIds, reportFilter, cmpData, limit, offset):
        self._oprot.writeMessageBegin('getCheckerCounts', TMessageType.CALL, self._seqid)
        args = getCheckerCounts_args()
        args.runIds = runIds
        args.reportFilter = reportFilter
        args.cmpData = cmpData
        args.limit = limit
        args.offset = offset
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getCheckerCounts(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getCheckerCounts_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getCheckerCounts failed: unknown result")

    def getCheckerStatusVerificationDetails(self, runIds, reportFilter):
        """
        Parameters:
         - runIds
         - reportFilter

        """
        self.send_getCheckerStatusVerificationDetails(runIds, reportFilter)
        return self.recv_getCheckerStatusVerificationDetails()

    def send_getCheckerStatusVerificationDetails(self, runIds, reportFilter):
        self._oprot.writeMessageBegin('getCheckerStatusVerificationDetails', TMessageType.CALL, self._seqid)
        args = getCheckerStatusVerificationDetails_args()
        args.runIds = runIds
        args.reportFilter = reportFilter
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getCheckerStatusVerificationDetails(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getCheckerStatusVerificationDetails_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getCheckerStatusVerificationDetails failed: unknown result")

    def getRunHistoryTagCounts(self, runIds, reportFilter, cmpData, limit, offset):
        """
        Parameters:
         - runIds
         - reportFilter
         - cmpData
         - limit
         - offset

        """
        self.send_getRunHistoryTagCounts(runIds, reportFilter, cmpData, limit, offset)
        return self.recv_getRunHistoryTagCounts()

    def send_getRunHistoryTagCounts(self, runIds, reportFilter, cmpData, limit, offset):
        self._oprot.writeMessageBegin('getRunHistoryTagCounts', TMessageType.CALL, self._seqid)
        args = getRunHistoryTagCounts_args()
        args.runIds = runIds
        args.reportFilter = reportFilter
        args.cmpData = cmpData
        args.limit = limit
        args.offset = offset
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getRunHistoryTagCounts(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getRunHistoryTagCounts_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getRunHistoryTagCounts failed: unknown result")

    def getAnalyzerNameCounts(self, runIds, reportFilter, cmpData, limit, offset):
        """
        Parameters:
         - runIds
         - reportFilter
         - cmpData
         - limit
         - offset

        """
        self.send_getAnalyzerNameCounts(runIds, reportFilter, cmpData, limit, offset)
        return self.recv_getAnalyzerNameCounts()

    def send_getAnalyzerNameCounts(self, runIds, reportFilter, cmpData, limit, offset):
        self._oprot.writeMessageBegin('getAnalyzerNameCounts', TMessageType.CALL, self._seqid)
        args = getAnalyzerNameCounts_args()
        args.runIds = runIds
        args.reportFilter = reportFilter
        args.cmpData = cmpData
        args.limit = limit
        args.offset = offset
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getAnalyzerNameCounts(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getAnalyzerNameCounts_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getAnalyzerNameCounts failed: unknown result")

    def addSourceComponent(self, name, value, description):
        """
        Parameters:
         - name
         - value
         - description

        """
        self.send_addSourceComponent(name, value, description)
        return self.recv_addSourceComponent()

    def send_addSourceComponent(self, name, value, description):
        self._oprot.writeMessageBegin('addSourceComponent', TMessageType.CALL, self._seqid)
        args = addSourceComponent_args()
        args.name = name
        args.value = value
        args.description = description
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_addSourceComponent(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = addSourceComponent_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "addSourceComponent failed: unknown result")

    def getSourceComponents(self, sourceComponentFilter):
        """
        Parameters:
         - sourceComponentFilter

        """
        self.send_getSourceComponents(sourceComponentFilter)
        return self.recv_getSourceComponents()

    def send_getSourceComponents(self, sourceComponentFilter):
        self._oprot.writeMessageBegin('getSourceComponents', TMessageType.CALL, self._seqid)
        args = getSourceComponents_args()
        args.sourceComponentFilter = sourceComponentFilter
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getSourceComponents(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getSourceComponents_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getSourceComponents failed: unknown result")

    def removeSourceComponent(self, name):
        """
        Parameters:
         - name

        """
        self.send_removeSourceComponent(name)
        return self.recv_removeSourceComponent()

    def send_removeSourceComponent(self, name):
        self._oprot.writeMessageBegin('removeSourceComponent', TMessageType.CALL, self._seqid)
        args = removeSourceComponent_args()
        args.name = name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_removeSourceComponent(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = removeSourceComponent_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "removeSourceComponent failed: unknown result")

    def getMissingContentHashes(self, fileHashes):
        """
        Parameters:
         - fileHashes

        """
        self.send_getMissingContentHashes(fileHashes)
        return self.recv_getMissingContentHashes()

    def send_getMissingContentHashes(self, fileHashes):
        self._oprot.writeMessageBegin('getMissingContentHashes', TMessageType.CALL, self._seqid)
        args = getMissingContentHashes_args()
        args.fileHashes = fileHashes
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getMissingContentHashes(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getMissingContentHashes_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getMissingContentHashes failed: unknown result")

    def getMissingContentHashesForBlameInfo(self, fileHashes):
        """
        Parameters:
         - fileHashes

        """
        self.send_getMissingContentHashesForBlameInfo(fileHashes)
        return self.recv_getMissingContentHashesForBlameInfo()

    def send_getMissingContentHashesForBlameInfo(self, fileHashes):
        self._oprot.writeMessageBegin('getMissingContentHashesForBlameInfo', TMessageType.CALL, self._seqid)
        args = getMissingContentHashesForBlameInfo_args()
        args.fileHashes = fileHashes
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getMissingContentHashesForBlameInfo(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getMissingContentHashesForBlameInfo_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getMissingContentHashesForBlameInfo failed: unknown result")

    def massStoreRun(self, runName, tag, version, zipfile, force, trimPathPrefixes, description):
        """
        Parameters:
         - runName
         - tag
         - version
         - zipfile
         - force
         - trimPathPrefixes
         - description

        """
        self.send_massStoreRun(runName, tag, version, zipfile, force, trimPathPrefixes, description)
        return self.recv_massStoreRun()

    def send_massStoreRun(self, runName, tag, version, zipfile, force, trimPathPrefixes, description):
        self._oprot.writeMessageBegin('massStoreRun', TMessageType.CALL, self._seqid)
        args = massStoreRun_args()
        args.runName = runName
        args.tag = tag
        args.version = version
        args.zipfile = zipfile
        args.force = force
        args.trimPathPrefixes = trimPathPrefixes
        args.description = description
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_massStoreRun(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = massStoreRun_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "massStoreRun failed: unknown result")

    def allowsStoringAnalysisStatistics(self):
        self.send_allowsStoringAnalysisStatistics()
        return self.recv_allowsStoringAnalysisStatistics()

    def send_allowsStoringAnalysisStatistics(self):
        self._oprot.writeMessageBegin('allowsStoringAnalysisStatistics', TMessageType.CALL, self._seqid)
        args = allowsStoringAnalysisStatistics_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_allowsStoringAnalysisStatistics(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = allowsStoringAnalysisStatistics_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "allowsStoringAnalysisStatistics failed: unknown result")

    def getAnalysisStatisticsLimits(self):
        self.send_getAnalysisStatisticsLimits()
        return self.recv_getAnalysisStatisticsLimits()

    def send_getAnalysisStatisticsLimits(self):
        self._oprot.writeMessageBegin('getAnalysisStatisticsLimits', TMessageType.CALL, self._seqid)
        args = getAnalysisStatisticsLimits_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getAnalysisStatisticsLimits(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getAnalysisStatisticsLimits_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getAnalysisStatisticsLimits failed: unknown result")

    def storeAnalysisStatistics(self, runName, zipfile):
        """
        Parameters:
         - runName
         - zipfile

        """
        self.send_storeAnalysisStatistics(runName, zipfile)
        return self.recv_storeAnalysisStatistics()

    def send_storeAnalysisStatistics(self, runName, zipfile):
        self._oprot.writeMessageBegin('storeAnalysisStatistics', TMessageType.CALL, self._seqid)
        args = storeAnalysisStatistics_args()
        args.runName = runName
        args.zipfile = zipfile
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_storeAnalysisStatistics(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = storeAnalysisStatistics_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "storeAnalysisStatistics failed: unknown result")

    def getAnalysisStatistics(self, runId, runHistoryId):
        """
        Parameters:
         - runId
         - runHistoryId

        """
        self.send_getAnalysisStatistics(runId, runHistoryId)
        return self.recv_getAnalysisStatistics()

    def send_getAnalysisStatistics(self, runId, runHistoryId):
        self._oprot.writeMessageBegin('getAnalysisStatistics', TMessageType.CALL, self._seqid)
        args = getAnalysisStatistics_args()
        args.runId = runId
        args.runHistoryId = runHistoryId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getAnalysisStatistics(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getAnalysisStatistics_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getAnalysisStatistics failed: unknown result")

    def exportData(self, runFilter):
        """
        Parameters:
         - runFilter

        """
        self.send_exportData(runFilter)
        return self.recv_exportData()

    def send_exportData(self, runFilter):
        self._oprot.writeMessageBegin('exportData', TMessageType.CALL, self._seqid)
        args = exportData_args()
        args.runFilter = runFilter
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_exportData(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = exportData_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "exportData failed: unknown result")

    def importData(self, exportData):
        """
        Parameters:
         - exportData

        """
        self.send_importData(exportData)
        return self.recv_importData()

    def send_importData(self, exportData):
        self._oprot.writeMessageBegin('importData', TMessageType.CALL, self._seqid)
        args = importData_args()
        args.exportData = exportData
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_importData(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = importData_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "importData failed: unknown result")

    def addCleanupPlan(self, name, description, dueDate):
        """
        Parameters:
         - name
         - description
         - dueDate

        """
        self.send_addCleanupPlan(name, description, dueDate)
        return self.recv_addCleanupPlan()

    def send_addCleanupPlan(self, name, description, dueDate):
        self._oprot.writeMessageBegin('addCleanupPlan', TMessageType.CALL, self._seqid)
        args = addCleanupPlan_args()
        args.name = name
        args.description = description
        args.dueDate = dueDate
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_addCleanupPlan(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = addCleanupPlan_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "addCleanupPlan failed: unknown result")

    def updateCleanupPlan(self, id, name, description, dueDate):
        """
        Parameters:
         - id
         - name
         - description
         - dueDate

        """
        self.send_updateCleanupPlan(id, name, description, dueDate)
        return self.recv_updateCleanupPlan()

    def send_updateCleanupPlan(self, id, name, description, dueDate):
        self._oprot.writeMessageBegin('updateCleanupPlan', TMessageType.CALL, self._seqid)
        args = updateCleanupPlan_args()
        args.id = id
        args.name = name
        args.description = description
        args.dueDate = dueDate
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_updateCleanupPlan(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = updateCleanupPlan_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "updateCleanupPlan failed: unknown result")

    def getCleanupPlans(self, filter):
        """
        Parameters:
         - filter

        """
        self.send_getCleanupPlans(filter)
        return self.recv_getCleanupPlans()

    def send_getCleanupPlans(self, filter):
        self._oprot.writeMessageBegin('getCleanupPlans', TMessageType.CALL, self._seqid)
        args = getCleanupPlans_args()
        args.filter = filter
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getCleanupPlans(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getCleanupPlans_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getCleanupPlans failed: unknown result")

    def removeCleanupPlan(self, cleanupPlanId):
        """
        Parameters:
         - cleanupPlanId

        """
        self.send_removeCleanupPlan(cleanupPlanId)
        return self.recv_removeCleanupPlan()

    def send_removeCleanupPlan(self, cleanupPlanId):
        self._oprot.writeMessageBegin('removeCleanupPlan', TMessageType.CALL, self._seqid)
        args = removeCleanupPlan_args()
        args.cleanupPlanId = cleanupPlanId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_removeCleanupPlan(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = removeCleanupPlan_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "removeCleanupPlan failed: unknown result")

    def closeCleanupPlan(self, cleanupPlanId):
        """
        Parameters:
         - cleanupPlanId

        """
        self.send_closeCleanupPlan(cleanupPlanId)
        return self.recv_closeCleanupPlan()

    def send_closeCleanupPlan(self, cleanupPlanId):
        self._oprot.writeMessageBegin('closeCleanupPlan', TMessageType.CALL, self._seqid)
        args = closeCleanupPlan_args()
        args.cleanupPlanId = cleanupPlanId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_closeCleanupPlan(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = closeCleanupPlan_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "closeCleanupPlan failed: unknown result")

    def reopenCleanupPlan(self, cleanupPlanId):
        """
        Parameters:
         - cleanupPlanId

        """
        self.send_reopenCleanupPlan(cleanupPlanId)
        return self.recv_reopenCleanupPlan()

    def send_reopenCleanupPlan(self, cleanupPlanId):
        self._oprot.writeMessageBegin('reopenCleanupPlan', TMessageType.CALL, self._seqid)
        args = reopenCleanupPlan_args()
        args.cleanupPlanId = cleanupPlanId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_reopenCleanupPlan(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = reopenCleanupPlan_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "reopenCleanupPlan failed: unknown result")

    def setCleanupPlan(self, cleanupPlanId, reportHashes):
        """
        Parameters:
         - cleanupPlanId
         - reportHashes

        """
        self.send_setCleanupPlan(cleanupPlanId, reportHashes)
        return self.recv_setCleanupPlan()

    def send_setCleanupPlan(self, cleanupPlanId, reportHashes):
        self._oprot.writeMessageBegin('setCleanupPlan', TMessageType.CALL, self._seqid)
        args = setCleanupPlan_args()
        args.cleanupPlanId = cleanupPlanId
        args.reportHashes = reportHashes
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_setCleanupPlan(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = setCleanupPlan_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "setCleanupPlan failed: unknown result")

    def unsetCleanupPlan(self, cleanupPlanId, reportHashes):
        """
        Parameters:
         - cleanupPlanId
         - reportHashes

        """
        self.send_unsetCleanupPlan(cleanupPlanId, reportHashes)
        return self.recv_unsetCleanupPlan()

    def send_unsetCleanupPlan(self, cleanupPlanId, reportHashes):
        self._oprot.writeMessageBegin('unsetCleanupPlan', TMessageType.CALL, self._seqid)
        args = unsetCleanupPlan_args()
        args.cleanupPlanId = cleanupPlanId
        args.reportHashes = reportHashes
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_unsetCleanupPlan(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = unsetCleanupPlan_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "unsetCleanupPlan failed: unknown result")


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["getRunData"] = Processor.process_getRunData
        self._processMap["getRunCount"] = Processor.process_getRunCount
        self._processMap["getCheckCommand"] = Processor.process_getCheckCommand
        self._processMap["getAnalysisInfo"] = Processor.process_getAnalysisInfo
        self._processMap["getRunHistory"] = Processor.process_getRunHistory
        self._processMap["getRunHistoryCount"] = Processor.process_getRunHistoryCount
        self._processMap["getDiffResultsHash"] = Processor.process_getDiffResultsHash
        self._processMap["getReport"] = Processor.process_getReport
        self._processMap["getRunResults"] = Processor.process_getRunResults
        self._processMap["getReportAnnotations"] = Processor.process_getReportAnnotations
        self._processMap["getRunReportCounts"] = Processor.process_getRunReportCounts
        self._processMap["getRunResultCount"] = Processor.process_getRunResultCount
        self._processMap["getFailedFilesCount"] = Processor.process_getFailedFilesCount
        self._processMap["getFailedFiles"] = Processor.process_getFailedFiles
        self._processMap["getReportDetails"] = Processor.process_getReportDetails
        self._processMap["getSourceFileData"] = Processor.process_getSourceFileData
        self._processMap["getBlameInfo"] = Processor.process_getBlameInfo
        self._processMap["getLinesInSourceFileContents"] = Processor.process_getLinesInSourceFileContents
        self._processMap["isReviewStatusChangeDisabled"] = Processor.process_isReviewStatusChangeDisabled
        self._processMap["changeReviewStatus"] = Processor.process_changeReviewStatus
        self._processMap["getReviewStatusRules"] = Processor.process_getReviewStatusRules
        self._processMap["getReviewStatusRulesCount"] = Processor.process_getReviewStatusRulesCount
        self._processMap["removeReviewStatusRules"] = Processor.process_removeReviewStatusRules
        self._processMap["addReviewStatusRule"] = Processor.process_addReviewStatusRule
        self._processMap["getComments"] = Processor.process_getComments
        self._processMap["getCommentCount"] = Processor.process_getCommentCount
        self._processMap["addComment"] = Processor.process_addComment
        self._processMap["updateComment"] = Processor.process_updateComment
        self._processMap["removeComment"] = Processor.process_removeComment
        self._processMap["getCheckerDoc"] = Processor.process_getCheckerDoc
        self._processMap["getCheckerLabels"] = Processor.process_getCheckerLabels
        self._processMap["getGuidelineRules"] = Processor.process_getGuidelineRules
        self._processMap["getPackageVersion"] = Processor.process_getPackageVersion
        self._processMap["removeRunResults"] = Processor.process_removeRunResults
        self._processMap["removeRunReports"] = Processor.process_removeRunReports
        self._processMap["removeRun"] = Processor.process_removeRun
        self._processMap["updateRunData"] = Processor.process_updateRunData
        self._processMap["getSuppressFile"] = Processor.process_getSuppressFile
        self._processMap["getSeverityCounts"] = Processor.process_getSeverityCounts
        self._processMap["getCheckerMsgCounts"] = Processor.process_getCheckerMsgCounts
        self._processMap["getReportStatusCounts"] = Processor.process_getReportStatusCounts
        self._processMap["getReviewStatusCounts"] = Processor.process_getReviewStatusCounts
        self._processMap["getDetectionStatusCounts"] = Processor.process_getDetectionStatusCounts
        self._processMap["getFileCounts"] = Processor.process_getFileCounts
        self._processMap["getCheckerCounts"] = Processor.process_getCheckerCounts
        self._processMap["getCheckerStatusVerificationDetails"] = Processor.process_getCheckerStatusVerificationDetails
        self._processMap["getRunHistoryTagCounts"] = Processor.process_getRunHistoryTagCounts
        self._processMap["getAnalyzerNameCounts"] = Processor.process_getAnalyzerNameCounts
        self._processMap["addSourceComponent"] = Processor.process_addSourceComponent
        self._processMap["getSourceComponents"] = Processor.process_getSourceComponents
        self._processMap["removeSourceComponent"] = Processor.process_removeSourceComponent
        self._processMap["getMissingContentHashes"] = Processor.process_getMissingContentHashes
        self._processMap["getMissingContentHashesForBlameInfo"] = Processor.process_getMissingContentHashesForBlameInfo
        self._processMap["massStoreRun"] = Processor.process_massStoreRun
        self._processMap["allowsStoringAnalysisStatistics"] = Processor.process_allowsStoringAnalysisStatistics
        self._processMap["getAnalysisStatisticsLimits"] = Processor.process_getAnalysisStatisticsLimits
        self._processMap["storeAnalysisStatistics"] = Processor.process_storeAnalysisStatistics
        self._processMap["getAnalysisStatistics"] = Processor.process_getAnalysisStatistics
        self._processMap["exportData"] = Processor.process_exportData
        self._processMap["importData"] = Processor.process_importData
        self._processMap["addCleanupPlan"] = Processor.process_addCleanupPlan
        self._processMap["updateCleanupPlan"] = Processor.process_updateCleanupPlan
        self._processMap["getCleanupPlans"] = Processor.process_getCleanupPlans
        self._processMap["removeCleanupPlan"] = Processor.process_removeCleanupPlan
        self._processMap["closeCleanupPlan"] = Processor.process_closeCleanupPlan
        self._processMap["reopenCleanupPlan"] = Processor.process_reopenCleanupPlan
        self._processMap["setCleanupPlan"] = Processor.process_setCleanupPlan
        self._processMap["unsetCleanupPlan"] = Processor.process_unsetCleanupPlan
        self._on_message_begin = None

    def on_message_begin(self, func):
        self._on_message_begin = func

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if self._on_message_begin:
            self._on_message_begin(name, type, seqid)
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_getRunData(self, seqid, iprot, oprot):
        args = getRunData_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getRunData_result()
        try:
            result.success = self._handler.getRunData(args.runFilter, args.limit, args.offset, args.sortMode)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getRunData", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getRunCount(self, seqid, iprot, oprot):
        args = getRunCount_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getRunCount_result()
        try:
            result.success = self._handler.getRunCount(args.runFilter)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getRunCount", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getCheckCommand(self, seqid, iprot, oprot):
        args = getCheckCommand_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getCheckCommand_result()
        try:
            result.success = self._handler.getCheckCommand(args.runHistoryId, args.runId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getCheckCommand", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getAnalysisInfo(self, seqid, iprot, oprot):
        args = getAnalysisInfo_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getAnalysisInfo_result()
        try:
            result.success = self._handler.getAnalysisInfo(args.analysisInfoFilter, args.limit, args.offset)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getAnalysisInfo", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getRunHistory(self, seqid, iprot, oprot):
        args = getRunHistory_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getRunHistory_result()
        try:
            result.success = self._handler.getRunHistory(args.runIds, args.limit, args.offset, args.runHistoryFilter)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getRunHistory", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getRunHistoryCount(self, seqid, iprot, oprot):
        args = getRunHistoryCount_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getRunHistoryCount_result()
        try:
            result.success = self._handler.getRunHistoryCount(args.runIds, args.runHistoryFilter)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getRunHistoryCount", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getDiffResultsHash(self, seqid, iprot, oprot):
        args = getDiffResultsHash_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDiffResultsHash_result()
        try:
            result.success = self._handler.getDiffResultsHash(args.runIds, args.reportHashes, args.diffType, args.skipDetectionStatuses, args.tagIds)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getDiffResultsHash", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getReport(self, seqid, iprot, oprot):
        args = getReport_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getReport_result()
        try:
            result.success = self._handler.getReport(args.reportId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getReport", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getRunResults(self, seqid, iprot, oprot):
        args = getRunResults_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getRunResults_result()
        try:
            result.success = self._handler.getRunResults(args.runIds, args.limit, args.offset, args.sortType, args.reportFilter, args.cmpData, args.getDetails)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getRunResults", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getReportAnnotations(self, seqid, iprot, oprot):
        args = getReportAnnotations_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getReportAnnotations_result()
        try:
            result.success = self._handler.getReportAnnotations(args.runIds, args.reportFilter, args.cmpData)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getReportAnnotations", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getRunReportCounts(self, seqid, iprot, oprot):
        args = getRunReportCounts_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getRunReportCounts_result()
        try:
            result.success = self._handler.getRunReportCounts(args.runIds, args.reportFilter, args.limit, args.offset)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getRunReportCounts", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getRunResultCount(self, seqid, iprot, oprot):
        args = getRunResultCount_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getRunResultCount_result()
        try:
            result.success = self._handler.getRunResultCount(args.runIds, args.reportFilter, args.cmpData)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getRunResultCount", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getFailedFilesCount(self, seqid, iprot, oprot):
        args = getFailedFilesCount_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getFailedFilesCount_result()
        try:
            result.success = self._handler.getFailedFilesCount(args.runIds)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getFailedFilesCount", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getFailedFiles(self, seqid, iprot, oprot):
        args = getFailedFiles_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getFailedFiles_result()
        try:
            result.success = self._handler.getFailedFiles(args.runIds)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getFailedFiles", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getReportDetails(self, seqid, iprot, oprot):
        args = getReportDetails_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getReportDetails_result()
        try:
            result.success = self._handler.getReportDetails(args.reportId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getReportDetails", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getSourceFileData(self, seqid, iprot, oprot):
        args = getSourceFileData_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getSourceFileData_result()
        try:
            result.success = self._handler.getSourceFileData(args.fileId, args.fileContent, args.encoding)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getSourceFileData", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getBlameInfo(self, seqid, iprot, oprot):
        args = getBlameInfo_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getBlameInfo_result()
        try:
            result.success = self._handler.getBlameInfo(args.fileId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getBlameInfo", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getLinesInSourceFileContents(self, seqid, iprot, oprot):
        args = getLinesInSourceFileContents_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getLinesInSourceFileContents_result()
        try:
            result.success = self._handler.getLinesInSourceFileContents(args.linesInFilesRequested, args.encoding)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getLinesInSourceFileContents", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_isReviewStatusChangeDisabled(self, seqid, iprot, oprot):
        args = isReviewStatusChangeDisabled_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = isReviewStatusChangeDisabled_result()
        try:
            result.success = self._handler.isReviewStatusChangeDisabled()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("isReviewStatusChangeDisabled", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_changeReviewStatus(self, seqid, iprot, oprot):
        args = changeReviewStatus_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = changeReviewStatus_result()
        try:
            result.success = self._handler.changeReviewStatus(args.reportId, args.status, args.message)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("changeReviewStatus", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getReviewStatusRules(self, seqid, iprot, oprot):
        args = getReviewStatusRules_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getReviewStatusRules_result()
        try:
            result.success = self._handler.getReviewStatusRules(args.filter, args.sortMode, args.limit, args.offset)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getReviewStatusRules", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getReviewStatusRulesCount(self, seqid, iprot, oprot):
        args = getReviewStatusRulesCount_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getReviewStatusRulesCount_result()
        try:
            result.success = self._handler.getReviewStatusRulesCount(args.filter)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getReviewStatusRulesCount", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_removeReviewStatusRules(self, seqid, iprot, oprot):
        args = removeReviewStatusRules_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = removeReviewStatusRules_result()
        try:
            result.success = self._handler.removeReviewStatusRules(args.filter)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("removeReviewStatusRules", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_addReviewStatusRule(self, seqid, iprot, oprot):
        args = addReviewStatusRule_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = addReviewStatusRule_result()
        try:
            result.success = self._handler.addReviewStatusRule(args.reportHash, args.status, args.message)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("addReviewStatusRule", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getComments(self, seqid, iprot, oprot):
        args = getComments_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getComments_result()
        try:
            result.success = self._handler.getComments(args.reportId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getComments", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getCommentCount(self, seqid, iprot, oprot):
        args = getCommentCount_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getCommentCount_result()
        try:
            result.success = self._handler.getCommentCount(args.reportId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getCommentCount", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_addComment(self, seqid, iprot, oprot):
        args = addComment_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = addComment_result()
        try:
            result.success = self._handler.addComment(args.reportId, args.comment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("addComment", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_updateComment(self, seqid, iprot, oprot):
        args = updateComment_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateComment_result()
        try:
            result.success = self._handler.updateComment(args.commentId, args.newMessage)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("updateComment", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_removeComment(self, seqid, iprot, oprot):
        args = removeComment_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = removeComment_result()
        try:
            result.success = self._handler.removeComment(args.commentId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("removeComment", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getCheckerDoc(self, seqid, iprot, oprot):
        args = getCheckerDoc_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getCheckerDoc_result()
        try:
            result.success = self._handler.getCheckerDoc(args.checkerId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getCheckerDoc", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getCheckerLabels(self, seqid, iprot, oprot):
        args = getCheckerLabels_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getCheckerLabels_result()
        try:
            result.success = self._handler.getCheckerLabels(args.checkers)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getCheckerLabels", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getGuidelineRules(self, seqid, iprot, oprot):
        args = getGuidelineRules_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getGuidelineRules_result()
        try:
            result.success = self._handler.getGuidelineRules(args.guidelines)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getGuidelineRules", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getPackageVersion(self, seqid, iprot, oprot):
        args = getPackageVersion_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getPackageVersion_result()
        try:
            result.success = self._handler.getPackageVersion()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getPackageVersion", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_removeRunResults(self, seqid, iprot, oprot):
        args = removeRunResults_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = removeRunResults_result()
        try:
            result.success = self._handler.removeRunResults(args.runIds)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("removeRunResults", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_removeRunReports(self, seqid, iprot, oprot):
        args = removeRunReports_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = removeRunReports_result()
        try:
            result.success = self._handler.removeRunReports(args.runIds, args.reportFilter, args.cmpData)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("removeRunReports", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_removeRun(self, seqid, iprot, oprot):
        args = removeRun_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = removeRun_result()
        try:
            result.success = self._handler.removeRun(args.runId, args.runFilter)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("removeRun", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_updateRunData(self, seqid, iprot, oprot):
        args = updateRunData_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateRunData_result()
        try:
            result.success = self._handler.updateRunData(args.runId, args.newRunName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("updateRunData", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getSuppressFile(self, seqid, iprot, oprot):
        args = getSuppressFile_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getSuppressFile_result()
        try:
            result.success = self._handler.getSuppressFile()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getSuppressFile", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getSeverityCounts(self, seqid, iprot, oprot):
        args = getSeverityCounts_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getSeverityCounts_result()
        try:
            result.success = self._handler.getSeverityCounts(args.runIds, args.reportFilter, args.cmpData)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getSeverityCounts", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getCheckerMsgCounts(self, seqid, iprot, oprot):
        args = getCheckerMsgCounts_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getCheckerMsgCounts_result()
        try:
            result.success = self._handler.getCheckerMsgCounts(args.runIds, args.reportFilter, args.cmpData, args.limit, args.offset)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getCheckerMsgCounts", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getReportStatusCounts(self, seqid, iprot, oprot):
        args = getReportStatusCounts_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getReportStatusCounts_result()
        try:
            result.success = self._handler.getReportStatusCounts(args.runIds, args.reportFilter, args.cmpData)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getReportStatusCounts", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getReviewStatusCounts(self, seqid, iprot, oprot):
        args = getReviewStatusCounts_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getReviewStatusCounts_result()
        try:
            result.success = self._handler.getReviewStatusCounts(args.runIds, args.reportFilter, args.cmpData)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getReviewStatusCounts", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getDetectionStatusCounts(self, seqid, iprot, oprot):
        args = getDetectionStatusCounts_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDetectionStatusCounts_result()
        try:
            result.success = self._handler.getDetectionStatusCounts(args.runIds, args.reportFilter, args.cmpData)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getDetectionStatusCounts", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getFileCounts(self, seqid, iprot, oprot):
        args = getFileCounts_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getFileCounts_result()
        try:
            result.success = self._handler.getFileCounts(args.runIds, args.reportFilter, args.cmpData, args.limit, args.offset)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getFileCounts", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getCheckerCounts(self, seqid, iprot, oprot):
        args = getCheckerCounts_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getCheckerCounts_result()
        try:
            result.success = self._handler.getCheckerCounts(args.runIds, args.reportFilter, args.cmpData, args.limit, args.offset)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getCheckerCounts", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getCheckerStatusVerificationDetails(self, seqid, iprot, oprot):
        args = getCheckerStatusVerificationDetails_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getCheckerStatusVerificationDetails_result()
        try:
            result.success = self._handler.getCheckerStatusVerificationDetails(args.runIds, args.reportFilter)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getCheckerStatusVerificationDetails", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getRunHistoryTagCounts(self, seqid, iprot, oprot):
        args = getRunHistoryTagCounts_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getRunHistoryTagCounts_result()
        try:
            result.success = self._handler.getRunHistoryTagCounts(args.runIds, args.reportFilter, args.cmpData, args.limit, args.offset)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getRunHistoryTagCounts", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getAnalyzerNameCounts(self, seqid, iprot, oprot):
        args = getAnalyzerNameCounts_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getAnalyzerNameCounts_result()
        try:
            result.success = self._handler.getAnalyzerNameCounts(args.runIds, args.reportFilter, args.cmpData, args.limit, args.offset)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getAnalyzerNameCounts", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_addSourceComponent(self, seqid, iprot, oprot):
        args = addSourceComponent_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = addSourceComponent_result()
        try:
            result.success = self._handler.addSourceComponent(args.name, args.value, args.description)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("addSourceComponent", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getSourceComponents(self, seqid, iprot, oprot):
        args = getSourceComponents_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getSourceComponents_result()
        try:
            result.success = self._handler.getSourceComponents(args.sourceComponentFilter)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getSourceComponents", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_removeSourceComponent(self, seqid, iprot, oprot):
        args = removeSourceComponent_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = removeSourceComponent_result()
        try:
            result.success = self._handler.removeSourceComponent(args.name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("removeSourceComponent", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getMissingContentHashes(self, seqid, iprot, oprot):
        args = getMissingContentHashes_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getMissingContentHashes_result()
        try:
            result.success = self._handler.getMissingContentHashes(args.fileHashes)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getMissingContentHashes", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getMissingContentHashesForBlameInfo(self, seqid, iprot, oprot):
        args = getMissingContentHashesForBlameInfo_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getMissingContentHashesForBlameInfo_result()
        try:
            result.success = self._handler.getMissingContentHashesForBlameInfo(args.fileHashes)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getMissingContentHashesForBlameInfo", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_massStoreRun(self, seqid, iprot, oprot):
        args = massStoreRun_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = massStoreRun_result()
        try:
            result.success = self._handler.massStoreRun(args.runName, args.tag, args.version, args.zipfile, args.force, args.trimPathPrefixes, args.description)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("massStoreRun", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_allowsStoringAnalysisStatistics(self, seqid, iprot, oprot):
        args = allowsStoringAnalysisStatistics_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = allowsStoringAnalysisStatistics_result()
        try:
            result.success = self._handler.allowsStoringAnalysisStatistics()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("allowsStoringAnalysisStatistics", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getAnalysisStatisticsLimits(self, seqid, iprot, oprot):
        args = getAnalysisStatisticsLimits_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getAnalysisStatisticsLimits_result()
        try:
            result.success = self._handler.getAnalysisStatisticsLimits()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getAnalysisStatisticsLimits", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_storeAnalysisStatistics(self, seqid, iprot, oprot):
        args = storeAnalysisStatistics_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = storeAnalysisStatistics_result()
        try:
            result.success = self._handler.storeAnalysisStatistics(args.runName, args.zipfile)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("storeAnalysisStatistics", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getAnalysisStatistics(self, seqid, iprot, oprot):
        args = getAnalysisStatistics_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getAnalysisStatistics_result()
        try:
            result.success = self._handler.getAnalysisStatistics(args.runId, args.runHistoryId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getAnalysisStatistics", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_exportData(self, seqid, iprot, oprot):
        args = exportData_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = exportData_result()
        try:
            result.success = self._handler.exportData(args.runFilter)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("exportData", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_importData(self, seqid, iprot, oprot):
        args = importData_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = importData_result()
        try:
            result.success = self._handler.importData(args.exportData)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("importData", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_addCleanupPlan(self, seqid, iprot, oprot):
        args = addCleanupPlan_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = addCleanupPlan_result()
        try:
            result.success = self._handler.addCleanupPlan(args.name, args.description, args.dueDate)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("addCleanupPlan", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_updateCleanupPlan(self, seqid, iprot, oprot):
        args = updateCleanupPlan_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateCleanupPlan_result()
        try:
            result.success = self._handler.updateCleanupPlan(args.id, args.name, args.description, args.dueDate)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("updateCleanupPlan", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getCleanupPlans(self, seqid, iprot, oprot):
        args = getCleanupPlans_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getCleanupPlans_result()
        try:
            result.success = self._handler.getCleanupPlans(args.filter)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getCleanupPlans", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_removeCleanupPlan(self, seqid, iprot, oprot):
        args = removeCleanupPlan_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = removeCleanupPlan_result()
        try:
            result.success = self._handler.removeCleanupPlan(args.cleanupPlanId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("removeCleanupPlan", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_closeCleanupPlan(self, seqid, iprot, oprot):
        args = closeCleanupPlan_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = closeCleanupPlan_result()
        try:
            result.success = self._handler.closeCleanupPlan(args.cleanupPlanId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("closeCleanupPlan", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_reopenCleanupPlan(self, seqid, iprot, oprot):
        args = reopenCleanupPlan_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = reopenCleanupPlan_result()
        try:
            result.success = self._handler.reopenCleanupPlan(args.cleanupPlanId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("reopenCleanupPlan", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_setCleanupPlan(self, seqid, iprot, oprot):
        args = setCleanupPlan_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = setCleanupPlan_result()
        try:
            result.success = self._handler.setCleanupPlan(args.cleanupPlanId, args.reportHashes)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("setCleanupPlan", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_unsetCleanupPlan(self, seqid, iprot, oprot):
        args = unsetCleanupPlan_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = unsetCleanupPlan_result()
        try:
            result.success = self._handler.unsetCleanupPlan(args.cleanupPlanId, args.reportHashes)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("unsetCleanupPlan", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class getRunData_args(object):
    """
    Attributes:
     - runFilter
     - limit
     - offset
     - sortMode

    """
    thrift_spec = None


    def __init__(self, runFilter = None, limit = None, offset = None, sortMode = None,):
        self.runFilter = runFilter
        self.limit = limit
        self.offset = offset
        self.sortMode = sortMode

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.runFilter = RunFilter()
                    self.runFilter.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.limit = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.offset = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.sortMode = RunSortMode()
                    self.sortMode.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getRunData_args')
        if self.runFilter is not None:
            oprot.writeFieldBegin('runFilter', TType.STRUCT, 1)
            self.runFilter.write(oprot)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I64, 2)
            oprot.writeI64(self.limit)
            oprot.writeFieldEnd()
        if self.offset is not None:
            oprot.writeFieldBegin('offset', TType.I64, 3)
            oprot.writeI64(self.offset)
            oprot.writeFieldEnd()
        if self.sortMode is not None:
            oprot.writeFieldBegin('sortMode', TType.STRUCT, 4)
            self.sortMode.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getRunData_args)
getRunData_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'runFilter', [RunFilter, None], None, ),  # 1
    (2, TType.I64, 'limit', None, None, ),  # 2
    (3, TType.I64, 'offset', None, None, ),  # 3
    (4, TType.STRUCT, 'sortMode', [RunSortMode, None], None, ),  # 4
)


class getRunData_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype350, _size347) = iprot.readListBegin()
                    for _i351 in range(_size347):
                        _elem352 = RunData()
                        _elem352.read(iprot)
                        self.success.append(_elem352)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getRunData_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter353 in self.success:
                iter353.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getRunData_result)
getRunData_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [RunData, None], False), None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getRunCount_args(object):
    """
    Attributes:
     - runFilter

    """
    thrift_spec = None


    def __init__(self, runFilter = None,):
        self.runFilter = runFilter

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.runFilter = RunFilter()
                    self.runFilter.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getRunCount_args')
        if self.runFilter is not None:
            oprot.writeFieldBegin('runFilter', TType.STRUCT, 1)
            self.runFilter.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getRunCount_args)
getRunCount_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'runFilter', [RunFilter, None], None, ),  # 1
)


class getRunCount_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getRunCount_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getRunCount_result)
getRunCount_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getCheckCommand_args(object):
    """
    Attributes:
     - runHistoryId
     - runId

    """
    thrift_spec = None


    def __init__(self, runHistoryId = None, runId = None,):
        self.runHistoryId = runHistoryId
        self.runId = runId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.runHistoryId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.runId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCheckCommand_args')
        if self.runHistoryId is not None:
            oprot.writeFieldBegin('runHistoryId', TType.I64, 1)
            oprot.writeI64(self.runHistoryId)
            oprot.writeFieldEnd()
        if self.runId is not None:
            oprot.writeFieldBegin('runId', TType.I64, 2)
            oprot.writeI64(self.runId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCheckCommand_args)
getCheckCommand_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'runHistoryId', None, None, ),  # 1
    (2, TType.I64, 'runId', None, None, ),  # 2
)


class getCheckCommand_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCheckCommand_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCheckCommand_result)
getCheckCommand_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getAnalysisInfo_args(object):
    """
    Attributes:
     - analysisInfoFilter
     - limit
     - offset

    """
    thrift_spec = None


    def __init__(self, analysisInfoFilter = None, limit = None, offset = None,):
        self.analysisInfoFilter = analysisInfoFilter
        self.limit = limit
        self.offset = offset

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.analysisInfoFilter = AnalysisInfoFilter()
                    self.analysisInfoFilter.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.limit = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.offset = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAnalysisInfo_args')
        if self.analysisInfoFilter is not None:
            oprot.writeFieldBegin('analysisInfoFilter', TType.STRUCT, 1)
            self.analysisInfoFilter.write(oprot)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I64, 2)
            oprot.writeI64(self.limit)
            oprot.writeFieldEnd()
        if self.offset is not None:
            oprot.writeFieldBegin('offset', TType.I64, 3)
            oprot.writeI64(self.offset)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAnalysisInfo_args)
getAnalysisInfo_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'analysisInfoFilter', [AnalysisInfoFilter, None], None, ),  # 1
    (2, TType.I64, 'limit', None, None, ),  # 2
    (3, TType.I64, 'offset', None, None, ),  # 3
)


class getAnalysisInfo_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype357, _size354) = iprot.readListBegin()
                    for _i358 in range(_size354):
                        _elem359 = AnalysisInfo()
                        _elem359.read(iprot)
                        self.success.append(_elem359)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAnalysisInfo_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter360 in self.success:
                iter360.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAnalysisInfo_result)
getAnalysisInfo_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [AnalysisInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getRunHistory_args(object):
    """
    Attributes:
     - runIds
     - limit
     - offset
     - runHistoryFilter

    """
    thrift_spec = None


    def __init__(self, runIds = None, limit = None, offset = None, runHistoryFilter = None,):
        self.runIds = runIds
        self.limit = limit
        self.offset = offset
        self.runHistoryFilter = runHistoryFilter

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.runIds = []
                    (_etype364, _size361) = iprot.readListBegin()
                    for _i365 in range(_size361):
                        _elem366 = iprot.readI64()
                        self.runIds.append(_elem366)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.limit = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.offset = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.runHistoryFilter = RunHistoryFilter()
                    self.runHistoryFilter.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getRunHistory_args')
        if self.runIds is not None:
            oprot.writeFieldBegin('runIds', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.runIds))
            for iter367 in self.runIds:
                oprot.writeI64(iter367)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I64, 2)
            oprot.writeI64(self.limit)
            oprot.writeFieldEnd()
        if self.offset is not None:
            oprot.writeFieldBegin('offset', TType.I64, 3)
            oprot.writeI64(self.offset)
            oprot.writeFieldEnd()
        if self.runHistoryFilter is not None:
            oprot.writeFieldBegin('runHistoryFilter', TType.STRUCT, 4)
            self.runHistoryFilter.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getRunHistory_args)
getRunHistory_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'runIds', (TType.I64, None, False), None, ),  # 1
    (2, TType.I64, 'limit', None, None, ),  # 2
    (3, TType.I64, 'offset', None, None, ),  # 3
    (4, TType.STRUCT, 'runHistoryFilter', [RunHistoryFilter, None], None, ),  # 4
)


class getRunHistory_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype371, _size368) = iprot.readListBegin()
                    for _i372 in range(_size368):
                        _elem373 = RunHistoryData()
                        _elem373.read(iprot)
                        self.success.append(_elem373)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getRunHistory_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter374 in self.success:
                iter374.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getRunHistory_result)
getRunHistory_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [RunHistoryData, None], False), None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getRunHistoryCount_args(object):
    """
    Attributes:
     - runIds
     - runHistoryFilter

    """
    thrift_spec = None


    def __init__(self, runIds = None, runHistoryFilter = None,):
        self.runIds = runIds
        self.runHistoryFilter = runHistoryFilter

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.runIds = []
                    (_etype378, _size375) = iprot.readListBegin()
                    for _i379 in range(_size375):
                        _elem380 = iprot.readI64()
                        self.runIds.append(_elem380)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.runHistoryFilter = RunHistoryFilter()
                    self.runHistoryFilter.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getRunHistoryCount_args')
        if self.runIds is not None:
            oprot.writeFieldBegin('runIds', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.runIds))
            for iter381 in self.runIds:
                oprot.writeI64(iter381)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.runHistoryFilter is not None:
            oprot.writeFieldBegin('runHistoryFilter', TType.STRUCT, 2)
            self.runHistoryFilter.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getRunHistoryCount_args)
getRunHistoryCount_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'runIds', (TType.I64, None, False), None, ),  # 1
    (2, TType.STRUCT, 'runHistoryFilter', [RunHistoryFilter, None], None, ),  # 2
)


class getRunHistoryCount_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getRunHistoryCount_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getRunHistoryCount_result)
getRunHistoryCount_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getDiffResultsHash_args(object):
    """
    Attributes:
     - runIds
     - reportHashes
     - diffType
     - skipDetectionStatuses
     - tagIds

    """
    thrift_spec = None


    def __init__(self, runIds = None, reportHashes = None, diffType = None, skipDetectionStatuses = None, tagIds = None,):
        self.runIds = runIds
        self.reportHashes = reportHashes
        self.diffType = diffType
        self.skipDetectionStatuses = skipDetectionStatuses
        self.tagIds = tagIds

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.runIds = []
                    (_etype385, _size382) = iprot.readListBegin()
                    for _i386 in range(_size382):
                        _elem387 = iprot.readI64()
                        self.runIds.append(_elem387)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.reportHashes = []
                    (_etype391, _size388) = iprot.readListBegin()
                    for _i392 in range(_size388):
                        _elem393 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.reportHashes.append(_elem393)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.diffType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.skipDetectionStatuses = []
                    (_etype397, _size394) = iprot.readListBegin()
                    for _i398 in range(_size394):
                        _elem399 = iprot.readI32()
                        self.skipDetectionStatuses.append(_elem399)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.tagIds = []
                    (_etype403, _size400) = iprot.readListBegin()
                    for _i404 in range(_size400):
                        _elem405 = iprot.readI64()
                        self.tagIds.append(_elem405)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDiffResultsHash_args')
        if self.runIds is not None:
            oprot.writeFieldBegin('runIds', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.runIds))
            for iter406 in self.runIds:
                oprot.writeI64(iter406)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.reportHashes is not None:
            oprot.writeFieldBegin('reportHashes', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.reportHashes))
            for iter407 in self.reportHashes:
                oprot.writeString(iter407.encode('utf-8') if sys.version_info[0] == 2 else iter407)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.diffType is not None:
            oprot.writeFieldBegin('diffType', TType.I32, 3)
            oprot.writeI32(self.diffType)
            oprot.writeFieldEnd()
        if self.skipDetectionStatuses is not None:
            oprot.writeFieldBegin('skipDetectionStatuses', TType.LIST, 4)
            oprot.writeListBegin(TType.I32, len(self.skipDetectionStatuses))
            for iter408 in self.skipDetectionStatuses:
                oprot.writeI32(iter408)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tagIds is not None:
            oprot.writeFieldBegin('tagIds', TType.LIST, 5)
            oprot.writeListBegin(TType.I64, len(self.tagIds))
            for iter409 in self.tagIds:
                oprot.writeI64(iter409)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDiffResultsHash_args)
getDiffResultsHash_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'runIds', (TType.I64, None, False), None, ),  # 1
    (2, TType.LIST, 'reportHashes', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.I32, 'diffType', None, None, ),  # 3
    (4, TType.LIST, 'skipDetectionStatuses', (TType.I32, None, False), None, ),  # 4
    (5, TType.LIST, 'tagIds', (TType.I64, None, False), None, ),  # 5
)


class getDiffResultsHash_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype413, _size410) = iprot.readListBegin()
                    for _i414 in range(_size410):
                        _elem415 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem415)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDiffResultsHash_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter416 in self.success:
                oprot.writeString(iter416.encode('utf-8') if sys.version_info[0] == 2 else iter416)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDiffResultsHash_result)
getDiffResultsHash_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getReport_args(object):
    """
    Attributes:
     - reportId

    """
    thrift_spec = None


    def __init__(self, reportId = None,):
        self.reportId = reportId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.reportId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getReport_args')
        if self.reportId is not None:
            oprot.writeFieldBegin('reportId', TType.I64, 1)
            oprot.writeI64(self.reportId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getReport_args)
getReport_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'reportId', None, None, ),  # 1
)


class getReport_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ReportData()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getReport_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getReport_result)
getReport_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ReportData, None], None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getRunResults_args(object):
    """
    Attributes:
     - runIds
     - limit
     - offset
     - sortType
     - reportFilter
     - cmpData
     - getDetails

    """
    thrift_spec = None


    def __init__(self, runIds = None, limit = None, offset = None, sortType = None, reportFilter = None, cmpData = None, getDetails = None,):
        self.runIds = runIds
        self.limit = limit
        self.offset = offset
        self.sortType = sortType
        self.reportFilter = reportFilter
        self.cmpData = cmpData
        self.getDetails = getDetails

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.runIds = []
                    (_etype420, _size417) = iprot.readListBegin()
                    for _i421 in range(_size417):
                        _elem422 = iprot.readI64()
                        self.runIds.append(_elem422)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.limit = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.offset = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.sortType = []
                    (_etype426, _size423) = iprot.readListBegin()
                    for _i427 in range(_size423):
                        _elem428 = SortMode()
                        _elem428.read(iprot)
                        self.sortType.append(_elem428)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.reportFilter = ReportFilter()
                    self.reportFilter.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.cmpData = CompareData()
                    self.cmpData.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.getDetails = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getRunResults_args')
        if self.runIds is not None:
            oprot.writeFieldBegin('runIds', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.runIds))
            for iter429 in self.runIds:
                oprot.writeI64(iter429)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I64, 2)
            oprot.writeI64(self.limit)
            oprot.writeFieldEnd()
        if self.offset is not None:
            oprot.writeFieldBegin('offset', TType.I64, 3)
            oprot.writeI64(self.offset)
            oprot.writeFieldEnd()
        if self.sortType is not None:
            oprot.writeFieldBegin('sortType', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.sortType))
            for iter430 in self.sortType:
                iter430.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.reportFilter is not None:
            oprot.writeFieldBegin('reportFilter', TType.STRUCT, 5)
            self.reportFilter.write(oprot)
            oprot.writeFieldEnd()
        if self.cmpData is not None:
            oprot.writeFieldBegin('cmpData', TType.STRUCT, 6)
            self.cmpData.write(oprot)
            oprot.writeFieldEnd()
        if self.getDetails is not None:
            oprot.writeFieldBegin('getDetails', TType.BOOL, 7)
            oprot.writeBool(self.getDetails)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getRunResults_args)
getRunResults_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'runIds', (TType.I64, None, False), None, ),  # 1
    (2, TType.I64, 'limit', None, None, ),  # 2
    (3, TType.I64, 'offset', None, None, ),  # 3
    (4, TType.LIST, 'sortType', (TType.STRUCT, [SortMode, None], False), None, ),  # 4
    (5, TType.STRUCT, 'reportFilter', [ReportFilter, None], None, ),  # 5
    (6, TType.STRUCT, 'cmpData', [CompareData, None], None, ),  # 6
    (7, TType.BOOL, 'getDetails', None, None, ),  # 7
)


class getRunResults_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype434, _size431) = iprot.readListBegin()
                    for _i435 in range(_size431):
                        _elem436 = ReportData()
                        _elem436.read(iprot)
                        self.success.append(_elem436)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getRunResults_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter437 in self.success:
                iter437.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getRunResults_result)
getRunResults_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ReportData, None], False), None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getReportAnnotations_args(object):
    """
    Attributes:
     - runIds
     - reportFilter
     - cmpData

    """
    thrift_spec = None


    def __init__(self, runIds = None, reportFilter = None, cmpData = None,):
        self.runIds = runIds
        self.reportFilter = reportFilter
        self.cmpData = cmpData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.LIST:
                    self.runIds = []
                    (_etype441, _size438) = iprot.readListBegin()
                    for _i442 in range(_size438):
                        _elem443 = iprot.readI64()
                        self.runIds.append(_elem443)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.reportFilter = ReportFilter()
                    self.reportFilter.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.cmpData = CompareData()
                    self.cmpData.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getReportAnnotations_args')
        if self.runIds is not None:
            oprot.writeFieldBegin('runIds', TType.LIST, 2)
            oprot.writeListBegin(TType.I64, len(self.runIds))
            for iter444 in self.runIds:
                oprot.writeI64(iter444)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.reportFilter is not None:
            oprot.writeFieldBegin('reportFilter', TType.STRUCT, 3)
            self.reportFilter.write(oprot)
            oprot.writeFieldEnd()
        if self.cmpData is not None:
            oprot.writeFieldBegin('cmpData', TType.STRUCT, 4)
            self.cmpData.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getReportAnnotations_args)
getReportAnnotations_args.thrift_spec = (
    None,  # 0
    None,  # 1
    (2, TType.LIST, 'runIds', (TType.I64, None, False), None, ),  # 2
    (3, TType.STRUCT, 'reportFilter', [ReportFilter, None], None, ),  # 3
    (4, TType.STRUCT, 'cmpData', [CompareData, None], None, ),  # 4
)


class getReportAnnotations_result(object):
    """
    Attributes:
     - success

    """
    thrift_spec = None


    def __init__(self, success = None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype448, _size445) = iprot.readListBegin()
                    for _i449 in range(_size445):
                        _elem450 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem450)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getReportAnnotations_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter451 in self.success:
                oprot.writeString(iter451.encode('utf-8') if sys.version_info[0] == 2 else iter451)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getReportAnnotations_result)
getReportAnnotations_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
)


class getRunReportCounts_args(object):
    """
    Attributes:
     - runIds
     - reportFilter
     - limit
     - offset

    """
    thrift_spec = None


    def __init__(self, runIds = None, reportFilter = None, limit = None, offset = None,):
        self.runIds = runIds
        self.reportFilter = reportFilter
        self.limit = limit
        self.offset = offset

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.runIds = []
                    (_etype455, _size452) = iprot.readListBegin()
                    for _i456 in range(_size452):
                        _elem457 = iprot.readI64()
                        self.runIds.append(_elem457)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.reportFilter = ReportFilter()
                    self.reportFilter.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.limit = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.offset = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getRunReportCounts_args')
        if self.runIds is not None:
            oprot.writeFieldBegin('runIds', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.runIds))
            for iter458 in self.runIds:
                oprot.writeI64(iter458)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.reportFilter is not None:
            oprot.writeFieldBegin('reportFilter', TType.STRUCT, 2)
            self.reportFilter.write(oprot)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I64, 3)
            oprot.writeI64(self.limit)
            oprot.writeFieldEnd()
        if self.offset is not None:
            oprot.writeFieldBegin('offset', TType.I64, 4)
            oprot.writeI64(self.offset)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getRunReportCounts_args)
getRunReportCounts_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'runIds', (TType.I64, None, False), None, ),  # 1
    (2, TType.STRUCT, 'reportFilter', [ReportFilter, None], None, ),  # 2
    (3, TType.I64, 'limit', None, None, ),  # 3
    (4, TType.I64, 'offset', None, None, ),  # 4
)


class getRunReportCounts_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype462, _size459) = iprot.readListBegin()
                    for _i463 in range(_size459):
                        _elem464 = RunReportCount()
                        _elem464.read(iprot)
                        self.success.append(_elem464)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getRunReportCounts_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter465 in self.success:
                iter465.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getRunReportCounts_result)
getRunReportCounts_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [RunReportCount, None], False), None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getRunResultCount_args(object):
    """
    Attributes:
     - runIds
     - reportFilter
     - cmpData

    """
    thrift_spec = None


    def __init__(self, runIds = None, reportFilter = None, cmpData = None,):
        self.runIds = runIds
        self.reportFilter = reportFilter
        self.cmpData = cmpData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.runIds = []
                    (_etype469, _size466) = iprot.readListBegin()
                    for _i470 in range(_size466):
                        _elem471 = iprot.readI64()
                        self.runIds.append(_elem471)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.reportFilter = ReportFilter()
                    self.reportFilter.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.cmpData = CompareData()
                    self.cmpData.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getRunResultCount_args')
        if self.runIds is not None:
            oprot.writeFieldBegin('runIds', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.runIds))
            for iter472 in self.runIds:
                oprot.writeI64(iter472)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.reportFilter is not None:
            oprot.writeFieldBegin('reportFilter', TType.STRUCT, 2)
            self.reportFilter.write(oprot)
            oprot.writeFieldEnd()
        if self.cmpData is not None:
            oprot.writeFieldBegin('cmpData', TType.STRUCT, 3)
            self.cmpData.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getRunResultCount_args)
getRunResultCount_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'runIds', (TType.I64, None, False), None, ),  # 1
    (2, TType.STRUCT, 'reportFilter', [ReportFilter, None], None, ),  # 2
    (3, TType.STRUCT, 'cmpData', [CompareData, None], None, ),  # 3
)


class getRunResultCount_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getRunResultCount_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getRunResultCount_result)
getRunResultCount_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getFailedFilesCount_args(object):
    """
    Attributes:
     - runIds

    """
    thrift_spec = None


    def __init__(self, runIds = None,):
        self.runIds = runIds

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.runIds = []
                    (_etype476, _size473) = iprot.readListBegin()
                    for _i477 in range(_size473):
                        _elem478 = iprot.readI64()
                        self.runIds.append(_elem478)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getFailedFilesCount_args')
        if self.runIds is not None:
            oprot.writeFieldBegin('runIds', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.runIds))
            for iter479 in self.runIds:
                oprot.writeI64(iter479)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getFailedFilesCount_args)
getFailedFilesCount_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'runIds', (TType.I64, None, False), None, ),  # 1
)


class getFailedFilesCount_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getFailedFilesCount_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getFailedFilesCount_result)
getFailedFilesCount_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getFailedFiles_args(object):
    """
    Attributes:
     - runIds

    """
    thrift_spec = None


    def __init__(self, runIds = None,):
        self.runIds = runIds

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.runIds = []
                    (_etype483, _size480) = iprot.readListBegin()
                    for _i484 in range(_size480):
                        _elem485 = iprot.readI64()
                        self.runIds.append(_elem485)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getFailedFiles_args')
        if self.runIds is not None:
            oprot.writeFieldBegin('runIds', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.runIds))
            for iter486 in self.runIds:
                oprot.writeI64(iter486)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getFailedFiles_args)
getFailedFiles_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'runIds', (TType.I64, None, False), None, ),  # 1
)


class getFailedFiles_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype488, _vtype489, _size487) = iprot.readMapBegin()
                    for _i491 in range(_size487):
                        _key492 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val493 = []
                        (_etype497, _size494) = iprot.readListBegin()
                        for _i498 in range(_size494):
                            _elem499 = AnalysisFailureInfo()
                            _elem499.read(iprot)
                            _val493.append(_elem499)
                        iprot.readListEnd()
                        self.success[_key492] = _val493
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getFailedFiles_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.success))
            for kiter500, viter501 in self.success.items():
                oprot.writeString(kiter500.encode('utf-8') if sys.version_info[0] == 2 else kiter500)
                oprot.writeListBegin(TType.STRUCT, len(viter501))
                for iter502 in viter501:
                    iter502.write(oprot)
                oprot.writeListEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getFailedFiles_result)
getFailedFiles_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.LIST, (TType.STRUCT, [AnalysisFailureInfo, None], False), False), None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getReportDetails_args(object):
    """
    Attributes:
     - reportId

    """
    thrift_spec = None


    def __init__(self, reportId = None,):
        self.reportId = reportId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.reportId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getReportDetails_args')
        if self.reportId is not None:
            oprot.writeFieldBegin('reportId', TType.I64, 1)
            oprot.writeI64(self.reportId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getReportDetails_args)
getReportDetails_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'reportId', None, None, ),  # 1
)


class getReportDetails_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ReportDetails()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getReportDetails_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getReportDetails_result)
getReportDetails_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ReportDetails, None], None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getSourceFileData_args(object):
    """
    Attributes:
     - fileId
     - fileContent
     - encoding

    """
    thrift_spec = None


    def __init__(self, fileId = None, fileContent = None, encoding = None,):
        self.fileId = fileId
        self.fileContent = fileContent
        self.encoding = encoding

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.fileId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.fileContent = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.encoding = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getSourceFileData_args')
        if self.fileId is not None:
            oprot.writeFieldBegin('fileId', TType.I64, 1)
            oprot.writeI64(self.fileId)
            oprot.writeFieldEnd()
        if self.fileContent is not None:
            oprot.writeFieldBegin('fileContent', TType.BOOL, 2)
            oprot.writeBool(self.fileContent)
            oprot.writeFieldEnd()
        if self.encoding is not None:
            oprot.writeFieldBegin('encoding', TType.I32, 3)
            oprot.writeI32(self.encoding)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getSourceFileData_args)
getSourceFileData_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'fileId', None, None, ),  # 1
    (2, TType.BOOL, 'fileContent', None, None, ),  # 2
    (3, TType.I32, 'encoding', None, None, ),  # 3
)


class getSourceFileData_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = SourceFileData()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getSourceFileData_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getSourceFileData_result)
getSourceFileData_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [SourceFileData, None], None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getBlameInfo_args(object):
    """
    Attributes:
     - fileId

    """
    thrift_spec = None


    def __init__(self, fileId = None,):
        self.fileId = fileId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.fileId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getBlameInfo_args')
        if self.fileId is not None:
            oprot.writeFieldBegin('fileId', TType.I64, 1)
            oprot.writeI64(self.fileId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getBlameInfo_args)
getBlameInfo_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'fileId', None, None, ),  # 1
)


class getBlameInfo_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = BlameInfo()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getBlameInfo_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getBlameInfo_result)
getBlameInfo_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [BlameInfo, None], None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getLinesInSourceFileContents_args(object):
    """
    Attributes:
     - linesInFilesRequested
     - encoding

    """
    thrift_spec = None


    def __init__(self, linesInFilesRequested = None, encoding = None,):
        self.linesInFilesRequested = linesInFilesRequested
        self.encoding = encoding

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.linesInFilesRequested = []
                    (_etype506, _size503) = iprot.readListBegin()
                    for _i507 in range(_size503):
                        _elem508 = LinesInFilesRequested()
                        _elem508.read(iprot)
                        self.linesInFilesRequested.append(_elem508)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.encoding = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getLinesInSourceFileContents_args')
        if self.linesInFilesRequested is not None:
            oprot.writeFieldBegin('linesInFilesRequested', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.linesInFilesRequested))
            for iter509 in self.linesInFilesRequested:
                iter509.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.encoding is not None:
            oprot.writeFieldBegin('encoding', TType.I32, 2)
            oprot.writeI32(self.encoding)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getLinesInSourceFileContents_args)
getLinesInSourceFileContents_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'linesInFilesRequested', (TType.STRUCT, [LinesInFilesRequested, None], False), None, ),  # 1
    (2, TType.I32, 'encoding', None, None, ),  # 2
)


class getLinesInSourceFileContents_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype511, _vtype512, _size510) = iprot.readMapBegin()
                    for _i514 in range(_size510):
                        _key515 = iprot.readI64()
                        _val516 = {}
                        (_ktype518, _vtype519, _size517) = iprot.readMapBegin()
                        for _i521 in range(_size517):
                            _key522 = iprot.readI64()
                            _val523 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val516[_key522] = _val523
                        iprot.readMapEnd()
                        self.success[_key515] = _val516
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getLinesInSourceFileContents_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
            for kiter524, viter525 in self.success.items():
                oprot.writeI64(kiter524)
                oprot.writeMapBegin(TType.I64, TType.STRING, len(viter525))
                for kiter526, viter527 in viter525.items():
                    oprot.writeI64(kiter526)
                    oprot.writeString(viter527.encode('utf-8') if sys.version_info[0] == 2 else viter527)
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getLinesInSourceFileContents_result)
getLinesInSourceFileContents_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.MAP, (TType.I64, None, TType.STRING, 'UTF8', False), False), None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class isReviewStatusChangeDisabled_args(object):
    thrift_spec = None


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('isReviewStatusChangeDisabled_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(isReviewStatusChangeDisabled_args)
isReviewStatusChangeDisabled_args.thrift_spec = (
)


class isReviewStatusChangeDisabled_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('isReviewStatusChangeDisabled_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(isReviewStatusChangeDisabled_result)
isReviewStatusChangeDisabled_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class changeReviewStatus_args(object):
    """
    Attributes:
     - reportId
     - status
     - message

    """
    thrift_spec = None


    def __init__(self, reportId = None, status = None, message = None,):
        self.reportId = reportId
        self.status = status
        self.message = message

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.reportId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.status = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('changeReviewStatus_args')
        if self.reportId is not None:
            oprot.writeFieldBegin('reportId', TType.I64, 1)
            oprot.writeI64(self.reportId)
            oprot.writeFieldEnd()
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.I32, 2)
            oprot.writeI32(self.status)
            oprot.writeFieldEnd()
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 3)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(changeReviewStatus_args)
changeReviewStatus_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'reportId', None, None, ),  # 1
    (2, TType.I32, 'status', None, None, ),  # 2
    (3, TType.STRING, 'message', 'UTF8', None, ),  # 3
)


class changeReviewStatus_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('changeReviewStatus_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(changeReviewStatus_result)
changeReviewStatus_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getReviewStatusRules_args(object):
    """
    Attributes:
     - filter
     - sortMode
     - limit
     - offset

    """
    thrift_spec = None


    def __init__(self, filter = None, sortMode = None, limit = None, offset = None,):
        self.filter = filter
        self.sortMode = sortMode
        self.limit = limit
        self.offset = offset

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.filter = ReviewStatusRuleFilter()
                    self.filter.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.sortMode = ReviewStatusRuleSortMode()
                    self.sortMode.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.limit = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.offset = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getReviewStatusRules_args')
        if self.filter is not None:
            oprot.writeFieldBegin('filter', TType.STRUCT, 1)
            self.filter.write(oprot)
            oprot.writeFieldEnd()
        if self.sortMode is not None:
            oprot.writeFieldBegin('sortMode', TType.STRUCT, 2)
            self.sortMode.write(oprot)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I64, 3)
            oprot.writeI64(self.limit)
            oprot.writeFieldEnd()
        if self.offset is not None:
            oprot.writeFieldBegin('offset', TType.I64, 4)
            oprot.writeI64(self.offset)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getReviewStatusRules_args)
getReviewStatusRules_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'filter', [ReviewStatusRuleFilter, None], None, ),  # 1
    (2, TType.STRUCT, 'sortMode', [ReviewStatusRuleSortMode, None], None, ),  # 2
    (3, TType.I64, 'limit', None, None, ),  # 3
    (4, TType.I64, 'offset', None, None, ),  # 4
)


class getReviewStatusRules_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype531, _size528) = iprot.readListBegin()
                    for _i532 in range(_size528):
                        _elem533 = ReviewStatusRule()
                        _elem533.read(iprot)
                        self.success.append(_elem533)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getReviewStatusRules_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter534 in self.success:
                iter534.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getReviewStatusRules_result)
getReviewStatusRules_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ReviewStatusRule, None], False), None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getReviewStatusRulesCount_args(object):
    """
    Attributes:
     - filter

    """
    thrift_spec = None


    def __init__(self, filter = None,):
        self.filter = filter

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.filter = ReviewStatusRuleFilter()
                    self.filter.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getReviewStatusRulesCount_args')
        if self.filter is not None:
            oprot.writeFieldBegin('filter', TType.STRUCT, 1)
            self.filter.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getReviewStatusRulesCount_args)
getReviewStatusRulesCount_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'filter', [ReviewStatusRuleFilter, None], None, ),  # 1
)


class getReviewStatusRulesCount_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getReviewStatusRulesCount_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getReviewStatusRulesCount_result)
getReviewStatusRulesCount_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class removeReviewStatusRules_args(object):
    """
    Attributes:
     - filter

    """
    thrift_spec = None


    def __init__(self, filter = None,):
        self.filter = filter

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.filter = ReviewStatusRuleFilter()
                    self.filter.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('removeReviewStatusRules_args')
        if self.filter is not None:
            oprot.writeFieldBegin('filter', TType.STRUCT, 1)
            self.filter.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(removeReviewStatusRules_args)
removeReviewStatusRules_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'filter', [ReviewStatusRuleFilter, None], None, ),  # 1
)


class removeReviewStatusRules_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('removeReviewStatusRules_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(removeReviewStatusRules_result)
removeReviewStatusRules_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class addReviewStatusRule_args(object):
    """
    Attributes:
     - reportHash
     - status
     - message

    """
    thrift_spec = None


    def __init__(self, reportHash = None, status = None, message = None,):
        self.reportHash = reportHash
        self.status = status
        self.message = message

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.reportHash = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.status = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('addReviewStatusRule_args')
        if self.reportHash is not None:
            oprot.writeFieldBegin('reportHash', TType.STRING, 1)
            oprot.writeString(self.reportHash.encode('utf-8') if sys.version_info[0] == 2 else self.reportHash)
            oprot.writeFieldEnd()
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.I32, 2)
            oprot.writeI32(self.status)
            oprot.writeFieldEnd()
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 3)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(addReviewStatusRule_args)
addReviewStatusRule_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'reportHash', 'UTF8', None, ),  # 1
    (2, TType.I32, 'status', None, None, ),  # 2
    (3, TType.STRING, 'message', 'UTF8', None, ),  # 3
)


class addReviewStatusRule_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('addReviewStatusRule_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(addReviewStatusRule_result)
addReviewStatusRule_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getComments_args(object):
    """
    Attributes:
     - reportId

    """
    thrift_spec = None


    def __init__(self, reportId = None,):
        self.reportId = reportId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.reportId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getComments_args')
        if self.reportId is not None:
            oprot.writeFieldBegin('reportId', TType.I64, 1)
            oprot.writeI64(self.reportId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getComments_args)
getComments_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'reportId', None, None, ),  # 1
)


class getComments_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype538, _size535) = iprot.readListBegin()
                    for _i539 in range(_size535):
                        _elem540 = CommentData()
                        _elem540.read(iprot)
                        self.success.append(_elem540)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getComments_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter541 in self.success:
                iter541.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getComments_result)
getComments_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [CommentData, None], False), None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getCommentCount_args(object):
    """
    Attributes:
     - reportId

    """
    thrift_spec = None


    def __init__(self, reportId = None,):
        self.reportId = reportId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.reportId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCommentCount_args')
        if self.reportId is not None:
            oprot.writeFieldBegin('reportId', TType.I64, 1)
            oprot.writeI64(self.reportId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCommentCount_args)
getCommentCount_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'reportId', None, None, ),  # 1
)


class getCommentCount_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCommentCount_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCommentCount_result)
getCommentCount_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class addComment_args(object):
    """
    Attributes:
     - reportId
     - comment

    """
    thrift_spec = None


    def __init__(self, reportId = None, comment = None,):
        self.reportId = reportId
        self.comment = comment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.reportId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.comment = CommentData()
                    self.comment.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('addComment_args')
        if self.reportId is not None:
            oprot.writeFieldBegin('reportId', TType.I64, 1)
            oprot.writeI64(self.reportId)
            oprot.writeFieldEnd()
        if self.comment is not None:
            oprot.writeFieldBegin('comment', TType.STRUCT, 2)
            self.comment.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(addComment_args)
addComment_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'reportId', None, None, ),  # 1
    (2, TType.STRUCT, 'comment', [CommentData, None], None, ),  # 2
)


class addComment_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('addComment_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(addComment_result)
addComment_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class updateComment_args(object):
    """
    Attributes:
     - commentId
     - newMessage

    """
    thrift_spec = None


    def __init__(self, commentId = None, newMessage = None,):
        self.commentId = commentId
        self.newMessage = newMessage

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.commentId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.newMessage = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateComment_args')
        if self.commentId is not None:
            oprot.writeFieldBegin('commentId', TType.I64, 1)
            oprot.writeI64(self.commentId)
            oprot.writeFieldEnd()
        if self.newMessage is not None:
            oprot.writeFieldBegin('newMessage', TType.STRING, 2)
            oprot.writeString(self.newMessage.encode('utf-8') if sys.version_info[0] == 2 else self.newMessage)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateComment_args)
updateComment_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'commentId', None, None, ),  # 1
    (2, TType.STRING, 'newMessage', 'UTF8', None, ),  # 2
)


class updateComment_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateComment_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateComment_result)
updateComment_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class removeComment_args(object):
    """
    Attributes:
     - commentId

    """
    thrift_spec = None


    def __init__(self, commentId = None,):
        self.commentId = commentId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.commentId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('removeComment_args')
        if self.commentId is not None:
            oprot.writeFieldBegin('commentId', TType.I64, 1)
            oprot.writeI64(self.commentId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(removeComment_args)
removeComment_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'commentId', None, None, ),  # 1
)


class removeComment_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('removeComment_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(removeComment_result)
removeComment_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getCheckerDoc_args(object):
    """
    Attributes:
     - checkerId

    """
    thrift_spec = None


    def __init__(self, checkerId = None,):
        self.checkerId = checkerId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.checkerId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCheckerDoc_args')
        if self.checkerId is not None:
            oprot.writeFieldBegin('checkerId', TType.STRING, 1)
            oprot.writeString(self.checkerId.encode('utf-8') if sys.version_info[0] == 2 else self.checkerId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCheckerDoc_args)
getCheckerDoc_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'checkerId', 'UTF8', None, ),  # 1
)


class getCheckerDoc_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCheckerDoc_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCheckerDoc_result)
getCheckerDoc_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getCheckerLabels_args(object):
    """
    Attributes:
     - checkers

    """
    thrift_spec = None


    def __init__(self, checkers = None,):
        self.checkers = checkers

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.checkers = []
                    (_etype545, _size542) = iprot.readListBegin()
                    for _i546 in range(_size542):
                        _elem547 = Checker()
                        _elem547.read(iprot)
                        self.checkers.append(_elem547)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCheckerLabels_args')
        if self.checkers is not None:
            oprot.writeFieldBegin('checkers', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.checkers))
            for iter548 in self.checkers:
                iter548.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCheckerLabels_args)
getCheckerLabels_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'checkers', (TType.STRUCT, [Checker, None], False), None, ),  # 1
)


class getCheckerLabels_result(object):
    """
    Attributes:
     - success

    """
    thrift_spec = None


    def __init__(self, success = None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype552, _size549) = iprot.readListBegin()
                    for _i553 in range(_size549):
                        _elem554 = []
                        (_etype558, _size555) = iprot.readListBegin()
                        for _i559 in range(_size555):
                            _elem560 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem554.append(_elem560)
                        iprot.readListEnd()
                        self.success.append(_elem554)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCheckerLabels_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.LIST, len(self.success))
            for iter561 in self.success:
                oprot.writeListBegin(TType.STRING, len(iter561))
                for iter562 in iter561:
                    oprot.writeString(iter562.encode('utf-8') if sys.version_info[0] == 2 else iter562)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCheckerLabels_result)
getCheckerLabels_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.LIST, (TType.STRING, 'UTF8', False), False), None, ),  # 0
)


class getGuidelineRules_args(object):
    """
    Attributes:
     - guidelines

    """
    thrift_spec = None


    def __init__(self, guidelines = None,):
        self.guidelines = guidelines

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.guidelines = []
                    (_etype566, _size563) = iprot.readListBegin()
                    for _i567 in range(_size563):
                        _elem568 = Guideline()
                        _elem568.read(iprot)
                        self.guidelines.append(_elem568)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getGuidelineRules_args')
        if self.guidelines is not None:
            oprot.writeFieldBegin('guidelines', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.guidelines))
            for iter569 in self.guidelines:
                iter569.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getGuidelineRules_args)
getGuidelineRules_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'guidelines', (TType.STRUCT, [Guideline, None], False), None, ),  # 1
)


class getGuidelineRules_result(object):
    """
    Attributes:
     - success

    """
    thrift_spec = None


    def __init__(self, success = None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype571, _vtype572, _size570) = iprot.readMapBegin()
                    for _i574 in range(_size570):
                        _key575 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val576 = []
                        (_etype580, _size577) = iprot.readListBegin()
                        for _i581 in range(_size577):
                            _elem582 = Rule()
                            _elem582.read(iprot)
                            _val576.append(_elem582)
                        iprot.readListEnd()
                        self.success[_key575] = _val576
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getGuidelineRules_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.success))
            for kiter583, viter584 in self.success.items():
                oprot.writeString(kiter583.encode('utf-8') if sys.version_info[0] == 2 else kiter583)
                oprot.writeListBegin(TType.STRUCT, len(viter584))
                for iter585 in viter584:
                    iter585.write(oprot)
                oprot.writeListEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getGuidelineRules_result)
getGuidelineRules_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.LIST, (TType.STRUCT, [Rule, None], False), False), None, ),  # 0
)


class getPackageVersion_args(object):
    thrift_spec = None


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getPackageVersion_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getPackageVersion_args)
getPackageVersion_args.thrift_spec = (
)


class getPackageVersion_result(object):
    """
    Attributes:
     - success

    """
    thrift_spec = None


    def __init__(self, success = None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getPackageVersion_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getPackageVersion_result)
getPackageVersion_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class removeRunResults_args(object):
    """
    Attributes:
     - runIds

    """
    thrift_spec = None


    def __init__(self, runIds = None,):
        self.runIds = runIds

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.runIds = []
                    (_etype589, _size586) = iprot.readListBegin()
                    for _i590 in range(_size586):
                        _elem591 = iprot.readI64()
                        self.runIds.append(_elem591)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('removeRunResults_args')
        if self.runIds is not None:
            oprot.writeFieldBegin('runIds', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.runIds))
            for iter592 in self.runIds:
                oprot.writeI64(iter592)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(removeRunResults_args)
removeRunResults_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'runIds', (TType.I64, None, False), None, ),  # 1
)


class removeRunResults_result(object):
    """
    Attributes:
     - success

    """
    thrift_spec = None


    def __init__(self, success = None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('removeRunResults_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(removeRunResults_result)
removeRunResults_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class removeRunReports_args(object):
    """
    Attributes:
     - runIds
     - reportFilter
     - cmpData

    """
    thrift_spec = None


    def __init__(self, runIds = None, reportFilter = None, cmpData = None,):
        self.runIds = runIds
        self.reportFilter = reportFilter
        self.cmpData = cmpData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.runIds = []
                    (_etype596, _size593) = iprot.readListBegin()
                    for _i597 in range(_size593):
                        _elem598 = iprot.readI64()
                        self.runIds.append(_elem598)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.reportFilter = ReportFilter()
                    self.reportFilter.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.cmpData = CompareData()
                    self.cmpData.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('removeRunReports_args')
        if self.runIds is not None:
            oprot.writeFieldBegin('runIds', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.runIds))
            for iter599 in self.runIds:
                oprot.writeI64(iter599)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.reportFilter is not None:
            oprot.writeFieldBegin('reportFilter', TType.STRUCT, 2)
            self.reportFilter.write(oprot)
            oprot.writeFieldEnd()
        if self.cmpData is not None:
            oprot.writeFieldBegin('cmpData', TType.STRUCT, 3)
            self.cmpData.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(removeRunReports_args)
removeRunReports_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'runIds', (TType.I64, None, False), None, ),  # 1
    (2, TType.STRUCT, 'reportFilter', [ReportFilter, None], None, ),  # 2
    (3, TType.STRUCT, 'cmpData', [CompareData, None], None, ),  # 3
)


class removeRunReports_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('removeRunReports_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(removeRunReports_result)
removeRunReports_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class removeRun_args(object):
    """
    Attributes:
     - runId
     - runFilter

    """
    thrift_spec = None


    def __init__(self, runId = None, runFilter = None,):
        self.runId = runId
        self.runFilter = runFilter

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.runId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.runFilter = RunFilter()
                    self.runFilter.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('removeRun_args')
        if self.runId is not None:
            oprot.writeFieldBegin('runId', TType.I64, 1)
            oprot.writeI64(self.runId)
            oprot.writeFieldEnd()
        if self.runFilter is not None:
            oprot.writeFieldBegin('runFilter', TType.STRUCT, 2)
            self.runFilter.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(removeRun_args)
removeRun_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'runId', None, None, ),  # 1
    (2, TType.STRUCT, 'runFilter', [RunFilter, None], None, ),  # 2
)


class removeRun_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('removeRun_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(removeRun_result)
removeRun_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class updateRunData_args(object):
    """
    Attributes:
     - runId
     - newRunName

    """
    thrift_spec = None


    def __init__(self, runId = None, newRunName = None,):
        self.runId = runId
        self.newRunName = newRunName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.runId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.newRunName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateRunData_args')
        if self.runId is not None:
            oprot.writeFieldBegin('runId', TType.I64, 1)
            oprot.writeI64(self.runId)
            oprot.writeFieldEnd()
        if self.newRunName is not None:
            oprot.writeFieldBegin('newRunName', TType.STRING, 2)
            oprot.writeString(self.newRunName.encode('utf-8') if sys.version_info[0] == 2 else self.newRunName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateRunData_args)
updateRunData_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'runId', None, None, ),  # 1
    (2, TType.STRING, 'newRunName', 'UTF8', None, ),  # 2
)


class updateRunData_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateRunData_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateRunData_result)
updateRunData_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getSuppressFile_args(object):
    thrift_spec = None


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getSuppressFile_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getSuppressFile_args)
getSuppressFile_args.thrift_spec = (
)


class getSuppressFile_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getSuppressFile_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getSuppressFile_result)
getSuppressFile_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getSeverityCounts_args(object):
    """
    Attributes:
     - runIds
     - reportFilter
     - cmpData

    """
    thrift_spec = None


    def __init__(self, runIds = None, reportFilter = None, cmpData = None,):
        self.runIds = runIds
        self.reportFilter = reportFilter
        self.cmpData = cmpData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.runIds = []
                    (_etype603, _size600) = iprot.readListBegin()
                    for _i604 in range(_size600):
                        _elem605 = iprot.readI64()
                        self.runIds.append(_elem605)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.reportFilter = ReportFilter()
                    self.reportFilter.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.cmpData = CompareData()
                    self.cmpData.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getSeverityCounts_args')
        if self.runIds is not None:
            oprot.writeFieldBegin('runIds', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.runIds))
            for iter606 in self.runIds:
                oprot.writeI64(iter606)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.reportFilter is not None:
            oprot.writeFieldBegin('reportFilter', TType.STRUCT, 2)
            self.reportFilter.write(oprot)
            oprot.writeFieldEnd()
        if self.cmpData is not None:
            oprot.writeFieldBegin('cmpData', TType.STRUCT, 3)
            self.cmpData.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getSeverityCounts_args)
getSeverityCounts_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'runIds', (TType.I64, None, False), None, ),  # 1
    (2, TType.STRUCT, 'reportFilter', [ReportFilter, None], None, ),  # 2
    (3, TType.STRUCT, 'cmpData', [CompareData, None], None, ),  # 3
)


class getSeverityCounts_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype608, _vtype609, _size607) = iprot.readMapBegin()
                    for _i611 in range(_size607):
                        _key612 = iprot.readI32()
                        _val613 = iprot.readI64()
                        self.success[_key612] = _val613
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getSeverityCounts_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I32, TType.I64, len(self.success))
            for kiter614, viter615 in self.success.items():
                oprot.writeI32(kiter614)
                oprot.writeI64(viter615)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getSeverityCounts_result)
getSeverityCounts_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I32, None, TType.I64, None, False), None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getCheckerMsgCounts_args(object):
    """
    Attributes:
     - runIds
     - reportFilter
     - cmpData
     - limit
     - offset

    """
    thrift_spec = None


    def __init__(self, runIds = None, reportFilter = None, cmpData = None, limit = None, offset = None,):
        self.runIds = runIds
        self.reportFilter = reportFilter
        self.cmpData = cmpData
        self.limit = limit
        self.offset = offset

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.runIds = []
                    (_etype619, _size616) = iprot.readListBegin()
                    for _i620 in range(_size616):
                        _elem621 = iprot.readI64()
                        self.runIds.append(_elem621)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.reportFilter = ReportFilter()
                    self.reportFilter.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.cmpData = CompareData()
                    self.cmpData.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.limit = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.offset = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCheckerMsgCounts_args')
        if self.runIds is not None:
            oprot.writeFieldBegin('runIds', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.runIds))
            for iter622 in self.runIds:
                oprot.writeI64(iter622)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.reportFilter is not None:
            oprot.writeFieldBegin('reportFilter', TType.STRUCT, 2)
            self.reportFilter.write(oprot)
            oprot.writeFieldEnd()
        if self.cmpData is not None:
            oprot.writeFieldBegin('cmpData', TType.STRUCT, 3)
            self.cmpData.write(oprot)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I64, 4)
            oprot.writeI64(self.limit)
            oprot.writeFieldEnd()
        if self.offset is not None:
            oprot.writeFieldBegin('offset', TType.I64, 5)
            oprot.writeI64(self.offset)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCheckerMsgCounts_args)
getCheckerMsgCounts_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'runIds', (TType.I64, None, False), None, ),  # 1
    (2, TType.STRUCT, 'reportFilter', [ReportFilter, None], None, ),  # 2
    (3, TType.STRUCT, 'cmpData', [CompareData, None], None, ),  # 3
    (4, TType.I64, 'limit', None, None, ),  # 4
    (5, TType.I64, 'offset', None, None, ),  # 5
)


class getCheckerMsgCounts_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype624, _vtype625, _size623) = iprot.readMapBegin()
                    for _i627 in range(_size623):
                        _key628 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val629 = iprot.readI64()
                        self.success[_key628] = _val629
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCheckerMsgCounts_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.I64, len(self.success))
            for kiter630, viter631 in self.success.items():
                oprot.writeString(kiter630.encode('utf-8') if sys.version_info[0] == 2 else kiter630)
                oprot.writeI64(viter631)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCheckerMsgCounts_result)
getCheckerMsgCounts_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.I64, None, False), None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getReportStatusCounts_args(object):
    """
    Attributes:
     - runIds
     - reportFilter
     - cmpData

    """
    thrift_spec = None


    def __init__(self, runIds = None, reportFilter = None, cmpData = None,):
        self.runIds = runIds
        self.reportFilter = reportFilter
        self.cmpData = cmpData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.runIds = []
                    (_etype635, _size632) = iprot.readListBegin()
                    for _i636 in range(_size632):
                        _elem637 = iprot.readI64()
                        self.runIds.append(_elem637)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.reportFilter = ReportFilter()
                    self.reportFilter.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.cmpData = CompareData()
                    self.cmpData.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getReportStatusCounts_args')
        if self.runIds is not None:
            oprot.writeFieldBegin('runIds', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.runIds))
            for iter638 in self.runIds:
                oprot.writeI64(iter638)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.reportFilter is not None:
            oprot.writeFieldBegin('reportFilter', TType.STRUCT, 2)
            self.reportFilter.write(oprot)
            oprot.writeFieldEnd()
        if self.cmpData is not None:
            oprot.writeFieldBegin('cmpData', TType.STRUCT, 3)
            self.cmpData.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getReportStatusCounts_args)
getReportStatusCounts_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'runIds', (TType.I64, None, False), None, ),  # 1
    (2, TType.STRUCT, 'reportFilter', [ReportFilter, None], None, ),  # 2
    (3, TType.STRUCT, 'cmpData', [CompareData, None], None, ),  # 3
)


class getReportStatusCounts_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype640, _vtype641, _size639) = iprot.readMapBegin()
                    for _i643 in range(_size639):
                        _key644 = iprot.readI32()
                        _val645 = iprot.readI64()
                        self.success[_key644] = _val645
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getReportStatusCounts_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I32, TType.I64, len(self.success))
            for kiter646, viter647 in self.success.items():
                oprot.writeI32(kiter646)
                oprot.writeI64(viter647)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getReportStatusCounts_result)
getReportStatusCounts_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I32, None, TType.I64, None, False), None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getReviewStatusCounts_args(object):
    """
    Attributes:
     - runIds
     - reportFilter
     - cmpData

    """
    thrift_spec = None


    def __init__(self, runIds = None, reportFilter = None, cmpData = None,):
        self.runIds = runIds
        self.reportFilter = reportFilter
        self.cmpData = cmpData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.runIds = []
                    (_etype651, _size648) = iprot.readListBegin()
                    for _i652 in range(_size648):
                        _elem653 = iprot.readI64()
                        self.runIds.append(_elem653)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.reportFilter = ReportFilter()
                    self.reportFilter.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.cmpData = CompareData()
                    self.cmpData.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getReviewStatusCounts_args')
        if self.runIds is not None:
            oprot.writeFieldBegin('runIds', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.runIds))
            for iter654 in self.runIds:
                oprot.writeI64(iter654)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.reportFilter is not None:
            oprot.writeFieldBegin('reportFilter', TType.STRUCT, 2)
            self.reportFilter.write(oprot)
            oprot.writeFieldEnd()
        if self.cmpData is not None:
            oprot.writeFieldBegin('cmpData', TType.STRUCT, 3)
            self.cmpData.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getReviewStatusCounts_args)
getReviewStatusCounts_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'runIds', (TType.I64, None, False), None, ),  # 1
    (2, TType.STRUCT, 'reportFilter', [ReportFilter, None], None, ),  # 2
    (3, TType.STRUCT, 'cmpData', [CompareData, None], None, ),  # 3
)


class getReviewStatusCounts_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype656, _vtype657, _size655) = iprot.readMapBegin()
                    for _i659 in range(_size655):
                        _key660 = iprot.readI32()
                        _val661 = iprot.readI64()
                        self.success[_key660] = _val661
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getReviewStatusCounts_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I32, TType.I64, len(self.success))
            for kiter662, viter663 in self.success.items():
                oprot.writeI32(kiter662)
                oprot.writeI64(viter663)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getReviewStatusCounts_result)
getReviewStatusCounts_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I32, None, TType.I64, None, False), None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getDetectionStatusCounts_args(object):
    """
    Attributes:
     - runIds
     - reportFilter
     - cmpData

    """
    thrift_spec = None


    def __init__(self, runIds = None, reportFilter = None, cmpData = None,):
        self.runIds = runIds
        self.reportFilter = reportFilter
        self.cmpData = cmpData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.runIds = []
                    (_etype667, _size664) = iprot.readListBegin()
                    for _i668 in range(_size664):
                        _elem669 = iprot.readI64()
                        self.runIds.append(_elem669)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.reportFilter = ReportFilter()
                    self.reportFilter.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.cmpData = CompareData()
                    self.cmpData.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDetectionStatusCounts_args')
        if self.runIds is not None:
            oprot.writeFieldBegin('runIds', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.runIds))
            for iter670 in self.runIds:
                oprot.writeI64(iter670)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.reportFilter is not None:
            oprot.writeFieldBegin('reportFilter', TType.STRUCT, 2)
            self.reportFilter.write(oprot)
            oprot.writeFieldEnd()
        if self.cmpData is not None:
            oprot.writeFieldBegin('cmpData', TType.STRUCT, 3)
            self.cmpData.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDetectionStatusCounts_args)
getDetectionStatusCounts_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'runIds', (TType.I64, None, False), None, ),  # 1
    (2, TType.STRUCT, 'reportFilter', [ReportFilter, None], None, ),  # 2
    (3, TType.STRUCT, 'cmpData', [CompareData, None], None, ),  # 3
)


class getDetectionStatusCounts_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype672, _vtype673, _size671) = iprot.readMapBegin()
                    for _i675 in range(_size671):
                        _key676 = iprot.readI32()
                        _val677 = iprot.readI64()
                        self.success[_key676] = _val677
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDetectionStatusCounts_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I32, TType.I64, len(self.success))
            for kiter678, viter679 in self.success.items():
                oprot.writeI32(kiter678)
                oprot.writeI64(viter679)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDetectionStatusCounts_result)
getDetectionStatusCounts_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I32, None, TType.I64, None, False), None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getFileCounts_args(object):
    """
    Attributes:
     - runIds
     - reportFilter
     - cmpData
     - limit
     - offset

    """
    thrift_spec = None


    def __init__(self, runIds = None, reportFilter = None, cmpData = None, limit = None, offset = None,):
        self.runIds = runIds
        self.reportFilter = reportFilter
        self.cmpData = cmpData
        self.limit = limit
        self.offset = offset

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.runIds = []
                    (_etype683, _size680) = iprot.readListBegin()
                    for _i684 in range(_size680):
                        _elem685 = iprot.readI64()
                        self.runIds.append(_elem685)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.reportFilter = ReportFilter()
                    self.reportFilter.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.cmpData = CompareData()
                    self.cmpData.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.limit = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.offset = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getFileCounts_args')
        if self.runIds is not None:
            oprot.writeFieldBegin('runIds', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.runIds))
            for iter686 in self.runIds:
                oprot.writeI64(iter686)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.reportFilter is not None:
            oprot.writeFieldBegin('reportFilter', TType.STRUCT, 2)
            self.reportFilter.write(oprot)
            oprot.writeFieldEnd()
        if self.cmpData is not None:
            oprot.writeFieldBegin('cmpData', TType.STRUCT, 3)
            self.cmpData.write(oprot)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I64, 4)
            oprot.writeI64(self.limit)
            oprot.writeFieldEnd()
        if self.offset is not None:
            oprot.writeFieldBegin('offset', TType.I64, 5)
            oprot.writeI64(self.offset)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getFileCounts_args)
getFileCounts_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'runIds', (TType.I64, None, False), None, ),  # 1
    (2, TType.STRUCT, 'reportFilter', [ReportFilter, None], None, ),  # 2
    (3, TType.STRUCT, 'cmpData', [CompareData, None], None, ),  # 3
    (4, TType.I64, 'limit', None, None, ),  # 4
    (5, TType.I64, 'offset', None, None, ),  # 5
)


class getFileCounts_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype688, _vtype689, _size687) = iprot.readMapBegin()
                    for _i691 in range(_size687):
                        _key692 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val693 = iprot.readI64()
                        self.success[_key692] = _val693
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getFileCounts_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.I64, len(self.success))
            for kiter694, viter695 in self.success.items():
                oprot.writeString(kiter694.encode('utf-8') if sys.version_info[0] == 2 else kiter694)
                oprot.writeI64(viter695)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getFileCounts_result)
getFileCounts_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.I64, None, False), None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getCheckerCounts_args(object):
    """
    Attributes:
     - runIds
     - reportFilter
     - cmpData
     - limit
     - offset

    """
    thrift_spec = None


    def __init__(self, runIds = None, reportFilter = None, cmpData = None, limit = None, offset = None,):
        self.runIds = runIds
        self.reportFilter = reportFilter
        self.cmpData = cmpData
        self.limit = limit
        self.offset = offset

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.runIds = []
                    (_etype699, _size696) = iprot.readListBegin()
                    for _i700 in range(_size696):
                        _elem701 = iprot.readI64()
                        self.runIds.append(_elem701)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.reportFilter = ReportFilter()
                    self.reportFilter.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.cmpData = CompareData()
                    self.cmpData.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.limit = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.offset = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCheckerCounts_args')
        if self.runIds is not None:
            oprot.writeFieldBegin('runIds', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.runIds))
            for iter702 in self.runIds:
                oprot.writeI64(iter702)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.reportFilter is not None:
            oprot.writeFieldBegin('reportFilter', TType.STRUCT, 2)
            self.reportFilter.write(oprot)
            oprot.writeFieldEnd()
        if self.cmpData is not None:
            oprot.writeFieldBegin('cmpData', TType.STRUCT, 3)
            self.cmpData.write(oprot)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I64, 4)
            oprot.writeI64(self.limit)
            oprot.writeFieldEnd()
        if self.offset is not None:
            oprot.writeFieldBegin('offset', TType.I64, 5)
            oprot.writeI64(self.offset)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCheckerCounts_args)
getCheckerCounts_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'runIds', (TType.I64, None, False), None, ),  # 1
    (2, TType.STRUCT, 'reportFilter', [ReportFilter, None], None, ),  # 2
    (3, TType.STRUCT, 'cmpData', [CompareData, None], None, ),  # 3
    (4, TType.I64, 'limit', None, None, ),  # 4
    (5, TType.I64, 'offset', None, None, ),  # 5
)


class getCheckerCounts_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype706, _size703) = iprot.readListBegin()
                    for _i707 in range(_size703):
                        _elem708 = CheckerCount()
                        _elem708.read(iprot)
                        self.success.append(_elem708)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCheckerCounts_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter709 in self.success:
                iter709.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCheckerCounts_result)
getCheckerCounts_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [CheckerCount, None], False), None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getCheckerStatusVerificationDetails_args(object):
    """
    Attributes:
     - runIds
     - reportFilter

    """
    thrift_spec = None


    def __init__(self, runIds = None, reportFilter = None,):
        self.runIds = runIds
        self.reportFilter = reportFilter

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.runIds = []
                    (_etype713, _size710) = iprot.readListBegin()
                    for _i714 in range(_size710):
                        _elem715 = iprot.readI64()
                        self.runIds.append(_elem715)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.reportFilter = ReportFilter()
                    self.reportFilter.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCheckerStatusVerificationDetails_args')
        if self.runIds is not None:
            oprot.writeFieldBegin('runIds', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.runIds))
            for iter716 in self.runIds:
                oprot.writeI64(iter716)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.reportFilter is not None:
            oprot.writeFieldBegin('reportFilter', TType.STRUCT, 2)
            self.reportFilter.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCheckerStatusVerificationDetails_args)
getCheckerStatusVerificationDetails_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'runIds', (TType.I64, None, False), None, ),  # 1
    (2, TType.STRUCT, 'reportFilter', [ReportFilter, None], None, ),  # 2
)


class getCheckerStatusVerificationDetails_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype718, _vtype719, _size717) = iprot.readMapBegin()
                    for _i721 in range(_size717):
                        _key722 = iprot.readI64()
                        _val723 = CheckerStatusVerificationDetail()
                        _val723.read(iprot)
                        self.success[_key722] = _val723
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCheckerStatusVerificationDetails_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.STRUCT, len(self.success))
            for kiter724, viter725 in self.success.items():
                oprot.writeI64(kiter724)
                viter725.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCheckerStatusVerificationDetails_result)
getCheckerStatusVerificationDetails_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.STRUCT, [CheckerStatusVerificationDetail, None], False), None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getRunHistoryTagCounts_args(object):
    """
    Attributes:
     - runIds
     - reportFilter
     - cmpData
     - limit
     - offset

    """
    thrift_spec = None


    def __init__(self, runIds = None, reportFilter = None, cmpData = None, limit = None, offset = None,):
        self.runIds = runIds
        self.reportFilter = reportFilter
        self.cmpData = cmpData
        self.limit = limit
        self.offset = offset

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.runIds = []
                    (_etype729, _size726) = iprot.readListBegin()
                    for _i730 in range(_size726):
                        _elem731 = iprot.readI64()
                        self.runIds.append(_elem731)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.reportFilter = ReportFilter()
                    self.reportFilter.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.cmpData = CompareData()
                    self.cmpData.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.limit = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.offset = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getRunHistoryTagCounts_args')
        if self.runIds is not None:
            oprot.writeFieldBegin('runIds', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.runIds))
            for iter732 in self.runIds:
                oprot.writeI64(iter732)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.reportFilter is not None:
            oprot.writeFieldBegin('reportFilter', TType.STRUCT, 2)
            self.reportFilter.write(oprot)
            oprot.writeFieldEnd()
        if self.cmpData is not None:
            oprot.writeFieldBegin('cmpData', TType.STRUCT, 3)
            self.cmpData.write(oprot)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I64, 4)
            oprot.writeI64(self.limit)
            oprot.writeFieldEnd()
        if self.offset is not None:
            oprot.writeFieldBegin('offset', TType.I64, 5)
            oprot.writeI64(self.offset)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getRunHistoryTagCounts_args)
getRunHistoryTagCounts_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'runIds', (TType.I64, None, False), None, ),  # 1
    (2, TType.STRUCT, 'reportFilter', [ReportFilter, None], None, ),  # 2
    (3, TType.STRUCT, 'cmpData', [CompareData, None], None, ),  # 3
    (4, TType.I64, 'limit', None, None, ),  # 4
    (5, TType.I64, 'offset', None, None, ),  # 5
)


class getRunHistoryTagCounts_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype736, _size733) = iprot.readListBegin()
                    for _i737 in range(_size733):
                        _elem738 = RunTagCount()
                        _elem738.read(iprot)
                        self.success.append(_elem738)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getRunHistoryTagCounts_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter739 in self.success:
                iter739.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getRunHistoryTagCounts_result)
getRunHistoryTagCounts_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [RunTagCount, None], False), None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getAnalyzerNameCounts_args(object):
    """
    Attributes:
     - runIds
     - reportFilter
     - cmpData
     - limit
     - offset

    """
    thrift_spec = None


    def __init__(self, runIds = None, reportFilter = None, cmpData = None, limit = None, offset = None,):
        self.runIds = runIds
        self.reportFilter = reportFilter
        self.cmpData = cmpData
        self.limit = limit
        self.offset = offset

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.runIds = []
                    (_etype743, _size740) = iprot.readListBegin()
                    for _i744 in range(_size740):
                        _elem745 = iprot.readI64()
                        self.runIds.append(_elem745)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.reportFilter = ReportFilter()
                    self.reportFilter.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.cmpData = CompareData()
                    self.cmpData.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.limit = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.offset = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAnalyzerNameCounts_args')
        if self.runIds is not None:
            oprot.writeFieldBegin('runIds', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.runIds))
            for iter746 in self.runIds:
                oprot.writeI64(iter746)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.reportFilter is not None:
            oprot.writeFieldBegin('reportFilter', TType.STRUCT, 2)
            self.reportFilter.write(oprot)
            oprot.writeFieldEnd()
        if self.cmpData is not None:
            oprot.writeFieldBegin('cmpData', TType.STRUCT, 3)
            self.cmpData.write(oprot)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I64, 4)
            oprot.writeI64(self.limit)
            oprot.writeFieldEnd()
        if self.offset is not None:
            oprot.writeFieldBegin('offset', TType.I64, 5)
            oprot.writeI64(self.offset)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAnalyzerNameCounts_args)
getAnalyzerNameCounts_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'runIds', (TType.I64, None, False), None, ),  # 1
    (2, TType.STRUCT, 'reportFilter', [ReportFilter, None], None, ),  # 2
    (3, TType.STRUCT, 'cmpData', [CompareData, None], None, ),  # 3
    (4, TType.I64, 'limit', None, None, ),  # 4
    (5, TType.I64, 'offset', None, None, ),  # 5
)


class getAnalyzerNameCounts_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype748, _vtype749, _size747) = iprot.readMapBegin()
                    for _i751 in range(_size747):
                        _key752 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val753 = iprot.readI64()
                        self.success[_key752] = _val753
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAnalyzerNameCounts_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.I64, len(self.success))
            for kiter754, viter755 in self.success.items():
                oprot.writeString(kiter754.encode('utf-8') if sys.version_info[0] == 2 else kiter754)
                oprot.writeI64(viter755)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAnalyzerNameCounts_result)
getAnalyzerNameCounts_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.I64, None, False), None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class addSourceComponent_args(object):
    """
    Attributes:
     - name
     - value
     - description

    """
    thrift_spec = None


    def __init__(self, name = None, value = None, description = None,):
        self.name = name
        self.value = value
        self.description = description

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.value = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.description = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('addSourceComponent_args')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 2)
            oprot.writeString(self.value.encode('utf-8') if sys.version_info[0] == 2 else self.value)
            oprot.writeFieldEnd()
        if self.description is not None:
            oprot.writeFieldBegin('description', TType.STRING, 3)
            oprot.writeString(self.description.encode('utf-8') if sys.version_info[0] == 2 else self.description)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(addSourceComponent_args)
addSourceComponent_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'value', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'description', 'UTF8', None, ),  # 3
)


class addSourceComponent_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('addSourceComponent_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(addSourceComponent_result)
addSourceComponent_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getSourceComponents_args(object):
    """
    Attributes:
     - sourceComponentFilter

    """
    thrift_spec = None


    def __init__(self, sourceComponentFilter = None,):
        self.sourceComponentFilter = sourceComponentFilter

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.sourceComponentFilter = []
                    (_etype759, _size756) = iprot.readListBegin()
                    for _i760 in range(_size756):
                        _elem761 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.sourceComponentFilter.append(_elem761)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getSourceComponents_args')
        if self.sourceComponentFilter is not None:
            oprot.writeFieldBegin('sourceComponentFilter', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.sourceComponentFilter))
            for iter762 in self.sourceComponentFilter:
                oprot.writeString(iter762.encode('utf-8') if sys.version_info[0] == 2 else iter762)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getSourceComponents_args)
getSourceComponents_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'sourceComponentFilter', (TType.STRING, 'UTF8', False), None, ),  # 1
)


class getSourceComponents_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype766, _size763) = iprot.readListBegin()
                    for _i767 in range(_size763):
                        _elem768 = SourceComponentData()
                        _elem768.read(iprot)
                        self.success.append(_elem768)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getSourceComponents_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter769 in self.success:
                iter769.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getSourceComponents_result)
getSourceComponents_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [SourceComponentData, None], False), None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class removeSourceComponent_args(object):
    """
    Attributes:
     - name

    """
    thrift_spec = None


    def __init__(self, name = None,):
        self.name = name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('removeSourceComponent_args')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(removeSourceComponent_args)
removeSourceComponent_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
)


class removeSourceComponent_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('removeSourceComponent_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(removeSourceComponent_result)
removeSourceComponent_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getMissingContentHashes_args(object):
    """
    Attributes:
     - fileHashes

    """
    thrift_spec = None


    def __init__(self, fileHashes = None,):
        self.fileHashes = fileHashes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.fileHashes = []
                    (_etype773, _size770) = iprot.readListBegin()
                    for _i774 in range(_size770):
                        _elem775 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.fileHashes.append(_elem775)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getMissingContentHashes_args')
        if self.fileHashes is not None:
            oprot.writeFieldBegin('fileHashes', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.fileHashes))
            for iter776 in self.fileHashes:
                oprot.writeString(iter776.encode('utf-8') if sys.version_info[0] == 2 else iter776)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getMissingContentHashes_args)
getMissingContentHashes_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'fileHashes', (TType.STRING, 'UTF8', False), None, ),  # 1
)


class getMissingContentHashes_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype780, _size777) = iprot.readListBegin()
                    for _i781 in range(_size777):
                        _elem782 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem782)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getMissingContentHashes_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter783 in self.success:
                oprot.writeString(iter783.encode('utf-8') if sys.version_info[0] == 2 else iter783)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getMissingContentHashes_result)
getMissingContentHashes_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getMissingContentHashesForBlameInfo_args(object):
    """
    Attributes:
     - fileHashes

    """
    thrift_spec = None


    def __init__(self, fileHashes = None,):
        self.fileHashes = fileHashes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.fileHashes = []
                    (_etype787, _size784) = iprot.readListBegin()
                    for _i788 in range(_size784):
                        _elem789 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.fileHashes.append(_elem789)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getMissingContentHashesForBlameInfo_args')
        if self.fileHashes is not None:
            oprot.writeFieldBegin('fileHashes', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.fileHashes))
            for iter790 in self.fileHashes:
                oprot.writeString(iter790.encode('utf-8') if sys.version_info[0] == 2 else iter790)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getMissingContentHashesForBlameInfo_args)
getMissingContentHashesForBlameInfo_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'fileHashes', (TType.STRING, 'UTF8', False), None, ),  # 1
)


class getMissingContentHashesForBlameInfo_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype794, _size791) = iprot.readListBegin()
                    for _i795 in range(_size791):
                        _elem796 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem796)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getMissingContentHashesForBlameInfo_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter797 in self.success:
                oprot.writeString(iter797.encode('utf-8') if sys.version_info[0] == 2 else iter797)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getMissingContentHashesForBlameInfo_result)
getMissingContentHashesForBlameInfo_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class massStoreRun_args(object):
    """
    Attributes:
     - runName
     - tag
     - version
     - zipfile
     - force
     - trimPathPrefixes
     - description

    """
    thrift_spec = None


    def __init__(self, runName = None, tag = None, version = None, zipfile = None, force = None, trimPathPrefixes = None, description = None,):
        self.runName = runName
        self.tag = tag
        self.version = version
        self.zipfile = zipfile
        self.force = force
        self.trimPathPrefixes = trimPathPrefixes
        self.description = description

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.runName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tag = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.version = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.zipfile = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.force = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.trimPathPrefixes = []
                    (_etype801, _size798) = iprot.readListBegin()
                    for _i802 in range(_size798):
                        _elem803 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.trimPathPrefixes.append(_elem803)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.description = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('massStoreRun_args')
        if self.runName is not None:
            oprot.writeFieldBegin('runName', TType.STRING, 1)
            oprot.writeString(self.runName.encode('utf-8') if sys.version_info[0] == 2 else self.runName)
            oprot.writeFieldEnd()
        if self.tag is not None:
            oprot.writeFieldBegin('tag', TType.STRING, 2)
            oprot.writeString(self.tag.encode('utf-8') if sys.version_info[0] == 2 else self.tag)
            oprot.writeFieldEnd()
        if self.version is not None:
            oprot.writeFieldBegin('version', TType.STRING, 3)
            oprot.writeString(self.version.encode('utf-8') if sys.version_info[0] == 2 else self.version)
            oprot.writeFieldEnd()
        if self.zipfile is not None:
            oprot.writeFieldBegin('zipfile', TType.STRING, 4)
            oprot.writeString(self.zipfile.encode('utf-8') if sys.version_info[0] == 2 else self.zipfile)
            oprot.writeFieldEnd()
        if self.force is not None:
            oprot.writeFieldBegin('force', TType.BOOL, 5)
            oprot.writeBool(self.force)
            oprot.writeFieldEnd()
        if self.trimPathPrefixes is not None:
            oprot.writeFieldBegin('trimPathPrefixes', TType.LIST, 6)
            oprot.writeListBegin(TType.STRING, len(self.trimPathPrefixes))
            for iter804 in self.trimPathPrefixes:
                oprot.writeString(iter804.encode('utf-8') if sys.version_info[0] == 2 else iter804)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.description is not None:
            oprot.writeFieldBegin('description', TType.STRING, 7)
            oprot.writeString(self.description.encode('utf-8') if sys.version_info[0] == 2 else self.description)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(massStoreRun_args)
massStoreRun_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'runName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tag', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'version', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'zipfile', 'UTF8', None, ),  # 4
    (5, TType.BOOL, 'force', None, None, ),  # 5
    (6, TType.LIST, 'trimPathPrefixes', (TType.STRING, 'UTF8', False), None, ),  # 6
    (7, TType.STRING, 'description', 'UTF8', None, ),  # 7
)


class massStoreRun_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('massStoreRun_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(massStoreRun_result)
massStoreRun_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class allowsStoringAnalysisStatistics_args(object):
    thrift_spec = None


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('allowsStoringAnalysisStatistics_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(allowsStoringAnalysisStatistics_args)
allowsStoringAnalysisStatistics_args.thrift_spec = (
)


class allowsStoringAnalysisStatistics_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('allowsStoringAnalysisStatistics_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(allowsStoringAnalysisStatistics_result)
allowsStoringAnalysisStatistics_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getAnalysisStatisticsLimits_args(object):
    thrift_spec = None


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAnalysisStatisticsLimits_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAnalysisStatisticsLimits_args)
getAnalysisStatisticsLimits_args.thrift_spec = (
)


class getAnalysisStatisticsLimits_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype806, _vtype807, _size805) = iprot.readMapBegin()
                    for _i809 in range(_size805):
                        _key810 = iprot.readI32()
                        _val811 = iprot.readI64()
                        self.success[_key810] = _val811
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAnalysisStatisticsLimits_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I32, TType.I64, len(self.success))
            for kiter812, viter813 in self.success.items():
                oprot.writeI32(kiter812)
                oprot.writeI64(viter813)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAnalysisStatisticsLimits_result)
getAnalysisStatisticsLimits_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I32, None, TType.I64, None, False), None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class storeAnalysisStatistics_args(object):
    """
    Attributes:
     - runName
     - zipfile

    """
    thrift_spec = None


    def __init__(self, runName = None, zipfile = None,):
        self.runName = runName
        self.zipfile = zipfile

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.runName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.zipfile = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('storeAnalysisStatistics_args')
        if self.runName is not None:
            oprot.writeFieldBegin('runName', TType.STRING, 1)
            oprot.writeString(self.runName.encode('utf-8') if sys.version_info[0] == 2 else self.runName)
            oprot.writeFieldEnd()
        if self.zipfile is not None:
            oprot.writeFieldBegin('zipfile', TType.STRING, 2)
            oprot.writeString(self.zipfile.encode('utf-8') if sys.version_info[0] == 2 else self.zipfile)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(storeAnalysisStatistics_args)
storeAnalysisStatistics_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'runName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'zipfile', 'UTF8', None, ),  # 2
)


class storeAnalysisStatistics_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('storeAnalysisStatistics_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(storeAnalysisStatistics_result)
storeAnalysisStatistics_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getAnalysisStatistics_args(object):
    """
    Attributes:
     - runId
     - runHistoryId

    """
    thrift_spec = None


    def __init__(self, runId = None, runHistoryId = None,):
        self.runId = runId
        self.runHistoryId = runHistoryId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.runId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.runHistoryId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAnalysisStatistics_args')
        if self.runId is not None:
            oprot.writeFieldBegin('runId', TType.I64, 1)
            oprot.writeI64(self.runId)
            oprot.writeFieldEnd()
        if self.runHistoryId is not None:
            oprot.writeFieldBegin('runHistoryId', TType.I64, 2)
            oprot.writeI64(self.runHistoryId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAnalysisStatistics_args)
getAnalysisStatistics_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'runId', None, None, ),  # 1
    (2, TType.I64, 'runHistoryId', None, None, ),  # 2
)


class getAnalysisStatistics_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype815, _vtype816, _size814) = iprot.readMapBegin()
                    for _i818 in range(_size814):
                        _key819 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val820 = AnalyzerStatistics()
                        _val820.read(iprot)
                        self.success[_key819] = _val820
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAnalysisStatistics_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
            for kiter821, viter822 in self.success.items():
                oprot.writeString(kiter821.encode('utf-8') if sys.version_info[0] == 2 else kiter821)
                viter822.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAnalysisStatistics_result)
getAnalysisStatistics_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRUCT, [AnalyzerStatistics, None], False), None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class exportData_args(object):
    """
    Attributes:
     - runFilter

    """
    thrift_spec = None


    def __init__(self, runFilter = None,):
        self.runFilter = runFilter

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.runFilter = RunFilter()
                    self.runFilter.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('exportData_args')
        if self.runFilter is not None:
            oprot.writeFieldBegin('runFilter', TType.STRUCT, 1)
            self.runFilter.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(exportData_args)
exportData_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'runFilter', [RunFilter, None], None, ),  # 1
)


class exportData_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ExportData()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('exportData_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(exportData_result)
exportData_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ExportData, None], None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class importData_args(object):
    """
    Attributes:
     - exportData

    """
    thrift_spec = None


    def __init__(self, exportData = None,):
        self.exportData = exportData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exportData = ExportData()
                    self.exportData.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('importData_args')
        if self.exportData is not None:
            oprot.writeFieldBegin('exportData', TType.STRUCT, 1)
            self.exportData.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(importData_args)
importData_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exportData', [ExportData, None], None, ),  # 1
)


class importData_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('importData_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(importData_result)
importData_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class addCleanupPlan_args(object):
    """
    Attributes:
     - name
     - description
     - dueDate

    """
    thrift_spec = None


    def __init__(self, name = None, description = None, dueDate = None,):
        self.name = name
        self.description = description
        self.dueDate = dueDate

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.description = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.dueDate = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('addCleanupPlan_args')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.description is not None:
            oprot.writeFieldBegin('description', TType.STRING, 2)
            oprot.writeString(self.description.encode('utf-8') if sys.version_info[0] == 2 else self.description)
            oprot.writeFieldEnd()
        if self.dueDate is not None:
            oprot.writeFieldBegin('dueDate', TType.I64, 3)
            oprot.writeI64(self.dueDate)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(addCleanupPlan_args)
addCleanupPlan_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'description', 'UTF8', None, ),  # 2
    (3, TType.I64, 'dueDate', None, None, ),  # 3
)


class addCleanupPlan_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('addCleanupPlan_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(addCleanupPlan_result)
addCleanupPlan_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class updateCleanupPlan_args(object):
    """
    Attributes:
     - id
     - name
     - description
     - dueDate

    """
    thrift_spec = None


    def __init__(self, id = None, name = None, description = None, dueDate = None,):
        self.id = id
        self.name = name
        self.description = description
        self.dueDate = dueDate

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.description = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.dueDate = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateCleanupPlan_args')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I64, 1)
            oprot.writeI64(self.id)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 2)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.description is not None:
            oprot.writeFieldBegin('description', TType.STRING, 3)
            oprot.writeString(self.description.encode('utf-8') if sys.version_info[0] == 2 else self.description)
            oprot.writeFieldEnd()
        if self.dueDate is not None:
            oprot.writeFieldBegin('dueDate', TType.I64, 4)
            oprot.writeI64(self.dueDate)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateCleanupPlan_args)
updateCleanupPlan_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'id', None, None, ),  # 1
    (2, TType.STRING, 'name', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'description', 'UTF8', None, ),  # 3
    (4, TType.I64, 'dueDate', None, None, ),  # 4
)


class updateCleanupPlan_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateCleanupPlan_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateCleanupPlan_result)
updateCleanupPlan_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getCleanupPlans_args(object):
    """
    Attributes:
     - filter

    """
    thrift_spec = None


    def __init__(self, filter = None,):
        self.filter = filter

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.filter = CleanupPlanFilter()
                    self.filter.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCleanupPlans_args')
        if self.filter is not None:
            oprot.writeFieldBegin('filter', TType.STRUCT, 1)
            self.filter.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCleanupPlans_args)
getCleanupPlans_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'filter', [CleanupPlanFilter, None], None, ),  # 1
)


class getCleanupPlans_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype826, _size823) = iprot.readListBegin()
                    for _i827 in range(_size823):
                        _elem828 = CleanupPlan()
                        _elem828.read(iprot)
                        self.success.append(_elem828)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCleanupPlans_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter829 in self.success:
                iter829.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCleanupPlans_result)
getCleanupPlans_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [CleanupPlan, None], False), None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class removeCleanupPlan_args(object):
    """
    Attributes:
     - cleanupPlanId

    """
    thrift_spec = None


    def __init__(self, cleanupPlanId = None,):
        self.cleanupPlanId = cleanupPlanId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.cleanupPlanId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('removeCleanupPlan_args')
        if self.cleanupPlanId is not None:
            oprot.writeFieldBegin('cleanupPlanId', TType.I64, 1)
            oprot.writeI64(self.cleanupPlanId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(removeCleanupPlan_args)
removeCleanupPlan_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'cleanupPlanId', None, None, ),  # 1
)


class removeCleanupPlan_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('removeCleanupPlan_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(removeCleanupPlan_result)
removeCleanupPlan_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class closeCleanupPlan_args(object):
    """
    Attributes:
     - cleanupPlanId

    """
    thrift_spec = None


    def __init__(self, cleanupPlanId = None,):
        self.cleanupPlanId = cleanupPlanId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.cleanupPlanId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('closeCleanupPlan_args')
        if self.cleanupPlanId is not None:
            oprot.writeFieldBegin('cleanupPlanId', TType.I64, 1)
            oprot.writeI64(self.cleanupPlanId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(closeCleanupPlan_args)
closeCleanupPlan_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'cleanupPlanId', None, None, ),  # 1
)


class closeCleanupPlan_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('closeCleanupPlan_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(closeCleanupPlan_result)
closeCleanupPlan_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class reopenCleanupPlan_args(object):
    """
    Attributes:
     - cleanupPlanId

    """
    thrift_spec = None


    def __init__(self, cleanupPlanId = None,):
        self.cleanupPlanId = cleanupPlanId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.cleanupPlanId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('reopenCleanupPlan_args')
        if self.cleanupPlanId is not None:
            oprot.writeFieldBegin('cleanupPlanId', TType.I64, 1)
            oprot.writeI64(self.cleanupPlanId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(reopenCleanupPlan_args)
reopenCleanupPlan_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'cleanupPlanId', None, None, ),  # 1
)


class reopenCleanupPlan_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('reopenCleanupPlan_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(reopenCleanupPlan_result)
reopenCleanupPlan_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class setCleanupPlan_args(object):
    """
    Attributes:
     - cleanupPlanId
     - reportHashes

    """
    thrift_spec = None


    def __init__(self, cleanupPlanId = None, reportHashes = None,):
        self.cleanupPlanId = cleanupPlanId
        self.reportHashes = reportHashes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.cleanupPlanId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.reportHashes = []
                    (_etype833, _size830) = iprot.readListBegin()
                    for _i834 in range(_size830):
                        _elem835 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.reportHashes.append(_elem835)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setCleanupPlan_args')
        if self.cleanupPlanId is not None:
            oprot.writeFieldBegin('cleanupPlanId', TType.I64, 1)
            oprot.writeI64(self.cleanupPlanId)
            oprot.writeFieldEnd()
        if self.reportHashes is not None:
            oprot.writeFieldBegin('reportHashes', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.reportHashes))
            for iter836 in self.reportHashes:
                oprot.writeString(iter836.encode('utf-8') if sys.version_info[0] == 2 else iter836)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setCleanupPlan_args)
setCleanupPlan_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'cleanupPlanId', None, None, ),  # 1
    (2, TType.LIST, 'reportHashes', (TType.STRING, 'UTF8', False), None, ),  # 2
)


class setCleanupPlan_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setCleanupPlan_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setCleanupPlan_result)
setCleanupPlan_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class unsetCleanupPlan_args(object):
    """
    Attributes:
     - cleanupPlanId
     - reportHashes

    """
    thrift_spec = None


    def __init__(self, cleanupPlanId = None, reportHashes = None,):
        self.cleanupPlanId = cleanupPlanId
        self.reportHashes = reportHashes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.cleanupPlanId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.reportHashes = []
                    (_etype840, _size837) = iprot.readListBegin()
                    for _i841 in range(_size837):
                        _elem842 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.reportHashes.append(_elem842)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('unsetCleanupPlan_args')
        if self.cleanupPlanId is not None:
            oprot.writeFieldBegin('cleanupPlanId', TType.I64, 1)
            oprot.writeI64(self.cleanupPlanId)
            oprot.writeFieldEnd()
        if self.reportHashes is not None:
            oprot.writeFieldBegin('reportHashes', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.reportHashes))
            for iter843 in self.reportHashes:
                oprot.writeString(iter843.encode('utf-8') if sys.version_info[0] == 2 else iter843)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(unsetCleanupPlan_args)
unsetCleanupPlan_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'cleanupPlanId', None, None, ),  # 1
    (2, TType.LIST, 'reportHashes', (TType.STRING, 'UTF8', False), None, ),  # 2
)


class unsetCleanupPlan_result(object):
    """
    Attributes:
     - success
     - requestError

    """
    thrift_spec = None


    def __init__(self, success = None, requestError = None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('unsetCleanupPlan_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(unsetCleanupPlan_result)
unsetCleanupPlan_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)
fix_spec(all_structs)
del all_structs
