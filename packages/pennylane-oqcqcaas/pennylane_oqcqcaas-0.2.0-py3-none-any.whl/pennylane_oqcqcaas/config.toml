schema = 3


[operators.gates]

PauliX = { properties = ["controllable", "invertible"] }
PauliY = { properties = ["controllable", "invertible"] }
PauliZ = { properties = ["controllable", "invertible"] }
RX = { properties = ["controllable", "invertible", "differentiable"] }
RY = { properties = ["controllable", "invertible", "differentiable"] }
RZ = { properties = ["controllable", "invertible", "differentiable"] }
CRY = { properties = ["invertible", "differentiable"] }
CRZ = { properties = ["invertible", "differentiable"] }
CNOT = { properties = ["invertible"] }


[operators.observables]

PauliX = { }
PauliY = { }
PauliZ = { }
Hamiltonian = { conditions = [ "terms-commute" ] }
Sum = { conditions = [ "terms-commute" ] }
SProd = { }
Prod = { }


[measurement_processes]

ExpectationMP = { }
CountsMP = { conditions = ["finiteshots"] }

# Additional support that the device may provide that informs the compilation
# process. All accepted fields and their default values are listed below.
[compilation]

# Whether the device is compatible with qjit.
qjit_compatible = false

# Whether the device requires run time generation of the quantum circuit.
runtime_code_generation = false

# Whether the device supports allocating and releasing qubits during execution.
dynamic_qubit_management = false

# Whether simultaneous measurements on overlapping wires is supported.
overlapping_observables = true

# Whether simultaneous measurements of non-commuting observables is supported.
# If false, a circuit with multiple non-commuting measurements will have to be
# split into multiple executions for each subset of commuting measurements.
non_commuting_observables = false

# Whether the device supports initial state preparation.
initial_state_prep = false

# The methods of handling mid-circuit measurements that the device supports,
# e.g., "one-shot", "tree-traversal", "device", etc. An empty list indicates
# that the device does not support mid-circuit measurements.
supported_mcm_methods = [ ]