"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
This protocol buffer uses optional fields, which requires either [buf] or a
[protoc] version 3.15 or later.

[buf]: https://buf.build/
[protoc]: https://github.com/protocolbuffers/protobuf#protobuf-compiler-installation
"""

import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _OutputStyle:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _OutputStyleEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_OutputStyle.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    EXPANDED: _OutputStyle.ValueType  # 0
    """Each selector and declaration is written on its own line."""
    COMPRESSED: _OutputStyle.ValueType  # 1
    """The entire stylesheet is written on a single line, with as few characters
    as possible.
    """

class OutputStyle(_OutputStyle, metaclass=_OutputStyleEnumTypeWrapper):
    """Possible ways to format the CSS output. The compiler is not required to
    support all possible options; if the host requests an unsupported style, the
    compiler should choose the closest supported style.
    """

EXPANDED: OutputStyle.ValueType  # 0
"""Each selector and declaration is written on its own line."""
COMPRESSED: OutputStyle.ValueType  # 1
"""The entire stylesheet is written on a single line, with as few characters
as possible.
"""
global___OutputStyle = OutputStyle

class _Syntax:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _SyntaxEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Syntax.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    SCSS: _Syntax.ValueType  # 0
    """The CSS-superset `.scss` syntax."""
    INDENTED: _Syntax.ValueType  # 1
    """The indented `.sass` syntax."""
    CSS: _Syntax.ValueType  # 2
    """Plain CSS syntax that doesn't support any special Sass features."""

class Syntax(_Syntax, metaclass=_SyntaxEnumTypeWrapper):
    """Possible syntaxes for a Sass stylesheet."""

SCSS: Syntax.ValueType  # 0
"""The CSS-superset `.scss` syntax."""
INDENTED: Syntax.ValueType  # 1
"""The indented `.sass` syntax."""
CSS: Syntax.ValueType  # 2
"""Plain CSS syntax that doesn't support any special Sass features."""
global___Syntax = Syntax

class _LogEventType:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _LogEventTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_LogEventType.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    WARNING: _LogEventType.ValueType  # 0
    """A warning for something other than a deprecated Sass feature. Often emitted
    due to a stylesheet using the `@warn` rule.
    """
    DEPRECATION_WARNING: _LogEventType.ValueType  # 1
    """A warning indicating that the stylesheet is using a deprecated Sass
    feature. Compilers should not add text like "deprecation warning" to
    deprecation warnings; it's up to the host to determine how to signal that
    to the user.
    """
    DEBUG: _LogEventType.ValueType  # 2
    """A message generated by the user for their own debugging purposes."""

class LogEventType(_LogEventType, metaclass=_LogEventTypeEnumTypeWrapper):
    """The possible types of [LogEvent]."""

WARNING: LogEventType.ValueType  # 0
"""A warning for something other than a deprecated Sass feature. Often emitted
due to a stylesheet using the `@warn` rule.
"""
DEPRECATION_WARNING: LogEventType.ValueType  # 1
"""A warning indicating that the stylesheet is using a deprecated Sass
feature. Compilers should not add text like "deprecation warning" to
deprecation warnings; it's up to the host to determine how to signal that
to the user.
"""
DEBUG: LogEventType.ValueType  # 2
"""A message generated by the user for their own debugging purposes."""
global___LogEventType = LogEventType

class _ProtocolErrorType:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _ProtocolErrorTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_ProtocolErrorType.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    PARSE: _ProtocolErrorType.ValueType  # 0
    """A message was received that couldn't be decoded as an `InboundMessage` (for
    the compiler) or `OutboundMessage` (for the host).
    """
    PARAMS: _ProtocolErrorType.ValueType  # 1
    """A message was received that violated a documented restriction, such as not
    providing a mandatory field.
    """
    INTERNAL: _ProtocolErrorType.ValueType  # 2
    """Something unexpected went wrong within the endpoint."""

class ProtocolErrorType(_ProtocolErrorType, metaclass=_ProtocolErrorTypeEnumTypeWrapper):
    """Potential types of protocol errors."""

PARSE: ProtocolErrorType.ValueType  # 0
"""A message was received that couldn't be decoded as an `InboundMessage` (for
the compiler) or `OutboundMessage` (for the host).
"""
PARAMS: ProtocolErrorType.ValueType  # 1
"""A message was received that violated a documented restriction, such as not
providing a mandatory field.
"""
INTERNAL: ProtocolErrorType.ValueType  # 2
"""Something unexpected went wrong within the endpoint."""
global___ProtocolErrorType = ProtocolErrorType

class _ListSeparator:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _ListSeparatorEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_ListSeparator.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    COMMA: _ListSeparator.ValueType  # 0
    """List elements are separated by a comma."""
    SPACE: _ListSeparator.ValueType  # 1
    """List elements are separated by whitespace."""
    SLASH: _ListSeparator.ValueType  # 2
    """List elements are separated by a forward slash."""
    UNDECIDED: _ListSeparator.ValueType  # 3
    """The list's separator hasn't yet been determined. This is only allowed for
    singleton and empty lists.

    Singleton lists and empty lists don't have separators defined. This means
    that list functions will prefer other lists' separators if possible.
    """

class ListSeparator(_ListSeparator, metaclass=_ListSeparatorEnumTypeWrapper):
    """Different types of separators a list can have."""

COMMA: ListSeparator.ValueType  # 0
"""List elements are separated by a comma."""
SPACE: ListSeparator.ValueType  # 1
"""List elements are separated by whitespace."""
SLASH: ListSeparator.ValueType  # 2
"""List elements are separated by a forward slash."""
UNDECIDED: ListSeparator.ValueType  # 3
"""The list's separator hasn't yet been determined. This is only allowed for
singleton and empty lists.

Singleton lists and empty lists don't have separators defined. This means
that list functions will prefer other lists' separators if possible.
"""
global___ListSeparator = ListSeparator

class _SingletonValue:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _SingletonValueEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_SingletonValue.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    TRUE: _SingletonValue.ValueType  # 0
    """The SassScript boolean true value."""
    FALSE: _SingletonValue.ValueType  # 1
    """The SassScript boolean false value."""
    NULL: _SingletonValue.ValueType  # 2
    """The SassScript null value."""

class SingletonValue(_SingletonValue, metaclass=_SingletonValueEnumTypeWrapper):
    """Singleton SassScript values that have no internal state."""

TRUE: SingletonValue.ValueType  # 0
"""The SassScript boolean true value."""
FALSE: SingletonValue.ValueType  # 1
"""The SassScript boolean false value."""
NULL: SingletonValue.ValueType  # 2
"""The SassScript null value."""
global___SingletonValue = SingletonValue

class _CalculationOperator:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _CalculationOperatorEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_CalculationOperator.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    PLUS: _CalculationOperator.ValueType  # 0
    """The addition operator."""
    MINUS: _CalculationOperator.ValueType  # 1
    """The subtraction operator."""
    TIMES: _CalculationOperator.ValueType  # 2
    """The multiplication operator."""
    DIVIDE: _CalculationOperator.ValueType  # 3
    """The division operator."""

class CalculationOperator(_CalculationOperator, metaclass=_CalculationOperatorEnumTypeWrapper):
    """An operator used in a calculation value's operation."""

PLUS: CalculationOperator.ValueType  # 0
"""The addition operator."""
MINUS: CalculationOperator.ValueType  # 1
"""The subtraction operator."""
TIMES: CalculationOperator.ValueType  # 2
"""The multiplication operator."""
DIVIDE: CalculationOperator.ValueType  # 3
"""The division operator."""
global___CalculationOperator = CalculationOperator

@typing.final
class InboundMessage(google.protobuf.message.Message):
    """The wrapper type for all messages sent from the host to the compiler. This
    provides a `oneof` that makes it possible to determine the type of each
    inbound message.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class VersionRequest(google.protobuf.message.Message):
        """A request for information about the version of the embedded compiler. The
        host can use this to provide diagnostic information to the user, to check
        which features the compiler supports, or to ensure that it's compatible
        with the same protocol version the compiler supports.
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        ID_FIELD_NUMBER: builtins.int
        id: builtins.int
        """This version request's id."""
        def __init__(
            self,
            *,
            id: builtins.int = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing.Literal["id", b"id"]) -> None: ...

    @typing.final
    class CompileRequest(google.protobuf.message.Message):
        """A request that compiles an entrypoint to CSS."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        @typing.final
        class StringInput(google.protobuf.message.Message):
            """An input stylesheet provided as plain text, rather than loaded from the
            filesystem.
            """

            DESCRIPTOR: google.protobuf.descriptor.Descriptor

            SOURCE_FIELD_NUMBER: builtins.int
            URL_FIELD_NUMBER: builtins.int
            SYNTAX_FIELD_NUMBER: builtins.int
            IMPORTER_FIELD_NUMBER: builtins.int
            source: builtins.str
            """The contents of the stylesheet."""
            url: builtins.str
            """The location from which `source` was loaded. If this is empty, it
            indicates that the URL is unknown.

            This must be a canonical URL recognized by `importer`, if it's passed.
            """
            syntax: global___Syntax.ValueType
            """The syntax to use to parse `source`."""
            @property
            def importer(self) -> global___InboundMessage.CompileRequest.Importer:
                """The importer to use to resolve imports relative to `url`."""

            def __init__(
                self,
                *,
                source: builtins.str = ...,
                url: builtins.str = ...,
                syntax: global___Syntax.ValueType = ...,
                importer: global___InboundMessage.CompileRequest.Importer | None = ...,
            ) -> None: ...
            def HasField(self, field_name: typing.Literal["importer", b"importer"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing.Literal["importer", b"importer", "source", b"source", "syntax", b"syntax", "url", b"url"]) -> None: ...

        @typing.final
        class Importer(google.protobuf.message.Message):
            """A wrapper message that represents either a user-defined importer or a
            load path on disk. This must be a wrapper because `oneof` types can't be
            `repeated`.
            """

            DESCRIPTOR: google.protobuf.descriptor.Descriptor

            PATH_FIELD_NUMBER: builtins.int
            IMPORTER_ID_FIELD_NUMBER: builtins.int
            FILE_IMPORTER_ID_FIELD_NUMBER: builtins.int
            NODE_PACKAGE_IMPORTER_FIELD_NUMBER: builtins.int
            NON_CANONICAL_SCHEME_FIELD_NUMBER: builtins.int
            path: builtins.str
            """A built-in importer that loads Sass files within the given directory
            on disk.
            """
            importer_id: builtins.int
            """A unique ID for a user-defined importer. This ID will be included in
            outbound `CanonicalizeRequest` and `ImportRequest` messages to
            indicate which importer is being called. The host is responsible for
            generating this ID and ensuring that it's unique across all
            importers registered for this compilation.
            """
            file_importer_id: builtins.int
            """A unique ID for a special kind of user-defined importer that tells
            the compiler where to look for files on the physical filesystem, but
            leaves the details of resolving partials and extensions and loading
            the file from disk up to the compiler itself.

            This ID will be included in outbound `FileImportRequest` messages to
            indicate which importer is being called. The host is responsible for
            generating this ID and ensuring that it's unique across all importers
            registered for this compilation.
            """
            @property
            def node_package_importer(self) -> global___NodePackageImporter:
                """The [Node.js package importer], which is a built-in Package Importer
                with an associated `entry_point_directory` that resolves `pkg:` URLs
                using the standards and conventions of the Node ecosystem.

                [Node.js package importer]: https://github.com/sass/sass/tree/main/spec/modules.md#node-package-importer
                """

            @property
            def non_canonical_scheme(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
                """The set of URL schemes that are considered *non-canonical* for this
                importer. This must be empty unless `importer.importer_id` is set.

                If any element of this contains a character other than a lowercase
                ASCII letter, an ASCII numeral, U+002B (`+`), U+002D (`-`), or U+002E
                (`.`), the compiler must treat the compilation as failed.
                """

            def __init__(
                self,
                *,
                path: builtins.str = ...,
                importer_id: builtins.int = ...,
                file_importer_id: builtins.int = ...,
                node_package_importer: global___NodePackageImporter | None = ...,
                non_canonical_scheme: collections.abc.Iterable[builtins.str] | None = ...,
            ) -> None: ...
            def HasField(self, field_name: typing.Literal["file_importer_id", b"file_importer_id", "importer", b"importer", "importer_id", b"importer_id", "node_package_importer", b"node_package_importer", "path", b"path"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing.Literal["file_importer_id", b"file_importer_id", "importer", b"importer", "importer_id", b"importer_id", "node_package_importer", b"node_package_importer", "non_canonical_scheme", b"non_canonical_scheme", "path", b"path"]) -> None: ...
            def WhichOneof(self, oneof_group: typing.Literal["importer", b"importer"]) -> typing.Literal["path", "importer_id", "file_importer_id", "node_package_importer"] | None: ...

        STRING_FIELD_NUMBER: builtins.int
        PATH_FIELD_NUMBER: builtins.int
        STYLE_FIELD_NUMBER: builtins.int
        SOURCE_MAP_FIELD_NUMBER: builtins.int
        IMPORTERS_FIELD_NUMBER: builtins.int
        GLOBAL_FUNCTIONS_FIELD_NUMBER: builtins.int
        ALERT_COLOR_FIELD_NUMBER: builtins.int
        ALERT_ASCII_FIELD_NUMBER: builtins.int
        VERBOSE_FIELD_NUMBER: builtins.int
        QUIET_DEPS_FIELD_NUMBER: builtins.int
        SOURCE_MAP_INCLUDE_SOURCES_FIELD_NUMBER: builtins.int
        CHARSET_FIELD_NUMBER: builtins.int
        SILENT_FIELD_NUMBER: builtins.int
        FATAL_DEPRECATION_FIELD_NUMBER: builtins.int
        SILENCE_DEPRECATION_FIELD_NUMBER: builtins.int
        FUTURE_DEPRECATION_FIELD_NUMBER: builtins.int
        path: builtins.str
        """A stylesheet loaded from the given path on the filesystem."""
        style: global___OutputStyle.ValueType
        """How to format the CSS output."""
        source_map: builtins.bool
        """Whether to generate a source map. Note that this will *not* add a source
        map comment to the stylesheet; that's up to the host or its users.
        """
        alert_color: builtins.bool
        """Whether to use terminal colors in the formatted message of errors and
        logs.
        """
        alert_ascii: builtins.bool
        """Whether to encode the formatted message of errors and logs in ASCII."""
        verbose: builtins.bool
        """Whether to report all deprecation warnings or only the first few ones.
        If this is `false`, the compiler may choose not to send events for
        repeated deprecation warnings. If this is `true`, the compiler must emit
        an event for every deprecation warning it encounters.
        """
        quiet_deps: builtins.bool
        """Whether to omit events for deprecation warnings coming from dependencies
        (files loaded from a different importer than the input).
        """
        source_map_include_sources: builtins.bool
        """Whether to include sources in the generated sourcemap"""
        charset: builtins.bool
        """Whether to emit a `@charset`/BOM for non-ASCII stylesheets."""
        silent: builtins.bool
        """Whether to silently suppresses all `LogEvent`s."""
        @property
        def string(self) -> global___InboundMessage.CompileRequest.StringInput:
            """A stylesheet loaded from its contents."""

        @property
        def importers(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___InboundMessage.CompileRequest.Importer]:
            """Importers (including load paths on the filesystem) to use when resolving
            imports that can't be resolved relative to the file that contains it. Each
            importer is checked in order until one recognizes the imported URL.
            """

        @property
        def global_functions(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
            """Signatures for custom global functions whose behavior is defined by the
            host.

            If this is not a valid Sass function signature that could appear after
            `@function` in a Sass stylesheet (such as `mix($color1, $color2, $weight:
            50%)`), or if it conflicts with a function name that's built into the
            Sass language, the compiler must treat the compilation as failed.

            Compilers must ensure that pure-Sass functions take precedence over
            custom global functions.
            """

        @property
        def fatal_deprecation(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
            """Deprecation IDs or versions to treat as fatal."""

        @property
        def silence_deprecation(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
            """Deprecation IDs to ignore."""

        @property
        def future_deprecation(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
            """Deprecation IDs to opt into early."""

        def __init__(
            self,
            *,
            string: global___InboundMessage.CompileRequest.StringInput | None = ...,
            path: builtins.str = ...,
            style: global___OutputStyle.ValueType = ...,
            source_map: builtins.bool = ...,
            importers: collections.abc.Iterable[global___InboundMessage.CompileRequest.Importer] | None = ...,
            global_functions: collections.abc.Iterable[builtins.str] | None = ...,
            alert_color: builtins.bool = ...,
            alert_ascii: builtins.bool = ...,
            verbose: builtins.bool = ...,
            quiet_deps: builtins.bool = ...,
            source_map_include_sources: builtins.bool = ...,
            charset: builtins.bool = ...,
            silent: builtins.bool = ...,
            fatal_deprecation: collections.abc.Iterable[builtins.str] | None = ...,
            silence_deprecation: collections.abc.Iterable[builtins.str] | None = ...,
            future_deprecation: collections.abc.Iterable[builtins.str] | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["input", b"input", "path", b"path", "string", b"string"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["alert_ascii", b"alert_ascii", "alert_color", b"alert_color", "charset", b"charset", "fatal_deprecation", b"fatal_deprecation", "future_deprecation", b"future_deprecation", "global_functions", b"global_functions", "importers", b"importers", "input", b"input", "path", b"path", "quiet_deps", b"quiet_deps", "silence_deprecation", b"silence_deprecation", "silent", b"silent", "source_map", b"source_map", "source_map_include_sources", b"source_map_include_sources", "string", b"string", "style", b"style", "verbose", b"verbose"]) -> None: ...
        def WhichOneof(self, oneof_group: typing.Literal["input", b"input"]) -> typing.Literal["string", "path"] | None: ...

    @typing.final
    class CanonicalizeResponse(google.protobuf.message.Message):
        """A response indicating the result of canonicalizing an imported URL."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        ID_FIELD_NUMBER: builtins.int
        URL_FIELD_NUMBER: builtins.int
        ERROR_FIELD_NUMBER: builtins.int
        CONTAINING_URL_UNUSED_FIELD_NUMBER: builtins.int
        id: builtins.int
        url: builtins.str
        """The successfully canonicalized URL.

        If this is not an absolute URL (including scheme), the compiler must
        treat that as an error thrown by the importer. If this URL's scheme is
        an `Importer.non_canonical_scheme` for the importer being invoked, the
        compiler must treat that as an error thrown by the importer.
        """
        error: builtins.str
        """An error message explaining why canonicalization failed.

        This indicates that a stylesheet was found, but a canonical URL for it
        could not be determined. If no stylesheet was found, `result` should be
        `null` instead.
        """
        containing_url_unused: builtins.bool
        """Whether `containing_url` in `CanonicalizeRequest` is unused.

        The compiler can cache the `CanonicalizeResponse` if the `containing_url`
        is unused.

        The default value is `false`, thus when the value is not set by the host,
        the `CanonicalizeResponse` will not be cached by the compiler.
        """
        def __init__(
            self,
            *,
            id: builtins.int = ...,
            url: builtins.str = ...,
            error: builtins.str = ...,
            containing_url_unused: builtins.bool = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["error", b"error", "result", b"result", "url", b"url"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["containing_url_unused", b"containing_url_unused", "error", b"error", "id", b"id", "result", b"result", "url", b"url"]) -> None: ...
        def WhichOneof(self, oneof_group: typing.Literal["result", b"result"]) -> typing.Literal["url", "error"] | None: ...

    @typing.final
    class ImportResponse(google.protobuf.message.Message):
        """A response indicating the result of importing a canonical URL."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        @typing.final
        class ImportSuccess(google.protobuf.message.Message):
            """The stylesheet's contents were loaded successfully."""

            DESCRIPTOR: google.protobuf.descriptor.Descriptor

            CONTENTS_FIELD_NUMBER: builtins.int
            SYNTAX_FIELD_NUMBER: builtins.int
            SOURCE_MAP_URL_FIELD_NUMBER: builtins.int
            contents: builtins.str
            """The text of the stylesheet."""
            syntax: global___Syntax.ValueType
            """The syntax of `contents`."""
            source_map_url: builtins.str
            """An absolute, browser-accessible URL indicating the resolved location of
            the imported stylesheet.

            This should be a `file:` URL if one is available, but an `http:` URL is
            acceptable as well. If no URL is supplied, a `data:` URL is generated
            automatically from `contents`.

            If this is provided and is not an absolute URL (including scheme) the
            compiler must treat that as an error thrown by the importer.
            """
            def __init__(
                self,
                *,
                contents: builtins.str = ...,
                syntax: global___Syntax.ValueType = ...,
                source_map_url: builtins.str | None = ...,
            ) -> None: ...
            def HasField(self, field_name: typing.Literal["_source_map_url", b"_source_map_url", "source_map_url", b"source_map_url"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing.Literal["_source_map_url", b"_source_map_url", "contents", b"contents", "source_map_url", b"source_map_url", "syntax", b"syntax"]) -> None: ...
            def WhichOneof(self, oneof_group: typing.Literal["_source_map_url", b"_source_map_url"]) -> typing.Literal["source_map_url"] | None: ...

        ID_FIELD_NUMBER: builtins.int
        SUCCESS_FIELD_NUMBER: builtins.int
        ERROR_FIELD_NUMBER: builtins.int
        id: builtins.int
        error: builtins.str
        """An error message explaining why the URL could not be loaded."""
        @property
        def success(self) -> global___InboundMessage.ImportResponse.ImportSuccess:
            """The contents of the loaded stylesheet."""

        def __init__(
            self,
            *,
            id: builtins.int = ...,
            success: global___InboundMessage.ImportResponse.ImportSuccess | None = ...,
            error: builtins.str = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["error", b"error", "result", b"result", "success", b"success"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["error", b"error", "id", b"id", "result", b"result", "success", b"success"]) -> None: ...
        def WhichOneof(self, oneof_group: typing.Literal["result", b"result"]) -> typing.Literal["success", "error"] | None: ...

    @typing.final
    class FileImportResponse(google.protobuf.message.Message):
        """A response indicating the result of redirecting a URL to the filesystem."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        ID_FIELD_NUMBER: builtins.int
        FILE_URL_FIELD_NUMBER: builtins.int
        ERROR_FIELD_NUMBER: builtins.int
        CONTAINING_URL_UNUSED_FIELD_NUMBER: builtins.int
        id: builtins.int
        file_url: builtins.str
        """The absolute `file:` URL to look for the file on the physical
        filesystem.

        The compiler must verify to the best of its ability that this URL
        follows the format for an absolute `file:` URL on the current operating
        system without a hostname. If it doesn't, the compiler must treat that
        as an error thrown by the importer. See
        https://en.wikipedia.org/wiki/File_URI_scheme for details on the
        format.

        The compiler must handle turning this into a canonical URL by resolving
        it for partials, file extensions, and index files. The compiler must
        then loading the contents of the resulting canonical URL from the
        filesystem.
        """
        error: builtins.str
        """An error message explaining why the URL could not be loaded."""
        containing_url_unused: builtins.bool
        """Whether `containing_url` in `FileImportRequest` is unused.

        The compiler can cache the `FileImportResponse` if the `containing_url`
        is unused.

        The default value is `false`, thus when the value is not set by the host,
        the `FileImportResponse` will not be cached by the compiler.
        """
        def __init__(
            self,
            *,
            id: builtins.int = ...,
            file_url: builtins.str = ...,
            error: builtins.str = ...,
            containing_url_unused: builtins.bool = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["error", b"error", "file_url", b"file_url", "result", b"result"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["containing_url_unused", b"containing_url_unused", "error", b"error", "file_url", b"file_url", "id", b"id", "result", b"result"]) -> None: ...
        def WhichOneof(self, oneof_group: typing.Literal["result", b"result"]) -> typing.Literal["file_url", "error"] | None: ...

    @typing.final
    class FunctionCallResponse(google.protobuf.message.Message):
        """A response indicating the result of calling a custom Sass function defined
        in the host.
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        ID_FIELD_NUMBER: builtins.int
        SUCCESS_FIELD_NUMBER: builtins.int
        ERROR_FIELD_NUMBER: builtins.int
        ACCESSED_ARGUMENT_LISTS_FIELD_NUMBER: builtins.int
        id: builtins.int
        error: builtins.str
        """An error message explaining why the function call failed."""
        @property
        def success(self) -> global___Value:
            """The return value of a successful function call."""

        @property
        def accessed_argument_lists(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
            """The IDs of all `Value.ArgumentList`s in `FunctionCallRequest.arguments`
            whose keywords were accessed. See `Value.ArgumentList` for details. This
            may not include the special value `0` and it may not include multiple
            instances of the same ID.
            """

        def __init__(
            self,
            *,
            id: builtins.int = ...,
            success: global___Value | None = ...,
            error: builtins.str = ...,
            accessed_argument_lists: collections.abc.Iterable[builtins.int] | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["error", b"error", "result", b"result", "success", b"success"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["accessed_argument_lists", b"accessed_argument_lists", "error", b"error", "id", b"id", "result", b"result", "success", b"success"]) -> None: ...
        def WhichOneof(self, oneof_group: typing.Literal["result", b"result"]) -> typing.Literal["success", "error"] | None: ...

    COMPILE_REQUEST_FIELD_NUMBER: builtins.int
    CANONICALIZE_RESPONSE_FIELD_NUMBER: builtins.int
    IMPORT_RESPONSE_FIELD_NUMBER: builtins.int
    FILE_IMPORT_RESPONSE_FIELD_NUMBER: builtins.int
    FUNCTION_CALL_RESPONSE_FIELD_NUMBER: builtins.int
    VERSION_REQUEST_FIELD_NUMBER: builtins.int
    @property
    def compile_request(self) -> global___InboundMessage.CompileRequest: ...
    @property
    def canonicalize_response(self) -> global___InboundMessage.CanonicalizeResponse: ...
    @property
    def import_response(self) -> global___InboundMessage.ImportResponse: ...
    @property
    def file_import_response(self) -> global___InboundMessage.FileImportResponse: ...
    @property
    def function_call_response(self) -> global___InboundMessage.FunctionCallResponse: ...
    @property
    def version_request(self) -> global___InboundMessage.VersionRequest: ...
    def __init__(
        self,
        *,
        compile_request: global___InboundMessage.CompileRequest | None = ...,
        canonicalize_response: global___InboundMessage.CanonicalizeResponse | None = ...,
        import_response: global___InboundMessage.ImportResponse | None = ...,
        file_import_response: global___InboundMessage.FileImportResponse | None = ...,
        function_call_response: global___InboundMessage.FunctionCallResponse | None = ...,
        version_request: global___InboundMessage.VersionRequest | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["canonicalize_response", b"canonicalize_response", "compile_request", b"compile_request", "file_import_response", b"file_import_response", "function_call_response", b"function_call_response", "import_response", b"import_response", "message", b"message", "version_request", b"version_request"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["canonicalize_response", b"canonicalize_response", "compile_request", b"compile_request", "file_import_response", b"file_import_response", "function_call_response", b"function_call_response", "import_response", b"import_response", "message", b"message", "version_request", b"version_request"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["message", b"message"]) -> typing.Literal["compile_request", "canonicalize_response", "import_response", "file_import_response", "function_call_response", "version_request"] | None: ...

global___InboundMessage = InboundMessage

@typing.final
class OutboundMessage(google.protobuf.message.Message):
    """The wrapper type for all messages sent from the compiler to the host. This
    provides a `oneof` that makes it possible to determine the type of each
    outbound message.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class VersionResponse(google.protobuf.message.Message):
        """A response that contains the version of the embedded compiler."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        ID_FIELD_NUMBER: builtins.int
        PROTOCOL_VERSION_FIELD_NUMBER: builtins.int
        COMPILER_VERSION_FIELD_NUMBER: builtins.int
        IMPLEMENTATION_VERSION_FIELD_NUMBER: builtins.int
        IMPLEMENTATION_NAME_FIELD_NUMBER: builtins.int
        id: builtins.int
        """This version request's id."""
        protocol_version: builtins.str
        """The version of the embedded protocol, in semver format."""
        compiler_version: builtins.str
        """The version of the embedded compiler package. This has no guaranteed
        format, although compilers are encouraged to use semver.
        """
        implementation_version: builtins.str
        """The version of the Sass implementation that the embedded compiler wraps.
        This has no guaranteed format, although Sass implementations are
        encouraged to use semver.
        """
        implementation_name: builtins.str
        """The name of the Sass implementation that the embedded compiler wraps."""
        def __init__(
            self,
            *,
            id: builtins.int = ...,
            protocol_version: builtins.str = ...,
            compiler_version: builtins.str = ...,
            implementation_version: builtins.str = ...,
            implementation_name: builtins.str = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing.Literal["compiler_version", b"compiler_version", "id", b"id", "implementation_name", b"implementation_name", "implementation_version", b"implementation_version", "protocol_version", b"protocol_version"]) -> None: ...

    @typing.final
    class CompileResponse(google.protobuf.message.Message):
        """A response that contains the result of a compilation."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        @typing.final
        class CompileSuccess(google.protobuf.message.Message):
            """A message indicating that the Sass file was successfully compiled to CSS."""

            DESCRIPTOR: google.protobuf.descriptor.Descriptor

            CSS_FIELD_NUMBER: builtins.int
            SOURCE_MAP_FIELD_NUMBER: builtins.int
            css: builtins.str
            """The compiled CSS."""
            source_map: builtins.str
            """The JSON-encoded source map, or the empty string if
            `CompileRequest.source_map` was `false`.

            The compiler must not add a `"file"` key to this source map. It's the
            host's (or the host's user's) responsibility to determine how the
            generated CSS can be reached from the source map.
            """
            def __init__(
                self,
                *,
                css: builtins.str = ...,
                source_map: builtins.str = ...,
            ) -> None: ...
            def ClearField(self, field_name: typing.Literal["css", b"css", "source_map", b"source_map"]) -> None: ...

        @typing.final
        class CompileFailure(google.protobuf.message.Message):
            """A message indicating that the Sass file could not be successfully
            compiled to CSS.
            """

            DESCRIPTOR: google.protobuf.descriptor.Descriptor

            MESSAGE_FIELD_NUMBER: builtins.int
            SPAN_FIELD_NUMBER: builtins.int
            STACK_TRACE_FIELD_NUMBER: builtins.int
            FORMATTED_FIELD_NUMBER: builtins.int
            message: builtins.str
            """A message describing the reason for the failure."""
            stack_trace: builtins.str
            """The stack trace associated with the failure.

            The empty string indicates that no stack trace is available. Otherwise,
            the format of this stack trace is not specified and is likely to be
            inconsistent between implementations.
            """
            formatted: builtins.str
            """A formatted, human-readable string that contains the message, span
            (if available), and trace (if available). The format of this string is
            not specified and is likely to be inconsistent between implementations.
            """
            @property
            def span(self) -> global___SourceSpan:
                """The span associated with the failure."""

            def __init__(
                self,
                *,
                message: builtins.str = ...,
                span: global___SourceSpan | None = ...,
                stack_trace: builtins.str = ...,
                formatted: builtins.str = ...,
            ) -> None: ...
            def HasField(self, field_name: typing.Literal["span", b"span"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing.Literal["formatted", b"formatted", "message", b"message", "span", b"span", "stack_trace", b"stack_trace"]) -> None: ...

        SUCCESS_FIELD_NUMBER: builtins.int
        FAILURE_FIELD_NUMBER: builtins.int
        LOADED_URLS_FIELD_NUMBER: builtins.int
        @property
        def success(self) -> global___OutboundMessage.CompileResponse.CompileSuccess:
            """The result of a successful compilation."""

        @property
        def failure(self) -> global___OutboundMessage.CompileResponse.CompileFailure:
            """The result of a failed compilation."""

        @property
        def loaded_urls(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
            """The canonical URLs of all source files loaded during the compilation.

            The compiler must ensure that each canonical URL appears only once in
            this list. This must include the entrypoint file's URL if either
            `CompileRequest.input.path` or `CompileRequest.StringInput.url` was
            passed.
            """

        def __init__(
            self,
            *,
            success: global___OutboundMessage.CompileResponse.CompileSuccess | None = ...,
            failure: global___OutboundMessage.CompileResponse.CompileFailure | None = ...,
            loaded_urls: collections.abc.Iterable[builtins.str] | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["failure", b"failure", "result", b"result", "success", b"success"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["failure", b"failure", "loaded_urls", b"loaded_urls", "result", b"result", "success", b"success"]) -> None: ...
        def WhichOneof(self, oneof_group: typing.Literal["result", b"result"]) -> typing.Literal["success", "failure"] | None: ...

    @typing.final
    class LogEvent(google.protobuf.message.Message):
        """An event indicating that a message should be displayed to the user."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        TYPE_FIELD_NUMBER: builtins.int
        MESSAGE_FIELD_NUMBER: builtins.int
        SPAN_FIELD_NUMBER: builtins.int
        STACK_TRACE_FIELD_NUMBER: builtins.int
        FORMATTED_FIELD_NUMBER: builtins.int
        DEPRECATION_TYPE_FIELD_NUMBER: builtins.int
        type: global___LogEventType.ValueType
        message: builtins.str
        """The text of the message."""
        stack_trace: builtins.str
        """The stack trace associated with this message.

        The empty string indicates that no stack trace is available. Otherwise,
        the format of this stack trace is not specified and is likely to be
        inconsistent between implementations.
        """
        formatted: builtins.str
        """A formatted, human-readable string that contains the message, span (if
        available), and trace (if available). The format of this string is not
        specified and is likely to be inconsistent between implementations.
        """
        deprecation_type: builtins.str
        """The deprecation ID for this warning, if type is DEPRECATION_WARNING."""
        @property
        def span(self) -> global___SourceSpan:
            """The span associated with this message."""

        def __init__(
            self,
            *,
            type: global___LogEventType.ValueType = ...,
            message: builtins.str = ...,
            span: global___SourceSpan | None = ...,
            stack_trace: builtins.str = ...,
            formatted: builtins.str = ...,
            deprecation_type: builtins.str | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["_deprecation_type", b"_deprecation_type", "_span", b"_span", "deprecation_type", b"deprecation_type", "span", b"span"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["_deprecation_type", b"_deprecation_type", "_span", b"_span", "deprecation_type", b"deprecation_type", "formatted", b"formatted", "message", b"message", "span", b"span", "stack_trace", b"stack_trace", "type", b"type"]) -> None: ...
        @typing.overload
        def WhichOneof(self, oneof_group: typing.Literal["_deprecation_type", b"_deprecation_type"]) -> typing.Literal["deprecation_type"] | None: ...
        @typing.overload
        def WhichOneof(self, oneof_group: typing.Literal["_span", b"_span"]) -> typing.Literal["span"] | None: ...

    @typing.final
    class CanonicalizeRequest(google.protobuf.message.Message):
        """A request for a custom importer to convert an imported URL to its canonical
        format.

        If the URL is not recognized by this importer, or if no stylesheet is found
        at that URL, `CanonicalizeResponse.result` must be `null`. Otherwise, the
        importer must return an absolute URL, including a scheme.

        > The host's documentation should encourage the use of file importers (via
        > `CompileRequest.Importer.file_importer_id`, `FileImportRequest`, and
        > `FileImportResponse`) for any importers that simply refer to files on
        > disk. This will allow Sass to handle the logic of resolving partials,
        > file extensions, and index files.

        If Sass has already loaded a stylesheet with the returned canonical URL, it
        re-uses the existing parse tree. This means that importers must ensure that
        the same canonical URL always refers to the same stylesheet, *even across
        different importers*. Importers must also ensure that any canonicalized
        URLs they return can be passed back to `CanonicalizeRequest` and will be
        returned unchanged.

        If this importer's URL format supports file extensions, it should
        canonicalize them the same way as the default filesystem importer:

        * The importer should look for stylesheets by adding the prefix `_` to the
          URL's basename, and by adding the extensions `.sass` and `.scss` if the
          URL doesn't already have one of those extensions. For example, if the URL
          was `foo/bar/baz`, the importer would look for:

          * `foo/bar/baz.sass`
          * `foo/bar/baz.scss`
          * `foo/bar/_baz.sass`
          * `foo/bar/_baz.scss`

          If the URL was foo/bar/baz.scss, the importer would just look for:

          * `foo/bar/baz.scss`
          * `foo/bar/_baz.scss`

          If the importer finds a stylesheet at more than one of these URLs, it
          should respond with a `CanonicalizeResponse.result.error` indicating that
          the import is ambiguous. Note that if the extension is explicitly
          specified, a stylesheet with another extension may exist without error.

        * If none of the possible paths is valid, the importer should perform the
          same resolution on the URL followed by `/index`. In the example above, it
          would look for:

          * `foo/bar/baz/_index.sass`
          * `foo/bar/baz/index.sass`
          * `foo/bar/baz/_index.scss`
          * `foo/bar/baz/index.scss`

          As above, if the importer finds a stylesheet at more than one of these
          URLs, it should respond with a `CanonicalizeResponse.result.error`
          indicating that the import is ambiguous.
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        ID_FIELD_NUMBER: builtins.int
        IMPORTER_ID_FIELD_NUMBER: builtins.int
        URL_FIELD_NUMBER: builtins.int
        FROM_IMPORT_FIELD_NUMBER: builtins.int
        CONTAINING_URL_FIELD_NUMBER: builtins.int
        id: builtins.int
        importer_id: builtins.int
        """The unique ID of the importer being invoked. This must match an importer
        ID passed to this compilation in `CompileRequest.importers` or
        `CompileRequest.input.string.importer`.
        """
        url: builtins.str
        """The URL of the import to be canonicalized. This may be either absolute or
        relative.

        When loading a URL, the compiler must first try resolving that URL
        relative to the canonical URL of the current file, and canonicalizing the
        result using the importer that loaded the current file. If this returns
        `null`, the compiler must then try canonicalizing the original URL with
        each importer in order until one returns something other than `null`.
        That is the result of the import.
        """
        from_import: builtins.bool
        """Whether this request comes from an `@import` rule.

        When evaluating `@import` rules, URLs should canonicalize to an
        [import-only file] if one exists for the URL being canonicalized.
        Otherwise, canonicalization should be identical for `@import` and `@use`
        rules.

        [import-only file]: https://sass-lang.com/documentation/at-rules/import#import-only-files
        """
        containing_url: builtins.str
        """The canonical URL of the [current source file] that contained the load
        to be canonicalized.

        [current source file]: ../spec.md#current-source-file

        The compiler must set this if and only if `url` is relative or its
        scheme is an `Importer.non_canonical_scheme` for the importer being
        invoked, unless the current source file has no canonical URL.

        [non-canonical-proto]: #non_canonical_scheme
        """
        def __init__(
            self,
            *,
            id: builtins.int = ...,
            importer_id: builtins.int = ...,
            url: builtins.str = ...,
            from_import: builtins.bool = ...,
            containing_url: builtins.str | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["_containing_url", b"_containing_url", "containing_url", b"containing_url"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["_containing_url", b"_containing_url", "containing_url", b"containing_url", "from_import", b"from_import", "id", b"id", "importer_id", b"importer_id", "url", b"url"]) -> None: ...
        def WhichOneof(self, oneof_group: typing.Literal["_containing_url", b"_containing_url"]) -> typing.Literal["containing_url"] | None: ...

    @typing.final
    class ImportRequest(google.protobuf.message.Message):
        """A request for a custom importer to load the contents of a stylesheet."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        ID_FIELD_NUMBER: builtins.int
        IMPORTER_ID_FIELD_NUMBER: builtins.int
        URL_FIELD_NUMBER: builtins.int
        id: builtins.int
        importer_id: builtins.int
        """The unique ID of the importer being invoked. This must match an
        `Importer.importer_id` passed to this compilation in
        `CompileRequest.importers` or `CompileRequest.input.string.importer`.
        """
        url: builtins.str
        """The canonical URL of the import. This is guaranteed to be a URL returned
        by a `CanonicalizeRequest` to this importer.
        """
        def __init__(
            self,
            *,
            id: builtins.int = ...,
            importer_id: builtins.int = ...,
            url: builtins.str = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing.Literal["id", b"id", "importer_id", b"importer_id", "url", b"url"]) -> None: ...

    @typing.final
    class FileImportRequest(google.protobuf.message.Message):
        """A request for a custom filesystem importer to load the contents of a
        stylesheet.

        A filesystem importer is represented in the compiler as an [importer]. When
        the importer is invoked with a string `string`:

        [importer]: https://github.com/sass/sass/tree/main/spec/modules.md#importer

        * If `string` is an absolute URL whose scheme is `file`:

          * Let `url` be string.

        * Otherwise:

          * Let `fromImport` be `true` if the importer is being run for an
            `@import` and `false` otherwise.

          * Let `containingUrl` be the canonical URL of the [current source file]
            if it has one, or undefined otherwise.


          * Let `response` be the result of sending a `FileImportRequest` with
            `string` as its `url`, `fromImport` as `from_import`, and
            `containingUrl` as `containing_url`.

          * If `response.result` is null, return null.

          * Otherwise, if `response.result.error` is set, throw an error.

          * Otherwise, let `url` be `response.result.file_url`.

        * Let `resolved` be the result of [resolving `url`].

        * If `resolved` is null, return null.

        * Let `text` be the contents of the file at `resolved`.

        * Let `syntax` be:
          * "scss" if `url` ends in `.scss`.
          * "indented" if `url` ends in `.sass`.
          * "css" if `url` ends in `.css`.

          > The algorithm for resolving a `file:` URL guarantees that `url` will have
          > one of these extensions.

        * Return `text`, `syntax`, and `resolved`.

        [current source file]: ../spec.md#current-source-file
        [resolving `url`]: https://github.com/sass/sass/tree/main/spec/modules.md#resolving-a-file-url
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        ID_FIELD_NUMBER: builtins.int
        IMPORTER_ID_FIELD_NUMBER: builtins.int
        URL_FIELD_NUMBER: builtins.int
        FROM_IMPORT_FIELD_NUMBER: builtins.int
        CONTAINING_URL_FIELD_NUMBER: builtins.int
        id: builtins.int
        importer_id: builtins.int
        """The unique ID of the importer being invoked. This must match an
        `Importer.file_importer_id` passed to this compilation in
        `CompileRequest.importers` or `CompileRequest.input.string.importer`.
        """
        url: builtins.str
        """The (non-canonicalized) URL of the import."""
        from_import: builtins.bool
        """Whether this request comes from an `@import` rule.

        When evaluating `@import` rules, filesystem importers should load an
        [import-only file] if one exists for the URL being canonicalized.
        Otherwise, canonicalization should be identical for `@import` and `@use`
        rules.

        [import-only file]: https://sass-lang.com/documentation/at-rules/import#import-only-files
        """
        containing_url: builtins.str
        """The canonical URL of the [current source file] that contained the load
        being resolved. The compiler must set this unless the current source file
        has no canonical URL.
        """
        def __init__(
            self,
            *,
            id: builtins.int = ...,
            importer_id: builtins.int = ...,
            url: builtins.str = ...,
            from_import: builtins.bool = ...,
            containing_url: builtins.str | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["_containing_url", b"_containing_url", "containing_url", b"containing_url"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["_containing_url", b"_containing_url", "containing_url", b"containing_url", "from_import", b"from_import", "id", b"id", "importer_id", b"importer_id", "url", b"url"]) -> None: ...
        def WhichOneof(self, oneof_group: typing.Literal["_containing_url", b"_containing_url"]) -> typing.Literal["containing_url"] | None: ...

    @typing.final
    class FunctionCallRequest(google.protobuf.message.Message):
        """A request to invoke a custom Sass function and return its result."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        ID_FIELD_NUMBER: builtins.int
        NAME_FIELD_NUMBER: builtins.int
        FUNCTION_ID_FIELD_NUMBER: builtins.int
        ARGUMENTS_FIELD_NUMBER: builtins.int
        id: builtins.int
        name: builtins.str
        """The name of the function to invoke.

        This must match the name of a function signature the host passed to the
        corresponding `CompileRequest.global_functions` call, including hyphens
        and underscores.
        """
        function_id: builtins.int
        """The opaque ID of the function to invoke.

        This must match the ID of a `Value.HostFunction` that the host passed
        to the compiler.
        """
        @property
        def arguments(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Value]:
            """The arguments passed to the function, in the order they appear in the
            function signature passed to `CompileRequest.global_functions`.

            The compiler must ensure that a valid number of arguments are passed for
            the given signature, that default argument values are instantiated
            appropriately, and that variable argument lists (`$args...`) are passed
            as `Value.ArgumentList`s.
            """

        def __init__(
            self,
            *,
            id: builtins.int = ...,
            name: builtins.str = ...,
            function_id: builtins.int = ...,
            arguments: collections.abc.Iterable[global___Value] | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["function_id", b"function_id", "identifier", b"identifier", "name", b"name"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["arguments", b"arguments", "function_id", b"function_id", "id", b"id", "identifier", b"identifier", "name", b"name"]) -> None: ...
        def WhichOneof(self, oneof_group: typing.Literal["identifier", b"identifier"]) -> typing.Literal["name", "function_id"] | None: ...

    ERROR_FIELD_NUMBER: builtins.int
    COMPILE_RESPONSE_FIELD_NUMBER: builtins.int
    LOG_EVENT_FIELD_NUMBER: builtins.int
    CANONICALIZE_REQUEST_FIELD_NUMBER: builtins.int
    IMPORT_REQUEST_FIELD_NUMBER: builtins.int
    FILE_IMPORT_REQUEST_FIELD_NUMBER: builtins.int
    FUNCTION_CALL_REQUEST_FIELD_NUMBER: builtins.int
    VERSION_RESPONSE_FIELD_NUMBER: builtins.int
    @property
    def error(self) -> global___ProtocolError: ...
    @property
    def compile_response(self) -> global___OutboundMessage.CompileResponse: ...
    @property
    def log_event(self) -> global___OutboundMessage.LogEvent: ...
    @property
    def canonicalize_request(self) -> global___OutboundMessage.CanonicalizeRequest: ...
    @property
    def import_request(self) -> global___OutboundMessage.ImportRequest: ...
    @property
    def file_import_request(self) -> global___OutboundMessage.FileImportRequest: ...
    @property
    def function_call_request(self) -> global___OutboundMessage.FunctionCallRequest: ...
    @property
    def version_response(self) -> global___OutboundMessage.VersionResponse: ...
    def __init__(
        self,
        *,
        error: global___ProtocolError | None = ...,
        compile_response: global___OutboundMessage.CompileResponse | None = ...,
        log_event: global___OutboundMessage.LogEvent | None = ...,
        canonicalize_request: global___OutboundMessage.CanonicalizeRequest | None = ...,
        import_request: global___OutboundMessage.ImportRequest | None = ...,
        file_import_request: global___OutboundMessage.FileImportRequest | None = ...,
        function_call_request: global___OutboundMessage.FunctionCallRequest | None = ...,
        version_response: global___OutboundMessage.VersionResponse | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["canonicalize_request", b"canonicalize_request", "compile_response", b"compile_response", "error", b"error", "file_import_request", b"file_import_request", "function_call_request", b"function_call_request", "import_request", b"import_request", "log_event", b"log_event", "message", b"message", "version_response", b"version_response"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["canonicalize_request", b"canonicalize_request", "compile_response", b"compile_response", "error", b"error", "file_import_request", b"file_import_request", "function_call_request", b"function_call_request", "import_request", b"import_request", "log_event", b"log_event", "message", b"message", "version_response", b"version_response"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["message", b"message"]) -> typing.Literal["error", "compile_response", "log_event", "canonicalize_request", "import_request", "file_import_request", "function_call_request", "version_response"] | None: ...

global___OutboundMessage = OutboundMessage

@typing.final
class ProtocolError(google.protobuf.message.Message):
    """An error reported when an endpoint violates the embedded Sass protocol."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TYPE_FIELD_NUMBER: builtins.int
    ID_FIELD_NUMBER: builtins.int
    MESSAGE_FIELD_NUMBER: builtins.int
    type: global___ProtocolErrorType.ValueType
    id: builtins.int
    """The ID of the request that had an error. This MUST be `4294967295` if the
    request ID couldn't be determined, or if the error is being reported for a
    response or an event.
    """
    message: builtins.str
    """A human-readable message providing more detail about the error."""
    def __init__(
        self,
        *,
        type: global___ProtocolErrorType.ValueType = ...,
        id: builtins.int = ...,
        message: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["id", b"id", "message", b"message", "type", b"type"]) -> None: ...

global___ProtocolError = ProtocolError

@typing.final
class SourceSpan(google.protobuf.message.Message):
    """A chunk of a source file."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class SourceLocation(google.protobuf.message.Message):
        """A single point in a source file."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        OFFSET_FIELD_NUMBER: builtins.int
        LINE_FIELD_NUMBER: builtins.int
        COLUMN_FIELD_NUMBER: builtins.int
        offset: builtins.int
        """The 0-based offset of this location within the source file."""
        line: builtins.int
        """The 0-based line number of this location within the source file."""
        column: builtins.int
        """The 0-based column number of this location within its line."""
        def __init__(
            self,
            *,
            offset: builtins.int = ...,
            line: builtins.int = ...,
            column: builtins.int = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing.Literal["column", b"column", "line", b"line", "offset", b"offset"]) -> None: ...

    TEXT_FIELD_NUMBER: builtins.int
    START_FIELD_NUMBER: builtins.int
    END_FIELD_NUMBER: builtins.int
    URL_FIELD_NUMBER: builtins.int
    CONTEXT_FIELD_NUMBER: builtins.int
    text: builtins.str
    """The text covered by the source span. Compilers must guarantee that this is
    the text between `start.offset` and `end.offset` in the source file
    referred to by `url`.
    """
    url: builtins.str
    """The URL of the file to which this span refers.

    This may be empty, indicating that the span refers to a
    `CompileRequest.StringInput` file that doesn't specify a URL.
    """
    context: builtins.str
    """Additional source text surrounding this span.

    If this isn't empty, it must contain `text`. Furthermore, `text` must begin
    at column `start.column` of a line in `context`.

    This usually contains the full lines the span begins and ends on if the
    span itself doesn't cover the full lines.
    """
    @property
    def start(self) -> global___SourceSpan.SourceLocation:
        """The location of the first character in this span."""

    @property
    def end(self) -> global___SourceSpan.SourceLocation:
        """The location of the first character after this span.

        If this is omitted, it indicates that the span is empty and points
        immediately before `start`. In that case, `text` must be empty.

        This must not point to a location before `start`.
        """

    def __init__(
        self,
        *,
        text: builtins.str = ...,
        start: global___SourceSpan.SourceLocation | None = ...,
        end: global___SourceSpan.SourceLocation | None = ...,
        url: builtins.str = ...,
        context: builtins.str = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["_end", b"_end", "end", b"end", "start", b"start"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["_end", b"_end", "context", b"context", "end", b"end", "start", b"start", "text", b"text", "url", b"url"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["_end", b"_end"]) -> typing.Literal["end"] | None: ...

global___SourceSpan = SourceSpan

@typing.final
class Value(google.protobuf.message.Message):
    """A SassScript value, passed to and returned by functions."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class String(google.protobuf.message.Message):
        """A SassScript string value."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        TEXT_FIELD_NUMBER: builtins.int
        QUOTED_FIELD_NUMBER: builtins.int
        text: builtins.str
        """The contents of the string."""
        quoted: builtins.bool
        """Whether the string is quoted or unquoted."""
        def __init__(
            self,
            *,
            text: builtins.str = ...,
            quoted: builtins.bool = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing.Literal["quoted", b"quoted", "text", b"text"]) -> None: ...

    @typing.final
    class Number(google.protobuf.message.Message):
        """A SassScript number value."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        VALUE_FIELD_NUMBER: builtins.int
        NUMERATORS_FIELD_NUMBER: builtins.int
        DENOMINATORS_FIELD_NUMBER: builtins.int
        value: builtins.float
        """The number's numeric value."""
        @property
        def numerators(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
            """The number's numerator units.

            The endpoint sending the number must ensure that no numerator units are
            [compatible][] with any denominator units. Such compatible units must be
            simplified away according to the multiplicative factor between them
            defined in the CSS Values and Units spec.

            [compatible]: https://www.w3.org/TR/css-values-4/#compat
            """

        @property
        def denominators(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
            """The number's denominator units."""

        def __init__(
            self,
            *,
            value: builtins.float = ...,
            numerators: collections.abc.Iterable[builtins.str] | None = ...,
            denominators: collections.abc.Iterable[builtins.str] | None = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing.Literal["denominators", b"denominators", "numerators", b"numerators", "value", b"value"]) -> None: ...

    @typing.final
    class Color(google.protobuf.message.Message):
        """A SassScript color value."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        SPACE_FIELD_NUMBER: builtins.int
        CHANNEL1_FIELD_NUMBER: builtins.int
        CHANNEL2_FIELD_NUMBER: builtins.int
        CHANNEL3_FIELD_NUMBER: builtins.int
        ALPHA_FIELD_NUMBER: builtins.int
        space: builtins.str
        """The name of a known color space."""
        channel1: builtins.float
        """The value of the first channel associated with `space`. A [missing]
        channel is represented by an unset value.

        [missing]: types/color.md#missing-components
        """
        channel2: builtins.float
        """The value of the second channel associated with `space`. A [missing]
        channel is represented by an unset value.

        [missing]: types/color.md#missing-components
        """
        channel3: builtins.float
        """The value of the third channel associated with `space`. A [missing]
        channel is represented by an unset value.

        [missing]: types/color.md#missing-components
        """
        alpha: builtins.float
        """The color's alpha channel. Mandatory. Must be between 0 and 1, inclusive.
        A [missing] channel is represented by an unset value.

        [missing]: types/color.md#missing-components
        """
        def __init__(
            self,
            *,
            space: builtins.str = ...,
            channel1: builtins.float | None = ...,
            channel2: builtins.float | None = ...,
            channel3: builtins.float | None = ...,
            alpha: builtins.float | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["_alpha", b"_alpha", "_channel1", b"_channel1", "_channel2", b"_channel2", "_channel3", b"_channel3", "alpha", b"alpha", "channel1", b"channel1", "channel2", b"channel2", "channel3", b"channel3"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["_alpha", b"_alpha", "_channel1", b"_channel1", "_channel2", b"_channel2", "_channel3", b"_channel3", "alpha", b"alpha", "channel1", b"channel1", "channel2", b"channel2", "channel3", b"channel3", "space", b"space"]) -> None: ...
        @typing.overload
        def WhichOneof(self, oneof_group: typing.Literal["_alpha", b"_alpha"]) -> typing.Literal["alpha"] | None: ...
        @typing.overload
        def WhichOneof(self, oneof_group: typing.Literal["_channel1", b"_channel1"]) -> typing.Literal["channel1"] | None: ...
        @typing.overload
        def WhichOneof(self, oneof_group: typing.Literal["_channel2", b"_channel2"]) -> typing.Literal["channel2"] | None: ...
        @typing.overload
        def WhichOneof(self, oneof_group: typing.Literal["_channel3", b"_channel3"]) -> typing.Literal["channel3"] | None: ...

    @typing.final
    class List(google.protobuf.message.Message):
        """A SassScript list value."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        SEPARATOR_FIELD_NUMBER: builtins.int
        HAS_BRACKETS_FIELD_NUMBER: builtins.int
        CONTENTS_FIELD_NUMBER: builtins.int
        separator: global___ListSeparator.ValueType
        """The type of separator for this list. Mandatory."""
        has_brackets: builtins.bool
        """Whether this list has square brackets. Mandatory."""
        @property
        def contents(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Value]:
            """The elements of this list."""

        def __init__(
            self,
            *,
            separator: global___ListSeparator.ValueType = ...,
            has_brackets: builtins.bool = ...,
            contents: collections.abc.Iterable[global___Value] | None = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing.Literal["contents", b"contents", "has_brackets", b"has_brackets", "separator", b"separator"]) -> None: ...

    @typing.final
    class Map(google.protobuf.message.Message):
        """A SassScript map value."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        @typing.final
        class Entry(google.protobuf.message.Message):
            """A single key/value pair in the map."""

            DESCRIPTOR: google.protobuf.descriptor.Descriptor

            KEY_FIELD_NUMBER: builtins.int
            VALUE_FIELD_NUMBER: builtins.int
            @property
            def key(self) -> global___Value:
                """The key this entry is associated with. Mandatory."""

            @property
            def value(self) -> global___Value:
                """The value associated with this key. Mandatory."""

            def __init__(
                self,
                *,
                key: global___Value | None = ...,
                value: global___Value | None = ...,
            ) -> None: ...
            def HasField(self, field_name: typing.Literal["key", b"key", "value", b"value"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing.Literal["key", b"key", "value", b"value"]) -> None: ...

        ENTRIES_FIELD_NUMBER: builtins.int
        @property
        def entries(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Value.Map.Entry]:
            """The entries in this map. The sending endpoint must guarantee that no two
            entries have the same key.
            """

        def __init__(
            self,
            *,
            entries: collections.abc.Iterable[global___Value.Map.Entry] | None = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing.Literal["entries", b"entries"]) -> None: ...

    @typing.final
    class CompilerFunction(google.protobuf.message.Message):
        """A first-class function defined in the compiler. New `CompilerFunction`s may
        only be created by the compiler, but the host may pass `CompilerFunction`s
        back to the compiler as long as their IDs match IDs of functions received
        by the host during that same compilation.
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        ID_FIELD_NUMBER: builtins.int
        id: builtins.int
        """A unique ID for this function. The compiler is responsible for generating
        this ID and ensuring it's unique across all functions passed to the host
        for this compilation. Mandatory.
        """
        def __init__(
            self,
            *,
            id: builtins.int = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing.Literal["id", b"id"]) -> None: ...

    @typing.final
    class HostFunction(google.protobuf.message.Message):
        """An anonymous custom function defined in the host. New `HostFunction`s may
        only be created by the host, and `HostFunction`s may *never* be passed from
        the compiler to the host. The compiler must instead pass a
        `CompilerFunction` that wraps the `HostFunction`.
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        ID_FIELD_NUMBER: builtins.int
        SIGNATURE_FIELD_NUMBER: builtins.int
        id: builtins.int
        """A unique ID for this function. The compiler must pass this ID as
        `OutboundRequest.FunctionCallRequest.id` when invoking this function. The
        host is responsible for generating this ID and ensuring it's unique
        across all functions for *all* compilations. Mandatory.
        """
        signature: builtins.str
        """The signature for this function. Mandatory.

        If this isn't a valid Sass function signature that could appear after
        `@function` in a Sass stylesheet (such as `mix($color1, $color2, $weight:
        50%)`), the compiler must treat it as though the function that returned
        this `HostFunction` threw an error.

        > This ensures that the host doesn't need to be able to correctly parse
        > the entire function declaration syntax.

        The compiler may not invoke the function by its name, since it's not
        guaranteed to be globally unique. However, it may use the name to
        generate the string representation of this function.
        """
        def __init__(
            self,
            *,
            id: builtins.int = ...,
            signature: builtins.str = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing.Literal["id", b"id", "signature", b"signature"]) -> None: ...

    @typing.final
    class CompilerMixin(google.protobuf.message.Message):
        """A first-class mixin defined in the compiler. New `CompilerMixin`s may
        only be created by the compiler, but the host may pass `CompilerMixin`s
        back to the compiler as long as their IDs match IDs of mixins received
        by the host during that same compilation.
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        ID_FIELD_NUMBER: builtins.int
        id: builtins.int
        """A unique ID for this mixin. The compiler is responsible for generating
        this ID and ensuring it's unique across all mixins passed to the host
        for this compilation. Mandatory.
        """
        def __init__(
            self,
            *,
            id: builtins.int = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing.Literal["id", b"id"]) -> None: ...

    @typing.final
    class ArgumentList(google.protobuf.message.Message):
        """A SassScript argument list value. This represents rest arguments passed to
        a function's `$arg...` parameter. Unlike a normal `List`, an argument list
        has an associated keywords map which tracks keyword arguments passed in
        alongside positional arguments.

        For each `ArgumentList` in `FunctionCallRequest.arguments` (including those
        nested within `List`s and `Map`s), the host must track whether its keyword
        arguments were accessed by the user. If they were, it must add its
        `ArgumentList.id` to `FunctionCallResponse.accessed_argument_lists`.

        The compiler must treat every `ArgumentList` whose `ArgumentList.id`
        appears in `FunctionCallResponse.accessed_argument_lists` as though it had
        been passed to `meta.keywords()`.
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        @typing.final
        class KeywordsEntry(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor

            KEY_FIELD_NUMBER: builtins.int
            VALUE_FIELD_NUMBER: builtins.int
            key: builtins.str
            @property
            def value(self) -> global___Value: ...
            def __init__(
                self,
                *,
                key: builtins.str = ...,
                value: global___Value | None = ...,
            ) -> None: ...
            def HasField(self, field_name: typing.Literal["value", b"value"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing.Literal["key", b"key", "value", b"value"]) -> None: ...

        ID_FIELD_NUMBER: builtins.int
        SEPARATOR_FIELD_NUMBER: builtins.int
        CONTENTS_FIELD_NUMBER: builtins.int
        KEYWORDS_FIELD_NUMBER: builtins.int
        id: builtins.int
        """An ID for this argument list that's unique within the scope of a given
        `FunctionCallRequest`.

        The special ID `0` is reserved for `ArgumentList`s created by the host,
        and may not be used by the compiler. These `ArgumentList`s do not need to
        have their IDs added to `FunctionCallResponse.accessed_argument_lists`,
        and the compiler should treat them as though their keywords have always
        been accessed.
        """
        separator: global___ListSeparator.ValueType
        """The type of separator for this list. The compiler must set this, but
        the host may omit it for `ArgumentList`s that were originally created by
        the compiler (that is, those with a non-0 ID).
        """
        @property
        def contents(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Value]:
            """The argument list's positional contents. The compiler must set this, but
            the host may omit it for `ArgumentList`s that were originally created by
            the compiler (that is, those with a non-0 ID).
            """

        @property
        def keywords(self) -> google.protobuf.internal.containers.MessageMap[builtins.str, global___Value]:
            """The argument list's keywords. The compiler must set this, but the host
            may omit it for `ArgumentList`s that were originally created by the
            compiler (that is, those with a non-0 ID).
            """

        def __init__(
            self,
            *,
            id: builtins.int = ...,
            separator: global___ListSeparator.ValueType = ...,
            contents: collections.abc.Iterable[global___Value] | None = ...,
            keywords: collections.abc.Mapping[builtins.str, global___Value] | None = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing.Literal["contents", b"contents", "id", b"id", "keywords", b"keywords", "separator", b"separator"]) -> None: ...

    @typing.final
    class Calculation(google.protobuf.message.Message):
        """A SassScript calculation value. The compiler must send fully [simplified]
        calculations, meaning that simplifying it again will produce the same
        calculation. The host is not required to simplify calculations.

        [simplified]: https://github.com/sass/sass/tree/main/spec/types/calculation.md#simplifying-a-calculation

        The compiler must simplify any calculations it receives from the host
        before returning them from a function. If this simplification produces an
        error, it should be treated as though the function call threw that error.
        It should *not* be treated as a protocol error.
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        @typing.final
        class CalculationValue(google.protobuf.message.Message):
            """A single component of a calculation expression."""

            DESCRIPTOR: google.protobuf.descriptor.Descriptor

            NUMBER_FIELD_NUMBER: builtins.int
            STRING_FIELD_NUMBER: builtins.int
            INTERPOLATION_FIELD_NUMBER: builtins.int
            OPERATION_FIELD_NUMBER: builtins.int
            CALCULATION_FIELD_NUMBER: builtins.int
            string: builtins.str
            """An unquoted string, as from a function like `var()` or `env()`."""
            interpolation: builtins.str
            """An unquoted string as created by interpolation for
            backwards-compatibility with older Sass syntax.

            The compiler must treat this as identical to a `string` option whose
            value is `"(" + interpolation + ")"`.

            This field is deprecated and hosts should avoid using it.
            """
            @property
            def number(self) -> global___Value.Number: ...
            @property
            def operation(self) -> global___Value.Calculation.CalculationOperation: ...
            @property
            def calculation(self) -> global___Value.Calculation: ...
            def __init__(
                self,
                *,
                number: global___Value.Number | None = ...,
                string: builtins.str = ...,
                interpolation: builtins.str = ...,
                operation: global___Value.Calculation.CalculationOperation | None = ...,
                calculation: global___Value.Calculation | None = ...,
            ) -> None: ...
            def HasField(self, field_name: typing.Literal["calculation", b"calculation", "interpolation", b"interpolation", "number", b"number", "operation", b"operation", "string", b"string", "value", b"value"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing.Literal["calculation", b"calculation", "interpolation", b"interpolation", "number", b"number", "operation", b"operation", "string", b"string", "value", b"value"]) -> None: ...
            def WhichOneof(self, oneof_group: typing.Literal["value", b"value"]) -> typing.Literal["number", "string", "interpolation", "operation", "calculation"] | None: ...

        @typing.final
        class CalculationOperation(google.protobuf.message.Message):
            """A binary operation that appears in a calculation."""

            DESCRIPTOR: google.protobuf.descriptor.Descriptor

            OPERATOR_FIELD_NUMBER: builtins.int
            LEFT_FIELD_NUMBER: builtins.int
            RIGHT_FIELD_NUMBER: builtins.int
            operator: global___CalculationOperator.ValueType
            """The operator to perform."""
            @property
            def left(self) -> global___Value.Calculation.CalculationValue:
                """The left-hand side of the operation."""

            @property
            def right(self) -> global___Value.Calculation.CalculationValue:
                """The right-hand side of the operation."""

            def __init__(
                self,
                *,
                operator: global___CalculationOperator.ValueType = ...,
                left: global___Value.Calculation.CalculationValue | None = ...,
                right: global___Value.Calculation.CalculationValue | None = ...,
            ) -> None: ...
            def HasField(self, field_name: typing.Literal["left", b"left", "right", b"right"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing.Literal["left", b"left", "operator", b"operator", "right", b"right"]) -> None: ...

        NAME_FIELD_NUMBER: builtins.int
        ARGUMENTS_FIELD_NUMBER: builtins.int
        name: builtins.str
        """The calculation's name. Mandatory. The host may only set this to names
        that the Sass specification uses to create calculations.
        """
        @property
        def arguments(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Value.Calculation.CalculationValue]:
            """The calculation's arguments. Mandatory. The host must use exactly the
            number of arguments used by the Sass specification for calculations with
            the given `name`.
            """

        def __init__(
            self,
            *,
            name: builtins.str = ...,
            arguments: collections.abc.Iterable[global___Value.Calculation.CalculationValue] | None = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing.Literal["arguments", b"arguments", "name", b"name"]) -> None: ...

    STRING_FIELD_NUMBER: builtins.int
    NUMBER_FIELD_NUMBER: builtins.int
    LIST_FIELD_NUMBER: builtins.int
    MAP_FIELD_NUMBER: builtins.int
    SINGLETON_FIELD_NUMBER: builtins.int
    COMPILER_FUNCTION_FIELD_NUMBER: builtins.int
    HOST_FUNCTION_FIELD_NUMBER: builtins.int
    ARGUMENT_LIST_FIELD_NUMBER: builtins.int
    CALCULATION_FIELD_NUMBER: builtins.int
    COMPILER_MIXIN_FIELD_NUMBER: builtins.int
    COLOR_FIELD_NUMBER: builtins.int
    singleton: global___SingletonValue.ValueType
    @property
    def string(self) -> global___Value.String: ...
    @property
    def number(self) -> global___Value.Number: ...
    @property
    def list(self) -> global___Value.List: ...
    @property
    def map(self) -> global___Value.Map: ...
    @property
    def compiler_function(self) -> global___Value.CompilerFunction: ...
    @property
    def host_function(self) -> global___Value.HostFunction: ...
    @property
    def argument_list(self) -> global___Value.ArgumentList: ...
    @property
    def calculation(self) -> global___Value.Calculation: ...
    @property
    def compiler_mixin(self) -> global___Value.CompilerMixin: ...
    @property
    def color(self) -> global___Value.Color: ...
    def __init__(
        self,
        *,
        string: global___Value.String | None = ...,
        number: global___Value.Number | None = ...,
        list: global___Value.List | None = ...,
        map: global___Value.Map | None = ...,
        singleton: global___SingletonValue.ValueType = ...,
        compiler_function: global___Value.CompilerFunction | None = ...,
        host_function: global___Value.HostFunction | None = ...,
        argument_list: global___Value.ArgumentList | None = ...,
        calculation: global___Value.Calculation | None = ...,
        compiler_mixin: global___Value.CompilerMixin | None = ...,
        color: global___Value.Color | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["argument_list", b"argument_list", "calculation", b"calculation", "color", b"color", "compiler_function", b"compiler_function", "compiler_mixin", b"compiler_mixin", "host_function", b"host_function", "list", b"list", "map", b"map", "number", b"number", "singleton", b"singleton", "string", b"string", "value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["argument_list", b"argument_list", "calculation", b"calculation", "color", b"color", "compiler_function", b"compiler_function", "compiler_mixin", b"compiler_mixin", "host_function", b"host_function", "list", b"list", "map", b"map", "number", b"number", "singleton", b"singleton", "string", b"string", "value", b"value"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["value", b"value"]) -> typing.Literal["string", "number", "list", "map", "singleton", "compiler_function", "host_function", "argument_list", "calculation", "compiler_mixin", "color"] | None: ...

global___Value = Value

@typing.final
class NodePackageImporter(google.protobuf.message.Message):
    """The built-in Node.js Package Importer, which is a Package Importer that
    resolves using the standards and conventions of the Node.js ecosystem. It
    enables a `pkg:` URL scheme for usage with `@use` that directs an
    implementation to resolve a URL within a dependency.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ENTRY_POINT_DIRECTORY_FIELD_NUMBER: builtins.int
    entry_point_directory: builtins.str
    """The absolute path to associate with the Node Package Importer, with
    semantics identical to the [entryPointDirectory option] in the JavaScript
    API.

    [entryPointDirectory option]: https://sass-lang.com/documentation/js-api/classes/NodePackageImporter.html#constructor
    """
    def __init__(
        self,
        *,
        entry_point_directory: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["entry_point_directory", b"entry_point_directory"]) -> None: ...

global___NodePackageImporter = NodePackageImporter
