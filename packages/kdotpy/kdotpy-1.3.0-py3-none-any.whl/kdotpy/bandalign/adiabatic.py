# kdotpy - kÂ·p theory on a lattice for simulating semiconductor band structures
# Copyright (C) 2024, 2025 The kdotpy collaboration <kdotpy@uni-wuerzburg.de>
#
# SPDX-License-Identifier: GPL-3.0-only
#
# This file is part of kdotpy.
#
# kdotpy is free software: you can redistribute it and/or modify it under the
# terms of the GNU General Public License as published by the Free Software
# Foundation, version 3.
#
# kdotpy is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with
# kdotpy. If not, see <https://www.gnu.org/licenses/>.
#
# Under Section 7 of GPL version 3 we require you to fulfill the following
# additional terms:
#
#     - We require the preservation of the full copyright notice and the license
#       in all original files.
#
#     - We prohibit misrepresentation of the origin of the original files. To
#       obtain the original files, please visit the Git repository at
#       <https://git.physik.uni-wuerzburg.de/kdotpy/kdotpy>
#
#     - As part of a scientific environment, we believe it is reasonable to
#       expect that you follow the rules of good scientific practice when using
#       kdotpy. In particular, we expect that you credit the original authors if
#       you benefit from this program, by citing our work, following the
#       citation instructions in the file CITATION.md bundled with kdotpy.
#
#     - If you make substantial changes to kdotpy, we strongly encourage that
#       you contribute to the original project by joining our team. If you use
#       or publish a modified version of this program, you are required to mark
#       your material in a reasonable way as different from the original
#       version.

import numpy as np
import sys

from ..config import get_config_bool
from ..cmdargs import sysargv
from ..cnp import estimate_charge_neutrality_point
from ..diagonalization import DiagData
from ..diagonalization import diagonalization as diag
from ..diagonalization import lldiagonalization as lldiag
from ..vector import Vector, VectorGrid
from ..parallel import parallel_apply

from .bandalign import bandindices

### ADIABATIC BAND INDEX INITIALIZATION
def diag_hz_pot(alpha, params, pot = None, **modelopts):
	"""Thin wrapper around diag.hz_k0"""
	alpha_val = alpha.value[0] if isinstance(alpha, Vector) else alpha
	if not isinstance(pot, np.ndarray):
		raise TypeError("Argument pot must be an array")
	ddp = diag.hz_k0(
		params, pot = alpha_val * pot, bandtype_warning_level = 0, **modelopts)
	ddp.paramval = alpha if isinstance(alpha, Vector) else Vector(alpha)
	return ddp

def diag_hz_pot_ll(alpha, ll_mode, ll_max, h_sym, params, pot = None, **modelopts):
	"""Thin wrapper around lldiag.hll_k0"""
	alpha_val = alpha.value[0] if isinstance(alpha, Vector) else alpha
	if not isinstance(pot, np.ndarray):
		raise TypeError("Argument pot must be an array")
	ddp = lldiag.hll_k0(
		ll_mode, ll_max, h_sym, params, pot = alpha_val * pot,
		bandtype_warning_level = 0, modelopts = modelopts)
	ddp.paramval = alpha if isinstance(alpha, Vector) else Vector(alpha)
	return ddp

def fmt_eival(x):
	"""String formatting function for bandindices_automatic_debug()"""
	return "" if x is None else ("%.3f" % x)

def bandindices_adiabatic_debug(filename, diagdata, alphas, b_max=6):
	"""Write bandindices_adiabatic(_ll) debug output to a file.

	Arguments:
	filename   String. The filename of the output file
	diagdata   DiagData instance. Generated by bandindices_adiabatic(_ll).
	alphas     Numpy array. Values between 0 and 1.
	b_max      Positive integer. Only include band indices from -b_max to b_max.
	"""
	b_idx = [b for b in range(-b_max, b_max + 1) if b != 0]
	with open(filename, "w") as f:
		f.write("alpha," + ",".join("%i" % b for b in b_idx) + "\n")
		for j, alpha in enumerate(alphas):
			f.write("%g," % alpha)
			f.write(",".join([fmt_eival(diagdata[j].get_eival((b,))) for b in b_idx]) + "\n")

def bandindices_adiabatic_verbose(diagdata, alphas):
	"""Verbose output for bandindices_adiabatic(_ll) to stdout"""
	for j, alpha in enumerate(alphas):
		e_m1 = diagdata[j].get_eival((-1,))
		e_p1 = diagdata[j].get_eival((1,))
		c_m1 = diagdata[j].get_char((-1,))
		c_p1 = diagdata[j].get_char((1,))
		print("alpha = %g: CNP between %s (%.2f meV) and %s (%.2f meV)" % (alpha, c_m1, e_m1, c_p1, e_p1))

def bandindices_adiabatic(
		params, steps = 10, pot = None, num_cpus = 1, modelopts = None,
		bandalign_opts = None):
	"""Do band alignment over slowly increasing potential, starting at zero potential

	Since an electrostatic potential can affect the band characters, these may
	no longer be suitable to estimate the charge neutrality point (CNP).
	Instead, estimate the CNP for zero potential and then increase it 'slowly'
	to full	strength, i.e., diagonalize the Hamiltonian H0 + alpha V, where H0
	is the Hamiltonian without potential and V is the potential. The coefficient
	alpha is increased from 0 to 1. Then do band alignment over the sequence of
	DiagDataPoint instances. The result is the DiagDataPoint for alpha = 1 with
	the	band indices set.

	Arguments:
	params          PhysParams instance.
	steps           Integer. The number of intermediate steps. The step size for
	                alpha is 1 / steps.
	pot             Array or None. The potential.
	num_cpus        Integer. Number of processes/threads for parallelization.
	modelopts       A dict instance. The options for diagonalization.
	bandalign_opts  A dict instance. The options for band alignment.

	Returns:
	ddp      DiagDataPoint for H = H0 + V, i.e., alpha = 1. The band indices
	         (ddp.bindex) are set.
	"""
	if modelopts is None:
		modelopts = {}
	if bandalign_opts is None:
		bandalign_opts = {}
	modelopts1 = modelopts.copy()  # Make a copy so that we can change it safely
	if 'obs' in modelopts1:
		del modelopts1['obs']
	if 'pot' in modelopts1:
		del modelopts1['pot']

	alphas = np.linspace(0, 1, steps+1)
	grid = VectorGrid(x=alphas, astype='x', prefix='a')
	diagdata = DiagData(parallel_apply(
		diag_hz_pot, grid, (params, pot), f_kwds = modelopts1,
		num_processes = num_cpus, propagate_interrupt = True,
		description = "Calculating bands (k=0)"),
		grid = grid)

	# If bandalign_opts contains e0 (the location of the charge neutrality
	# point), use it. Otherwise, get it from estimate_charge_neutrality_point().
	if 'e0' in bandalign_opts:
		ba_data = bandindices(diagdata, input_data=diagdata[0], params=params, **bandalign_opts)
	else:
		e0 = estimate_charge_neutrality_point(params, data=diagdata[0])
		ba_data = bandindices(diagdata, e0=e0, input_data=diagdata[0], params=params, **bandalign_opts)

	if get_config_bool('bandindices_adiabatic_debug'):  # debug output (to a file)
		debug_file = "bandindices-adiabatic.csv"
		bandindices_adiabatic_debug(debug_file, diagdata, alphas)
	if sysargv.verbose:  # verbose output (to stdout)
		bandindices_adiabatic_verbose(diagdata, alphas)

	# The value of paramval should be reset to 0, as otherwise paramval = 1
	# can be misinterpreted as B = 1.
	diagdata[-1].paramval = Vector(0)
	return diagdata[-1]

def bandindices_adiabatic_ll(
		ll_mode, ll_max, h_sym, params, steps=10, pot=None, num_cpus=1,
		modelopts=None, bandalign_opts=None):
	"""Do band alignment over slowly increasing potential, starting at zero potential, LL version

	This function is for the most part identical to bandindices_adiabatic() and
	should/could be	merged into it in the future.

	Since an electrostatic potential can affect the band characters, these may
	no longer be suitable to estimate the charge neutrality point (CNP).
	Instead, estimate the CNP for zero potential and then increase it 'slowly'
	to full	strength, i.e., diagonalize the Hamiltonian H0 + alpha V, where H0
	is the Hamiltonian without potential and V is the potential. The coefficient
	alpha is increased from 0 to 1. Then do band alignment over the sequence of
	DiagDataPoint instances. The result is the DiagDataPoint for alpha = 1 with
	the	band indices set.

	Arguments:
	ll_mode         String. The Landau level mode, 'legacy', 'sym', or 'full'.
	ll_max          Integer. The highest Landau level index to consider.
	h_sym           SymbolicHamiltonian instance.
	params          PhysParams instance.
	steps           Integer. The number of intermediate steps. The step size for
	                alpha is 1 / steps.
	pot             Array or None. The potential.
	num_cpus        Integer. Number of processes/threads for parallelization.
	modelopts       A dict instance. The options for diagonalization.
	bandalign_opts  A dict instance. The options for band alignment.

	Returns:
	ddp      DiagDataPoint for H = H0 + V, i.e., alpha = 1. The band indices
	         (ddp.bindex) are set.
	"""
	if modelopts is None:
		modelopts = {}
	if bandalign_opts is None:
		bandalign_opts = {}
	modelopts1 = modelopts.copy()  # Make a copy so that we can change it safely
	if 'obs' in modelopts1:
		del modelopts1['obs']
	if 'pot' in modelopts1:
		del modelopts1['pot']

	alphas = np.linspace(0, 1, steps + 1)
	grid = VectorGrid(x=alphas, astype='x', prefix='a')
	diagdata = DiagData(parallel_apply(
		diag_hz_pot_ll, grid, (ll_mode, ll_max, h_sym, params, pot), f_kwds=modelopts1,  # mind different diag-function
		num_processes=num_cpus, propagate_interrupt=True,
		description="Calculating bands (k=0)"),
		grid=grid)

	# If bandalign_opts contains e0 (the location of the charge neutrality
	# point), use it. Otherwise, get it from estimate_charge_neutrality_point().
	if 'e0' in bandalign_opts:
		ba_data = bandindices(diagdata, input_data=diagdata[0], params=params, **bandalign_opts)
	else:
		e0 = estimate_charge_neutrality_point(params, data=diagdata[0])
		ba_data = bandindices(diagdata, e0=e0, input_data=diagdata[0], params=params, **bandalign_opts)

	if get_config_bool('bandindices_adiabatic_debug'):  # debug output (to a file)
		debug_file = "bandindices-adiabatic.csv"
		bandindices_adiabatic_debug(debug_file, diagdata, alphas)
	if sysargv.verbose:  # verbose output (to stdout)
		bandindices_adiabatic_verbose(diagdata, alphas)

	# For b-dependence, paramval should be reset to 0, as otherwise data cannot
	# be interpreted as B = 0.
	diagdata[-1].paramval = Vector(0)
	return diagdata[-1]

