"""
测试代码模板管理系统

提供统一的模板管理和配置，支持自定义模板和动态生成。
"""

from dataclasses import dataclass
from typing import Optional


@dataclass
class TemplateConfig:
    """模板配置类"""
    encoding: str = "utf-8"
    indent: str = "    "  # 4个空格缩进
    use_type_hints: bool = True
    use_docstrings: bool = True
    author: Optional[str] = None
    
    def get_file_header(self, filename: str) -> str:
        """获取文件头部注释"""
        header = f'"""\n{filename}\n'
        if self.author:
            header += f'\nAuthor: {self.author}\n'
        header += 'Generated by PyTestifyx\n"""\n\n'
        return header


class CodeTemplates:
    """代码模板集合"""
    
    def __init__(self, config: TemplateConfig = None):
        self.config = config or TemplateConfig()
    
    def get_core_class_template(self, application_name: str, converted_name: str) -> str:
        """API核心类模板"""
        template = self.config.get_file_header("API核心测试类")
        template += f"""from pytestifyx import TestCase
from pytestifyx.driver.api import APIRequestMeta


class {converted_name}(TestCase, metaclass=APIRequestMeta):
    \"\"\"
    {application_name} API测试核心类
    
    提供所有API接口的基础调用方法
    \"\"\"
    
    def setup_class(cls):
        \"\"\"类级别的初始化，设置基础URL\"\"\"
        super().setup_class()
    
    def setup_method(self):
        \"\"\"方法级别的初始化\"\"\"
        super().__init__()
        self.base_url = ""  # 在子类中设置基础URL
"""
        return template
    
    def get_api_method_template(self, api_name: str, url: str, method: str, 
                               description: str = None) -> str:
        """API方法模板"""
        desc = description or f"{api_name} API接口"
        return f"""
    def {api_name}(self, data: dict = None, config=None):
        \"\"\"
        {desc}
        
        Args:
            data: 请求数据
            config: 请求配置
            
        Returns:
            响应对象
            
        接口信息:
            - URL: {url}
            - Method: {method.upper()}
        \"\"\"
        # 实现将在运行时由元类自动生成
        pass
"""
    
    def get_test_class_template(self, category: str, application_name: str, 
                              converted_name: str) -> str:
        """测试类模板"""
        category_map = {
            'busi': '业务逻辑',
            'conc': '并发性能', 
            'flow': '流程'
        }
        
        category_desc = category_map.get(category, category)
        template = self.config.get_file_header(f"{category_desc}测试类")
        
        template += f"""import pytest
from pytestifyx import TestCase
from pytestifyx.utils.database.assertion.core import deep_diff
from pytest_cases import parametrize_with_cases

from api_test.{application_name}.template.core import {converted_name}
from api_test.{application_name}.test_data.{category.lower()} import {category.capitalize()}{converted_name}


class Test{category.capitalize()}{converted_name}(TestCase):
    \"\"\"
    {application_name} {category_desc}测试类
    
    负责执行{category_desc}相关的测试用例
    \"\"\"
    
    def setup_method(self):
        \"\"\"每个测试方法执行前的准备工作\"\"\"
        super().__init__()
        self.api = {converted_name}()
    
    def teardown_method(self):
        \"\"\"每个测试方法执行后的清理工作\"\"\"
        pass
"""
        return template
    
    def get_test_method_template(self, category: str, api_name: str, method: str,
                               content_type: str, converted_name: str, concurrent_number: int = 1) -> str:
        """测试方法模板"""
        marker = f"pytest.mark.{category}"
        return f"""
    @{marker}
    @parametrize_with_cases('test_data', cases={category.capitalize()}{converted_name}.{category}_{api_name})
    def test_{category}_{api_name}(self, test_data: dict, **kwargs):
        \"\"\"
        测试 {api_name} 接口的{category}场景
        
        Args:
            test_data: 测试数据
            **kwargs: 额外配置参数
        \"\"\"
        config = self.config
        config.set_attr(
            concurrent_number={concurrent_number},
            content_type="{content_type}",
            request_method="{method.upper()}",
            **kwargs
        )
        
        response = self.api.{api_name}(test_data, config)
        
        # 响应断言
        if response.status_code == 200:
            expected_result = test_data.get('expected_result', {{'message': 'success'}})
            assert deep_diff(response.json(), expected_result), f"响应结果不匹配: {{response.json()}}"
        else:
            expected_error = test_data.get('expected_error')
            if expected_error:
                assert deep_diff(response.json(), expected_error), f"错误响应不匹配: {{response.json()}}"
            else:
                pytest.fail(f"请求失败，状态码: {{response.status_code}}, 响应: {{response.text}}")
        
        return response
"""
    
    def get_data_class_template(self, category: str, application_name: str, 
                              converted_name: str) -> str:
        """测试数据类模板"""
        category_map = {
            'busi': '业务逻辑',
            'conc': '并发性能',
            'flow': '流程'
        }
        
        category_desc = category_map.get(category, category)
        template = self.config.get_file_header(f"{category_desc}测试数据")
        
        template += f"""from pytest_cases import parametrize
from typing import Dict, Any


class {category.capitalize()}{converted_name}:
    \"\"\"
    {application_name} {category_desc}测试数据提供者
    
    定义各种测试场景的数据和期望结果
    \"\"\"
    
    @staticmethod
    def get_base_data() -> Dict[str, Any]:
        \"\"\"获取基础测试数据模板\"\"\"
        return {{
            "expected_result": {{"message": "success"}},
            "expected_error": None,
            "timeout": 30,
            "retry_count": 0
        }}
"""
        return template
    
    def get_data_method_template(self, category: str, api_name: str) -> str:
        """测试数据方法模板"""
        return f"""
    @parametrize(data=(
        {{"正向测试_成功": {{}}}},
        {{"边界测试_最小值": {{}}}},
        {{"边界测试_最大值": {{}}}},
        {{"异常测试_无效参数": {{"expected_error": {{"code": 400, "message": "参数错误"}}}}}},
    ))
    def {category}_{api_name}(self, data: tuple) -> Dict[str, Any]:
        \"\"\"
        {api_name} 接口的{category}测试数据
        
        Args:
            data: 参数化测试数据元组
            
        Returns:
            完整的测试数据字典
        \"\"\"
        test_name, test_data = list(data.items())[0]
        
        # 合并基础数据和测试特定数据
        base_data = self.get_base_data()
        base_data.update(test_data)
        base_data["test_name"] = test_name
        
        return base_data
"""
    
    def get_body_template(self, method: str, api_name: str, body_data: dict) -> str:
        """请求体模板"""
        import json
        return f"""
# {method.upper()} {api_name} 请求体数据
{method.upper()}_{api_name} = {json.dumps(body_data, indent=4, ensure_ascii=False)}
"""
    
    def get_default_body_template(self) -> str:
        """默认body文件模板（当没有请求体数据时使用）"""
        header = self.config.get_file_header("请求体数据配置")
        return f"""{header}# 请求体数据配置文件
# 在此文件中定义各API接口的请求体数据

# 示例:
# POST_api_name = {{
#     "key": "value",
#     "nested": {{
#         "inner_key": "inner_value"
#     }}
# }}

# 查询参数示例:
# GET_api_name_query_params = {{
#     "page": "1",
#     "limit": "10"
# }}
"""
    
    def get_headers_template(self, api_name: str, headers: dict) -> str:
        """请求头模板"""
        import json
        return f"""
# {api_name} 请求头配置
{api_name}_headers = {json.dumps(headers, indent=4, ensure_ascii=False)}
"""
    
    def get_base_url_template(self, domain: str) -> str:
        """基础URL模板（只在文件不存在时使用）"""
        return f"""# 测试环境基础URL
url_prefix_test = "{domain}"
"""
    
    def get_api_path_template(self, method: str, api_name: str, path: str) -> str:
        """API路径模板（用于添加具体API路径）"""
        # 检查路径是否包含参数
        path_params = self._extract_path_parameters(path)
        if path_params:
            # 生成包含路径参数说明的注释
            param_comment = f"# 路径参数: {', '.join(path_params)}"
            return f"""
# {method.upper()} {api_name} 接口路径
{param_comment}
{method.upper()}_{api_name} = "{path}"
"""
        else:
            return f"""
# {method.upper()} {api_name} 接口路径
{method.upper()}_{api_name} = "{path}"
"""
    
    def get_url_template(self, method: str, api_name: str, domain: str, path: str) -> str:
        """完整URL配置模板（包含基础URL和API路径）"""
        # 检查路径是否包含参数
        path_params = self._extract_path_parameters(path)
        if path_params:
            # 生成包含路径参数说明的注释
            param_comment = f"# 路径参数: {', '.join(path_params)}"
            path_section = f"""# {method.upper()} {api_name} 接口路径
{param_comment}
{method.upper()}_{api_name} = "{path}"
"""
        else:
            path_section = f"""# {method.upper()} {api_name} 接口路径
{method.upper()}_{api_name} = "{path}"
"""
        
        return f"""# 测试环境基础URL
url_prefix_test = "{domain}"

{path_section}"""
    
    def get_flow_class_template(self, application_name: str, converted_name: str) -> str:
        """流程测试类模板"""
        template = self.config.get_file_header("流程测试类")
        template += f"""import pytest
from pytestifyx import TestCase
from pytest_cases import parametrize_with_cases

from api_test.{application_name}.test_case.busi import TestBusi{converted_name}
from api_test.{application_name}.test_data.flow import Flow{converted_name}


class TestFlow{converted_name}(TestCase):
    \"\"\"
    {application_name} 流程测试类
    
    组合多个API调用，验证完整的业务流程
    \"\"\"
    
    def setup_method(self):
        \"\"\"流程测试前的环境准备\"\"\"
        super().__init__()
        self.busi_test = TestBusi{converted_name}()
    
    def teardown_method(self):
        \"\"\"流程测试后的环境清理\"\"\"
        pass
"""
        return template
    
    def get_flow_method_template(self, api_methods: list, converted_name: str) -> str:
        """流程测试方法模板"""
        method_calls = ""
        for api_name in api_methods:
            method_calls += f"""        # 执行 {api_name} 接口
        {api_name}_response = self.busi_test.test_busi_{api_name}(test_data)
        test_data.update({{"previous_response": {api_name}_response.json()}})
        
"""
        
        last_response = api_methods[-1] if api_methods else "None"
        
        return f"""
    @pytest.mark.flow
    @parametrize_with_cases('test_data', cases=Flow{converted_name}.flow_all)
    def test_flow_all(self, test_data: dict):
        \"\"\"
        完整业务流程测试
        
        Args:
            test_data: 流程测试数据
        \"\"\"
        print(f"开始执行流程测试: {{test_data.get('flow_name', 'default')}}")
        
{method_calls}        print("流程测试执行完成")
        return {last_response}_response if '{last_response}' in locals() else None
"""
    
    def get_conftest_template(self) -> str:
        """conftest.py 模板"""
        template = self.config.get_file_header("pytest配置文件")
        template += '''import pytest
from pathlib import Path


@pytest.fixture(scope="session")
def project_root():
    """获取项目根目录"""
    return Path(__file__).parent


@pytest.fixture(scope="session") 
def test_config():
    """测试配置"""
    return {
        "base_url": "http://localhost:8080",
        "timeout": 30,
        "retry_count": 3,
        "log_level": "INFO"
    }


@pytest.fixture(autouse=True)
def setup_test_environment(test_config):
    """自动设置测试环境"""
    print(f"\\n=== 测试环境初始化 ===")
    print(f"Base URL: {test_config['base_url']}")
    yield
    print("=== 测试环境清理完成 ===")


def pytest_configure(config):
    """pytest配置钩子"""
    # 注册自定义标记
    config.addinivalue_line("markers", "busi: 业务逻辑测试")
    config.addinivalue_line("markers", "conc: 并发性能测试") 
    config.addinivalue_line("markers", "flow: 流程测试")


def pytest_collection_modifyitems(config, items):
    """测试收集完成后的处理"""
    for item in items:
        # 为所有测试添加默认标记
        if not any(item.iter_markers()):
            item.add_marker(pytest.mark.busi)
'''
        return template
    
    def _extract_path_parameters(self, path: str) -> list:
        """
        提取路径中的参数名列表
        
        Args:
            path: API路径，如 '/system/hotel/operation/info/{code}'
            
        Returns:
            路径参数名列表，如 ['code']
        """
        import re
        # 提取所有大括号中的参数名
        path_params = re.findall(r'\{([^}]+)\}', path)
        return path_params


# 导出模板管理器实例
default_templates = CodeTemplates()
