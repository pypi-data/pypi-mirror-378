# 自动生成指定包目录下的 __init__.py（懒加载格式：lazy_loader.attach）
# 并且支持IDE友好的 __init__.py 版本

import ast
from pathlib import Path
from typing import Dict, List, Set


def _extract_exports_from_module(py_file: Path) -> List[str]:
    """
    优先读取模块内显式定义的 __all__，否则收集顶层的类与函数名（排除以下划线开头的）。
    """
    try:
        source = py_file.read_text(encoding='utf-8')
    except UnicodeDecodeError:
        source = py_file.read_text(errors='ignore')

    try:
        tree = ast.parse(source, filename=str(py_file))
    except SyntaxError:
        return []

    # 1) 如果定义了 __all__ 则优先使用
    for node in tree.body:
        if isinstance(node, ast.Assign):
            for target in node.targets:
                if isinstance(target, ast.Name) and target.id == '__all__':
                    values: List[str] = []
                    if isinstance(node.value, (ast.List, ast.Tuple)):
                        for elt in node.value.elts:
                            if isinstance(elt, ast.Str):  # py<3.8
                                values.append(elt.s)
                            elif isinstance(elt, ast.Constant) and isinstance(elt.value, str):
                                values.append(elt.value)
                    return [name for name in values if name and not name.startswith('_')]

    # 2) 否则收集顶层函数与类名
    exports: Set[str] = set()
    for node in tree.body:
        if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef, ast.ClassDef)):
            name = node.name
            if not name.startswith('_'):
                exports.add(name)
    return sorted(exports)


def generate_init_for_directory(package_dir: Path, ide_friendly: bool = False) -> Path:
    """
    为指定目录生成懒加载版 __init__.py（覆盖写入）。
    - 仅扫描一级子模块（同级 .py 文件），忽略以下划线开头的模块与 __init__.py 本身。
    - 生成结构：
        from lazy_loader import attach

        __getattr__, __dir__, __all__ = attach(
            __name__,
            submodules=["m1", "m2", ...],
            submod_attrs={"m1": ["A", "B"], ...}
        )

    Args:
        package_dir: 包目录路径
        ide_friendly: 是否生成IDE友好版本（使用TYPE_CHECKING）
    """
    package_dir = package_dir.resolve()
    if not package_dir.is_dir():
        raise ValueError(f"目标不是目录: {package_dir}")

    module_to_exports: Dict[str, List[str]] = {}
    module_names: List[str] = []
    for py_file in sorted(package_dir.glob('*.py')):
        if py_file.name == '__init__.py':
            continue
        if py_file.name.startswith('_'):
            continue
        module_name = py_file.stem
        module_names.append(module_name)
        exports = _extract_exports_from_module(py_file)
        if exports:
            module_to_exports[module_name] = exports

    lines: List[str] = []
    lines.append('# This file is auto-generated. Do NOT edit manually.')
    lines.append('# Generated by neverlib.QA.gen_init')

    if ide_friendly:
        lines.append('')
        lines.append('from typing import TYPE_CHECKING, Any')
        lines.append('')
        lines.append('if TYPE_CHECKING:')
        lines.append('    # 仅在类型检查时导入，提供IDE补全支持')

        # 生成 TYPE_CHECKING 导入
        for module_name in sorted(module_to_exports.keys()):
            exports = module_to_exports[module_name]
            if exports:
                imports = ', '.join(exports)
                lines.append(f'    from .{module_name} import {imports}')

        lines.append('')
        lines.append('# 运行时使用懒加载')

    lines.append('from lazy_loader import attach')
    lines.append('')
    lines.append('__getattr__, __dir__, __all__ = attach(')
    lines.append('    __name__,')
    lines.append('    submodules=[')
    for name in sorted(module_names):
        lines.append(f'        "{name}",')
    lines.append('    ],')
    lines.append('    submod_attrs={')
    for module_name in sorted(module_to_exports.keys()):
        exports_sorted = sorted(module_to_exports[module_name])
        joined = ', '.join([f"'{e}'" for e in exports_sorted])
        lines.append(f'        "{module_name}": [{joined}],')
    lines.append('    }')
    lines.append(')')
    lines.append('')

    if ide_friendly:
        # 生成显式的 __all__ 声明
        lines.append('# 显式声明 __all__ 以便 IDE 识别')
        lines.append('if TYPE_CHECKING:')
        lines.append('    __all__ = [')

        all_exports = []
        for module_name in sorted(module_to_exports.keys()):
            exports = module_to_exports[module_name]
            for export in exports:
                all_exports.append(f"        '{export}',")

        lines.extend(all_exports)
        lines.append('    ]')

    init_file = package_dir / '__init__.py'
    init_file.write_text('\n'.join(lines), encoding='utf-8')
    return init_file


def generate_all_packages(root_dir: Path, ide_friendly: bool = False) -> List[Path]:
    """
    为所有子包生成 __init__.py 文件

    Args:
        root_dir: 根目录路径
        ide_friendly: 是否生成IDE友好版本

    Returns:
        生成的文件路径列表
    """
    generated_files = []
    processed_dirs = set()  # 避免重复处理

    # 查找所有包含 __init__.py 的包目录
    for init_file in root_dir.rglob('__init__.py'):
        package_dir = init_file.parent

        # 跳过根目录和已处理的目录
        if package_dir == root_dir or package_dir in processed_dirs:
            continue

        # 检查是否包含其他Python文件（不是只有__init__.py）
        has_other_py_files = any(
            f.name != '__init__.py' and f.suffix == '.py'
            for f in package_dir.iterdir()
        )

        if has_other_py_files:
            processed_dirs.add(package_dir)
            try:
                init_path = generate_init_for_directory(package_dir, ide_friendly=ide_friendly)
                generated_files.append(init_path)
                print(f'✅ 已生成: {init_path}')
            except Exception as e:
                print(f'❌ 生成失败 {package_dir}: {e}')

    return generated_files


def main():
    import argparse

    parser = argparse.ArgumentParser(description='为指定包目录自动生成 __init__.py')
    parser.add_argument('-p', '--package-dir', dest='package_dir',
                        help='包目录路径，比如 /path/to/pkg 或 ./neverlib/utils')
    parser.add_argument('--all', action='store_true',
                        help='为所有子包生成 __init__.py')
    parser.add_argument('--ide-friendly', action='store_true',
                        help='生成IDE友好版本（使用TYPE_CHECKING）')
    parser.add_argument('--backup', action='store_true',
                        help='备份原始文件')
    args = parser.parse_args()

    if args.all:
        # 批量生成所有包
        root_dir = Path(__file__).parent.parent  # neverlib 目录
        generated_files = generate_all_packages(root_dir, ide_friendly=args.ide_friendly)
    else:
        # 生成单个包
        if not args.package_dir:
            parser.error('请指定包目录路径 (-p) 或使用 --all 批量生成')

        target_dir = Path(args.package_dir)

        if args.backup and (target_dir / '__init__.py').exists():
            backup_path = target_dir / '__init__.py.backup'
            (target_dir / '__init__.py').rename(backup_path)
            print(f"已备份原始文件到: {backup_path}")

        init_path = generate_init_for_directory(target_dir, ide_friendly=args.ide_friendly)
        print(f'已生成: {init_path}')
        if args.ide_friendly:
            print('✅ 已生成IDE友好版本（支持代码补全和类型检查）')
        else:
            print('ℹ️  生成标准懒加载版本，如需IDE支持请使用 --ide-friendly 参数')


if __name__ == '__main__':
    main()
