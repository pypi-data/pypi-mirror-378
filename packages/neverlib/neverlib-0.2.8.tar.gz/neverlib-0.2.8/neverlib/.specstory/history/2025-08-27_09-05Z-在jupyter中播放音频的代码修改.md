<!-- Generated by SpecStory -->

# 在jupyter中播放音频的代码修改 (2025-08-27 09:05Z)

_**User**_

我想要在jupyter中听音频该如何改代码

---

_**Assistant**_

我需要查看当前的代码，了解如何在Jupyter中添加音频播放功能。

---

Read file: Docs/audio_aug_test/test_volume.ipynb

---

Read file: Docs/audio_aug_test/test_volume.ipynb

---

我注意到您想在Jupyter中播放音频文件。在您的代码中，第12行有一个被注释掉的导入语句：`# from IPython.display import Audio, display`。要在Jupyter中播放音频，您需要取消这行的注释并添加播放音频的代码。

以下是修改建议：

```python:Docs/audio_aug_test/test_volume.ipynb
# 确保使用本地版本而非安装版本
import os
import sys
sys.path.append("../../")
from audio_aug import volume_aug_linmax, volume_aug_dbrms, volume_aug_lufs, measure_loudness
import soundfile as sf
import numpy as np
import matplotlib.pyplot as plt
from IPython.display import Audio, display

wav_path = "/data03/never/Dataset/kws_data/Command_Word/group_a_class/zh/pos_example/上一首/037/soft_normal_male_25_151_vadstart5920_vadend33600_snr14.2.wav"
wav, sr = sf.read(wav_path, always_2d=True, dtype="float32")
wav = wav[:, 1]
```

然后在需要播放音频的单元格中添加以下代码：

```python
# 播放原始音频
display(Audio(wav, rate=sr))

# 播放处理后的音频（比如wav_linear）
display(Audio(wav_linear, rate=sr))

# 播放处理后的音频（比如wav_dbrms）
display(Audio(wav_dbrms, rate=sr))

# 播放处理后的音频（比如wav_lufs）
display(Audio(wav_lufs, rate=sr))
```

您可以在任何需要播放音频的单元格中添加这些代码。例如，在每个处理完音频后的单元格中添加对应的播放代码，或者创建一个新的单元格专门用于播放所有处理过的音频进行比较。

---

_**User**_

jupyte有画时域波形的函数吗？

---

_**Assistant**_

是的，Jupyter中可以使用matplotlib库来绘制时域波形。从您当前的代码中可以看到，您已经在使用matplotlib绘制波形了。

在您的代码中，已经有时域波形的绘制：

```python
plt.figure(figsize=(10, 6))
plt.subplot(2, 1, 1)
time = np.arange(len(wav)) / sr
plt.plot(time, wav)  # 这里就是绘制时域波形
plt.ylim(-1, 1)
plt.grid()
```

这段代码创建了一个图形，其中上半部分绘制了音频信号的时域波形，下半部分绘制了频谱图。

如果您想单独绘制更美观的时域波形，可以使用以下代码：

```python
def plot_waveform(signal, sample_rate, title="波形图"):
    """绘制音频波形的时域图"""
    duration = len(signal) / sample_rate
    time = np.linspace(0, duration, len(signal))
    
    plt.figure(figsize=(12, 4))
    plt.plot(time, signal, color='blue')
    plt.title(title)
    plt.xlabel('时间 (秒)')
    plt.ylabel('振幅')
    plt.grid(True)
    plt.tight_layout()
    plt.show()

# 使用方法
plot_waveform(wav, sr, "原始音频波形")
plot_waveform(wav_linear, sr, "线性增强后的波形")
```

这个函数会创建一个更清晰、更专注于时域表示的波形图，包含适当的标签和网格。

---

_**User**_

wav_linear = volume_aug_linmax(wav, 0.5, hpf=True)
为什么这段代码后，wav初始值会被改变

---

_**Assistant**_

<details>
                <summary>Searched codebase "volume_aug_linmax function implementation" • **14** results</summary>
            
| File | Lines |
|------|-------|
| `audio_aug/audio_aug.py` | L283-372 |
| `.history/audio_aug/audio_aug_20250827170056.py` | L283-374 |
| `.history/audio_aug/audio_aug_20250827170216.py` | L283-373 |
| `.history/audio_aug/audio_aug_20250827170314.py` | L283-373 |
| `.history/audio_aug/audio_aug_20250827170143.py` | L283-373 |
| `.history/audio_aug/audio_aug_20250827170106.py` | L283-373 |
| `.history/audio_aug/audio_aug_20250827171500.py` | L283-372 |
| `.history/audio_aug/audio_aug_20250827170218.py` | L283-373 |
| `audio_aug/audio_aug.py` | L257-301 |
| `.history/audio_aug/audio_aug_20250827170106.py` | L257-302 |
| `.history/audio_aug/audio_aug_20250827170056.py` | L257-303 |
| `.history/audio_aug/audio_aug_20250827170216.py` | L257-302 |
| `Docs/audio_aug/test_volume.ipynb` | Lundefined-22 |
| `.history/audio_aug/audio_aug_20250827170143.py` | L257-302 |

</details>

---

问题在于`volume_aug_linmax`函数中直接修改了输入参数`wav`的值。查看函数实现，在第323行有一个关键操作：

```python
wav *= scalar
```

这行代码直接对传入的`wav`数组进行了原地修改（in-place modification），而不是创建一个新的数组。在Python中，NumPy数组是可变对象，当你将数组传递给函数时，函数接收的是数组的引用，而不是数组的副本。因此，当函数中修改了这个数组，原始数组也会被修改。

要避免这个问题，您可以在调用函数前先创建原始数据的副本：

```python
# 创建wav的副本再传入函数
wav_copy = wav.copy()
wav_linear = volume_aug_linmax(wav_copy, 0.5, hpf=True)
```

或者修改`volume_aug_linmax`函数，让它在内部处理时不修改原始数据：

```python
def volume_aug_linmax(wav, target_level, hpf=False, sr=16000, order=4, cutoff=100):
    """
    音量增强, 使用linmax方法
    Args:
        wav: 音频
        target_level: 目标音量, 单位dB
        hpf: 是否高通滤波
        sr: 采样率
        order: 滤波器阶数
        cutoff: 截止频率
    """
    assert target_level > 0 and target_level < 1, "target_level must be between 0 and 1"
    # 创建输入数据的副本，避免修改原始数据
    wav_out = wav.copy()
    wav_tmp = wav.copy()
    if hpf:
        wav_tmp = HPFilter(wav_tmp, sr=sr, order=order, cutoff=cutoff)
    wav_max = np.max(np.abs(wav_tmp))
    scalar = target_level / (wav_max + EPS)
    wav_out *= scalar
    wav_out = limiter(wav_out)

    return wav_out
```

这样修改后，函数就不会改变原始输入数据了。

---

_**User**_

不太理解，局部变量为什么会改变局全局变量，有没有其他解法，比如深浅拷贝方式

---

_**Assistant**_

这个问题涉及到Python中对象的传递方式和可变对象的特性。让我解释一下：

### 为什么局部变量会改变全局变量

在Python中，当你将一个变量传递给函数时，实际上传递的是对象的引用，而不是对象的副本。对于可变对象（如列表、字典、NumPy数组等），这意味着函数内部对该对象的修改会影响到函数外部的原始对象。

在`volume_aug_linmax`函数中：
```python
def volume_aug_linmax(wav, target_level, hpf=False, sr=16000, order=4, cutoff=100):
    # ...
    wav *= scalar  # 直接修改了传入的wav对象
    # ...
```

这里的`wav`参数接收的是外部传入的NumPy数组的引用，所以当函数内部使用`*=`运算符修改它时，外部的原始数组也被修改了。

### 解决方案

#### 1. 深拷贝与浅拷贝

对于NumPy数组，可以使用以下方法创建副本：

- **浅拷贝**：`wav.copy()`或`np.copy(wav)`
  - 对于一维数组，浅拷贝已经足够
  - 这会创建一个新的数组对象，但内部的复杂对象（如果有）仍然是引用

- **深拷贝**：`import copy; copy.deepcopy(wav)`
  - 完全复制整个对象及其所有嵌套对象
  - 对于简单的NumPy数组，通常不需要深拷贝

#### 2. 在调用函数前创建副本

```python
# 方法1：使用NumPy的copy方法
wav_copy = wav.copy()
wav_linear = volume_aug_linmax(wav_copy, 0.5, hpf=True)

# 方法2：使用NumPy的array函数创建新数组
wav_copy = np.array(wav)
wav_linear = volume_aug_linmax(wav_copy, 0.5, hpf=True)
```

#### 3. 修改函数返回新对象而不修改输入

```python
def volume_aug_linmax_fixed(wav, target_level, hpf=False, sr=16000, order=4, cutoff=100):
    """
    音量增强, 使用linmax方法（不修改输入）
    """
    assert target_level > 0 and target_level < 1, "target_level must be between 0 and 1"
    # 创建输入数据的副本
    wav_out = wav.copy()  # 关键是这一步
    wav_tmp = wav.copy()
    if hpf:
        wav_tmp = HPFilter(wav_tmp, sr=sr, order=order, cutoff=cutoff)
    wav_max = np.max(np.abs(wav_tmp))
    scalar = target_level / (wav_max + EPS)
    wav_out *= scalar  # 修改副本而不是原始数据
    wav_out = limiter(wav_out)
    return wav_out
```

#### 4. 函数式编程方法（不修改任何输入）

```python
def volume_aug_linmax_functional(wav, target_level, hpf=False, sr=16000, order=4, cutoff=100):
    """
    音量增强, 使用linmax方法（函数式方法）
    """
    assert target_level > 0 and target_level < 1, "target_level must be between 0 and 1"
    wav_tmp = wav.copy() if hpf else wav
    if hpf:
        wav_tmp = HPFilter(wav_tmp, sr=sr, order=order, cutoff=cutoff)
    wav_max = np.max(np.abs(wav_tmp))
    scalar = target_level / (wav_max + EPS)
    # 创建新数组而不是修改原始数组
    return limiter(wav * scalar)
```

对于您的情况，最简单的解决方案是在调用函数前创建一个副本，或者修改函数内部创建副本。对于NumPy数组，通常`.copy()`方法就足够了，不需要使用`copy.deepcopy()`，因为NumPy数组通常不包含嵌套的复杂对象。

---

_**User**_

我改成了这样还是有问题

---

_**Assistant**_

我看到您修改了`volume_aug_dbrms`函数，但问题可能出在`volume_aug_linmax`函数上。让我们检查一下`volume_aug_linmax`函数的当前实现：

---

Read file: audio_aug/audio_aug.py

---

我发现问题所在了。尽管您修改了`volume_aug_dbrms`函数使其不改变原始数组，但`volume_aug_linmax`函数仍然有问题。在第322行：

```python
wav *= scalar
```

这行代码直接修改了输入的`wav`数组。虽然在第317行创建了`wav_tmp = wav.copy()`，但这个副本只用于计算，而实际的音量调整仍然是在原始`wav`上进行的。

要解决这个问题，您需要修改`volume_aug_linmax`函数，使其像`volume_aug_dbrms`一样不修改原始输入：

```python
def volume_aug_linmax(wav, target_level, hpf=False, sr=16000, order=4, cutoff=100):
    """
    音量增强, 使用linmax方法
    Args:
        wav: 音频
        target_level: 目标音量, 单位dB
        hpf: 是否高通滤波
        sr: 采样率
        order: 滤波器阶数
        cutoff: 截止频率
    """
    assert target_level > 0 and target_level < 1, "target_level must be between 0 and 1"
    wav_tmp = wav.copy()
    if hpf:
        wav_tmp = HPFilter(wav_tmp, sr=sr, order=order, cutoff=cutoff)
    wav_max = np.max(np.abs(wav_tmp))
    scalar = target_level / (wav_max + EPS)
    wav_opt = wav.copy() * scalar  # 创建新数组而不是修改原始数组
    wav_opt = limiter(wav_opt)
    
    return wav_opt
```

关键的改变是：
1. 创建一个新的数组`wav_opt`来存储调整后的音频，而不是修改原始的`wav`
2. 使用`wav.copy() * scalar`而不是`wav *= scalar`来避免原地修改

同样，我注意到`volume_aug_lufs`函数也有类似问题，在第370行：

```python
wav = wav * scalar
```

虽然这看起来像是创建了新数组，但实际上Python可能会优化这个操作为原地修改。为了安全起见，也应该修改为：

```python
wav_opt = wav.copy() * scalar
```

然后返回`wav_opt`而不是修改后的`wav`。

修改后的`volume_aug_linmax`函数应该不会再改变原始的`wav`数组了。

---

