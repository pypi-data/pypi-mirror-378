# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'IamRoleRuleArgs',
    'IamRoleRuleArgsDict',
    'IamServiceAccountRoleBindingArgs',
    'IamServiceAccountRoleBindingArgsDict',
    'IamTeamMemberArgs',
    'IamTeamMemberArgsDict',
    'KubernetesClusterApiServerAclArgs',
    'KubernetesClusterApiServerAclArgsDict',
    'KubernetesNodePoolNodeTaintArgs',
    'KubernetesNodePoolNodeTaintArgsDict',
    'SecurityGroupEgressRuleArgs',
    'SecurityGroupEgressRuleArgsDict',
    'SecurityGroupIngressRuleArgs',
    'SecurityGroupIngressRuleArgsDict',
    'TargetGroupAttachmentArgs',
    'TargetGroupAttachmentArgsDict',
]

MYPY = False

if not MYPY:
    class IamRoleRuleArgsDict(TypedDict):
        permissions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of permissions (create, read, update, delete, list, *)
        """
        resources: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of resources this rule applies to
        """
        identity: NotRequired[pulumi.Input[_builtins.str]]
        """
        Identity of the permission rule
        """
        note: NotRequired[pulumi.Input[_builtins.str]]
        """
        Human-readable note for the permission rule
        """
        resource_identities: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of specific resource identities this rule applies to
        """
elif False:
    IamRoleRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IamRoleRuleArgs:
    def __init__(__self__, *,
                 permissions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 resources: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 identity: Optional[pulumi.Input[_builtins.str]] = None,
                 note: Optional[pulumi.Input[_builtins.str]] = None,
                 resource_identities: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] permissions: List of permissions (create, read, update, delete, list, *)
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] resources: List of resources this rule applies to
        :param pulumi.Input[_builtins.str] identity: Identity of the permission rule
        :param pulumi.Input[_builtins.str] note: Human-readable note for the permission rule
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] resource_identities: List of specific resource identities this rule applies to
        """
        pulumi.set(__self__, "permissions", permissions)
        pulumi.set(__self__, "resources", resources)
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if note is not None:
            pulumi.set(__self__, "note", note)
        if resource_identities is not None:
            pulumi.set(__self__, "resource_identities", resource_identities)

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of permissions (create, read, update, delete, list, *)
        """
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "permissions", value)

    @_builtins.property
    @pulumi.getter
    def resources(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of resources this rule applies to
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "resources", value)

    @_builtins.property
    @pulumi.getter
    def identity(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Identity of the permission rule
        """
        return pulumi.get(self, "identity")

    @identity.setter
    def identity(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "identity", value)

    @_builtins.property
    @pulumi.getter
    def note(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Human-readable note for the permission rule
        """
        return pulumi.get(self, "note")

    @note.setter
    def note(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "note", value)

    @_builtins.property
    @pulumi.getter(name="resourceIdentities")
    def resource_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of specific resource identities this rule applies to
        """
        return pulumi.get(self, "resource_identities")

    @resource_identities.setter
    def resource_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "resource_identities", value)


if not MYPY:
    class IamServiceAccountRoleBindingArgsDict(TypedDict):
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Creation timestamp of the role binding
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the role binding
        """
        identity: NotRequired[pulumi.Input[_builtins.str]]
        """
        Identity of the role binding
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the role binding
        """
        role_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Identity of the role binding
        """
        updated_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Last update timestamp of the role binding
        """
elif False:
    IamServiceAccountRoleBindingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IamServiceAccountRoleBindingArgs:
    def __init__(__self__, *,
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 identity: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 role_id: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_at: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] created_at: Creation timestamp of the role binding
        :param pulumi.Input[_builtins.str] description: Description of the role binding
        :param pulumi.Input[_builtins.str] identity: Identity of the role binding
        :param pulumi.Input[_builtins.str] name: Name of the role binding
        :param pulumi.Input[_builtins.str] role_id: Identity of the role binding
        :param pulumi.Input[_builtins.str] updated_at: Last update timestamp of the role binding
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if role_id is not None:
            pulumi.set(__self__, "role_id", role_id)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Creation timestamp of the role binding
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the role binding
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def identity(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Identity of the role binding
        """
        return pulumi.get(self, "identity")

    @identity.setter
    def identity(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "identity", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the role binding
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="roleId")
    def role_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Identity of the role binding
        """
        return pulumi.get(self, "role_id")

    @role_id.setter
    def role_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_id", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Last update timestamp of the role binding
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_at", value)


if not MYPY:
    class IamTeamMemberArgsDict(TypedDict):
        email: NotRequired[pulumi.Input[_builtins.str]]
        """
        Email address of the user to add to the team. If provided, user_identity will be resolved automatically.
        """
        role: NotRequired[pulumi.Input[_builtins.str]]
        """
        Role of the team member. Optional. Default: MEMBER.
        """
        user_identity: NotRequired[pulumi.Input[_builtins.str]]
        """
        Identity of the user to add to the team
        """
elif False:
    IamTeamMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IamTeamMemberArgs:
    def __init__(__self__, *,
                 email: Optional[pulumi.Input[_builtins.str]] = None,
                 role: Optional[pulumi.Input[_builtins.str]] = None,
                 user_identity: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] email: Email address of the user to add to the team. If provided, user_identity will be resolved automatically.
        :param pulumi.Input[_builtins.str] role: Role of the team member. Optional. Default: MEMBER.
        :param pulumi.Input[_builtins.str] user_identity: Identity of the user to add to the team
        """
        if email is not None:
            pulumi.set(__self__, "email", email)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if user_identity is not None:
            pulumi.set(__self__, "user_identity", user_identity)

    @_builtins.property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Email address of the user to add to the team. If provided, user_identity will be resolved automatically.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "email", value)

    @_builtins.property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Role of the team member. Optional. Default: MEMBER.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role", value)

    @_builtins.property
    @pulumi.getter(name="userIdentity")
    def user_identity(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Identity of the user to add to the team
        """
        return pulumi.get(self, "user_identity")

    @user_identity.setter
    def user_identity(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_identity", value)


if not MYPY:
    class KubernetesClusterApiServerAclArgsDict(TypedDict):
        allowed_cidrs: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of allowed CIDRs for API server access
        """
elif False:
    KubernetesClusterApiServerAclArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesClusterApiServerAclArgs:
    def __init__(__self__, *,
                 allowed_cidrs: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_cidrs: List of allowed CIDRs for API server access
        """
        if allowed_cidrs is not None:
            pulumi.set(__self__, "allowed_cidrs", allowed_cidrs)

    @_builtins.property
    @pulumi.getter(name="allowedCidrs")
    def allowed_cidrs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of allowed CIDRs for API server access
        """
        return pulumi.get(self, "allowed_cidrs")

    @allowed_cidrs.setter
    def allowed_cidrs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_cidrs", value)


if not MYPY:
    class KubernetesNodePoolNodeTaintArgsDict(TypedDict):
        effect: NotRequired[pulumi.Input[_builtins.str]]
        """
        Effect of the taint
        """
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Key of the taint
        """
        operator: NotRequired[pulumi.Input[_builtins.str]]
        """
        Operator of the taint
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Value of the taint. Optional.
        """
elif False:
    KubernetesNodePoolNodeTaintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesNodePoolNodeTaintArgs:
    def __init__(__self__, *,
                 effect: Optional[pulumi.Input[_builtins.str]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 operator: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] effect: Effect of the taint
        :param pulumi.Input[_builtins.str] key: Key of the taint
        :param pulumi.Input[_builtins.str] operator: Operator of the taint
        :param pulumi.Input[_builtins.str] value: Value of the taint. Optional.
        """
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Effect of the taint
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "effect", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Key of the taint
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Operator of the taint
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Value of the taint. Optional.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SecurityGroupEgressRuleArgsDict(TypedDict):
        ip_version: pulumi.Input[_builtins.str]
        """
        IP version of the rule (ipv4 or ipv6)
        """
        name: pulumi.Input[_builtins.str]
        """
        Name of the rule
        """
        policy: pulumi.Input[_builtins.str]
        """
        Policy of the rule (allow or drop)
        """
        priority: pulumi.Input[_builtins.int]
        """
        Priority of the rule. Must be greater than 0 and less than 200.
        """
        protocol: pulumi.Input[_builtins.str]
        """
        Protocol of the rule (all, tcp, udp, icmp)
        """
        remote_type: pulumi.Input[_builtins.str]
        """
        Type of the remote address (address or securityGroup)
        """
        port_range_max: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum port of the rule. Must be greater than 0 and less than 65535.
        """
        port_range_min: NotRequired[pulumi.Input[_builtins.int]]
        """
        Minimum port of the rule. Must be greater than 0 and less than 65535.
        """
        remote_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        IP address or CIDR block that the rule applies to
        """
        remote_security_group_identity: NotRequired[pulumi.Input[_builtins.str]]
        """
        Identity of the security group that the rule applies to
        """
elif False:
    SecurityGroupEgressRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityGroupEgressRuleArgs:
    def __init__(__self__, *,
                 ip_version: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 policy: pulumi.Input[_builtins.str],
                 priority: pulumi.Input[_builtins.int],
                 protocol: pulumi.Input[_builtins.str],
                 remote_type: pulumi.Input[_builtins.str],
                 port_range_max: Optional[pulumi.Input[_builtins.int]] = None,
                 port_range_min: Optional[pulumi.Input[_builtins.int]] = None,
                 remote_address: Optional[pulumi.Input[_builtins.str]] = None,
                 remote_security_group_identity: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ip_version: IP version of the rule (ipv4 or ipv6)
        :param pulumi.Input[_builtins.str] name: Name of the rule
        :param pulumi.Input[_builtins.str] policy: Policy of the rule (allow or drop)
        :param pulumi.Input[_builtins.int] priority: Priority of the rule. Must be greater than 0 and less than 200.
        :param pulumi.Input[_builtins.str] protocol: Protocol of the rule (all, tcp, udp, icmp)
        :param pulumi.Input[_builtins.str] remote_type: Type of the remote address (address or securityGroup)
        :param pulumi.Input[_builtins.int] port_range_max: Maximum port of the rule. Must be greater than 0 and less than 65535.
        :param pulumi.Input[_builtins.int] port_range_min: Minimum port of the rule. Must be greater than 0 and less than 65535.
        :param pulumi.Input[_builtins.str] remote_address: IP address or CIDR block that the rule applies to
        :param pulumi.Input[_builtins.str] remote_security_group_identity: Identity of the security group that the rule applies to
        """
        pulumi.set(__self__, "ip_version", ip_version)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "policy", policy)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "remote_type", remote_type)
        if port_range_max is not None:
            pulumi.set(__self__, "port_range_max", port_range_max)
        if port_range_min is not None:
            pulumi.set(__self__, "port_range_min", port_range_min)
        if remote_address is not None:
            pulumi.set(__self__, "remote_address", remote_address)
        if remote_security_group_identity is not None:
            pulumi.set(__self__, "remote_security_group_identity", remote_security_group_identity)

    @_builtins.property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> pulumi.Input[_builtins.str]:
        """
        IP version of the rule (ipv4 or ipv6)
        """
        return pulumi.get(self, "ip_version")

    @ip_version.setter
    def ip_version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip_version", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the rule
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def policy(self) -> pulumi.Input[_builtins.str]:
        """
        Policy of the rule (allow or drop)
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "policy", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        """
        Priority of the rule. Must be greater than 0 and less than 200.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[_builtins.str]:
        """
        Protocol of the rule (all, tcp, udp, icmp)
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="remoteType")
    def remote_type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of the remote address (address or securityGroup)
        """
        return pulumi.get(self, "remote_type")

    @remote_type.setter
    def remote_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "remote_type", value)

    @_builtins.property
    @pulumi.getter(name="portRangeMax")
    def port_range_max(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum port of the rule. Must be greater than 0 and less than 65535.
        """
        return pulumi.get(self, "port_range_max")

    @port_range_max.setter
    def port_range_max(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_range_max", value)

    @_builtins.property
    @pulumi.getter(name="portRangeMin")
    def port_range_min(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Minimum port of the rule. Must be greater than 0 and less than 65535.
        """
        return pulumi.get(self, "port_range_min")

    @port_range_min.setter
    def port_range_min(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_range_min", value)

    @_builtins.property
    @pulumi.getter(name="remoteAddress")
    def remote_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IP address or CIDR block that the rule applies to
        """
        return pulumi.get(self, "remote_address")

    @remote_address.setter
    def remote_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "remote_address", value)

    @_builtins.property
    @pulumi.getter(name="remoteSecurityGroupIdentity")
    def remote_security_group_identity(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Identity of the security group that the rule applies to
        """
        return pulumi.get(self, "remote_security_group_identity")

    @remote_security_group_identity.setter
    def remote_security_group_identity(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "remote_security_group_identity", value)


if not MYPY:
    class SecurityGroupIngressRuleArgsDict(TypedDict):
        ip_version: pulumi.Input[_builtins.str]
        """
        IP version of the rule (ipv4 or ipv6)
        """
        name: pulumi.Input[_builtins.str]
        """
        Name of the rule
        """
        policy: pulumi.Input[_builtins.str]
        """
        Policy of the rule (allow or drop)
        """
        priority: pulumi.Input[_builtins.int]
        """
        Priority of the rule. Must be greater than 0 and less than 200.
        """
        protocol: pulumi.Input[_builtins.str]
        """
        Protocol of the rule (all, tcp, udp, icmp)
        """
        remote_type: pulumi.Input[_builtins.str]
        """
        Type of the remote address (address or securityGroup)
        """
        port_range_max: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum port of the rule. Must be greater than 0 and less than 65535.
        """
        port_range_min: NotRequired[pulumi.Input[_builtins.int]]
        """
        Minimum port of the rule. Must be greater than 0 and less than 65535.
        """
        remote_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        IP address or CIDR block that the rule applies to
        """
        remote_security_group_identity: NotRequired[pulumi.Input[_builtins.str]]
        """
        Identity of the security group that the rule applies to
        """
elif False:
    SecurityGroupIngressRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityGroupIngressRuleArgs:
    def __init__(__self__, *,
                 ip_version: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 policy: pulumi.Input[_builtins.str],
                 priority: pulumi.Input[_builtins.int],
                 protocol: pulumi.Input[_builtins.str],
                 remote_type: pulumi.Input[_builtins.str],
                 port_range_max: Optional[pulumi.Input[_builtins.int]] = None,
                 port_range_min: Optional[pulumi.Input[_builtins.int]] = None,
                 remote_address: Optional[pulumi.Input[_builtins.str]] = None,
                 remote_security_group_identity: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ip_version: IP version of the rule (ipv4 or ipv6)
        :param pulumi.Input[_builtins.str] name: Name of the rule
        :param pulumi.Input[_builtins.str] policy: Policy of the rule (allow or drop)
        :param pulumi.Input[_builtins.int] priority: Priority of the rule. Must be greater than 0 and less than 200.
        :param pulumi.Input[_builtins.str] protocol: Protocol of the rule (all, tcp, udp, icmp)
        :param pulumi.Input[_builtins.str] remote_type: Type of the remote address (address or securityGroup)
        :param pulumi.Input[_builtins.int] port_range_max: Maximum port of the rule. Must be greater than 0 and less than 65535.
        :param pulumi.Input[_builtins.int] port_range_min: Minimum port of the rule. Must be greater than 0 and less than 65535.
        :param pulumi.Input[_builtins.str] remote_address: IP address or CIDR block that the rule applies to
        :param pulumi.Input[_builtins.str] remote_security_group_identity: Identity of the security group that the rule applies to
        """
        pulumi.set(__self__, "ip_version", ip_version)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "policy", policy)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "remote_type", remote_type)
        if port_range_max is not None:
            pulumi.set(__self__, "port_range_max", port_range_max)
        if port_range_min is not None:
            pulumi.set(__self__, "port_range_min", port_range_min)
        if remote_address is not None:
            pulumi.set(__self__, "remote_address", remote_address)
        if remote_security_group_identity is not None:
            pulumi.set(__self__, "remote_security_group_identity", remote_security_group_identity)

    @_builtins.property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> pulumi.Input[_builtins.str]:
        """
        IP version of the rule (ipv4 or ipv6)
        """
        return pulumi.get(self, "ip_version")

    @ip_version.setter
    def ip_version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip_version", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the rule
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def policy(self) -> pulumi.Input[_builtins.str]:
        """
        Policy of the rule (allow or drop)
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "policy", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        """
        Priority of the rule. Must be greater than 0 and less than 200.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[_builtins.str]:
        """
        Protocol of the rule (all, tcp, udp, icmp)
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="remoteType")
    def remote_type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of the remote address (address or securityGroup)
        """
        return pulumi.get(self, "remote_type")

    @remote_type.setter
    def remote_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "remote_type", value)

    @_builtins.property
    @pulumi.getter(name="portRangeMax")
    def port_range_max(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum port of the rule. Must be greater than 0 and less than 65535.
        """
        return pulumi.get(self, "port_range_max")

    @port_range_max.setter
    def port_range_max(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_range_max", value)

    @_builtins.property
    @pulumi.getter(name="portRangeMin")
    def port_range_min(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Minimum port of the rule. Must be greater than 0 and less than 65535.
        """
        return pulumi.get(self, "port_range_min")

    @port_range_min.setter
    def port_range_min(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_range_min", value)

    @_builtins.property
    @pulumi.getter(name="remoteAddress")
    def remote_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IP address or CIDR block that the rule applies to
        """
        return pulumi.get(self, "remote_address")

    @remote_address.setter
    def remote_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "remote_address", value)

    @_builtins.property
    @pulumi.getter(name="remoteSecurityGroupIdentity")
    def remote_security_group_identity(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Identity of the security group that the rule applies to
        """
        return pulumi.get(self, "remote_security_group_identity")

    @remote_security_group_identity.setter
    def remote_security_group_identity(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "remote_security_group_identity", value)


if not MYPY:
    class TargetGroupAttachmentArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of the target (e.g. instance ID)
        """
elif False:
    TargetGroupAttachmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetGroupAttachmentArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the target (e.g. instance ID)
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the target (e.g. instance ID)
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


