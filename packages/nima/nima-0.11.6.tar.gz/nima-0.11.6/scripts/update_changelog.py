#!/usr/bin/env python
import argparse
import os
import re

# Matches lines like:
# - *(deps)* Bump xmltodict from 1.0.0 to 1.0.2 (#123)
# - *(deps)* Bump actions/checkout action from v4 to v5 (#1187)
# - *(hooks)* Bump pre-commit hook executablebooks/mdformat from 0.7.17 to 0.7.22 (#1065)
PAT = re.compile(
    r"^(\s*-\s*)"  # 1: bullet + spaces
    r"(\*?\(([^)]+)\)\*?)\s*"  # 2: tag with optional asterisks; 3: inner tag (deps/docs/...)
    r"Bump\s+"
    r"(?:(?:pre-commit\s+hook)\s+)?"  # optional phrase
    r"(\S+?)"  # 4: package name
    r"(?:\s+action)?\s+"  # optional " action"
    r"from\s+(\S+)\s+to\s+(\S+)"  # 5: from, 6: to
    r".*?$"  # rest (PR, etc.)
)


def norm_tuple(v: str) -> tuple[int, ...]:
    s = v.lstrip("vV")
    parts = re.split(r"[.\-+_]", s)
    out = []
    for p in parts:
        m = re.match(r"(\d+)", p)
        if m:
            out.append(int(m.group(1)))
        else:
            break
    return tuple(out) if out else (0,)


def condense_bumps(lines: list[str], allowed_tags: set) -> list[str]:
    # Aggregate min(from), max(to) per (tag, pkg)
    agg = {}
    for idx, line in enumerate(lines):
        m = PAT.match(line)
        if not m:
            continue
        bullet, tag_text, tag, pkg, v_from, v_to = m.groups()
        if tag not in allowed_tags:
            continue
        k_from = norm_tuple(v_from)
        k_to = norm_tuple(v_to)
        key = (tag, pkg)
        if key not in agg:
            agg[key] = {
                "first_idx": idx,
                "bullet": bullet,
                "tag_text": tag_text,
                "min_from": v_from,
                "min_key": k_from,
                "max_to": v_to,
                "max_key": k_to,
            }
        else:
            if k_from < agg[key]["min_key"]:
                agg[key]["min_from"] = v_from
                agg[key]["min_key"] = k_from
            if k_to > agg[key]["max_key"]:
                agg[key]["max_to"] = v_to
                agg[key]["max_key"] = k_to

    seen = set()
    out: list[str] = []
    for idx, line in enumerate(lines):
        m = PAT.match(line)
        if not m:
            out.append(line)
            continue

        bullet, tag_text, tag, pkg, _vf, _vt = m.groups()
        if tag not in allowed_tags:
            out.append(line)
            continue

        key = (tag, pkg)
        if key in seen:
            continue
        seen.add(key)

        info = agg[key]
        # Keep the first occurrence position if possible
        if idx == info["first_idx"]:
            out.append(
                f"{info['bullet']}{info['tag_text']} Bump {pkg} from {info['min_from']} to {info['max_to']}\n"
            )
        else:
            out.append(
                f"{bullet}{tag_text} Bump {pkg} from {info['min_from']} to {info['max_to']}\n"
            )

    return out


def read_lines(path: str) -> list[str]:
    with open(path, encoding="utf-8") as f:
        return f.readlines()


def write_text(path: str, text: str) -> None:
    with open(path, "w", encoding="utf-8") as f:
        f.write(text)


def insert_section_at_top(changelog_lines: list[str], section: list[str]) -> list[str]:
    """
    Insert the new release section just before the first '## ' heading, i.e.,
    right after the title/header at the top. If no '## ' is found, append.
    Ensures one blank line around the inserted section.
    """
    # Find the first release header
    first_release_idx = next(
        (i for i, ln in enumerate(changelog_lines) if ln.startswith("## ")), None
    )

    # Default insertion index: before the first '## ', else end of file
    insert_idx = (
        first_release_idx if first_release_idx is not None else len(changelog_lines)
    )

    # Ensure the changelog starts with a title; if not, do not try to preserve 3-line header
    # But if it does (e.g., "# Changelog\n\n"), this will place the new section after it.
    # Normalize spacing: ensure exactly one blank line before and after the inserted section.
    before = changelog_lines[:insert_idx]
    after = changelog_lines[insert_idx:]

    if before and before[-1].strip() != "":
        before.append("\n")
    if section and section[-1].strip() != "":
        section = [*section, "\n"]
    if after and after[0].strip() != "":
        section = [*section, "\n"]

    return before + section + after


def main() -> None:
    ap = argparse.ArgumentParser(
        description="Condense bump entries and insert the new release notes at the top of CHANGELOG.md."
    )
    ap.add_argument(
        "--raw",
        required=True,
        help="Path to RELEASE_RAW.md generated by git-cliff (should include the '## [x.y.z] - date' line).",
    )
    ap.add_argument(
        "--changelog", required=True, help="Path to CHANGELOG.md to update."
    )
    ap.add_argument(
        "--tags",
        default=os.environ.get("CONDENSE_TAGS", "deps"),
        help="Comma-separated tags to condense (default: deps). Example: deps,docs,hooks",
    )
    ap.add_argument(
        "--strip-header",
        type=int,
        default=2,
        help="Drop this many header lines from raw notes before condensing (default: 0 for changelog insertion).",
    )
    args = ap.parse_args()

    allowed_tags = {t.strip() for t in args.tags.split(",") if t.strip()}

    # Read and prep new notes
    raw_lines = read_lines(args.raw)
    body = raw_lines[args.strip_header :] if args.strip_header > 0 else raw_lines
    new_section = condense_bumps(body, allowed_tags)

    # Ensure new-section ends with a newline
    if new_section and new_section[-1].strip() != "":
        new_section.append("\n")

    # Read existing changelog and insert
    changelog_lines = (
        read_lines(args.changelog)
        if os.path.exists(args.changelog)
        else ["# Changelog\n", "\n"]
    )
    updated = insert_section_at_top(changelog_lines, new_section)

    write_text(args.changelog, "".join(updated))


if __name__ == "__main__":
    main()
