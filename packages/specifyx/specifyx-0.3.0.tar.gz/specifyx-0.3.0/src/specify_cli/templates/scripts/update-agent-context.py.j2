#!/usr/bin/env python3
"""
Update AI assistant context file with new technical information from current plan.

This script reads the current implementation plan and updates the assistant's
context file with new technical stack information, preserving existing content
and manual additions between markers.

Generated by SpecifyX init command for {{ ai_assistant }}.
"""

import json
import re
from pathlib import Path
from typing import Any, Dict

import typer
from rich.console import Console

from specify_cli.assistants import get_assistant
from specify_cli.services.memory_service import MemoryManager
from specify_cli.utils.script_helpers import ScriptHelpers

app = typer.Typer(add_completion=False)
console = Console()


# Note: extract_spec_context is now provided by ScriptHelpers.extract_spec_context()
# This reduces code duplication and improves maintainability


def generate_custom_reminders(context_info: Dict[str, Any]) -> str:
    """
    Generate custom reminders based on project state.

    Users can edit this function to customize reminders for their workflow.
    """
    reminders = []

    # Task completion reminders
    if context_info.get("current_tasks"):
        reminders.append(
            "**Remember**: Mark tasks as done by changing `- [ ]` to `- [x]` in tasks.md"
        )

    # Phase-specific reminders
    current_phase = context_info.get("current_phase", "")
    if "Implementation" in current_phase:
        reminders.append(
            "**TDD Reminder**: Write tests first, ensure they fail, then implement (Red-Green-Refactor)"
        )

    if context_info.get("progress", {}).get("tasks"):
        progress = context_info["progress"]["tasks"]
        if progress and not progress.startswith("0/"):
            reminders.append(
                "**Progress Tip**: Update plan.md checkboxes as you complete implementation phases"
            )

    # File-specific reminders
    files = context_info.get("files", [])
    if "tasks.md" in files and "plan.md" in files:
        reminders.append(
            "**Workflow**: tasks.md contains specific todos, plan.md tracks overall phases"
        )

    return "\n".join(reminders) if reminders else ""


def update_context_file(
    context_file: Path, context_info: Dict[str, Any], assistant_type: str
) -> bool:
    """Update the assistant context file with comprehensive project context."""
    if not context_file.exists():
        console.print(f"[yellow]Context file not found: {context_file}[/yellow]")
        return False

    content = context_file.read_text()

    # Check if assistant supports imports
    try:
        assistant_provider = get_assistant(assistant_type)
        supports_imports = (
            assistant_provider.imports_supported if assistant_provider else False
        )
    except Exception:
        supports_imports = False

    # Use ScriptHelpers to build enhanced context sections
    helpers = ScriptHelpers()
    sections, _ = helpers.build_context_sections(context_info, supports_imports)

    # Generate custom reminders using the user-customizable function
    reminders = generate_custom_reminders(context_info)

    if not sections:
        console.print("[yellow]No project context found to add[/yellow]")
        return False

    # Build enhanced context section with reminders
    context_content = chr(10).join(sections)
    if reminders:
        context_content += f"\n\n{reminders}"

    new_context_section = f"""<!-- PROJECT_CONTEXT_START -->
## Current Project Context
{context_content}

*Auto-updated from spec files*
<!-- PROJECT_CONTEXT_END -->"""

    # Replace or add context section
    context_pattern = r"(<!-- PROJECT_CONTEXT_START -->.*?<!-- PROJECT_CONTEXT_END -->)"
    if re.search(context_pattern, content, re.DOTALL):
        updated_content = re.sub(
            context_pattern, new_context_section, content, flags=re.DOTALL
        )
    else:
        if content.strip().endswith("---"):
            updated_content = (
                content.rsplit("---", 1)[0].rstrip()
                + "\n\n"
                + new_context_section
                + "\n\n---"
            )
        else:
            updated_content = content.rstrip() + "\n\n" + new_context_section + "\n"

    context_file.write_text(updated_content)
    console.print(
        f"[green]Updated {context_file.name} with comprehensive project context[/green]"
    )
    return True


@app.command()
def main(
    assistant: str = typer.Argument(help="AI assistant type ({{ ai_assistant }})"),
    debug: bool = typer.Option(False, "--debug", help="Enable debug output"),
    json_output: bool = typer.Option(False, "--json", help="Output results as JSON"),
):
    """Update AI assistant context file with technical information from current plan."""

    def echo_info(msg: str):
        if not json_output:
            console.print(f"[blue]ℹ[/blue] {msg}")

    def echo_error(msg: str):
        if not json_output:
            console.print(f"[red]✗[/red] {msg}")

    def echo_debug(msg: str, debug_mode: bool = False):
        if debug_mode and not json_output:
            console.print(f"[dim]DEBUG: {msg}[/dim]")

    try:
        # Validate assistant type
        if assistant != "{{ ai_assistant }}":
            if json_output:
                print(json.dumps({"error": f"Unsupported assistant type: {assistant}"}))
            else:
                echo_error(
                    f"This script is configured for {{ ai_assistant }}, got: {assistant}"
                )
            raise typer.Exit(1) from None

        # Find current feature directory and plan
        helpers = ScriptHelpers()

        # Find spec directory with any spec files
        cwd = Path.cwd()
        spec_dir = None

        # Check if we're in a spec directory
        if (cwd / "spec.md").exists() or (cwd / "plan.md").exists():
            spec_dir = cwd
        else:
            # Look for most recent spec directory
            spec_dirs = []
            for pattern in ["specs/*/", "features/*/", "*/specs/"]:
                spec_dirs.extend(cwd.glob(pattern))

            # Filter to directories with spec files and find most recent
            valid_dirs = []
            for d in spec_dirs:
                if any((d / f).exists() for f in ["spec.md", "plan.md", "tasks.md"]):
                    # Get the most recently modified spec file
                    spec_files = [
                        f
                        for f in [d / "spec.md", d / "plan.md", d / "tasks.md"]
                        if f.exists()
                    ]
                    if spec_files:
                        recent_time = max(f.stat().st_mtime for f in spec_files)
                        valid_dirs.append((d, recent_time))

            if valid_dirs:
                # Use most recently modified spec directory
                spec_dir = max(valid_dirs, key=lambda x: x[1])[0]

        if not spec_dir:
            if json_output:
                print(json.dumps({"error": "No spec directory found with spec files"}))
            else:
                echo_error("No spec directory found")
                echo_info(
                    "Run this from a spec directory or after running /specify, /plan, or /tasks commands"
                )
            raise typer.Exit(1) from None

        echo_debug(f"Found spec directory: {spec_dir}", debug)

        # Extract comprehensive context from spec files using ScriptHelpers
        helpers = ScriptHelpers()
        context_info = helpers.extract_spec_context(spec_dir)

        echo_debug(f"Extracted context info: {context_info}", debug)

        # Get context file path from assistant registry (no hardcoding!)
        try:
            assistant_provider = get_assistant("{{ ai_assistant }}")
            if not assistant_provider:
                raise ValueError("Assistant not found")

            # Get the context file path from assistant config
            context_file_path = assistant_provider.config.context_file.file

            # Find context file (the config file path is relative to repo root)
            repo_root = helpers.get_repo_root()
            context_file = repo_root / context_file_path

        except Exception as e:
            error_msg = f"Failed to get context file for {{ ai_assistant }}: {e}"
            if json_output:
                print(json.dumps({"error": error_msg}))
            else:
                echo_error(error_msg)
            raise typer.Exit(1) from None

        echo_debug(f"Context file path: {context_file}", debug)

        # Update context file
        success = update_context_file(context_file, context_info, "{{ ai_assistant }}")

        # If context updated successfully, refresh memory imports
        memory_updated = False
        try:
            assistant_provider = get_assistant("{{ ai_assistant }}")
            supports_imports = (
                assistant_provider.imports_supported if assistant_provider else False
            )
        except Exception:
            supports_imports = False

        if success and supports_imports:
            try:
                echo_debug("Refreshing memory service imports...", debug)
                memory_manager = MemoryManager(repo_root)

                # Get available memory files and generate import section
                import_section = memory_manager.generate_import_section(
                    ai_assistant="{{ ai_assistant }}",
                    context_file_dir=context_file.parent,
                )

                if import_section:
                    # Read current content and update the Project Memory section
                    current_content = context_file.read_text()

                    # Replace or add Project Memory section
                    memory_pattern = r"## Project Memory\n.*?(?=\n##|\n---|\Z)"
                    new_memory_section = f"## Project Memory\n{import_section}"

                    if re.search(memory_pattern, current_content, re.DOTALL):
                        updated_content = re.sub(
                            memory_pattern,
                            new_memory_section,
                            current_content,
                            flags=re.DOTALL,
                        )
                    else:
                        # Add before the final --- if it exists
                        if current_content.strip().endswith("---"):
                            updated_content = (
                                current_content.rsplit("---", 1)[0].rstrip()
                                + "\n\n"
                                + new_memory_section
                                + "\n\n---"
                            )
                        else:
                            updated_content = (
                                current_content.rstrip()
                                + "\n\n"
                                + new_memory_section
                                + "\n"
                            )

                    context_file.write_text(updated_content)
                    memory_updated = True
                    echo_debug("Memory imports refreshed successfully", debug)
                else:
                    echo_debug("No memory files available for import", debug)

            except Exception as e:
                echo_debug(f"Memory service error (non-fatal): {e}", debug)

        if json_output:
            result = {
                "success": success,
                "spec_dir": str(spec_dir),
                "context_file": str(context_file),
                "context_info": context_info,
                "memory_updated": memory_updated,
            }
            print(json.dumps(result))
        elif success:
            if memory_updated:
                echo_info(
                    f"Successfully updated {context_file.name} with project context and refreshed memory imports"
                )
            else:
                echo_info(
                    f"Successfully updated {context_file.name} with project context from {spec_dir.name}"
                )
        else:
            echo_error("Failed to update context file")
            raise typer.Exit(1) from None

    except Exception as e:
        if json_output:
            print(json.dumps({"error": str(e)}))
        else:
            echo_error(f"Error updating agent context: {e}")
        raise typer.Exit(1) from None


if __name__ == "__main__":
    app()
