"""
Exploitation category implementation for HATS framework.
Handles exploitation tools and frameworks.
"""

import re
from typing import Dict, List, Optional
from ..utils.logger import get_logger


class ExploitationCategory:
    """Handles exploitation tools like Metasploit, sqlmap, etc."""
    
    def __init__(self):
        """Initialize the exploitation category."""
        self.logger = get_logger(__name__)
        self.category = "exploitation"
    
    def parse_metasploit_output(self, output: str) -> Dict:
        """
        Parse Metasploit console output.
        
        Args:
            output (str): Raw Metasploit output
            
        Returns:
            Dict: Parsed exploitation results
        """
        results = {
            'sessions': [],
            'exploits_used': [],
            'payloads': [],
            'targets': [],
            'success': False
        }
        
        lines = output.split('\n')
        
        for line in lines:
            line = line.strip()
            
            # Extract session information
            if 'session' in line.lower() and 'opened' in line.lower():
                session_match = re.search(r'session (\d+) opened', line, re.IGNORECASE)
                if session_match:
                    results['sessions'].append(session_match.group(1))
                    results['success'] = True
            
            # Extract exploit information
            if line.startswith('[*] Using exploit'):
                exploit_match = re.search(r'Using exploit (.+)', line)
                if exploit_match:
                    results['exploits_used'].append(exploit_match.group(1))
            
            # Extract payload information
            if 'payload' in line.lower():
                payload_match = re.search(r'payload (.+)', line, re.IGNORECASE)
                if payload_match:
                    results['payloads'].append(payload_match.group(1))
        
        return results
    
    def parse_sqlmap_output(self, output: str) -> Dict:
        """
        Parse sqlmap output for SQL injection results.
        
        Args:
            output (str): Raw sqlmap output
            
        Returns:
            Dict: Parsed SQL injection results
        """
        results = {
            'vulnerable': False,
            'injection_type': [],
            'databases': [],
            'tables': [],
            'columns': [],
            'data': []
        }
        
        lines = output.split('\n')
        
        for line in lines:
            line = line.strip()
            
            # Check if vulnerable
            if 'is vulnerable' in line.lower():
                results['vulnerable'] = True
            
            # Extract injection types
            if 'Type:' in line:
                injection_match = re.search(r'Type:\s+(.+)', line)
                if injection_match:
                    results['injection_type'].append(injection_match.group(1))
            
            # Extract databases
            if 'available databases' in line.lower():
                db_match = re.findall(r"'([^']+)'", line)
                results['databases'].extend(db_match)
            
            # Extract tables
            if 'Database:' in line and 'Table:' in line:
                table_match = re.search(r'Table:\s+(\w+)', line)
                if table_match:
                    results['tables'].append(table_match.group(1))
        
        return results
    
    def generate_metasploit_command(self, exploit: str, target: str, 
                                  payload: str = None, options: Dict = None) -> List[str]:
        """
        Generate Metasploit command.
        
        Args:
            exploit (str): Exploit module to use
            target (str): Target IP/hostname
            payload (str): Payload to use
            options (Dict): Additional options
            
        Returns:
            List[str]: Command as list of strings
        """
        commands = []
        
        # Use exploit
        commands.append(f"use {exploit}")
        
        # Set target
        commands.append(f"set RHOSTS {target}")
        
        # Set payload if specified
        if payload:
            commands.append(f"set PAYLOAD {payload}")
        
        # Set additional options
        if options:
            for key, value in options.items():
                commands.append(f"set {key} {value}")
        
        # Run exploit
        commands.append("exploit")
        
        return commands
    
    def generate_sqlmap_command(self, url: str, data: str = None, 
                              cookie: str = None, level: int = 1, 
                              risk: int = 1) -> List[str]:
        """
        Generate sqlmap command for SQL injection testing.
        
        Args:
            url (str): Target URL
            data (str): POST data
            cookie (str): Cookie string
            level (int): Level of tests (1-5)
            risk (int): Risk of tests (1-3)
            
        Returns:
            List[str]: Command as list of strings
        """
        command = ['sqlmap', '-u', url]
        
        # Add POST data
        if data:
            command.extend(['--data', data])
        
        # Add cookie
        if cookie:
            command.extend(['--cookie', cookie])
        
        # Add level and risk
        command.extend(['--level', str(level)])
        command.extend(['--risk', str(risk)])
        
        # Add common options
        command.extend(['--batch', '--random-agent'])
        
        return command
    
    def get_common_exploits(self) -> Dict[str, List[str]]:
        """
        Get common exploit modules by service.
        
        Returns:
            Dict[str, List[str]]: Exploit modules by service
        """
        return {
            'web': [
                'exploit/multi/http/struts2_content_type_ognl',
                'exploit/multi/http/apache_struts2_rest_xstream',
                'exploit/multi/http/php_cgi_arg_injection'
            ],
            'windows': [
                'exploit/windows/smb/ms17_010_eternalblue',
                'exploit/windows/smb/ms08_067_netapi',
                'exploit/windows/dcerpc/ms03_026_dcom'
            ],
            'linux': [
                'exploit/linux/local/dirty_cow',
                'exploit/linux/http/apache_mod_cgi_bash_env_exec',
                'exploit/linux/samba/is_known_pipename'
            ],
            'database': [
                'exploit/windows/mssql/ms02_056_hello',
                'exploit/linux/mysql/mysql_yassl_hello',
                'exploit/multi/postgres/postgres_copy_from_program_cmd_exec'
            ]
        }
    
    def get_common_payloads(self) -> Dict[str, List[str]]:
        """
        Get common payload options by platform.
        
        Returns:
            Dict[str, List[str]]: Payloads by platform
        """
        return {
            'windows': [
                'windows/meterpreter/reverse_tcp',
                'windows/meterpreter/reverse_https',
                'windows/shell/reverse_tcp'
            ],
            'linux': [
                'linux/x86/meterpreter/reverse_tcp',
                'linux/x64/meterpreter/reverse_tcp',
                'linux/x86/shell/reverse_tcp'
            ],
            'web': [
                'php/meterpreter/reverse_tcp',
                'java/jsp_shell_reverse_tcp',
                'python/meterpreter/reverse_tcp'
            ]
        }
    
    def validate_exploit_parameters(self, exploit: str, target: str) -> List[str]:
        """
        Validate exploit parameters.
        
        Args:
            exploit (str): Exploit module
            target (str): Target address
            
        Returns:
            List[str]: List of validation errors
        """
        errors = []
        
        # Validate exploit format
        if not exploit.startswith('exploit/'):
            errors.append("Exploit must start with 'exploit/'")
        
        # Validate target format (basic IP validation)
        ip_pattern = r'^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$'
        hostname_pattern = r'^[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?)*$'
        
        if not (re.match(ip_pattern, target) or re.match(hostname_pattern, target)):
            errors.append("Invalid target format")
        
        return errors
