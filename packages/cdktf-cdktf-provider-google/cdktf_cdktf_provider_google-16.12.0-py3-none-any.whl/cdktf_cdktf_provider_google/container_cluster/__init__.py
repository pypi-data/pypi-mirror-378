r'''
# `google_container_cluster`

Refer to the Terraform Registry for docs: [`google_container_cluster`](https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster).
'''
from pkgutil import extend_path
__path__ = extend_path(__path__, __name__)

import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

import typeguard
from importlib.metadata import version as _metadata_package_version
TYPEGUARD_MAJOR_VERSION = int(_metadata_package_version('typeguard').split('.')[0])

def check_type(argname: str, value: object, expected_type: typing.Any) -> typing.Any:
    if TYPEGUARD_MAJOR_VERSION <= 2:
        return typeguard.check_type(argname=argname, value=value, expected_type=expected_type) # type:ignore
    else:
        if isinstance(value, jsii._reference_map.InterfaceDynamicProxy): # pyright: ignore [reportAttributeAccessIssue]
           pass
        else:
            if TYPEGUARD_MAJOR_VERSION == 3:
                typeguard.config.collection_check_strategy = typeguard.CollectionCheckStrategy.ALL_ITEMS # type:ignore
                typeguard.check_type(value=value, expected_type=expected_type) # type:ignore
            else:
                typeguard.check_type(value=value, expected_type=expected_type, collection_check_strategy=typeguard.CollectionCheckStrategy.ALL_ITEMS) # type:ignore

from .._jsii import *

import cdktf as _cdktf_9a9027ec
import constructs as _constructs_77d1e7e8


class ContainerCluster(
    _cdktf_9a9027ec.TerraformResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerCluster",
):
    '''Represents a {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster google_container_cluster}.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id_: builtins.str,
        *,
        name: builtins.str,
        addons_config: typing.Optional[typing.Union["ContainerClusterAddonsConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        allow_net_admin: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        anonymous_authentication_config: typing.Optional[typing.Union["ContainerClusterAnonymousAuthenticationConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        authenticator_groups_config: typing.Optional[typing.Union["ContainerClusterAuthenticatorGroupsConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        binary_authorization: typing.Optional[typing.Union["ContainerClusterBinaryAuthorization", typing.Dict[builtins.str, typing.Any]]] = None,
        cluster_autoscaling: typing.Optional[typing.Union["ContainerClusterClusterAutoscaling", typing.Dict[builtins.str, typing.Any]]] = None,
        cluster_ipv4_cidr: typing.Optional[builtins.str] = None,
        confidential_nodes: typing.Optional[typing.Union["ContainerClusterConfidentialNodes", typing.Dict[builtins.str, typing.Any]]] = None,
        control_plane_endpoints_config: typing.Optional[typing.Union["ContainerClusterControlPlaneEndpointsConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        cost_management_config: typing.Optional[typing.Union["ContainerClusterCostManagementConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        database_encryption: typing.Optional[typing.Union["ContainerClusterDatabaseEncryption", typing.Dict[builtins.str, typing.Any]]] = None,
        datapath_provider: typing.Optional[builtins.str] = None,
        default_max_pods_per_node: typing.Optional[jsii.Number] = None,
        default_snat_status: typing.Optional[typing.Union["ContainerClusterDefaultSnatStatus", typing.Dict[builtins.str, typing.Any]]] = None,
        deletion_protection: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        description: typing.Optional[builtins.str] = None,
        disable_l4_lb_firewall_reconciliation: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        dns_config: typing.Optional[typing.Union["ContainerClusterDnsConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        enable_autopilot: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        enable_cilium_clusterwide_network_policy: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        enable_fqdn_network_policy: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        enable_intranode_visibility: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        enable_k8_s_beta_apis: typing.Optional[typing.Union["ContainerClusterEnableK8SBetaApis", typing.Dict[builtins.str, typing.Any]]] = None,
        enable_kubernetes_alpha: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        enable_l4_ilb_subsetting: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        enable_legacy_abac: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        enable_multi_networking: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        enable_shielded_nodes: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        enable_tpu: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        enterprise_config: typing.Optional[typing.Union["ContainerClusterEnterpriseConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        fleet: typing.Optional[typing.Union["ContainerClusterFleet", typing.Dict[builtins.str, typing.Any]]] = None,
        gateway_api_config: typing.Optional[typing.Union["ContainerClusterGatewayApiConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        gke_auto_upgrade_config: typing.Optional[typing.Union["ContainerClusterGkeAutoUpgradeConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        id: typing.Optional[builtins.str] = None,
        identity_service_config: typing.Optional[typing.Union["ContainerClusterIdentityServiceConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        initial_node_count: typing.Optional[jsii.Number] = None,
        in_transit_encryption_config: typing.Optional[builtins.str] = None,
        ip_allocation_policy: typing.Optional[typing.Union["ContainerClusterIpAllocationPolicy", typing.Dict[builtins.str, typing.Any]]] = None,
        location: typing.Optional[builtins.str] = None,
        logging_config: typing.Optional[typing.Union["ContainerClusterLoggingConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        logging_service: typing.Optional[builtins.str] = None,
        maintenance_policy: typing.Optional[typing.Union["ContainerClusterMaintenancePolicy", typing.Dict[builtins.str, typing.Any]]] = None,
        master_auth: typing.Optional[typing.Union["ContainerClusterMasterAuth", typing.Dict[builtins.str, typing.Any]]] = None,
        master_authorized_networks_config: typing.Optional[typing.Union["ContainerClusterMasterAuthorizedNetworksConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        mesh_certificates: typing.Optional[typing.Union["ContainerClusterMeshCertificates", typing.Dict[builtins.str, typing.Any]]] = None,
        min_master_version: typing.Optional[builtins.str] = None,
        monitoring_config: typing.Optional[typing.Union["ContainerClusterMonitoringConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        monitoring_service: typing.Optional[builtins.str] = None,
        network: typing.Optional[builtins.str] = None,
        networking_mode: typing.Optional[builtins.str] = None,
        network_performance_config: typing.Optional[typing.Union["ContainerClusterNetworkPerformanceConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        network_policy: typing.Optional[typing.Union["ContainerClusterNetworkPolicy", typing.Dict[builtins.str, typing.Any]]] = None,
        node_config: typing.Optional[typing.Union["ContainerClusterNodeConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        node_locations: typing.Optional[typing.Sequence[builtins.str]] = None,
        node_pool: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ContainerClusterNodePool", typing.Dict[builtins.str, typing.Any]]]]] = None,
        node_pool_auto_config: typing.Optional[typing.Union["ContainerClusterNodePoolAutoConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        node_pool_defaults: typing.Optional[typing.Union["ContainerClusterNodePoolDefaults", typing.Dict[builtins.str, typing.Any]]] = None,
        node_version: typing.Optional[builtins.str] = None,
        notification_config: typing.Optional[typing.Union["ContainerClusterNotificationConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        pod_autoscaling: typing.Optional[typing.Union["ContainerClusterPodAutoscaling", typing.Dict[builtins.str, typing.Any]]] = None,
        private_cluster_config: typing.Optional[typing.Union["ContainerClusterPrivateClusterConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        private_ipv6_google_access: typing.Optional[builtins.str] = None,
        project: typing.Optional[builtins.str] = None,
        rbac_binding_config: typing.Optional[typing.Union["ContainerClusterRbacBindingConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        release_channel: typing.Optional[typing.Union["ContainerClusterReleaseChannel", typing.Dict[builtins.str, typing.Any]]] = None,
        remove_default_node_pool: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        resource_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        resource_usage_export_config: typing.Optional[typing.Union["ContainerClusterResourceUsageExportConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        secret_manager_config: typing.Optional[typing.Union["ContainerClusterSecretManagerConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        security_posture_config: typing.Optional[typing.Union["ContainerClusterSecurityPostureConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        service_external_ips_config: typing.Optional[typing.Union["ContainerClusterServiceExternalIpsConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        subnetwork: typing.Optional[builtins.str] = None,
        timeouts: typing.Optional[typing.Union["ContainerClusterTimeouts", typing.Dict[builtins.str, typing.Any]]] = None,
        user_managed_keys_config: typing.Optional[typing.Union["ContainerClusterUserManagedKeysConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        vertical_pod_autoscaling: typing.Optional[typing.Union["ContainerClusterVerticalPodAutoscaling", typing.Dict[builtins.str, typing.Any]]] = None,
        workload_identity_config: typing.Optional[typing.Union["ContainerClusterWorkloadIdentityConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''Create a new {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster google_container_cluster} Resource.

        :param scope: The scope in which to define this construct.
        :param id_: The scoped construct ID. Must be unique amongst siblings in the same scope
        :param name: The name of the cluster, unique within the project and location. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#name ContainerCluster#name}
        :param addons_config: addons_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#addons_config ContainerCluster#addons_config}
        :param allow_net_admin: Enable NET_ADMIN for this cluster. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#allow_net_admin ContainerCluster#allow_net_admin}
        :param anonymous_authentication_config: anonymous_authentication_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#anonymous_authentication_config ContainerCluster#anonymous_authentication_config}
        :param authenticator_groups_config: authenticator_groups_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#authenticator_groups_config ContainerCluster#authenticator_groups_config}
        :param binary_authorization: binary_authorization block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#binary_authorization ContainerCluster#binary_authorization}
        :param cluster_autoscaling: cluster_autoscaling block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cluster_autoscaling ContainerCluster#cluster_autoscaling}
        :param cluster_ipv4_cidr: The IP address range of the Kubernetes pods in this cluster in CIDR notation (e.g. 10.96.0.0/14). Leave blank to have one automatically chosen or specify a /14 block in 10.0.0.0/8. This field will only work for routes-based clusters, where ip_allocation_policy is not defined. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cluster_ipv4_cidr ContainerCluster#cluster_ipv4_cidr}
        :param confidential_nodes: confidential_nodes block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#confidential_nodes ContainerCluster#confidential_nodes}
        :param control_plane_endpoints_config: control_plane_endpoints_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#control_plane_endpoints_config ContainerCluster#control_plane_endpoints_config}
        :param cost_management_config: cost_management_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cost_management_config ContainerCluster#cost_management_config}
        :param database_encryption: database_encryption block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#database_encryption ContainerCluster#database_encryption}
        :param datapath_provider: The desired datapath provider for this cluster. By default, uses the IPTables-based kube-proxy implementation. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#datapath_provider ContainerCluster#datapath_provider}
        :param default_max_pods_per_node: The default maximum number of pods per node in this cluster. This doesn't work on "routes-based" clusters, clusters that don't have IP Aliasing enabled. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#default_max_pods_per_node ContainerCluster#default_max_pods_per_node}
        :param default_snat_status: default_snat_status block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#default_snat_status ContainerCluster#default_snat_status}
        :param deletion_protection: When the field is set to true or unset in Terraform state, a terraform apply or terraform destroy that would delete the cluster will fail. When the field is set to false, deleting the cluster is allowed. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#deletion_protection ContainerCluster#deletion_protection}
        :param description: Description of the cluster. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#description ContainerCluster#description}
        :param disable_l4_lb_firewall_reconciliation: Disable L4 load balancer VPC firewalls to enable firewall policies. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#disable_l4_lb_firewall_reconciliation ContainerCluster#disable_l4_lb_firewall_reconciliation}
        :param dns_config: dns_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#dns_config ContainerCluster#dns_config}
        :param enable_autopilot: Enable Autopilot for this cluster. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_autopilot ContainerCluster#enable_autopilot}
        :param enable_cilium_clusterwide_network_policy: Whether Cilium cluster-wide network policy is enabled on this cluster. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_cilium_clusterwide_network_policy ContainerCluster#enable_cilium_clusterwide_network_policy}
        :param enable_fqdn_network_policy: Whether FQDN Network Policy is enabled on this cluster. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_fqdn_network_policy ContainerCluster#enable_fqdn_network_policy}
        :param enable_intranode_visibility: Whether Intra-node visibility is enabled for this cluster. This makes same node pod to pod traffic visible for VPC network. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_intranode_visibility ContainerCluster#enable_intranode_visibility}
        :param enable_k8_s_beta_apis: enable_k8s_beta_apis block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_k8s_beta_apis ContainerCluster#enable_k8s_beta_apis}
        :param enable_kubernetes_alpha: Whether to enable Kubernetes Alpha features for this cluster. Note that when this option is enabled, the cluster cannot be upgraded and will be automatically deleted after 30 days. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_kubernetes_alpha ContainerCluster#enable_kubernetes_alpha}
        :param enable_l4_ilb_subsetting: Whether L4ILB Subsetting is enabled for this cluster. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_l4_ilb_subsetting ContainerCluster#enable_l4_ilb_subsetting}
        :param enable_legacy_abac: Whether the ABAC authorizer is enabled for this cluster. When enabled, identities in the system, including service accounts, nodes, and controllers, will have statically granted permissions beyond those provided by the RBAC configuration or IAM. Defaults to false. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_legacy_abac ContainerCluster#enable_legacy_abac}
        :param enable_multi_networking: Whether multi-networking is enabled for this cluster. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_multi_networking ContainerCluster#enable_multi_networking}
        :param enable_shielded_nodes: Enable Shielded Nodes features on all nodes in this cluster. Defaults to true. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_shielded_nodes ContainerCluster#enable_shielded_nodes}
        :param enable_tpu: Whether to enable Cloud TPU resources in this cluster. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_tpu ContainerCluster#enable_tpu}
        :param enterprise_config: enterprise_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enterprise_config ContainerCluster#enterprise_config}
        :param fleet: fleet block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#fleet ContainerCluster#fleet}
        :param gateway_api_config: gateway_api_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gateway_api_config ContainerCluster#gateway_api_config}
        :param gke_auto_upgrade_config: gke_auto_upgrade_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gke_auto_upgrade_config ContainerCluster#gke_auto_upgrade_config}
        :param id: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#id ContainerCluster#id}. Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param identity_service_config: identity_service_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#identity_service_config ContainerCluster#identity_service_config}
        :param initial_node_count: The number of nodes to create in this cluster's default node pool. In regional or multi-zonal clusters, this is the number of nodes per zone. Must be set if node_pool is not set. If you're using google_container_node_pool objects with no default node pool, you'll need to set this to a value of at least 1, alongside setting remove_default_node_pool to true. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#initial_node_count ContainerCluster#initial_node_count}
        :param in_transit_encryption_config: Defines the config of in-transit encryption. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#in_transit_encryption_config ContainerCluster#in_transit_encryption_config}
        :param ip_allocation_policy: ip_allocation_policy block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#ip_allocation_policy ContainerCluster#ip_allocation_policy}
        :param location: The location (region or zone) in which the cluster master will be created, as well as the default node location. If you specify a zone (such as us-central1-a), the cluster will be a zonal cluster with a single cluster master. If you specify a region (such as us-west1), the cluster will be a regional cluster with multiple masters spread across zones in the region, and with default node locations in those zones as well. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#location ContainerCluster#location}
        :param logging_config: logging_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#logging_config ContainerCluster#logging_config}
        :param logging_service: The logging service that the cluster should write logs to. Available options include logging.googleapis.com(Legacy Stackdriver), logging.googleapis.com/kubernetes(Stackdriver Kubernetes Engine Logging), and none. Defaults to logging.googleapis.com/kubernetes. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#logging_service ContainerCluster#logging_service}
        :param maintenance_policy: maintenance_policy block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#maintenance_policy ContainerCluster#maintenance_policy}
        :param master_auth: master_auth block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#master_auth ContainerCluster#master_auth}
        :param master_authorized_networks_config: master_authorized_networks_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#master_authorized_networks_config ContainerCluster#master_authorized_networks_config}
        :param mesh_certificates: mesh_certificates block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#mesh_certificates ContainerCluster#mesh_certificates}
        :param min_master_version: The minimum version of the master. GKE will auto-update the master to new versions, so this does not guarantee the current master version--use the read-only master_version field to obtain that. If unset, the cluster's version will be set by GKE to the version of the most recent official release (which is not necessarily the latest version). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#min_master_version ContainerCluster#min_master_version}
        :param monitoring_config: monitoring_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#monitoring_config ContainerCluster#monitoring_config}
        :param monitoring_service: The monitoring service that the cluster should write metrics to. Automatically send metrics from pods in the cluster to the Google Cloud Monitoring API. VM metrics will be collected by Google Compute Engine regardless of this setting Available options include monitoring.googleapis.com(Legacy Stackdriver), monitoring.googleapis.com/kubernetes(Stackdriver Kubernetes Engine Monitoring), and none. Defaults to monitoring.googleapis.com/kubernetes. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#monitoring_service ContainerCluster#monitoring_service}
        :param network: The name or self_link of the Google Compute Engine network to which the cluster is connected. For Shared VPC, set this to the self link of the shared network. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#network ContainerCluster#network}
        :param networking_mode: Determines whether alias IPs or routes will be used for pod IPs in the cluster. Defaults to VPC_NATIVE for new clusters. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#networking_mode ContainerCluster#networking_mode}
        :param network_performance_config: network_performance_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#network_performance_config ContainerCluster#network_performance_config}
        :param network_policy: network_policy block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#network_policy ContainerCluster#network_policy}
        :param node_config: node_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#node_config ContainerCluster#node_config}
        :param node_locations: The list of zones in which the cluster's nodes are located. Nodes must be in the region of their regional cluster or in the same region as their cluster's zone for zonal clusters. If this is specified for a zonal cluster, omit the cluster's zone. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#node_locations ContainerCluster#node_locations}
        :param node_pool: node_pool block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#node_pool ContainerCluster#node_pool}
        :param node_pool_auto_config: node_pool_auto_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#node_pool_auto_config ContainerCluster#node_pool_auto_config}
        :param node_pool_defaults: node_pool_defaults block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#node_pool_defaults ContainerCluster#node_pool_defaults}
        :param node_version: The Kubernetes version on the nodes. Must either be unset or set to the same value as min_master_version on create. Defaults to the default version set by GKE which is not necessarily the latest version. This only affects nodes in the default node pool. While a fuzzy version can be specified, it's recommended that you specify explicit versions as Terraform will see spurious diffs when fuzzy versions are used. See the google_container_engine_versions data source's version_prefix field to approximate fuzzy versions in a Terraform-compatible way. To update nodes in other node pools, use the version attribute on the node pool. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#node_version ContainerCluster#node_version}
        :param notification_config: notification_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#notification_config ContainerCluster#notification_config}
        :param pod_autoscaling: pod_autoscaling block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#pod_autoscaling ContainerCluster#pod_autoscaling}
        :param private_cluster_config: private_cluster_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#private_cluster_config ContainerCluster#private_cluster_config}
        :param private_ipv6_google_access: The desired state of IPv6 connectivity to Google Services. By default, no private IPv6 access to or from Google Services (all access will be via IPv4). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#private_ipv6_google_access ContainerCluster#private_ipv6_google_access}
        :param project: The ID of the project in which the resource belongs. If it is not provided, the provider project is used. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#project ContainerCluster#project}
        :param rbac_binding_config: rbac_binding_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#rbac_binding_config ContainerCluster#rbac_binding_config}
        :param release_channel: release_channel block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#release_channel ContainerCluster#release_channel}
        :param remove_default_node_pool: If true, deletes the default node pool upon cluster creation. If you're using google_container_node_pool resources with no default node pool, this should be set to true, alongside setting initial_node_count to at least 1. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#remove_default_node_pool ContainerCluster#remove_default_node_pool}
        :param resource_labels: The GCE resource labels (a map of key/value pairs) to be applied to the cluster. **Note**: This field is non-authoritative, and will only manage the labels present in your configuration. Please refer to the field 'effective_labels' for all of the labels present on the resource. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#resource_labels ContainerCluster#resource_labels}
        :param resource_usage_export_config: resource_usage_export_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#resource_usage_export_config ContainerCluster#resource_usage_export_config}
        :param secret_manager_config: secret_manager_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#secret_manager_config ContainerCluster#secret_manager_config}
        :param security_posture_config: security_posture_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#security_posture_config ContainerCluster#security_posture_config}
        :param service_external_ips_config: service_external_ips_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#service_external_ips_config ContainerCluster#service_external_ips_config}
        :param subnetwork: The name or self_link of the Google Compute Engine subnetwork in which the cluster's instances are launched. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#subnetwork ContainerCluster#subnetwork}
        :param timeouts: timeouts block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#timeouts ContainerCluster#timeouts}
        :param user_managed_keys_config: user_managed_keys_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#user_managed_keys_config ContainerCluster#user_managed_keys_config}
        :param vertical_pod_autoscaling: vertical_pod_autoscaling block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#vertical_pod_autoscaling ContainerCluster#vertical_pod_autoscaling}
        :param workload_identity_config: workload_identity_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#workload_identity_config ContainerCluster#workload_identity_config}
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__af1997513508cac85424bc74f71db511ff5c7d660ba2550cc73e0ae55cf04b0a)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id_", value=id_, expected_type=type_hints["id_"])
        config = ContainerClusterConfig(
            name=name,
            addons_config=addons_config,
            allow_net_admin=allow_net_admin,
            anonymous_authentication_config=anonymous_authentication_config,
            authenticator_groups_config=authenticator_groups_config,
            binary_authorization=binary_authorization,
            cluster_autoscaling=cluster_autoscaling,
            cluster_ipv4_cidr=cluster_ipv4_cidr,
            confidential_nodes=confidential_nodes,
            control_plane_endpoints_config=control_plane_endpoints_config,
            cost_management_config=cost_management_config,
            database_encryption=database_encryption,
            datapath_provider=datapath_provider,
            default_max_pods_per_node=default_max_pods_per_node,
            default_snat_status=default_snat_status,
            deletion_protection=deletion_protection,
            description=description,
            disable_l4_lb_firewall_reconciliation=disable_l4_lb_firewall_reconciliation,
            dns_config=dns_config,
            enable_autopilot=enable_autopilot,
            enable_cilium_clusterwide_network_policy=enable_cilium_clusterwide_network_policy,
            enable_fqdn_network_policy=enable_fqdn_network_policy,
            enable_intranode_visibility=enable_intranode_visibility,
            enable_k8_s_beta_apis=enable_k8_s_beta_apis,
            enable_kubernetes_alpha=enable_kubernetes_alpha,
            enable_l4_ilb_subsetting=enable_l4_ilb_subsetting,
            enable_legacy_abac=enable_legacy_abac,
            enable_multi_networking=enable_multi_networking,
            enable_shielded_nodes=enable_shielded_nodes,
            enable_tpu=enable_tpu,
            enterprise_config=enterprise_config,
            fleet=fleet,
            gateway_api_config=gateway_api_config,
            gke_auto_upgrade_config=gke_auto_upgrade_config,
            id=id,
            identity_service_config=identity_service_config,
            initial_node_count=initial_node_count,
            in_transit_encryption_config=in_transit_encryption_config,
            ip_allocation_policy=ip_allocation_policy,
            location=location,
            logging_config=logging_config,
            logging_service=logging_service,
            maintenance_policy=maintenance_policy,
            master_auth=master_auth,
            master_authorized_networks_config=master_authorized_networks_config,
            mesh_certificates=mesh_certificates,
            min_master_version=min_master_version,
            monitoring_config=monitoring_config,
            monitoring_service=monitoring_service,
            network=network,
            networking_mode=networking_mode,
            network_performance_config=network_performance_config,
            network_policy=network_policy,
            node_config=node_config,
            node_locations=node_locations,
            node_pool=node_pool,
            node_pool_auto_config=node_pool_auto_config,
            node_pool_defaults=node_pool_defaults,
            node_version=node_version,
            notification_config=notification_config,
            pod_autoscaling=pod_autoscaling,
            private_cluster_config=private_cluster_config,
            private_ipv6_google_access=private_ipv6_google_access,
            project=project,
            rbac_binding_config=rbac_binding_config,
            release_channel=release_channel,
            remove_default_node_pool=remove_default_node_pool,
            resource_labels=resource_labels,
            resource_usage_export_config=resource_usage_export_config,
            secret_manager_config=secret_manager_config,
            security_posture_config=security_posture_config,
            service_external_ips_config=service_external_ips_config,
            subnetwork=subnetwork,
            timeouts=timeouts,
            user_managed_keys_config=user_managed_keys_config,
            vertical_pod_autoscaling=vertical_pod_autoscaling,
            workload_identity_config=workload_identity_config,
            connection=connection,
            count=count,
            depends_on=depends_on,
            for_each=for_each,
            lifecycle=lifecycle,
            provider=provider,
            provisioners=provisioners,
        )

        jsii.create(self.__class__, self, [scope, id_, config])

    @jsii.member(jsii_name="generateConfigForImport")
    @builtins.classmethod
    def generate_config_for_import(
        cls,
        scope: _constructs_77d1e7e8.Construct,
        import_to_id: builtins.str,
        import_from_id: builtins.str,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    ) -> _cdktf_9a9027ec.ImportableResource:
        '''Generates CDKTF code for importing a ContainerCluster resource upon running "cdktf plan ".

        :param scope: The scope in which to define this construct.
        :param import_to_id: The construct id used in the generated config for the ContainerCluster to import.
        :param import_from_id: The id of the existing ContainerCluster that should be imported. Refer to the {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#import import section} in the documentation of this resource for the id to use
        :param provider: ? Optional instance of the provider where the ContainerCluster to import is found.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f97ab9e0e99bac83bd23fb992fefac1506b5a640bf6fa4a1628b4977a4779dbc)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument import_to_id", value=import_to_id, expected_type=type_hints["import_to_id"])
            check_type(argname="argument import_from_id", value=import_from_id, expected_type=type_hints["import_from_id"])
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
        return typing.cast(_cdktf_9a9027ec.ImportableResource, jsii.sinvoke(cls, "generateConfigForImport", [scope, import_to_id, import_from_id, provider]))

    @jsii.member(jsii_name="putAddonsConfig")
    def put_addons_config(
        self,
        *,
        cloudrun_config: typing.Optional[typing.Union["ContainerClusterAddonsConfigCloudrunConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        config_connector_config: typing.Optional[typing.Union["ContainerClusterAddonsConfigConfigConnectorConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        dns_cache_config: typing.Optional[typing.Union["ContainerClusterAddonsConfigDnsCacheConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        gce_persistent_disk_csi_driver_config: typing.Optional[typing.Union["ContainerClusterAddonsConfigGcePersistentDiskCsiDriverConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        gcp_filestore_csi_driver_config: typing.Optional[typing.Union["ContainerClusterAddonsConfigGcpFilestoreCsiDriverConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        gcs_fuse_csi_driver_config: typing.Optional[typing.Union["ContainerClusterAddonsConfigGcsFuseCsiDriverConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        gke_backup_agent_config: typing.Optional[typing.Union["ContainerClusterAddonsConfigGkeBackupAgentConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        horizontal_pod_autoscaling: typing.Optional[typing.Union["ContainerClusterAddonsConfigHorizontalPodAutoscaling", typing.Dict[builtins.str, typing.Any]]] = None,
        http_load_balancing: typing.Optional[typing.Union["ContainerClusterAddonsConfigHttpLoadBalancing", typing.Dict[builtins.str, typing.Any]]] = None,
        lustre_csi_driver_config: typing.Optional[typing.Union["ContainerClusterAddonsConfigLustreCsiDriverConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        network_policy_config: typing.Optional[typing.Union["ContainerClusterAddonsConfigNetworkPolicyConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        parallelstore_csi_driver_config: typing.Optional[typing.Union["ContainerClusterAddonsConfigParallelstoreCsiDriverConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        ray_operator_config: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ContainerClusterAddonsConfigRayOperatorConfig", typing.Dict[builtins.str, typing.Any]]]]] = None,
        stateful_ha_config: typing.Optional[typing.Union["ContainerClusterAddonsConfigStatefulHaConfig", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param cloudrun_config: cloudrun_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cloudrun_config ContainerCluster#cloudrun_config}
        :param config_connector_config: config_connector_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#config_connector_config ContainerCluster#config_connector_config}
        :param dns_cache_config: dns_cache_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#dns_cache_config ContainerCluster#dns_cache_config}
        :param gce_persistent_disk_csi_driver_config: gce_persistent_disk_csi_driver_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gce_persistent_disk_csi_driver_config ContainerCluster#gce_persistent_disk_csi_driver_config}
        :param gcp_filestore_csi_driver_config: gcp_filestore_csi_driver_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gcp_filestore_csi_driver_config ContainerCluster#gcp_filestore_csi_driver_config}
        :param gcs_fuse_csi_driver_config: gcs_fuse_csi_driver_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gcs_fuse_csi_driver_config ContainerCluster#gcs_fuse_csi_driver_config}
        :param gke_backup_agent_config: gke_backup_agent_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gke_backup_agent_config ContainerCluster#gke_backup_agent_config}
        :param horizontal_pod_autoscaling: horizontal_pod_autoscaling block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#horizontal_pod_autoscaling ContainerCluster#horizontal_pod_autoscaling}
        :param http_load_balancing: http_load_balancing block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#http_load_balancing ContainerCluster#http_load_balancing}
        :param lustre_csi_driver_config: lustre_csi_driver_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#lustre_csi_driver_config ContainerCluster#lustre_csi_driver_config}
        :param network_policy_config: network_policy_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#network_policy_config ContainerCluster#network_policy_config}
        :param parallelstore_csi_driver_config: parallelstore_csi_driver_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#parallelstore_csi_driver_config ContainerCluster#parallelstore_csi_driver_config}
        :param ray_operator_config: ray_operator_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#ray_operator_config ContainerCluster#ray_operator_config}
        :param stateful_ha_config: stateful_ha_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#stateful_ha_config ContainerCluster#stateful_ha_config}
        '''
        value = ContainerClusterAddonsConfig(
            cloudrun_config=cloudrun_config,
            config_connector_config=config_connector_config,
            dns_cache_config=dns_cache_config,
            gce_persistent_disk_csi_driver_config=gce_persistent_disk_csi_driver_config,
            gcp_filestore_csi_driver_config=gcp_filestore_csi_driver_config,
            gcs_fuse_csi_driver_config=gcs_fuse_csi_driver_config,
            gke_backup_agent_config=gke_backup_agent_config,
            horizontal_pod_autoscaling=horizontal_pod_autoscaling,
            http_load_balancing=http_load_balancing,
            lustre_csi_driver_config=lustre_csi_driver_config,
            network_policy_config=network_policy_config,
            parallelstore_csi_driver_config=parallelstore_csi_driver_config,
            ray_operator_config=ray_operator_config,
            stateful_ha_config=stateful_ha_config,
        )

        return typing.cast(None, jsii.invoke(self, "putAddonsConfig", [value]))

    @jsii.member(jsii_name="putAnonymousAuthenticationConfig")
    def put_anonymous_authentication_config(self, *, mode: builtins.str) -> None:
        '''
        :param mode: Setting this to LIMITED will restrict authentication of anonymous users to health check endpoints only. Accepted values are: - ENABLED: Authentication of anonymous users is enabled for all endpoints. - LIMITED: Anonymous access is only allowed for health check endpoints. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#mode ContainerCluster#mode}
        '''
        value = ContainerClusterAnonymousAuthenticationConfig(mode=mode)

        return typing.cast(None, jsii.invoke(self, "putAnonymousAuthenticationConfig", [value]))

    @jsii.member(jsii_name="putAuthenticatorGroupsConfig")
    def put_authenticator_groups_config(self, *, security_group: builtins.str) -> None:
        '''
        :param security_group: The name of the RBAC security group for use with Google security groups in Kubernetes RBAC. Group name must be in format gke-security-groups@yourdomain.com. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#security_group ContainerCluster#security_group}
        '''
        value = ContainerClusterAuthenticatorGroupsConfig(
            security_group=security_group
        )

        return typing.cast(None, jsii.invoke(self, "putAuthenticatorGroupsConfig", [value]))

    @jsii.member(jsii_name="putBinaryAuthorization")
    def put_binary_authorization(
        self,
        *,
        enabled: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        evaluation_mode: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param enabled: Enable Binary Authorization for this cluster. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        :param evaluation_mode: Mode of operation for Binary Authorization policy evaluation. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#evaluation_mode ContainerCluster#evaluation_mode}
        '''
        value = ContainerClusterBinaryAuthorization(
            enabled=enabled, evaluation_mode=evaluation_mode
        )

        return typing.cast(None, jsii.invoke(self, "putBinaryAuthorization", [value]))

    @jsii.member(jsii_name="putClusterAutoscaling")
    def put_cluster_autoscaling(
        self,
        *,
        auto_provisioning_defaults: typing.Optional[typing.Union["ContainerClusterClusterAutoscalingAutoProvisioningDefaults", typing.Dict[builtins.str, typing.Any]]] = None,
        auto_provisioning_locations: typing.Optional[typing.Sequence[builtins.str]] = None,
        autoscaling_profile: typing.Optional[builtins.str] = None,
        enabled: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        resource_limits: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ContainerClusterClusterAutoscalingResourceLimits", typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''
        :param auto_provisioning_defaults: auto_provisioning_defaults block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#auto_provisioning_defaults ContainerCluster#auto_provisioning_defaults}
        :param auto_provisioning_locations: The list of Google Compute Engine zones in which the NodePool's nodes can be created by NAP. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#auto_provisioning_locations ContainerCluster#auto_provisioning_locations}
        :param autoscaling_profile: Configuration options for the Autoscaling profile feature, which lets you choose whether the cluster autoscaler should optimize for resource utilization or resource availability when deciding to remove nodes from a cluster. Can be BALANCED or OPTIMIZE_UTILIZATION. Defaults to BALANCED. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#autoscaling_profile ContainerCluster#autoscaling_profile}
        :param enabled: Whether node auto-provisioning is enabled. Resource limits for cpu and memory must be defined to enable node auto-provisioning. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        :param resource_limits: resource_limits block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#resource_limits ContainerCluster#resource_limits}
        '''
        value = ContainerClusterClusterAutoscaling(
            auto_provisioning_defaults=auto_provisioning_defaults,
            auto_provisioning_locations=auto_provisioning_locations,
            autoscaling_profile=autoscaling_profile,
            enabled=enabled,
            resource_limits=resource_limits,
        )

        return typing.cast(None, jsii.invoke(self, "putClusterAutoscaling", [value]))

    @jsii.member(jsii_name="putConfidentialNodes")
    def put_confidential_nodes(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
        confidential_instance_type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param enabled: Whether Confidential Nodes feature is enabled for all nodes in this cluster. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        :param confidential_instance_type: Defines the type of technology used by the confidential node. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#confidential_instance_type ContainerCluster#confidential_instance_type}
        '''
        value = ContainerClusterConfidentialNodes(
            enabled=enabled, confidential_instance_type=confidential_instance_type
        )

        return typing.cast(None, jsii.invoke(self, "putConfidentialNodes", [value]))

    @jsii.member(jsii_name="putControlPlaneEndpointsConfig")
    def put_control_plane_endpoints_config(
        self,
        *,
        dns_endpoint_config: typing.Optional[typing.Union["ContainerClusterControlPlaneEndpointsConfigDnsEndpointConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        ip_endpoints_config: typing.Optional[typing.Union["ContainerClusterControlPlaneEndpointsConfigIpEndpointsConfig", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param dns_endpoint_config: dns_endpoint_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#dns_endpoint_config ContainerCluster#dns_endpoint_config}
        :param ip_endpoints_config: ip_endpoints_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#ip_endpoints_config ContainerCluster#ip_endpoints_config}
        '''
        value = ContainerClusterControlPlaneEndpointsConfig(
            dns_endpoint_config=dns_endpoint_config,
            ip_endpoints_config=ip_endpoints_config,
        )

        return typing.cast(None, jsii.invoke(self, "putControlPlaneEndpointsConfig", [value]))

    @jsii.member(jsii_name="putCostManagementConfig")
    def put_cost_management_config(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param enabled: Whether to enable GKE cost allocation. When you enable GKE cost allocation, the cluster name and namespace of your GKE workloads appear in the labels field of the billing export to BigQuery. Defaults to false. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        '''
        value = ContainerClusterCostManagementConfig(enabled=enabled)

        return typing.cast(None, jsii.invoke(self, "putCostManagementConfig", [value]))

    @jsii.member(jsii_name="putDatabaseEncryption")
    def put_database_encryption(
        self,
        *,
        state: builtins.str,
        key_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param state: ENCRYPTED or DECRYPTED. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#state ContainerCluster#state}
        :param key_name: The key to use to encrypt/decrypt secrets. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#key_name ContainerCluster#key_name}
        '''
        value = ContainerClusterDatabaseEncryption(state=state, key_name=key_name)

        return typing.cast(None, jsii.invoke(self, "putDatabaseEncryption", [value]))

    @jsii.member(jsii_name="putDefaultSnatStatus")
    def put_default_snat_status(
        self,
        *,
        disabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param disabled: When disabled is set to false, default IP masquerade rules will be applied to the nodes to prevent sNAT on cluster internal traffic. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#disabled ContainerCluster#disabled}
        '''
        value = ContainerClusterDefaultSnatStatus(disabled=disabled)

        return typing.cast(None, jsii.invoke(self, "putDefaultSnatStatus", [value]))

    @jsii.member(jsii_name="putDnsConfig")
    def put_dns_config(
        self,
        *,
        additive_vpc_scope_dns_domain: typing.Optional[builtins.str] = None,
        cluster_dns: typing.Optional[builtins.str] = None,
        cluster_dns_domain: typing.Optional[builtins.str] = None,
        cluster_dns_scope: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param additive_vpc_scope_dns_domain: Enable additive VPC scope DNS in a GKE cluster. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#additive_vpc_scope_dns_domain ContainerCluster#additive_vpc_scope_dns_domain}
        :param cluster_dns: Which in-cluster DNS provider should be used. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cluster_dns ContainerCluster#cluster_dns}
        :param cluster_dns_domain: The suffix used for all cluster service records. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cluster_dns_domain ContainerCluster#cluster_dns_domain}
        :param cluster_dns_scope: The scope of access to cluster DNS records. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cluster_dns_scope ContainerCluster#cluster_dns_scope}
        '''
        value = ContainerClusterDnsConfig(
            additive_vpc_scope_dns_domain=additive_vpc_scope_dns_domain,
            cluster_dns=cluster_dns,
            cluster_dns_domain=cluster_dns_domain,
            cluster_dns_scope=cluster_dns_scope,
        )

        return typing.cast(None, jsii.invoke(self, "putDnsConfig", [value]))

    @jsii.member(jsii_name="putEnableK8SBetaApis")
    def put_enable_k8_s_beta_apis(
        self,
        *,
        enabled_apis: typing.Sequence[builtins.str],
    ) -> None:
        '''
        :param enabled_apis: Enabled Kubernetes Beta APIs. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled_apis ContainerCluster#enabled_apis}
        '''
        value = ContainerClusterEnableK8SBetaApis(enabled_apis=enabled_apis)

        return typing.cast(None, jsii.invoke(self, "putEnableK8SBetaApis", [value]))

    @jsii.member(jsii_name="putEnterpriseConfig")
    def put_enterprise_config(
        self,
        *,
        desired_tier: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param desired_tier: Indicates the desired cluster tier. Available options include STANDARD and ENTERPRISE. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#desired_tier ContainerCluster#desired_tier}
        '''
        value = ContainerClusterEnterpriseConfig(desired_tier=desired_tier)

        return typing.cast(None, jsii.invoke(self, "putEnterpriseConfig", [value]))

    @jsii.member(jsii_name="putFleet")
    def put_fleet(self, *, project: typing.Optional[builtins.str] = None) -> None:
        '''
        :param project: The Fleet host project of the cluster. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#project ContainerCluster#project}
        '''
        value = ContainerClusterFleet(project=project)

        return typing.cast(None, jsii.invoke(self, "putFleet", [value]))

    @jsii.member(jsii_name="putGatewayApiConfig")
    def put_gateway_api_config(self, *, channel: builtins.str) -> None:
        '''
        :param channel: The Gateway API release channel to use for Gateway API. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#channel ContainerCluster#channel}
        '''
        value = ContainerClusterGatewayApiConfig(channel=channel)

        return typing.cast(None, jsii.invoke(self, "putGatewayApiConfig", [value]))

    @jsii.member(jsii_name="putGkeAutoUpgradeConfig")
    def put_gke_auto_upgrade_config(self, *, patch_mode: builtins.str) -> None:
        '''
        :param patch_mode: The selected auto-upgrade patch type. Accepted values are: - ACCELERATED: Upgrades to the latest available patch version in a given minor and release channel. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#patch_mode ContainerCluster#patch_mode}
        '''
        value = ContainerClusterGkeAutoUpgradeConfig(patch_mode=patch_mode)

        return typing.cast(None, jsii.invoke(self, "putGkeAutoUpgradeConfig", [value]))

    @jsii.member(jsii_name="putIdentityServiceConfig")
    def put_identity_service_config(
        self,
        *,
        enabled: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    ) -> None:
        '''
        :param enabled: Whether to enable the Identity Service component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        '''
        value = ContainerClusterIdentityServiceConfig(enabled=enabled)

        return typing.cast(None, jsii.invoke(self, "putIdentityServiceConfig", [value]))

    @jsii.member(jsii_name="putIpAllocationPolicy")
    def put_ip_allocation_policy(
        self,
        *,
        additional_ip_ranges_config: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ContainerClusterIpAllocationPolicyAdditionalIpRangesConfig", typing.Dict[builtins.str, typing.Any]]]]] = None,
        additional_pod_ranges_config: typing.Optional[typing.Union["ContainerClusterIpAllocationPolicyAdditionalPodRangesConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        cluster_ipv4_cidr_block: typing.Optional[builtins.str] = None,
        cluster_secondary_range_name: typing.Optional[builtins.str] = None,
        pod_cidr_overprovision_config: typing.Optional[typing.Union["ContainerClusterIpAllocationPolicyPodCidrOverprovisionConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        services_ipv4_cidr_block: typing.Optional[builtins.str] = None,
        services_secondary_range_name: typing.Optional[builtins.str] = None,
        stack_type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param additional_ip_ranges_config: additional_ip_ranges_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#additional_ip_ranges_config ContainerCluster#additional_ip_ranges_config}
        :param additional_pod_ranges_config: additional_pod_ranges_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#additional_pod_ranges_config ContainerCluster#additional_pod_ranges_config}
        :param cluster_ipv4_cidr_block: The IP address range for the cluster pod IPs. Set to blank to have a range chosen with the default size. Set to /netmask (e.g. /14) to have a range chosen with a specific netmask. Set to a CIDR notation (e.g. 10.96.0.0/14) from the RFC-1918 private networks (e.g. 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16) to pick a specific range to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cluster_ipv4_cidr_block ContainerCluster#cluster_ipv4_cidr_block}
        :param cluster_secondary_range_name: The name of the existing secondary range in the cluster's subnetwork to use for pod IP addresses. Alternatively, cluster_ipv4_cidr_block can be used to automatically create a GKE-managed one. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cluster_secondary_range_name ContainerCluster#cluster_secondary_range_name}
        :param pod_cidr_overprovision_config: pod_cidr_overprovision_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#pod_cidr_overprovision_config ContainerCluster#pod_cidr_overprovision_config}
        :param services_ipv4_cidr_block: The IP address range of the services IPs in this cluster. Set to blank to have a range chosen with the default size. Set to /netmask (e.g. /14) to have a range chosen with a specific netmask. Set to a CIDR notation (e.g. 10.96.0.0/14) from the RFC-1918 private networks (e.g. 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16) to pick a specific range to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#services_ipv4_cidr_block ContainerCluster#services_ipv4_cidr_block}
        :param services_secondary_range_name: The name of the existing secondary range in the cluster's subnetwork to use for service ClusterIPs. Alternatively, services_ipv4_cidr_block can be used to automatically create a GKE-managed one. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#services_secondary_range_name ContainerCluster#services_secondary_range_name}
        :param stack_type: The IP Stack type of the cluster. Choose between IPV4 and IPV4_IPV6. Default type is IPV4 Only if not set Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#stack_type ContainerCluster#stack_type}
        '''
        value = ContainerClusterIpAllocationPolicy(
            additional_ip_ranges_config=additional_ip_ranges_config,
            additional_pod_ranges_config=additional_pod_ranges_config,
            cluster_ipv4_cidr_block=cluster_ipv4_cidr_block,
            cluster_secondary_range_name=cluster_secondary_range_name,
            pod_cidr_overprovision_config=pod_cidr_overprovision_config,
            services_ipv4_cidr_block=services_ipv4_cidr_block,
            services_secondary_range_name=services_secondary_range_name,
            stack_type=stack_type,
        )

        return typing.cast(None, jsii.invoke(self, "putIpAllocationPolicy", [value]))

    @jsii.member(jsii_name="putLoggingConfig")
    def put_logging_config(
        self,
        *,
        enable_components: typing.Sequence[builtins.str],
    ) -> None:
        '''
        :param enable_components: GKE components exposing logs. Valid values include SYSTEM_COMPONENTS, APISERVER, CONTROLLER_MANAGER, KCP_CONNECTION, KCP_SSHD, KCP_HPA, SCHEDULER, and WORKLOADS. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_components ContainerCluster#enable_components}
        '''
        value = ContainerClusterLoggingConfig(enable_components=enable_components)

        return typing.cast(None, jsii.invoke(self, "putLoggingConfig", [value]))

    @jsii.member(jsii_name="putMaintenancePolicy")
    def put_maintenance_policy(
        self,
        *,
        daily_maintenance_window: typing.Optional[typing.Union["ContainerClusterMaintenancePolicyDailyMaintenanceWindow", typing.Dict[builtins.str, typing.Any]]] = None,
        maintenance_exclusion: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ContainerClusterMaintenancePolicyMaintenanceExclusion", typing.Dict[builtins.str, typing.Any]]]]] = None,
        recurring_window: typing.Optional[typing.Union["ContainerClusterMaintenancePolicyRecurringWindow", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param daily_maintenance_window: daily_maintenance_window block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#daily_maintenance_window ContainerCluster#daily_maintenance_window}
        :param maintenance_exclusion: maintenance_exclusion block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#maintenance_exclusion ContainerCluster#maintenance_exclusion}
        :param recurring_window: recurring_window block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#recurring_window ContainerCluster#recurring_window}
        '''
        value = ContainerClusterMaintenancePolicy(
            daily_maintenance_window=daily_maintenance_window,
            maintenance_exclusion=maintenance_exclusion,
            recurring_window=recurring_window,
        )

        return typing.cast(None, jsii.invoke(self, "putMaintenancePolicy", [value]))

    @jsii.member(jsii_name="putMasterAuth")
    def put_master_auth(
        self,
        *,
        client_certificate_config: typing.Union["ContainerClusterMasterAuthClientCertificateConfig", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''
        :param client_certificate_config: client_certificate_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#client_certificate_config ContainerCluster#client_certificate_config}
        '''
        value = ContainerClusterMasterAuth(
            client_certificate_config=client_certificate_config
        )

        return typing.cast(None, jsii.invoke(self, "putMasterAuth", [value]))

    @jsii.member(jsii_name="putMasterAuthorizedNetworksConfig")
    def put_master_authorized_networks_config(
        self,
        *,
        cidr_blocks: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ContainerClusterMasterAuthorizedNetworksConfigCidrBlocks", typing.Dict[builtins.str, typing.Any]]]]] = None,
        gcp_public_cidrs_access_enabled: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        private_endpoint_enforcement_enabled: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    ) -> None:
        '''
        :param cidr_blocks: cidr_blocks block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cidr_blocks ContainerCluster#cidr_blocks}
        :param gcp_public_cidrs_access_enabled: Whether Kubernetes master is accessible via Google Compute Engine Public IPs. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gcp_public_cidrs_access_enabled ContainerCluster#gcp_public_cidrs_access_enabled}
        :param private_endpoint_enforcement_enabled: Whether authorized networks is enforced on the private endpoint or not. Defaults to false. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#private_endpoint_enforcement_enabled ContainerCluster#private_endpoint_enforcement_enabled}
        '''
        value = ContainerClusterMasterAuthorizedNetworksConfig(
            cidr_blocks=cidr_blocks,
            gcp_public_cidrs_access_enabled=gcp_public_cidrs_access_enabled,
            private_endpoint_enforcement_enabled=private_endpoint_enforcement_enabled,
        )

        return typing.cast(None, jsii.invoke(self, "putMasterAuthorizedNetworksConfig", [value]))

    @jsii.member(jsii_name="putMeshCertificates")
    def put_mesh_certificates(
        self,
        *,
        enable_certificates: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param enable_certificates: When enabled the GKE Workload Identity Certificates controller and node agent will be deployed in the cluster. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_certificates ContainerCluster#enable_certificates}
        '''
        value = ContainerClusterMeshCertificates(
            enable_certificates=enable_certificates
        )

        return typing.cast(None, jsii.invoke(self, "putMeshCertificates", [value]))

    @jsii.member(jsii_name="putMonitoringConfig")
    def put_monitoring_config(
        self,
        *,
        advanced_datapath_observability_config: typing.Optional[typing.Union["ContainerClusterMonitoringConfigAdvancedDatapathObservabilityConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        enable_components: typing.Optional[typing.Sequence[builtins.str]] = None,
        managed_prometheus: typing.Optional[typing.Union["ContainerClusterMonitoringConfigManagedPrometheus", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param advanced_datapath_observability_config: advanced_datapath_observability_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#advanced_datapath_observability_config ContainerCluster#advanced_datapath_observability_config}
        :param enable_components: GKE components exposing metrics. Valid values include SYSTEM_COMPONENTS, APISERVER, SCHEDULER, CONTROLLER_MANAGER, STORAGE, HPA, POD, DAEMONSET, DEPLOYMENT, STATEFULSET, KUBELET, CADVISOR, DCGM and JOBSET. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_components ContainerCluster#enable_components}
        :param managed_prometheus: managed_prometheus block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#managed_prometheus ContainerCluster#managed_prometheus}
        '''
        value = ContainerClusterMonitoringConfig(
            advanced_datapath_observability_config=advanced_datapath_observability_config,
            enable_components=enable_components,
            managed_prometheus=managed_prometheus,
        )

        return typing.cast(None, jsii.invoke(self, "putMonitoringConfig", [value]))

    @jsii.member(jsii_name="putNetworkPerformanceConfig")
    def put_network_performance_config(
        self,
        *,
        total_egress_bandwidth_tier: builtins.str,
    ) -> None:
        '''
        :param total_egress_bandwidth_tier: Specifies the total network bandwidth tier for NodePools in the cluster. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#total_egress_bandwidth_tier ContainerCluster#total_egress_bandwidth_tier}
        '''
        value = ContainerClusterNetworkPerformanceConfig(
            total_egress_bandwidth_tier=total_egress_bandwidth_tier
        )

        return typing.cast(None, jsii.invoke(self, "putNetworkPerformanceConfig", [value]))

    @jsii.member(jsii_name="putNetworkPolicy")
    def put_network_policy(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
        provider: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param enabled: Whether network policy is enabled on the cluster. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        :param provider: The selected network policy provider. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#provider ContainerCluster#provider}
        '''
        value = ContainerClusterNetworkPolicy(enabled=enabled, provider=provider)

        return typing.cast(None, jsii.invoke(self, "putNetworkPolicy", [value]))

    @jsii.member(jsii_name="putNodeConfig")
    def put_node_config(
        self,
        *,
        advanced_machine_features: typing.Optional[typing.Union["ContainerClusterNodeConfigAdvancedMachineFeatures", typing.Dict[builtins.str, typing.Any]]] = None,
        boot_disk: typing.Optional[typing.Union["ContainerClusterNodeConfigBootDisk", typing.Dict[builtins.str, typing.Any]]] = None,
        boot_disk_kms_key: typing.Optional[builtins.str] = None,
        confidential_nodes: typing.Optional[typing.Union["ContainerClusterNodeConfigConfidentialNodes", typing.Dict[builtins.str, typing.Any]]] = None,
        containerd_config: typing.Optional[typing.Union["ContainerClusterNodeConfigContainerdConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        disk_size_gb: typing.Optional[jsii.Number] = None,
        disk_type: typing.Optional[builtins.str] = None,
        enable_confidential_storage: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        ephemeral_storage_local_ssd_config: typing.Optional[typing.Union["ContainerClusterNodeConfigEphemeralStorageLocalSsdConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        fast_socket: typing.Optional[typing.Union["ContainerClusterNodeConfigFastSocket", typing.Dict[builtins.str, typing.Any]]] = None,
        flex_start: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        gcfs_config: typing.Optional[typing.Union["ContainerClusterNodeConfigGcfsConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        guest_accelerator: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ContainerClusterNodeConfigGuestAccelerator", typing.Dict[builtins.str, typing.Any]]]]] = None,
        gvnic: typing.Optional[typing.Union["ContainerClusterNodeConfigGvnic", typing.Dict[builtins.str, typing.Any]]] = None,
        host_maintenance_policy: typing.Optional[typing.Union["ContainerClusterNodeConfigHostMaintenancePolicy", typing.Dict[builtins.str, typing.Any]]] = None,
        image_type: typing.Optional[builtins.str] = None,
        kubelet_config: typing.Optional[typing.Union["ContainerClusterNodeConfigKubeletConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        linux_node_config: typing.Optional[typing.Union["ContainerClusterNodeConfigLinuxNodeConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        local_nvme_ssd_block_config: typing.Optional[typing.Union["ContainerClusterNodeConfigLocalNvmeSsdBlockConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        local_ssd_count: typing.Optional[jsii.Number] = None,
        local_ssd_encryption_mode: typing.Optional[builtins.str] = None,
        logging_variant: typing.Optional[builtins.str] = None,
        machine_type: typing.Optional[builtins.str] = None,
        max_run_duration: typing.Optional[builtins.str] = None,
        metadata: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        min_cpu_platform: typing.Optional[builtins.str] = None,
        node_group: typing.Optional[builtins.str] = None,
        oauth_scopes: typing.Optional[typing.Sequence[builtins.str]] = None,
        preemptible: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        reservation_affinity: typing.Optional[typing.Union["ContainerClusterNodeConfigReservationAffinity", typing.Dict[builtins.str, typing.Any]]] = None,
        resource_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        resource_manager_tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        secondary_boot_disks: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ContainerClusterNodeConfigSecondaryBootDisks", typing.Dict[builtins.str, typing.Any]]]]] = None,
        service_account: typing.Optional[builtins.str] = None,
        shielded_instance_config: typing.Optional[typing.Union["ContainerClusterNodeConfigShieldedInstanceConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        sole_tenant_config: typing.Optional[typing.Union["ContainerClusterNodeConfigSoleTenantConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        spot: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        storage_pools: typing.Optional[typing.Sequence[builtins.str]] = None,
        tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        taint: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ContainerClusterNodeConfigTaint", typing.Dict[builtins.str, typing.Any]]]]] = None,
        windows_node_config: typing.Optional[typing.Union["ContainerClusterNodeConfigWindowsNodeConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        workload_metadata_config: typing.Optional[typing.Union["ContainerClusterNodeConfigWorkloadMetadataConfig", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param advanced_machine_features: advanced_machine_features block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#advanced_machine_features ContainerCluster#advanced_machine_features}
        :param boot_disk: boot_disk block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#boot_disk ContainerCluster#boot_disk}
        :param boot_disk_kms_key: The Customer Managed Encryption Key used to encrypt the boot disk attached to each node in the node pool. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#boot_disk_kms_key ContainerCluster#boot_disk_kms_key}
        :param confidential_nodes: confidential_nodes block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#confidential_nodes ContainerCluster#confidential_nodes}
        :param containerd_config: containerd_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#containerd_config ContainerCluster#containerd_config}
        :param disk_size_gb: Size of the disk attached to each node, specified in GB. The smallest allowed disk size is 10GB. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#disk_size_gb ContainerCluster#disk_size_gb}
        :param disk_type: Type of the disk attached to each node. Such as pd-standard, pd-balanced or pd-ssd. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#disk_type ContainerCluster#disk_type}
        :param enable_confidential_storage: If enabled boot disks are configured with confidential mode. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_confidential_storage ContainerCluster#enable_confidential_storage}
        :param ephemeral_storage_local_ssd_config: ephemeral_storage_local_ssd_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#ephemeral_storage_local_ssd_config ContainerCluster#ephemeral_storage_local_ssd_config}
        :param fast_socket: fast_socket block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#fast_socket ContainerCluster#fast_socket}
        :param flex_start: Enables Flex Start provisioning model for the node pool. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#flex_start ContainerCluster#flex_start}
        :param gcfs_config: gcfs_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gcfs_config ContainerCluster#gcfs_config}
        :param guest_accelerator: guest_accelerator block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#guest_accelerator ContainerCluster#guest_accelerator}
        :param gvnic: gvnic block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gvnic ContainerCluster#gvnic}
        :param host_maintenance_policy: host_maintenance_policy block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#host_maintenance_policy ContainerCluster#host_maintenance_policy}
        :param image_type: The image type to use for this node. Note that for a given image type, the latest version of it will be used. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#image_type ContainerCluster#image_type}
        :param kubelet_config: kubelet_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#kubelet_config ContainerCluster#kubelet_config}
        :param labels: The map of Kubernetes labels (key/value pairs) to be applied to each node. These will added in addition to any default label(s) that Kubernetes may apply to the node. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#labels ContainerCluster#labels}
        :param linux_node_config: linux_node_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#linux_node_config ContainerCluster#linux_node_config}
        :param local_nvme_ssd_block_config: local_nvme_ssd_block_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#local_nvme_ssd_block_config ContainerCluster#local_nvme_ssd_block_config}
        :param local_ssd_count: The number of local SSD disks to be attached to the node. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#local_ssd_count ContainerCluster#local_ssd_count}
        :param local_ssd_encryption_mode: LocalSsdEncryptionMode specified the method used for encrypting the local SSDs attached to the node. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#local_ssd_encryption_mode ContainerCluster#local_ssd_encryption_mode}
        :param logging_variant: Type of logging agent that is used as the default value for node pools in the cluster. Valid values include DEFAULT and MAX_THROUGHPUT. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#logging_variant ContainerCluster#logging_variant}
        :param machine_type: The name of a Google Compute Engine machine type. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#machine_type ContainerCluster#machine_type}
        :param max_run_duration: The runtime of each node in the node pool in seconds, terminated by 's'. Example: "3600s". Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#max_run_duration ContainerCluster#max_run_duration}
        :param metadata: The metadata key/value pairs assigned to instances in the cluster. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#metadata ContainerCluster#metadata}
        :param min_cpu_platform: Minimum CPU platform to be used by this instance. The instance may be scheduled on the specified or newer CPU platform. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#min_cpu_platform ContainerCluster#min_cpu_platform}
        :param node_group: Setting this field will assign instances of this pool to run on the specified node group. This is useful for running workloads on sole tenant nodes. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#node_group ContainerCluster#node_group}
        :param oauth_scopes: The set of Google API scopes to be made available on all of the node VMs. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#oauth_scopes ContainerCluster#oauth_scopes}
        :param preemptible: Whether the nodes are created as preemptible VM instances. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#preemptible ContainerCluster#preemptible}
        :param reservation_affinity: reservation_affinity block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#reservation_affinity ContainerCluster#reservation_affinity}
        :param resource_labels: The GCE resource labels (a map of key/value pairs) to be applied to the node pool. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#resource_labels ContainerCluster#resource_labels}
        :param resource_manager_tags: A map of resource manager tags. Resource manager tag keys and values have the same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id}, and values are in the format tagValues/456. The field is ignored (both PUT & PATCH) when empty. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#resource_manager_tags ContainerCluster#resource_manager_tags}
        :param secondary_boot_disks: secondary_boot_disks block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#secondary_boot_disks ContainerCluster#secondary_boot_disks}
        :param service_account: The Google Cloud Platform Service Account to be used by the node VMs. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#service_account ContainerCluster#service_account}
        :param shielded_instance_config: shielded_instance_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#shielded_instance_config ContainerCluster#shielded_instance_config}
        :param sole_tenant_config: sole_tenant_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#sole_tenant_config ContainerCluster#sole_tenant_config}
        :param spot: Whether the nodes are created as spot VM instances. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#spot ContainerCluster#spot}
        :param storage_pools: The list of Storage Pools where boot disks are provisioned. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#storage_pools ContainerCluster#storage_pools}
        :param tags: The list of instance tags applied to all nodes. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#tags ContainerCluster#tags}
        :param taint: taint block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#taint ContainerCluster#taint}
        :param windows_node_config: windows_node_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#windows_node_config ContainerCluster#windows_node_config}
        :param workload_metadata_config: workload_metadata_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#workload_metadata_config ContainerCluster#workload_metadata_config}
        '''
        value = ContainerClusterNodeConfig(
            advanced_machine_features=advanced_machine_features,
            boot_disk=boot_disk,
            boot_disk_kms_key=boot_disk_kms_key,
            confidential_nodes=confidential_nodes,
            containerd_config=containerd_config,
            disk_size_gb=disk_size_gb,
            disk_type=disk_type,
            enable_confidential_storage=enable_confidential_storage,
            ephemeral_storage_local_ssd_config=ephemeral_storage_local_ssd_config,
            fast_socket=fast_socket,
            flex_start=flex_start,
            gcfs_config=gcfs_config,
            guest_accelerator=guest_accelerator,
            gvnic=gvnic,
            host_maintenance_policy=host_maintenance_policy,
            image_type=image_type,
            kubelet_config=kubelet_config,
            labels=labels,
            linux_node_config=linux_node_config,
            local_nvme_ssd_block_config=local_nvme_ssd_block_config,
            local_ssd_count=local_ssd_count,
            local_ssd_encryption_mode=local_ssd_encryption_mode,
            logging_variant=logging_variant,
            machine_type=machine_type,
            max_run_duration=max_run_duration,
            metadata=metadata,
            min_cpu_platform=min_cpu_platform,
            node_group=node_group,
            oauth_scopes=oauth_scopes,
            preemptible=preemptible,
            reservation_affinity=reservation_affinity,
            resource_labels=resource_labels,
            resource_manager_tags=resource_manager_tags,
            secondary_boot_disks=secondary_boot_disks,
            service_account=service_account,
            shielded_instance_config=shielded_instance_config,
            sole_tenant_config=sole_tenant_config,
            spot=spot,
            storage_pools=storage_pools,
            tags=tags,
            taint=taint,
            windows_node_config=windows_node_config,
            workload_metadata_config=workload_metadata_config,
        )

        return typing.cast(None, jsii.invoke(self, "putNodeConfig", [value]))

    @jsii.member(jsii_name="putNodePool")
    def put_node_pool(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ContainerClusterNodePool", typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__def24b0bab2637d0b9b35c4b7fca5c845eed84048b81fc3af2232b3db07ac2c1)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putNodePool", [value]))

    @jsii.member(jsii_name="putNodePoolAutoConfig")
    def put_node_pool_auto_config(
        self,
        *,
        linux_node_config: typing.Optional[typing.Union["ContainerClusterNodePoolAutoConfigLinuxNodeConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        network_tags: typing.Optional[typing.Union["ContainerClusterNodePoolAutoConfigNetworkTags", typing.Dict[builtins.str, typing.Any]]] = None,
        node_kubelet_config: typing.Optional[typing.Union["ContainerClusterNodePoolAutoConfigNodeKubeletConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        resource_manager_tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param linux_node_config: linux_node_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#linux_node_config ContainerCluster#linux_node_config}
        :param network_tags: network_tags block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#network_tags ContainerCluster#network_tags}
        :param node_kubelet_config: node_kubelet_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#node_kubelet_config ContainerCluster#node_kubelet_config}
        :param resource_manager_tags: A map of resource manager tags. Resource manager tag keys and values have the same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id}, and values are in the format tagValues/456. The field is ignored (both PUT & PATCH) when empty. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#resource_manager_tags ContainerCluster#resource_manager_tags}
        '''
        value = ContainerClusterNodePoolAutoConfig(
            linux_node_config=linux_node_config,
            network_tags=network_tags,
            node_kubelet_config=node_kubelet_config,
            resource_manager_tags=resource_manager_tags,
        )

        return typing.cast(None, jsii.invoke(self, "putNodePoolAutoConfig", [value]))

    @jsii.member(jsii_name="putNodePoolDefaults")
    def put_node_pool_defaults(
        self,
        *,
        node_config_defaults: typing.Optional[typing.Union["ContainerClusterNodePoolDefaultsNodeConfigDefaults", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param node_config_defaults: node_config_defaults block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#node_config_defaults ContainerCluster#node_config_defaults}
        '''
        value = ContainerClusterNodePoolDefaults(
            node_config_defaults=node_config_defaults
        )

        return typing.cast(None, jsii.invoke(self, "putNodePoolDefaults", [value]))

    @jsii.member(jsii_name="putNotificationConfig")
    def put_notification_config(
        self,
        *,
        pubsub: typing.Union["ContainerClusterNotificationConfigPubsub", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''
        :param pubsub: pubsub block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#pubsub ContainerCluster#pubsub}
        '''
        value = ContainerClusterNotificationConfig(pubsub=pubsub)

        return typing.cast(None, jsii.invoke(self, "putNotificationConfig", [value]))

    @jsii.member(jsii_name="putPodAutoscaling")
    def put_pod_autoscaling(self, *, hpa_profile: builtins.str) -> None:
        '''
        :param hpa_profile: HPA Profile is used to configure the Horizontal Pod Autoscaler (HPA) profile for the cluster. Available options include: - NONE: Customers explicitly opt-out of HPA profiles. - PERFORMANCE: PERFORMANCE is used when customers opt-in to the performance HPA profile. In this profile we support a higher number of HPAs per cluster and faster metrics collection for workload autoscaling. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#hpa_profile ContainerCluster#hpa_profile}
        '''
        value = ContainerClusterPodAutoscaling(hpa_profile=hpa_profile)

        return typing.cast(None, jsii.invoke(self, "putPodAutoscaling", [value]))

    @jsii.member(jsii_name="putPrivateClusterConfig")
    def put_private_cluster_config(
        self,
        *,
        enable_private_endpoint: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        enable_private_nodes: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        master_global_access_config: typing.Optional[typing.Union["ContainerClusterPrivateClusterConfigMasterGlobalAccessConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        master_ipv4_cidr_block: typing.Optional[builtins.str] = None,
        private_endpoint_subnetwork: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param enable_private_endpoint: When true, the cluster's private endpoint is used as the cluster endpoint and access through the public endpoint is disabled. When false, either endpoint can be used. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_private_endpoint ContainerCluster#enable_private_endpoint}
        :param enable_private_nodes: Enables the private cluster feature, creating a private endpoint on the cluster. In a private cluster, nodes only have RFC 1918 private addresses and communicate with the master's private endpoint via private networking. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_private_nodes ContainerCluster#enable_private_nodes}
        :param master_global_access_config: master_global_access_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#master_global_access_config ContainerCluster#master_global_access_config}
        :param master_ipv4_cidr_block: The IP range in CIDR notation to use for the hosted master network. This range will be used for assigning private IP addresses to the cluster master(s) and the ILB VIP. This range must not overlap with any other ranges in use within the cluster's network, and it must be a /28 subnet. See Private Cluster Limitations for more details. This field only applies to private clusters, when enable_private_nodes is true. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#master_ipv4_cidr_block ContainerCluster#master_ipv4_cidr_block}
        :param private_endpoint_subnetwork: Subnetwork in cluster's network where master's endpoint will be provisioned. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#private_endpoint_subnetwork ContainerCluster#private_endpoint_subnetwork}
        '''
        value = ContainerClusterPrivateClusterConfig(
            enable_private_endpoint=enable_private_endpoint,
            enable_private_nodes=enable_private_nodes,
            master_global_access_config=master_global_access_config,
            master_ipv4_cidr_block=master_ipv4_cidr_block,
            private_endpoint_subnetwork=private_endpoint_subnetwork,
        )

        return typing.cast(None, jsii.invoke(self, "putPrivateClusterConfig", [value]))

    @jsii.member(jsii_name="putRbacBindingConfig")
    def put_rbac_binding_config(
        self,
        *,
        enable_insecure_binding_system_authenticated: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        enable_insecure_binding_system_unauthenticated: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    ) -> None:
        '''
        :param enable_insecure_binding_system_authenticated: Setting this to true will allow any ClusterRoleBinding and RoleBinding with subjects system:authenticated. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_insecure_binding_system_authenticated ContainerCluster#enable_insecure_binding_system_authenticated}
        :param enable_insecure_binding_system_unauthenticated: Setting this to true will allow any ClusterRoleBinding and RoleBinding with subjects system:anonymous or system:unauthenticated. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_insecure_binding_system_unauthenticated ContainerCluster#enable_insecure_binding_system_unauthenticated}
        '''
        value = ContainerClusterRbacBindingConfig(
            enable_insecure_binding_system_authenticated=enable_insecure_binding_system_authenticated,
            enable_insecure_binding_system_unauthenticated=enable_insecure_binding_system_unauthenticated,
        )

        return typing.cast(None, jsii.invoke(self, "putRbacBindingConfig", [value]))

    @jsii.member(jsii_name="putReleaseChannel")
    def put_release_channel(self, *, channel: builtins.str) -> None:
        '''
        :param channel: The selected release channel. Accepted values are: - UNSPECIFIED: Not set. - RAPID: Weekly upgrade cadence; Early testers and developers who requires new features. - REGULAR: Multiple per month upgrade cadence; Production users who need features not yet offered in the Stable channel. - STABLE: Every few months upgrade cadence; Production users who need stability above all else, and for whom frequent upgrades are too risky. - EXTENDED: GKE provides extended support for Kubernetes minor versions through the Extended channel. With this channel, you can stay on a minor version for up to 24 months. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#channel ContainerCluster#channel}
        '''
        value = ContainerClusterReleaseChannel(channel=channel)

        return typing.cast(None, jsii.invoke(self, "putReleaseChannel", [value]))

    @jsii.member(jsii_name="putResourceUsageExportConfig")
    def put_resource_usage_export_config(
        self,
        *,
        bigquery_destination: typing.Union["ContainerClusterResourceUsageExportConfigBigqueryDestination", typing.Dict[builtins.str, typing.Any]],
        enable_network_egress_metering: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        enable_resource_consumption_metering: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    ) -> None:
        '''
        :param bigquery_destination: bigquery_destination block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#bigquery_destination ContainerCluster#bigquery_destination}
        :param enable_network_egress_metering: Whether to enable network egress metering for this cluster. If enabled, a daemonset will be created in the cluster to meter network egress traffic. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_network_egress_metering ContainerCluster#enable_network_egress_metering}
        :param enable_resource_consumption_metering: Whether to enable resource consumption metering on this cluster. When enabled, a table will be created in the resource export BigQuery dataset to store resource consumption data. The resulting table can be joined with the resource usage table or with BigQuery billing export. Defaults to true. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_resource_consumption_metering ContainerCluster#enable_resource_consumption_metering}
        '''
        value = ContainerClusterResourceUsageExportConfig(
            bigquery_destination=bigquery_destination,
            enable_network_egress_metering=enable_network_egress_metering,
            enable_resource_consumption_metering=enable_resource_consumption_metering,
        )

        return typing.cast(None, jsii.invoke(self, "putResourceUsageExportConfig", [value]))

    @jsii.member(jsii_name="putSecretManagerConfig")
    def put_secret_manager_config(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param enabled: Enable the Secret manager csi component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        '''
        value = ContainerClusterSecretManagerConfig(enabled=enabled)

        return typing.cast(None, jsii.invoke(self, "putSecretManagerConfig", [value]))

    @jsii.member(jsii_name="putSecurityPostureConfig")
    def put_security_posture_config(
        self,
        *,
        mode: typing.Optional[builtins.str] = None,
        vulnerability_mode: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param mode: Sets the mode of the Kubernetes security posture API's off-cluster features. Available options include DISABLED, BASIC, and ENTERPRISE. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#mode ContainerCluster#mode}
        :param vulnerability_mode: Sets the mode of the Kubernetes security posture API's workload vulnerability scanning. Available options include VULNERABILITY_DISABLED, VULNERABILITY_BASIC and VULNERABILITY_ENTERPRISE. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#vulnerability_mode ContainerCluster#vulnerability_mode}
        '''
        value = ContainerClusterSecurityPostureConfig(
            mode=mode, vulnerability_mode=vulnerability_mode
        )

        return typing.cast(None, jsii.invoke(self, "putSecurityPostureConfig", [value]))

    @jsii.member(jsii_name="putServiceExternalIpsConfig")
    def put_service_external_ips_config(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param enabled: When enabled, services with external ips specified will be allowed. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        '''
        value = ContainerClusterServiceExternalIpsConfig(enabled=enabled)

        return typing.cast(None, jsii.invoke(self, "putServiceExternalIpsConfig", [value]))

    @jsii.member(jsii_name="putTimeouts")
    def put_timeouts(
        self,
        *,
        create: typing.Optional[builtins.str] = None,
        delete: typing.Optional[builtins.str] = None,
        read: typing.Optional[builtins.str] = None,
        update: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param create: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#create ContainerCluster#create}.
        :param delete: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#delete ContainerCluster#delete}.
        :param read: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#read ContainerCluster#read}.
        :param update: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#update ContainerCluster#update}.
        '''
        value = ContainerClusterTimeouts(
            create=create, delete=delete, read=read, update=update
        )

        return typing.cast(None, jsii.invoke(self, "putTimeouts", [value]))

    @jsii.member(jsii_name="putUserManagedKeysConfig")
    def put_user_managed_keys_config(
        self,
        *,
        aggregation_ca: typing.Optional[builtins.str] = None,
        cluster_ca: typing.Optional[builtins.str] = None,
        control_plane_disk_encryption_key: typing.Optional[builtins.str] = None,
        etcd_api_ca: typing.Optional[builtins.str] = None,
        etcd_peer_ca: typing.Optional[builtins.str] = None,
        gkeops_etcd_backup_encryption_key: typing.Optional[builtins.str] = None,
        service_account_signing_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
        service_account_verification_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param aggregation_ca: The Certificate Authority Service caPool to use for the aggreation CA in this cluster. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#aggregation_ca ContainerCluster#aggregation_ca}
        :param cluster_ca: The Certificate Authority Service caPool to use for the cluster CA in this cluster. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cluster_ca ContainerCluster#cluster_ca}
        :param control_plane_disk_encryption_key: The Cloud KMS cryptoKey to use for Confidential Hyperdisk on the control plane nodes. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#control_plane_disk_encryption_key ContainerCluster#control_plane_disk_encryption_key}
        :param etcd_api_ca: The Certificate Authority Service caPool to use for the etcd API CA in this cluster. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#etcd_api_ca ContainerCluster#etcd_api_ca}
        :param etcd_peer_ca: The Certificate Authority Service caPool to use for the etcd peer CA in this cluster. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#etcd_peer_ca ContainerCluster#etcd_peer_ca}
        :param gkeops_etcd_backup_encryption_key: Resource path of the Cloud KMS cryptoKey to use for encryption of internal etcd backups. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gkeops_etcd_backup_encryption_key ContainerCluster#gkeops_etcd_backup_encryption_key}
        :param service_account_signing_keys: The Cloud KMS cryptoKeyVersions to use for signing service account JWTs issued by this cluster. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#service_account_signing_keys ContainerCluster#service_account_signing_keys}
        :param service_account_verification_keys: The Cloud KMS cryptoKeyVersions to use for verifying service account JWTs issued by this cluster. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#service_account_verification_keys ContainerCluster#service_account_verification_keys}
        '''
        value = ContainerClusterUserManagedKeysConfig(
            aggregation_ca=aggregation_ca,
            cluster_ca=cluster_ca,
            control_plane_disk_encryption_key=control_plane_disk_encryption_key,
            etcd_api_ca=etcd_api_ca,
            etcd_peer_ca=etcd_peer_ca,
            gkeops_etcd_backup_encryption_key=gkeops_etcd_backup_encryption_key,
            service_account_signing_keys=service_account_signing_keys,
            service_account_verification_keys=service_account_verification_keys,
        )

        return typing.cast(None, jsii.invoke(self, "putUserManagedKeysConfig", [value]))

    @jsii.member(jsii_name="putVerticalPodAutoscaling")
    def put_vertical_pod_autoscaling(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param enabled: Enables vertical pod autoscaling. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        '''
        value = ContainerClusterVerticalPodAutoscaling(enabled=enabled)

        return typing.cast(None, jsii.invoke(self, "putVerticalPodAutoscaling", [value]))

    @jsii.member(jsii_name="putWorkloadIdentityConfig")
    def put_workload_identity_config(
        self,
        *,
        workload_pool: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param workload_pool: The workload pool to attach all Kubernetes service accounts to. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#workload_pool ContainerCluster#workload_pool}
        '''
        value = ContainerClusterWorkloadIdentityConfig(workload_pool=workload_pool)

        return typing.cast(None, jsii.invoke(self, "putWorkloadIdentityConfig", [value]))

    @jsii.member(jsii_name="resetAddonsConfig")
    def reset_addons_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAddonsConfig", []))

    @jsii.member(jsii_name="resetAllowNetAdmin")
    def reset_allow_net_admin(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAllowNetAdmin", []))

    @jsii.member(jsii_name="resetAnonymousAuthenticationConfig")
    def reset_anonymous_authentication_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAnonymousAuthenticationConfig", []))

    @jsii.member(jsii_name="resetAuthenticatorGroupsConfig")
    def reset_authenticator_groups_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAuthenticatorGroupsConfig", []))

    @jsii.member(jsii_name="resetBinaryAuthorization")
    def reset_binary_authorization(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBinaryAuthorization", []))

    @jsii.member(jsii_name="resetClusterAutoscaling")
    def reset_cluster_autoscaling(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetClusterAutoscaling", []))

    @jsii.member(jsii_name="resetClusterIpv4Cidr")
    def reset_cluster_ipv4_cidr(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetClusterIpv4Cidr", []))

    @jsii.member(jsii_name="resetConfidentialNodes")
    def reset_confidential_nodes(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetConfidentialNodes", []))

    @jsii.member(jsii_name="resetControlPlaneEndpointsConfig")
    def reset_control_plane_endpoints_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetControlPlaneEndpointsConfig", []))

    @jsii.member(jsii_name="resetCostManagementConfig")
    def reset_cost_management_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCostManagementConfig", []))

    @jsii.member(jsii_name="resetDatabaseEncryption")
    def reset_database_encryption(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDatabaseEncryption", []))

    @jsii.member(jsii_name="resetDatapathProvider")
    def reset_datapath_provider(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDatapathProvider", []))

    @jsii.member(jsii_name="resetDefaultMaxPodsPerNode")
    def reset_default_max_pods_per_node(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDefaultMaxPodsPerNode", []))

    @jsii.member(jsii_name="resetDefaultSnatStatus")
    def reset_default_snat_status(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDefaultSnatStatus", []))

    @jsii.member(jsii_name="resetDeletionProtection")
    def reset_deletion_protection(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDeletionProtection", []))

    @jsii.member(jsii_name="resetDescription")
    def reset_description(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDescription", []))

    @jsii.member(jsii_name="resetDisableL4LbFirewallReconciliation")
    def reset_disable_l4_lb_firewall_reconciliation(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDisableL4LbFirewallReconciliation", []))

    @jsii.member(jsii_name="resetDnsConfig")
    def reset_dns_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDnsConfig", []))

    @jsii.member(jsii_name="resetEnableAutopilot")
    def reset_enable_autopilot(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnableAutopilot", []))

    @jsii.member(jsii_name="resetEnableCiliumClusterwideNetworkPolicy")
    def reset_enable_cilium_clusterwide_network_policy(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnableCiliumClusterwideNetworkPolicy", []))

    @jsii.member(jsii_name="resetEnableFqdnNetworkPolicy")
    def reset_enable_fqdn_network_policy(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnableFqdnNetworkPolicy", []))

    @jsii.member(jsii_name="resetEnableIntranodeVisibility")
    def reset_enable_intranode_visibility(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnableIntranodeVisibility", []))

    @jsii.member(jsii_name="resetEnableK8SBetaApis")
    def reset_enable_k8_s_beta_apis(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnableK8SBetaApis", []))

    @jsii.member(jsii_name="resetEnableKubernetesAlpha")
    def reset_enable_kubernetes_alpha(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnableKubernetesAlpha", []))

    @jsii.member(jsii_name="resetEnableL4IlbSubsetting")
    def reset_enable_l4_ilb_subsetting(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnableL4IlbSubsetting", []))

    @jsii.member(jsii_name="resetEnableLegacyAbac")
    def reset_enable_legacy_abac(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnableLegacyAbac", []))

    @jsii.member(jsii_name="resetEnableMultiNetworking")
    def reset_enable_multi_networking(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnableMultiNetworking", []))

    @jsii.member(jsii_name="resetEnableShieldedNodes")
    def reset_enable_shielded_nodes(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnableShieldedNodes", []))

    @jsii.member(jsii_name="resetEnableTpu")
    def reset_enable_tpu(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnableTpu", []))

    @jsii.member(jsii_name="resetEnterpriseConfig")
    def reset_enterprise_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnterpriseConfig", []))

    @jsii.member(jsii_name="resetFleet")
    def reset_fleet(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetFleet", []))

    @jsii.member(jsii_name="resetGatewayApiConfig")
    def reset_gateway_api_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGatewayApiConfig", []))

    @jsii.member(jsii_name="resetGkeAutoUpgradeConfig")
    def reset_gke_auto_upgrade_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGkeAutoUpgradeConfig", []))

    @jsii.member(jsii_name="resetId")
    def reset_id(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetId", []))

    @jsii.member(jsii_name="resetIdentityServiceConfig")
    def reset_identity_service_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetIdentityServiceConfig", []))

    @jsii.member(jsii_name="resetInitialNodeCount")
    def reset_initial_node_count(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetInitialNodeCount", []))

    @jsii.member(jsii_name="resetInTransitEncryptionConfig")
    def reset_in_transit_encryption_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetInTransitEncryptionConfig", []))

    @jsii.member(jsii_name="resetIpAllocationPolicy")
    def reset_ip_allocation_policy(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetIpAllocationPolicy", []))

    @jsii.member(jsii_name="resetLocation")
    def reset_location(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLocation", []))

    @jsii.member(jsii_name="resetLoggingConfig")
    def reset_logging_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLoggingConfig", []))

    @jsii.member(jsii_name="resetLoggingService")
    def reset_logging_service(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLoggingService", []))

    @jsii.member(jsii_name="resetMaintenancePolicy")
    def reset_maintenance_policy(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMaintenancePolicy", []))

    @jsii.member(jsii_name="resetMasterAuth")
    def reset_master_auth(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMasterAuth", []))

    @jsii.member(jsii_name="resetMasterAuthorizedNetworksConfig")
    def reset_master_authorized_networks_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMasterAuthorizedNetworksConfig", []))

    @jsii.member(jsii_name="resetMeshCertificates")
    def reset_mesh_certificates(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMeshCertificates", []))

    @jsii.member(jsii_name="resetMinMasterVersion")
    def reset_min_master_version(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMinMasterVersion", []))

    @jsii.member(jsii_name="resetMonitoringConfig")
    def reset_monitoring_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMonitoringConfig", []))

    @jsii.member(jsii_name="resetMonitoringService")
    def reset_monitoring_service(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMonitoringService", []))

    @jsii.member(jsii_name="resetNetwork")
    def reset_network(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNetwork", []))

    @jsii.member(jsii_name="resetNetworkingMode")
    def reset_networking_mode(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNetworkingMode", []))

    @jsii.member(jsii_name="resetNetworkPerformanceConfig")
    def reset_network_performance_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNetworkPerformanceConfig", []))

    @jsii.member(jsii_name="resetNetworkPolicy")
    def reset_network_policy(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNetworkPolicy", []))

    @jsii.member(jsii_name="resetNodeConfig")
    def reset_node_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNodeConfig", []))

    @jsii.member(jsii_name="resetNodeLocations")
    def reset_node_locations(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNodeLocations", []))

    @jsii.member(jsii_name="resetNodePool")
    def reset_node_pool(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNodePool", []))

    @jsii.member(jsii_name="resetNodePoolAutoConfig")
    def reset_node_pool_auto_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNodePoolAutoConfig", []))

    @jsii.member(jsii_name="resetNodePoolDefaults")
    def reset_node_pool_defaults(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNodePoolDefaults", []))

    @jsii.member(jsii_name="resetNodeVersion")
    def reset_node_version(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNodeVersion", []))

    @jsii.member(jsii_name="resetNotificationConfig")
    def reset_notification_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNotificationConfig", []))

    @jsii.member(jsii_name="resetPodAutoscaling")
    def reset_pod_autoscaling(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPodAutoscaling", []))

    @jsii.member(jsii_name="resetPrivateClusterConfig")
    def reset_private_cluster_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPrivateClusterConfig", []))

    @jsii.member(jsii_name="resetPrivateIpv6GoogleAccess")
    def reset_private_ipv6_google_access(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPrivateIpv6GoogleAccess", []))

    @jsii.member(jsii_name="resetProject")
    def reset_project(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetProject", []))

    @jsii.member(jsii_name="resetRbacBindingConfig")
    def reset_rbac_binding_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRbacBindingConfig", []))

    @jsii.member(jsii_name="resetReleaseChannel")
    def reset_release_channel(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetReleaseChannel", []))

    @jsii.member(jsii_name="resetRemoveDefaultNodePool")
    def reset_remove_default_node_pool(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRemoveDefaultNodePool", []))

    @jsii.member(jsii_name="resetResourceLabels")
    def reset_resource_labels(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetResourceLabels", []))

    @jsii.member(jsii_name="resetResourceUsageExportConfig")
    def reset_resource_usage_export_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetResourceUsageExportConfig", []))

    @jsii.member(jsii_name="resetSecretManagerConfig")
    def reset_secret_manager_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSecretManagerConfig", []))

    @jsii.member(jsii_name="resetSecurityPostureConfig")
    def reset_security_posture_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSecurityPostureConfig", []))

    @jsii.member(jsii_name="resetServiceExternalIpsConfig")
    def reset_service_external_ips_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetServiceExternalIpsConfig", []))

    @jsii.member(jsii_name="resetSubnetwork")
    def reset_subnetwork(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSubnetwork", []))

    @jsii.member(jsii_name="resetTimeouts")
    def reset_timeouts(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTimeouts", []))

    @jsii.member(jsii_name="resetUserManagedKeysConfig")
    def reset_user_managed_keys_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetUserManagedKeysConfig", []))

    @jsii.member(jsii_name="resetVerticalPodAutoscaling")
    def reset_vertical_pod_autoscaling(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetVerticalPodAutoscaling", []))

    @jsii.member(jsii_name="resetWorkloadIdentityConfig")
    def reset_workload_identity_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetWorkloadIdentityConfig", []))

    @jsii.member(jsii_name="synthesizeAttributes")
    def _synthesize_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeAttributes", []))

    @jsii.member(jsii_name="synthesizeHclAttributes")
    def _synthesize_hcl_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeHclAttributes", []))

    @jsii.python.classproperty
    @jsii.member(jsii_name="tfResourceType")
    def TF_RESOURCE_TYPE(cls) -> builtins.str:
        return typing.cast(builtins.str, jsii.sget(cls, "tfResourceType"))

    @builtins.property
    @jsii.member(jsii_name="addonsConfig")
    def addons_config(self) -> "ContainerClusterAddonsConfigOutputReference":
        return typing.cast("ContainerClusterAddonsConfigOutputReference", jsii.get(self, "addonsConfig"))

    @builtins.property
    @jsii.member(jsii_name="anonymousAuthenticationConfig")
    def anonymous_authentication_config(
        self,
    ) -> "ContainerClusterAnonymousAuthenticationConfigOutputReference":
        return typing.cast("ContainerClusterAnonymousAuthenticationConfigOutputReference", jsii.get(self, "anonymousAuthenticationConfig"))

    @builtins.property
    @jsii.member(jsii_name="authenticatorGroupsConfig")
    def authenticator_groups_config(
        self,
    ) -> "ContainerClusterAuthenticatorGroupsConfigOutputReference":
        return typing.cast("ContainerClusterAuthenticatorGroupsConfigOutputReference", jsii.get(self, "authenticatorGroupsConfig"))

    @builtins.property
    @jsii.member(jsii_name="binaryAuthorization")
    def binary_authorization(
        self,
    ) -> "ContainerClusterBinaryAuthorizationOutputReference":
        return typing.cast("ContainerClusterBinaryAuthorizationOutputReference", jsii.get(self, "binaryAuthorization"))

    @builtins.property
    @jsii.member(jsii_name="clusterAutoscaling")
    def cluster_autoscaling(
        self,
    ) -> "ContainerClusterClusterAutoscalingOutputReference":
        return typing.cast("ContainerClusterClusterAutoscalingOutputReference", jsii.get(self, "clusterAutoscaling"))

    @builtins.property
    @jsii.member(jsii_name="confidentialNodes")
    def confidential_nodes(self) -> "ContainerClusterConfidentialNodesOutputReference":
        return typing.cast("ContainerClusterConfidentialNodesOutputReference", jsii.get(self, "confidentialNodes"))

    @builtins.property
    @jsii.member(jsii_name="controlPlaneEndpointsConfig")
    def control_plane_endpoints_config(
        self,
    ) -> "ContainerClusterControlPlaneEndpointsConfigOutputReference":
        return typing.cast("ContainerClusterControlPlaneEndpointsConfigOutputReference", jsii.get(self, "controlPlaneEndpointsConfig"))

    @builtins.property
    @jsii.member(jsii_name="costManagementConfig")
    def cost_management_config(
        self,
    ) -> "ContainerClusterCostManagementConfigOutputReference":
        return typing.cast("ContainerClusterCostManagementConfigOutputReference", jsii.get(self, "costManagementConfig"))

    @builtins.property
    @jsii.member(jsii_name="databaseEncryption")
    def database_encryption(
        self,
    ) -> "ContainerClusterDatabaseEncryptionOutputReference":
        return typing.cast("ContainerClusterDatabaseEncryptionOutputReference", jsii.get(self, "databaseEncryption"))

    @builtins.property
    @jsii.member(jsii_name="defaultSnatStatus")
    def default_snat_status(self) -> "ContainerClusterDefaultSnatStatusOutputReference":
        return typing.cast("ContainerClusterDefaultSnatStatusOutputReference", jsii.get(self, "defaultSnatStatus"))

    @builtins.property
    @jsii.member(jsii_name="dnsConfig")
    def dns_config(self) -> "ContainerClusterDnsConfigOutputReference":
        return typing.cast("ContainerClusterDnsConfigOutputReference", jsii.get(self, "dnsConfig"))

    @builtins.property
    @jsii.member(jsii_name="effectiveLabels")
    def effective_labels(self) -> _cdktf_9a9027ec.StringMap:
        return typing.cast(_cdktf_9a9027ec.StringMap, jsii.get(self, "effectiveLabels"))

    @builtins.property
    @jsii.member(jsii_name="enableK8SBetaApis")
    def enable_k8_s_beta_apis(
        self,
    ) -> "ContainerClusterEnableK8SBetaApisOutputReference":
        return typing.cast("ContainerClusterEnableK8SBetaApisOutputReference", jsii.get(self, "enableK8SBetaApis"))

    @builtins.property
    @jsii.member(jsii_name="endpoint")
    def endpoint(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "endpoint"))

    @builtins.property
    @jsii.member(jsii_name="enterpriseConfig")
    def enterprise_config(self) -> "ContainerClusterEnterpriseConfigOutputReference":
        return typing.cast("ContainerClusterEnterpriseConfigOutputReference", jsii.get(self, "enterpriseConfig"))

    @builtins.property
    @jsii.member(jsii_name="fleet")
    def fleet(self) -> "ContainerClusterFleetOutputReference":
        return typing.cast("ContainerClusterFleetOutputReference", jsii.get(self, "fleet"))

    @builtins.property
    @jsii.member(jsii_name="gatewayApiConfig")
    def gateway_api_config(self) -> "ContainerClusterGatewayApiConfigOutputReference":
        return typing.cast("ContainerClusterGatewayApiConfigOutputReference", jsii.get(self, "gatewayApiConfig"))

    @builtins.property
    @jsii.member(jsii_name="gkeAutoUpgradeConfig")
    def gke_auto_upgrade_config(
        self,
    ) -> "ContainerClusterGkeAutoUpgradeConfigOutputReference":
        return typing.cast("ContainerClusterGkeAutoUpgradeConfigOutputReference", jsii.get(self, "gkeAutoUpgradeConfig"))

    @builtins.property
    @jsii.member(jsii_name="identityServiceConfig")
    def identity_service_config(
        self,
    ) -> "ContainerClusterIdentityServiceConfigOutputReference":
        return typing.cast("ContainerClusterIdentityServiceConfigOutputReference", jsii.get(self, "identityServiceConfig"))

    @builtins.property
    @jsii.member(jsii_name="ipAllocationPolicy")
    def ip_allocation_policy(
        self,
    ) -> "ContainerClusterIpAllocationPolicyOutputReference":
        return typing.cast("ContainerClusterIpAllocationPolicyOutputReference", jsii.get(self, "ipAllocationPolicy"))

    @builtins.property
    @jsii.member(jsii_name="labelFingerprint")
    def label_fingerprint(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "labelFingerprint"))

    @builtins.property
    @jsii.member(jsii_name="loggingConfig")
    def logging_config(self) -> "ContainerClusterLoggingConfigOutputReference":
        return typing.cast("ContainerClusterLoggingConfigOutputReference", jsii.get(self, "loggingConfig"))

    @builtins.property
    @jsii.member(jsii_name="maintenancePolicy")
    def maintenance_policy(self) -> "ContainerClusterMaintenancePolicyOutputReference":
        return typing.cast("ContainerClusterMaintenancePolicyOutputReference", jsii.get(self, "maintenancePolicy"))

    @builtins.property
    @jsii.member(jsii_name="masterAuth")
    def master_auth(self) -> "ContainerClusterMasterAuthOutputReference":
        return typing.cast("ContainerClusterMasterAuthOutputReference", jsii.get(self, "masterAuth"))

    @builtins.property
    @jsii.member(jsii_name="masterAuthorizedNetworksConfig")
    def master_authorized_networks_config(
        self,
    ) -> "ContainerClusterMasterAuthorizedNetworksConfigOutputReference":
        return typing.cast("ContainerClusterMasterAuthorizedNetworksConfigOutputReference", jsii.get(self, "masterAuthorizedNetworksConfig"))

    @builtins.property
    @jsii.member(jsii_name="masterVersion")
    def master_version(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "masterVersion"))

    @builtins.property
    @jsii.member(jsii_name="meshCertificates")
    def mesh_certificates(self) -> "ContainerClusterMeshCertificatesOutputReference":
        return typing.cast("ContainerClusterMeshCertificatesOutputReference", jsii.get(self, "meshCertificates"))

    @builtins.property
    @jsii.member(jsii_name="monitoringConfig")
    def monitoring_config(self) -> "ContainerClusterMonitoringConfigOutputReference":
        return typing.cast("ContainerClusterMonitoringConfigOutputReference", jsii.get(self, "monitoringConfig"))

    @builtins.property
    @jsii.member(jsii_name="networkPerformanceConfig")
    def network_performance_config(
        self,
    ) -> "ContainerClusterNetworkPerformanceConfigOutputReference":
        return typing.cast("ContainerClusterNetworkPerformanceConfigOutputReference", jsii.get(self, "networkPerformanceConfig"))

    @builtins.property
    @jsii.member(jsii_name="networkPolicy")
    def network_policy(self) -> "ContainerClusterNetworkPolicyOutputReference":
        return typing.cast("ContainerClusterNetworkPolicyOutputReference", jsii.get(self, "networkPolicy"))

    @builtins.property
    @jsii.member(jsii_name="nodeConfig")
    def node_config(self) -> "ContainerClusterNodeConfigOutputReference":
        return typing.cast("ContainerClusterNodeConfigOutputReference", jsii.get(self, "nodeConfig"))

    @builtins.property
    @jsii.member(jsii_name="nodePool")
    def node_pool(self) -> "ContainerClusterNodePoolList":
        return typing.cast("ContainerClusterNodePoolList", jsii.get(self, "nodePool"))

    @builtins.property
    @jsii.member(jsii_name="nodePoolAutoConfig")
    def node_pool_auto_config(
        self,
    ) -> "ContainerClusterNodePoolAutoConfigOutputReference":
        return typing.cast("ContainerClusterNodePoolAutoConfigOutputReference", jsii.get(self, "nodePoolAutoConfig"))

    @builtins.property
    @jsii.member(jsii_name="nodePoolDefaults")
    def node_pool_defaults(self) -> "ContainerClusterNodePoolDefaultsOutputReference":
        return typing.cast("ContainerClusterNodePoolDefaultsOutputReference", jsii.get(self, "nodePoolDefaults"))

    @builtins.property
    @jsii.member(jsii_name="notificationConfig")
    def notification_config(
        self,
    ) -> "ContainerClusterNotificationConfigOutputReference":
        return typing.cast("ContainerClusterNotificationConfigOutputReference", jsii.get(self, "notificationConfig"))

    @builtins.property
    @jsii.member(jsii_name="operation")
    def operation(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "operation"))

    @builtins.property
    @jsii.member(jsii_name="podAutoscaling")
    def pod_autoscaling(self) -> "ContainerClusterPodAutoscalingOutputReference":
        return typing.cast("ContainerClusterPodAutoscalingOutputReference", jsii.get(self, "podAutoscaling"))

    @builtins.property
    @jsii.member(jsii_name="privateClusterConfig")
    def private_cluster_config(
        self,
    ) -> "ContainerClusterPrivateClusterConfigOutputReference":
        return typing.cast("ContainerClusterPrivateClusterConfigOutputReference", jsii.get(self, "privateClusterConfig"))

    @builtins.property
    @jsii.member(jsii_name="rbacBindingConfig")
    def rbac_binding_config(self) -> "ContainerClusterRbacBindingConfigOutputReference":
        return typing.cast("ContainerClusterRbacBindingConfigOutputReference", jsii.get(self, "rbacBindingConfig"))

    @builtins.property
    @jsii.member(jsii_name="releaseChannel")
    def release_channel(self) -> "ContainerClusterReleaseChannelOutputReference":
        return typing.cast("ContainerClusterReleaseChannelOutputReference", jsii.get(self, "releaseChannel"))

    @builtins.property
    @jsii.member(jsii_name="resourceUsageExportConfig")
    def resource_usage_export_config(
        self,
    ) -> "ContainerClusterResourceUsageExportConfigOutputReference":
        return typing.cast("ContainerClusterResourceUsageExportConfigOutputReference", jsii.get(self, "resourceUsageExportConfig"))

    @builtins.property
    @jsii.member(jsii_name="secretManagerConfig")
    def secret_manager_config(
        self,
    ) -> "ContainerClusterSecretManagerConfigOutputReference":
        return typing.cast("ContainerClusterSecretManagerConfigOutputReference", jsii.get(self, "secretManagerConfig"))

    @builtins.property
    @jsii.member(jsii_name="securityPostureConfig")
    def security_posture_config(
        self,
    ) -> "ContainerClusterSecurityPostureConfigOutputReference":
        return typing.cast("ContainerClusterSecurityPostureConfigOutputReference", jsii.get(self, "securityPostureConfig"))

    @builtins.property
    @jsii.member(jsii_name="selfLink")
    def self_link(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "selfLink"))

    @builtins.property
    @jsii.member(jsii_name="serviceExternalIpsConfig")
    def service_external_ips_config(
        self,
    ) -> "ContainerClusterServiceExternalIpsConfigOutputReference":
        return typing.cast("ContainerClusterServiceExternalIpsConfigOutputReference", jsii.get(self, "serviceExternalIpsConfig"))

    @builtins.property
    @jsii.member(jsii_name="servicesIpv4Cidr")
    def services_ipv4_cidr(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "servicesIpv4Cidr"))

    @builtins.property
    @jsii.member(jsii_name="terraformLabels")
    def terraform_labels(self) -> _cdktf_9a9027ec.StringMap:
        return typing.cast(_cdktf_9a9027ec.StringMap, jsii.get(self, "terraformLabels"))

    @builtins.property
    @jsii.member(jsii_name="timeouts")
    def timeouts(self) -> "ContainerClusterTimeoutsOutputReference":
        return typing.cast("ContainerClusterTimeoutsOutputReference", jsii.get(self, "timeouts"))

    @builtins.property
    @jsii.member(jsii_name="tpuIpv4CidrBlock")
    def tpu_ipv4_cidr_block(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "tpuIpv4CidrBlock"))

    @builtins.property
    @jsii.member(jsii_name="userManagedKeysConfig")
    def user_managed_keys_config(
        self,
    ) -> "ContainerClusterUserManagedKeysConfigOutputReference":
        return typing.cast("ContainerClusterUserManagedKeysConfigOutputReference", jsii.get(self, "userManagedKeysConfig"))

    @builtins.property
    @jsii.member(jsii_name="verticalPodAutoscaling")
    def vertical_pod_autoscaling(
        self,
    ) -> "ContainerClusterVerticalPodAutoscalingOutputReference":
        return typing.cast("ContainerClusterVerticalPodAutoscalingOutputReference", jsii.get(self, "verticalPodAutoscaling"))

    @builtins.property
    @jsii.member(jsii_name="workloadIdentityConfig")
    def workload_identity_config(
        self,
    ) -> "ContainerClusterWorkloadIdentityConfigOutputReference":
        return typing.cast("ContainerClusterWorkloadIdentityConfigOutputReference", jsii.get(self, "workloadIdentityConfig"))

    @builtins.property
    @jsii.member(jsii_name="addonsConfigInput")
    def addons_config_input(self) -> typing.Optional["ContainerClusterAddonsConfig"]:
        return typing.cast(typing.Optional["ContainerClusterAddonsConfig"], jsii.get(self, "addonsConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="allowNetAdminInput")
    def allow_net_admin_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "allowNetAdminInput"))

    @builtins.property
    @jsii.member(jsii_name="anonymousAuthenticationConfigInput")
    def anonymous_authentication_config_input(
        self,
    ) -> typing.Optional["ContainerClusterAnonymousAuthenticationConfig"]:
        return typing.cast(typing.Optional["ContainerClusterAnonymousAuthenticationConfig"], jsii.get(self, "anonymousAuthenticationConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="authenticatorGroupsConfigInput")
    def authenticator_groups_config_input(
        self,
    ) -> typing.Optional["ContainerClusterAuthenticatorGroupsConfig"]:
        return typing.cast(typing.Optional["ContainerClusterAuthenticatorGroupsConfig"], jsii.get(self, "authenticatorGroupsConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="binaryAuthorizationInput")
    def binary_authorization_input(
        self,
    ) -> typing.Optional["ContainerClusterBinaryAuthorization"]:
        return typing.cast(typing.Optional["ContainerClusterBinaryAuthorization"], jsii.get(self, "binaryAuthorizationInput"))

    @builtins.property
    @jsii.member(jsii_name="clusterAutoscalingInput")
    def cluster_autoscaling_input(
        self,
    ) -> typing.Optional["ContainerClusterClusterAutoscaling"]:
        return typing.cast(typing.Optional["ContainerClusterClusterAutoscaling"], jsii.get(self, "clusterAutoscalingInput"))

    @builtins.property
    @jsii.member(jsii_name="clusterIpv4CidrInput")
    def cluster_ipv4_cidr_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "clusterIpv4CidrInput"))

    @builtins.property
    @jsii.member(jsii_name="confidentialNodesInput")
    def confidential_nodes_input(
        self,
    ) -> typing.Optional["ContainerClusterConfidentialNodes"]:
        return typing.cast(typing.Optional["ContainerClusterConfidentialNodes"], jsii.get(self, "confidentialNodesInput"))

    @builtins.property
    @jsii.member(jsii_name="controlPlaneEndpointsConfigInput")
    def control_plane_endpoints_config_input(
        self,
    ) -> typing.Optional["ContainerClusterControlPlaneEndpointsConfig"]:
        return typing.cast(typing.Optional["ContainerClusterControlPlaneEndpointsConfig"], jsii.get(self, "controlPlaneEndpointsConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="costManagementConfigInput")
    def cost_management_config_input(
        self,
    ) -> typing.Optional["ContainerClusterCostManagementConfig"]:
        return typing.cast(typing.Optional["ContainerClusterCostManagementConfig"], jsii.get(self, "costManagementConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="databaseEncryptionInput")
    def database_encryption_input(
        self,
    ) -> typing.Optional["ContainerClusterDatabaseEncryption"]:
        return typing.cast(typing.Optional["ContainerClusterDatabaseEncryption"], jsii.get(self, "databaseEncryptionInput"))

    @builtins.property
    @jsii.member(jsii_name="datapathProviderInput")
    def datapath_provider_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "datapathProviderInput"))

    @builtins.property
    @jsii.member(jsii_name="defaultMaxPodsPerNodeInput")
    def default_max_pods_per_node_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "defaultMaxPodsPerNodeInput"))

    @builtins.property
    @jsii.member(jsii_name="defaultSnatStatusInput")
    def default_snat_status_input(
        self,
    ) -> typing.Optional["ContainerClusterDefaultSnatStatus"]:
        return typing.cast(typing.Optional["ContainerClusterDefaultSnatStatus"], jsii.get(self, "defaultSnatStatusInput"))

    @builtins.property
    @jsii.member(jsii_name="deletionProtectionInput")
    def deletion_protection_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "deletionProtectionInput"))

    @builtins.property
    @jsii.member(jsii_name="descriptionInput")
    def description_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "descriptionInput"))

    @builtins.property
    @jsii.member(jsii_name="disableL4LbFirewallReconciliationInput")
    def disable_l4_lb_firewall_reconciliation_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "disableL4LbFirewallReconciliationInput"))

    @builtins.property
    @jsii.member(jsii_name="dnsConfigInput")
    def dns_config_input(self) -> typing.Optional["ContainerClusterDnsConfig"]:
        return typing.cast(typing.Optional["ContainerClusterDnsConfig"], jsii.get(self, "dnsConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="enableAutopilotInput")
    def enable_autopilot_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enableAutopilotInput"))

    @builtins.property
    @jsii.member(jsii_name="enableCiliumClusterwideNetworkPolicyInput")
    def enable_cilium_clusterwide_network_policy_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enableCiliumClusterwideNetworkPolicyInput"))

    @builtins.property
    @jsii.member(jsii_name="enableFqdnNetworkPolicyInput")
    def enable_fqdn_network_policy_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enableFqdnNetworkPolicyInput"))

    @builtins.property
    @jsii.member(jsii_name="enableIntranodeVisibilityInput")
    def enable_intranode_visibility_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enableIntranodeVisibilityInput"))

    @builtins.property
    @jsii.member(jsii_name="enableK8SBetaApisInput")
    def enable_k8_s_beta_apis_input(
        self,
    ) -> typing.Optional["ContainerClusterEnableK8SBetaApis"]:
        return typing.cast(typing.Optional["ContainerClusterEnableK8SBetaApis"], jsii.get(self, "enableK8SBetaApisInput"))

    @builtins.property
    @jsii.member(jsii_name="enableKubernetesAlphaInput")
    def enable_kubernetes_alpha_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enableKubernetesAlphaInput"))

    @builtins.property
    @jsii.member(jsii_name="enableL4IlbSubsettingInput")
    def enable_l4_ilb_subsetting_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enableL4IlbSubsettingInput"))

    @builtins.property
    @jsii.member(jsii_name="enableLegacyAbacInput")
    def enable_legacy_abac_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enableLegacyAbacInput"))

    @builtins.property
    @jsii.member(jsii_name="enableMultiNetworkingInput")
    def enable_multi_networking_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enableMultiNetworkingInput"))

    @builtins.property
    @jsii.member(jsii_name="enableShieldedNodesInput")
    def enable_shielded_nodes_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enableShieldedNodesInput"))

    @builtins.property
    @jsii.member(jsii_name="enableTpuInput")
    def enable_tpu_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enableTpuInput"))

    @builtins.property
    @jsii.member(jsii_name="enterpriseConfigInput")
    def enterprise_config_input(
        self,
    ) -> typing.Optional["ContainerClusterEnterpriseConfig"]:
        return typing.cast(typing.Optional["ContainerClusterEnterpriseConfig"], jsii.get(self, "enterpriseConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="fleetInput")
    def fleet_input(self) -> typing.Optional["ContainerClusterFleet"]:
        return typing.cast(typing.Optional["ContainerClusterFleet"], jsii.get(self, "fleetInput"))

    @builtins.property
    @jsii.member(jsii_name="gatewayApiConfigInput")
    def gateway_api_config_input(
        self,
    ) -> typing.Optional["ContainerClusterGatewayApiConfig"]:
        return typing.cast(typing.Optional["ContainerClusterGatewayApiConfig"], jsii.get(self, "gatewayApiConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="gkeAutoUpgradeConfigInput")
    def gke_auto_upgrade_config_input(
        self,
    ) -> typing.Optional["ContainerClusterGkeAutoUpgradeConfig"]:
        return typing.cast(typing.Optional["ContainerClusterGkeAutoUpgradeConfig"], jsii.get(self, "gkeAutoUpgradeConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="identityServiceConfigInput")
    def identity_service_config_input(
        self,
    ) -> typing.Optional["ContainerClusterIdentityServiceConfig"]:
        return typing.cast(typing.Optional["ContainerClusterIdentityServiceConfig"], jsii.get(self, "identityServiceConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property
    @jsii.member(jsii_name="initialNodeCountInput")
    def initial_node_count_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "initialNodeCountInput"))

    @builtins.property
    @jsii.member(jsii_name="inTransitEncryptionConfigInput")
    def in_transit_encryption_config_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "inTransitEncryptionConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="ipAllocationPolicyInput")
    def ip_allocation_policy_input(
        self,
    ) -> typing.Optional["ContainerClusterIpAllocationPolicy"]:
        return typing.cast(typing.Optional["ContainerClusterIpAllocationPolicy"], jsii.get(self, "ipAllocationPolicyInput"))

    @builtins.property
    @jsii.member(jsii_name="locationInput")
    def location_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "locationInput"))

    @builtins.property
    @jsii.member(jsii_name="loggingConfigInput")
    def logging_config_input(self) -> typing.Optional["ContainerClusterLoggingConfig"]:
        return typing.cast(typing.Optional["ContainerClusterLoggingConfig"], jsii.get(self, "loggingConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="loggingServiceInput")
    def logging_service_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "loggingServiceInput"))

    @builtins.property
    @jsii.member(jsii_name="maintenancePolicyInput")
    def maintenance_policy_input(
        self,
    ) -> typing.Optional["ContainerClusterMaintenancePolicy"]:
        return typing.cast(typing.Optional["ContainerClusterMaintenancePolicy"], jsii.get(self, "maintenancePolicyInput"))

    @builtins.property
    @jsii.member(jsii_name="masterAuthInput")
    def master_auth_input(self) -> typing.Optional["ContainerClusterMasterAuth"]:
        return typing.cast(typing.Optional["ContainerClusterMasterAuth"], jsii.get(self, "masterAuthInput"))

    @builtins.property
    @jsii.member(jsii_name="masterAuthorizedNetworksConfigInput")
    def master_authorized_networks_config_input(
        self,
    ) -> typing.Optional["ContainerClusterMasterAuthorizedNetworksConfig"]:
        return typing.cast(typing.Optional["ContainerClusterMasterAuthorizedNetworksConfig"], jsii.get(self, "masterAuthorizedNetworksConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="meshCertificatesInput")
    def mesh_certificates_input(
        self,
    ) -> typing.Optional["ContainerClusterMeshCertificates"]:
        return typing.cast(typing.Optional["ContainerClusterMeshCertificates"], jsii.get(self, "meshCertificatesInput"))

    @builtins.property
    @jsii.member(jsii_name="minMasterVersionInput")
    def min_master_version_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "minMasterVersionInput"))

    @builtins.property
    @jsii.member(jsii_name="monitoringConfigInput")
    def monitoring_config_input(
        self,
    ) -> typing.Optional["ContainerClusterMonitoringConfig"]:
        return typing.cast(typing.Optional["ContainerClusterMonitoringConfig"], jsii.get(self, "monitoringConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="monitoringServiceInput")
    def monitoring_service_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "monitoringServiceInput"))

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="networkingModeInput")
    def networking_mode_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "networkingModeInput"))

    @builtins.property
    @jsii.member(jsii_name="networkInput")
    def network_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "networkInput"))

    @builtins.property
    @jsii.member(jsii_name="networkPerformanceConfigInput")
    def network_performance_config_input(
        self,
    ) -> typing.Optional["ContainerClusterNetworkPerformanceConfig"]:
        return typing.cast(typing.Optional["ContainerClusterNetworkPerformanceConfig"], jsii.get(self, "networkPerformanceConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="networkPolicyInput")
    def network_policy_input(self) -> typing.Optional["ContainerClusterNetworkPolicy"]:
        return typing.cast(typing.Optional["ContainerClusterNetworkPolicy"], jsii.get(self, "networkPolicyInput"))

    @builtins.property
    @jsii.member(jsii_name="nodeConfigInput")
    def node_config_input(self) -> typing.Optional["ContainerClusterNodeConfig"]:
        return typing.cast(typing.Optional["ContainerClusterNodeConfig"], jsii.get(self, "nodeConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="nodeLocationsInput")
    def node_locations_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "nodeLocationsInput"))

    @builtins.property
    @jsii.member(jsii_name="nodePoolAutoConfigInput")
    def node_pool_auto_config_input(
        self,
    ) -> typing.Optional["ContainerClusterNodePoolAutoConfig"]:
        return typing.cast(typing.Optional["ContainerClusterNodePoolAutoConfig"], jsii.get(self, "nodePoolAutoConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="nodePoolDefaultsInput")
    def node_pool_defaults_input(
        self,
    ) -> typing.Optional["ContainerClusterNodePoolDefaults"]:
        return typing.cast(typing.Optional["ContainerClusterNodePoolDefaults"], jsii.get(self, "nodePoolDefaultsInput"))

    @builtins.property
    @jsii.member(jsii_name="nodePoolInput")
    def node_pool_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ContainerClusterNodePool"]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ContainerClusterNodePool"]]], jsii.get(self, "nodePoolInput"))

    @builtins.property
    @jsii.member(jsii_name="nodeVersionInput")
    def node_version_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nodeVersionInput"))

    @builtins.property
    @jsii.member(jsii_name="notificationConfigInput")
    def notification_config_input(
        self,
    ) -> typing.Optional["ContainerClusterNotificationConfig"]:
        return typing.cast(typing.Optional["ContainerClusterNotificationConfig"], jsii.get(self, "notificationConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="podAutoscalingInput")
    def pod_autoscaling_input(
        self,
    ) -> typing.Optional["ContainerClusterPodAutoscaling"]:
        return typing.cast(typing.Optional["ContainerClusterPodAutoscaling"], jsii.get(self, "podAutoscalingInput"))

    @builtins.property
    @jsii.member(jsii_name="privateClusterConfigInput")
    def private_cluster_config_input(
        self,
    ) -> typing.Optional["ContainerClusterPrivateClusterConfig"]:
        return typing.cast(typing.Optional["ContainerClusterPrivateClusterConfig"], jsii.get(self, "privateClusterConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="privateIpv6GoogleAccessInput")
    def private_ipv6_google_access_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "privateIpv6GoogleAccessInput"))

    @builtins.property
    @jsii.member(jsii_name="projectInput")
    def project_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "projectInput"))

    @builtins.property
    @jsii.member(jsii_name="rbacBindingConfigInput")
    def rbac_binding_config_input(
        self,
    ) -> typing.Optional["ContainerClusterRbacBindingConfig"]:
        return typing.cast(typing.Optional["ContainerClusterRbacBindingConfig"], jsii.get(self, "rbacBindingConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="releaseChannelInput")
    def release_channel_input(
        self,
    ) -> typing.Optional["ContainerClusterReleaseChannel"]:
        return typing.cast(typing.Optional["ContainerClusterReleaseChannel"], jsii.get(self, "releaseChannelInput"))

    @builtins.property
    @jsii.member(jsii_name="removeDefaultNodePoolInput")
    def remove_default_node_pool_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "removeDefaultNodePoolInput"))

    @builtins.property
    @jsii.member(jsii_name="resourceLabelsInput")
    def resource_labels_input(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], jsii.get(self, "resourceLabelsInput"))

    @builtins.property
    @jsii.member(jsii_name="resourceUsageExportConfigInput")
    def resource_usage_export_config_input(
        self,
    ) -> typing.Optional["ContainerClusterResourceUsageExportConfig"]:
        return typing.cast(typing.Optional["ContainerClusterResourceUsageExportConfig"], jsii.get(self, "resourceUsageExportConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="secretManagerConfigInput")
    def secret_manager_config_input(
        self,
    ) -> typing.Optional["ContainerClusterSecretManagerConfig"]:
        return typing.cast(typing.Optional["ContainerClusterSecretManagerConfig"], jsii.get(self, "secretManagerConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="securityPostureConfigInput")
    def security_posture_config_input(
        self,
    ) -> typing.Optional["ContainerClusterSecurityPostureConfig"]:
        return typing.cast(typing.Optional["ContainerClusterSecurityPostureConfig"], jsii.get(self, "securityPostureConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="serviceExternalIpsConfigInput")
    def service_external_ips_config_input(
        self,
    ) -> typing.Optional["ContainerClusterServiceExternalIpsConfig"]:
        return typing.cast(typing.Optional["ContainerClusterServiceExternalIpsConfig"], jsii.get(self, "serviceExternalIpsConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="subnetworkInput")
    def subnetwork_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "subnetworkInput"))

    @builtins.property
    @jsii.member(jsii_name="timeoutsInput")
    def timeouts_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ContainerClusterTimeouts"]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ContainerClusterTimeouts"]], jsii.get(self, "timeoutsInput"))

    @builtins.property
    @jsii.member(jsii_name="userManagedKeysConfigInput")
    def user_managed_keys_config_input(
        self,
    ) -> typing.Optional["ContainerClusterUserManagedKeysConfig"]:
        return typing.cast(typing.Optional["ContainerClusterUserManagedKeysConfig"], jsii.get(self, "userManagedKeysConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="verticalPodAutoscalingInput")
    def vertical_pod_autoscaling_input(
        self,
    ) -> typing.Optional["ContainerClusterVerticalPodAutoscaling"]:
        return typing.cast(typing.Optional["ContainerClusterVerticalPodAutoscaling"], jsii.get(self, "verticalPodAutoscalingInput"))

    @builtins.property
    @jsii.member(jsii_name="workloadIdentityConfigInput")
    def workload_identity_config_input(
        self,
    ) -> typing.Optional["ContainerClusterWorkloadIdentityConfig"]:
        return typing.cast(typing.Optional["ContainerClusterWorkloadIdentityConfig"], jsii.get(self, "workloadIdentityConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="allowNetAdmin")
    def allow_net_admin(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "allowNetAdmin"))

    @allow_net_admin.setter
    def allow_net_admin(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d5c15cc7fb2a2d8d5523fe0f7da7df947fad97a0bd5b26658c6ce886bb3611d3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "allowNetAdmin", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="clusterIpv4Cidr")
    def cluster_ipv4_cidr(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "clusterIpv4Cidr"))

    @cluster_ipv4_cidr.setter
    def cluster_ipv4_cidr(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__67623886670665df6107edc81983ce7619658a6e1d7244172828726c2ac0b6e8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "clusterIpv4Cidr", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="datapathProvider")
    def datapath_provider(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "datapathProvider"))

    @datapath_provider.setter
    def datapath_provider(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__615a96278b5f98a112fc3d5bca11c37a4fc559b32ed4f2e20f699459ff24166d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "datapathProvider", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="defaultMaxPodsPerNode")
    def default_max_pods_per_node(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "defaultMaxPodsPerNode"))

    @default_max_pods_per_node.setter
    def default_max_pods_per_node(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fd9dad9d5f16d1dea7536962ad7826ef751615f4337eb3441c18481cdbb65343)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "defaultMaxPodsPerNode", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="deletionProtection")
    def deletion_protection(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "deletionProtection"))

    @deletion_protection.setter
    def deletion_protection(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6161c340f0072cb54615fec8a1ef3a17b791d2c8552d5a79d31b917f252a52af)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "deletionProtection", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="description")
    def description(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "description"))

    @description.setter
    def description(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__28167017e9393fa2d955873ed002e448c5c4835f1ee2ef72156afd87b88f74a3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "description", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="disableL4LbFirewallReconciliation")
    def disable_l4_lb_firewall_reconciliation(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "disableL4LbFirewallReconciliation"))

    @disable_l4_lb_firewall_reconciliation.setter
    def disable_l4_lb_firewall_reconciliation(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4d0265084ee57d12d366397d2fdf8dc4423eaaae61b9b50dcddd814b5487b6b9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "disableL4LbFirewallReconciliation", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="enableAutopilot")
    def enable_autopilot(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enableAutopilot"))

    @enable_autopilot.setter
    def enable_autopilot(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__14d1bcab61ba35db086cefa53c36e1ca28568e51033792b326fdf8a4f455cd35)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableAutopilot", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="enableCiliumClusterwideNetworkPolicy")
    def enable_cilium_clusterwide_network_policy(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enableCiliumClusterwideNetworkPolicy"))

    @enable_cilium_clusterwide_network_policy.setter
    def enable_cilium_clusterwide_network_policy(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6989332a5a61e9bbf059734b2da6c6a220208f98bebad60b1c22eb9d719d6dc6)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableCiliumClusterwideNetworkPolicy", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="enableFqdnNetworkPolicy")
    def enable_fqdn_network_policy(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enableFqdnNetworkPolicy"))

    @enable_fqdn_network_policy.setter
    def enable_fqdn_network_policy(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__478507f5575c1def237355171025a7885c3619da69dbca7f60928ea76578f81d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableFqdnNetworkPolicy", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="enableIntranodeVisibility")
    def enable_intranode_visibility(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enableIntranodeVisibility"))

    @enable_intranode_visibility.setter
    def enable_intranode_visibility(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9549f8a4eeafb85ecab6705d1d66626469a06cdf03bba9a62df6380309a84b18)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableIntranodeVisibility", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="enableKubernetesAlpha")
    def enable_kubernetes_alpha(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enableKubernetesAlpha"))

    @enable_kubernetes_alpha.setter
    def enable_kubernetes_alpha(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__709877277a977fa4fb1ec4aa11269a31cebd54e9bc6ca217b8a453b11124dad1)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableKubernetesAlpha", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="enableL4IlbSubsetting")
    def enable_l4_ilb_subsetting(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enableL4IlbSubsetting"))

    @enable_l4_ilb_subsetting.setter
    def enable_l4_ilb_subsetting(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2a8f9d16df64bd460e95f11fdfb8a8a499de0039586e11fc3e66646a8be9758f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableL4IlbSubsetting", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="enableLegacyAbac")
    def enable_legacy_abac(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enableLegacyAbac"))

    @enable_legacy_abac.setter
    def enable_legacy_abac(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2fc5ae3fb89bb4319cadec2735d8f43e2526d2842aba604fcf90a05afd240878)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableLegacyAbac", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="enableMultiNetworking")
    def enable_multi_networking(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enableMultiNetworking"))

    @enable_multi_networking.setter
    def enable_multi_networking(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__532f25249ade8ee53fe536f19754286aab9b65276d60d6acb0e0827f47bbf1d0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableMultiNetworking", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="enableShieldedNodes")
    def enable_shielded_nodes(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enableShieldedNodes"))

    @enable_shielded_nodes.setter
    def enable_shielded_nodes(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bfa8471401c848361329cb383a64e45010818802c08093a0c1350c0aac5ccbd6)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableShieldedNodes", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="enableTpu")
    def enable_tpu(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enableTpu"))

    @enable_tpu.setter
    def enable_tpu(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__96fbc3719e219096f4bcb2415af317779e666ca7c2f83d74672bd0a0d2ebdb30)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableTpu", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7a38046d9775897bf0227a36f427f4afd1600cd8d072483cca529a04600a3821)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "id", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="initialNodeCount")
    def initial_node_count(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "initialNodeCount"))

    @initial_node_count.setter
    def initial_node_count(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cbb565b1c38b85be3a7ab342b4eb4e7574d1332a59e1c06b1580c449e55af9a6)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "initialNodeCount", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="inTransitEncryptionConfig")
    def in_transit_encryption_config(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "inTransitEncryptionConfig"))

    @in_transit_encryption_config.setter
    def in_transit_encryption_config(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d954594b6ef735b0d5873e23bbd1f500df98ef2eaa158db3a6882ac726c56bd5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "inTransitEncryptionConfig", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="location")
    def location(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "location"))

    @location.setter
    def location(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bd011b58574d0c3fbdc34e6ef71c887c7c2ff1949df5769835f6124477c738a4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "location", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="loggingService")
    def logging_service(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "loggingService"))

    @logging_service.setter
    def logging_service(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d7a2c6390e1899fbce14c30cd5071e0bca19e56acd942c1a9a39a8576d1295be)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "loggingService", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="minMasterVersion")
    def min_master_version(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "minMasterVersion"))

    @min_master_version.setter
    def min_master_version(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2d9e31e232eb879e1b25542c09cf8e80d24d153b3f421e4da34fd9a1b70bec82)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "minMasterVersion", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="monitoringService")
    def monitoring_service(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "monitoringService"))

    @monitoring_service.setter
    def monitoring_service(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f756e6128d188efac08a07503f28e8b3462bcf9c294a547c6b488d3453245cf2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "monitoringService", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__26b4a2a73024f018cc2bcc75cb4d4aa19c9edb93309b9222b0b6cc31a49a71b0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "name", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="network")
    def network(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "network"))

    @network.setter
    def network(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__708c0f4ecb0c069a9af35efb3cb464a9345f465db4ace0dbecc0003f447ea423)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "network", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="networkingMode")
    def networking_mode(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "networkingMode"))

    @networking_mode.setter
    def networking_mode(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__13b292f88b4a4fc4097ef4ab70ca54abb7a81125eb9e781ef4689cf656123b0d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "networkingMode", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="nodeLocations")
    def node_locations(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "nodeLocations"))

    @node_locations.setter
    def node_locations(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__de251d5e4e992cc4dc8c1e13410d32652f6ad7c19dc065a23a446e2b8dcd246c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "nodeLocations", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="nodeVersion")
    def node_version(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "nodeVersion"))

    @node_version.setter
    def node_version(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__146fc372af154a7a606a70a52423411c6cb0d5690ec04719e8216631292e2775)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "nodeVersion", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="privateIpv6GoogleAccess")
    def private_ipv6_google_access(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "privateIpv6GoogleAccess"))

    @private_ipv6_google_access.setter
    def private_ipv6_google_access(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f1e16d73b1ebae43e5cf76a80ec9b64c1cd3c805f95c957e2c07ea7c2f64ee1d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "privateIpv6GoogleAccess", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="project")
    def project(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "project"))

    @project.setter
    def project(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d2ef2f681192771b3e78e205c60b19c8fb77564dca07d2b05762b8163e7f3b27)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "project", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="removeDefaultNodePool")
    def remove_default_node_pool(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "removeDefaultNodePool"))

    @remove_default_node_pool.setter
    def remove_default_node_pool(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__945a5076c45095b19331b13817217d1ac301b3657a2dd0f5770f761b51009311)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "removeDefaultNodePool", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="resourceLabels")
    def resource_labels(self) -> typing.Mapping[builtins.str, builtins.str]:
        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.get(self, "resourceLabels"))

    @resource_labels.setter
    def resource_labels(
        self,
        value: typing.Mapping[builtins.str, builtins.str],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__65ccd82c4b764468077e42e3e6eb073364f896b36fed9ea01c7f8bef99899b03)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "resourceLabels", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="subnetwork")
    def subnetwork(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "subnetwork"))

    @subnetwork.setter
    def subnetwork(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f0ea3e309e9ae8456d2454a88e71e1eaaba811ea5ac7f2181ff30656db05606d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "subnetwork", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterAddonsConfig",
    jsii_struct_bases=[],
    name_mapping={
        "cloudrun_config": "cloudrunConfig",
        "config_connector_config": "configConnectorConfig",
        "dns_cache_config": "dnsCacheConfig",
        "gce_persistent_disk_csi_driver_config": "gcePersistentDiskCsiDriverConfig",
        "gcp_filestore_csi_driver_config": "gcpFilestoreCsiDriverConfig",
        "gcs_fuse_csi_driver_config": "gcsFuseCsiDriverConfig",
        "gke_backup_agent_config": "gkeBackupAgentConfig",
        "horizontal_pod_autoscaling": "horizontalPodAutoscaling",
        "http_load_balancing": "httpLoadBalancing",
        "lustre_csi_driver_config": "lustreCsiDriverConfig",
        "network_policy_config": "networkPolicyConfig",
        "parallelstore_csi_driver_config": "parallelstoreCsiDriverConfig",
        "ray_operator_config": "rayOperatorConfig",
        "stateful_ha_config": "statefulHaConfig",
    },
)
class ContainerClusterAddonsConfig:
    def __init__(
        self,
        *,
        cloudrun_config: typing.Optional[typing.Union["ContainerClusterAddonsConfigCloudrunConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        config_connector_config: typing.Optional[typing.Union["ContainerClusterAddonsConfigConfigConnectorConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        dns_cache_config: typing.Optional[typing.Union["ContainerClusterAddonsConfigDnsCacheConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        gce_persistent_disk_csi_driver_config: typing.Optional[typing.Union["ContainerClusterAddonsConfigGcePersistentDiskCsiDriverConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        gcp_filestore_csi_driver_config: typing.Optional[typing.Union["ContainerClusterAddonsConfigGcpFilestoreCsiDriverConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        gcs_fuse_csi_driver_config: typing.Optional[typing.Union["ContainerClusterAddonsConfigGcsFuseCsiDriverConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        gke_backup_agent_config: typing.Optional[typing.Union["ContainerClusterAddonsConfigGkeBackupAgentConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        horizontal_pod_autoscaling: typing.Optional[typing.Union["ContainerClusterAddonsConfigHorizontalPodAutoscaling", typing.Dict[builtins.str, typing.Any]]] = None,
        http_load_balancing: typing.Optional[typing.Union["ContainerClusterAddonsConfigHttpLoadBalancing", typing.Dict[builtins.str, typing.Any]]] = None,
        lustre_csi_driver_config: typing.Optional[typing.Union["ContainerClusterAddonsConfigLustreCsiDriverConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        network_policy_config: typing.Optional[typing.Union["ContainerClusterAddonsConfigNetworkPolicyConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        parallelstore_csi_driver_config: typing.Optional[typing.Union["ContainerClusterAddonsConfigParallelstoreCsiDriverConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        ray_operator_config: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ContainerClusterAddonsConfigRayOperatorConfig", typing.Dict[builtins.str, typing.Any]]]]] = None,
        stateful_ha_config: typing.Optional[typing.Union["ContainerClusterAddonsConfigStatefulHaConfig", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param cloudrun_config: cloudrun_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cloudrun_config ContainerCluster#cloudrun_config}
        :param config_connector_config: config_connector_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#config_connector_config ContainerCluster#config_connector_config}
        :param dns_cache_config: dns_cache_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#dns_cache_config ContainerCluster#dns_cache_config}
        :param gce_persistent_disk_csi_driver_config: gce_persistent_disk_csi_driver_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gce_persistent_disk_csi_driver_config ContainerCluster#gce_persistent_disk_csi_driver_config}
        :param gcp_filestore_csi_driver_config: gcp_filestore_csi_driver_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gcp_filestore_csi_driver_config ContainerCluster#gcp_filestore_csi_driver_config}
        :param gcs_fuse_csi_driver_config: gcs_fuse_csi_driver_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gcs_fuse_csi_driver_config ContainerCluster#gcs_fuse_csi_driver_config}
        :param gke_backup_agent_config: gke_backup_agent_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gke_backup_agent_config ContainerCluster#gke_backup_agent_config}
        :param horizontal_pod_autoscaling: horizontal_pod_autoscaling block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#horizontal_pod_autoscaling ContainerCluster#horizontal_pod_autoscaling}
        :param http_load_balancing: http_load_balancing block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#http_load_balancing ContainerCluster#http_load_balancing}
        :param lustre_csi_driver_config: lustre_csi_driver_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#lustre_csi_driver_config ContainerCluster#lustre_csi_driver_config}
        :param network_policy_config: network_policy_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#network_policy_config ContainerCluster#network_policy_config}
        :param parallelstore_csi_driver_config: parallelstore_csi_driver_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#parallelstore_csi_driver_config ContainerCluster#parallelstore_csi_driver_config}
        :param ray_operator_config: ray_operator_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#ray_operator_config ContainerCluster#ray_operator_config}
        :param stateful_ha_config: stateful_ha_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#stateful_ha_config ContainerCluster#stateful_ha_config}
        '''
        if isinstance(cloudrun_config, dict):
            cloudrun_config = ContainerClusterAddonsConfigCloudrunConfig(**cloudrun_config)
        if isinstance(config_connector_config, dict):
            config_connector_config = ContainerClusterAddonsConfigConfigConnectorConfig(**config_connector_config)
        if isinstance(dns_cache_config, dict):
            dns_cache_config = ContainerClusterAddonsConfigDnsCacheConfig(**dns_cache_config)
        if isinstance(gce_persistent_disk_csi_driver_config, dict):
            gce_persistent_disk_csi_driver_config = ContainerClusterAddonsConfigGcePersistentDiskCsiDriverConfig(**gce_persistent_disk_csi_driver_config)
        if isinstance(gcp_filestore_csi_driver_config, dict):
            gcp_filestore_csi_driver_config = ContainerClusterAddonsConfigGcpFilestoreCsiDriverConfig(**gcp_filestore_csi_driver_config)
        if isinstance(gcs_fuse_csi_driver_config, dict):
            gcs_fuse_csi_driver_config = ContainerClusterAddonsConfigGcsFuseCsiDriverConfig(**gcs_fuse_csi_driver_config)
        if isinstance(gke_backup_agent_config, dict):
            gke_backup_agent_config = ContainerClusterAddonsConfigGkeBackupAgentConfig(**gke_backup_agent_config)
        if isinstance(horizontal_pod_autoscaling, dict):
            horizontal_pod_autoscaling = ContainerClusterAddonsConfigHorizontalPodAutoscaling(**horizontal_pod_autoscaling)
        if isinstance(http_load_balancing, dict):
            http_load_balancing = ContainerClusterAddonsConfigHttpLoadBalancing(**http_load_balancing)
        if isinstance(lustre_csi_driver_config, dict):
            lustre_csi_driver_config = ContainerClusterAddonsConfigLustreCsiDriverConfig(**lustre_csi_driver_config)
        if isinstance(network_policy_config, dict):
            network_policy_config = ContainerClusterAddonsConfigNetworkPolicyConfig(**network_policy_config)
        if isinstance(parallelstore_csi_driver_config, dict):
            parallelstore_csi_driver_config = ContainerClusterAddonsConfigParallelstoreCsiDriverConfig(**parallelstore_csi_driver_config)
        if isinstance(stateful_ha_config, dict):
            stateful_ha_config = ContainerClusterAddonsConfigStatefulHaConfig(**stateful_ha_config)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__90d120aa82f3a9a996300b5c06bf091c103df155899cce463d6b347915676793)
            check_type(argname="argument cloudrun_config", value=cloudrun_config, expected_type=type_hints["cloudrun_config"])
            check_type(argname="argument config_connector_config", value=config_connector_config, expected_type=type_hints["config_connector_config"])
            check_type(argname="argument dns_cache_config", value=dns_cache_config, expected_type=type_hints["dns_cache_config"])
            check_type(argname="argument gce_persistent_disk_csi_driver_config", value=gce_persistent_disk_csi_driver_config, expected_type=type_hints["gce_persistent_disk_csi_driver_config"])
            check_type(argname="argument gcp_filestore_csi_driver_config", value=gcp_filestore_csi_driver_config, expected_type=type_hints["gcp_filestore_csi_driver_config"])
            check_type(argname="argument gcs_fuse_csi_driver_config", value=gcs_fuse_csi_driver_config, expected_type=type_hints["gcs_fuse_csi_driver_config"])
            check_type(argname="argument gke_backup_agent_config", value=gke_backup_agent_config, expected_type=type_hints["gke_backup_agent_config"])
            check_type(argname="argument horizontal_pod_autoscaling", value=horizontal_pod_autoscaling, expected_type=type_hints["horizontal_pod_autoscaling"])
            check_type(argname="argument http_load_balancing", value=http_load_balancing, expected_type=type_hints["http_load_balancing"])
            check_type(argname="argument lustre_csi_driver_config", value=lustre_csi_driver_config, expected_type=type_hints["lustre_csi_driver_config"])
            check_type(argname="argument network_policy_config", value=network_policy_config, expected_type=type_hints["network_policy_config"])
            check_type(argname="argument parallelstore_csi_driver_config", value=parallelstore_csi_driver_config, expected_type=type_hints["parallelstore_csi_driver_config"])
            check_type(argname="argument ray_operator_config", value=ray_operator_config, expected_type=type_hints["ray_operator_config"])
            check_type(argname="argument stateful_ha_config", value=stateful_ha_config, expected_type=type_hints["stateful_ha_config"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if cloudrun_config is not None:
            self._values["cloudrun_config"] = cloudrun_config
        if config_connector_config is not None:
            self._values["config_connector_config"] = config_connector_config
        if dns_cache_config is not None:
            self._values["dns_cache_config"] = dns_cache_config
        if gce_persistent_disk_csi_driver_config is not None:
            self._values["gce_persistent_disk_csi_driver_config"] = gce_persistent_disk_csi_driver_config
        if gcp_filestore_csi_driver_config is not None:
            self._values["gcp_filestore_csi_driver_config"] = gcp_filestore_csi_driver_config
        if gcs_fuse_csi_driver_config is not None:
            self._values["gcs_fuse_csi_driver_config"] = gcs_fuse_csi_driver_config
        if gke_backup_agent_config is not None:
            self._values["gke_backup_agent_config"] = gke_backup_agent_config
        if horizontal_pod_autoscaling is not None:
            self._values["horizontal_pod_autoscaling"] = horizontal_pod_autoscaling
        if http_load_balancing is not None:
            self._values["http_load_balancing"] = http_load_balancing
        if lustre_csi_driver_config is not None:
            self._values["lustre_csi_driver_config"] = lustre_csi_driver_config
        if network_policy_config is not None:
            self._values["network_policy_config"] = network_policy_config
        if parallelstore_csi_driver_config is not None:
            self._values["parallelstore_csi_driver_config"] = parallelstore_csi_driver_config
        if ray_operator_config is not None:
            self._values["ray_operator_config"] = ray_operator_config
        if stateful_ha_config is not None:
            self._values["stateful_ha_config"] = stateful_ha_config

    @builtins.property
    def cloudrun_config(
        self,
    ) -> typing.Optional["ContainerClusterAddonsConfigCloudrunConfig"]:
        '''cloudrun_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cloudrun_config ContainerCluster#cloudrun_config}
        '''
        result = self._values.get("cloudrun_config")
        return typing.cast(typing.Optional["ContainerClusterAddonsConfigCloudrunConfig"], result)

    @builtins.property
    def config_connector_config(
        self,
    ) -> typing.Optional["ContainerClusterAddonsConfigConfigConnectorConfig"]:
        '''config_connector_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#config_connector_config ContainerCluster#config_connector_config}
        '''
        result = self._values.get("config_connector_config")
        return typing.cast(typing.Optional["ContainerClusterAddonsConfigConfigConnectorConfig"], result)

    @builtins.property
    def dns_cache_config(
        self,
    ) -> typing.Optional["ContainerClusterAddonsConfigDnsCacheConfig"]:
        '''dns_cache_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#dns_cache_config ContainerCluster#dns_cache_config}
        '''
        result = self._values.get("dns_cache_config")
        return typing.cast(typing.Optional["ContainerClusterAddonsConfigDnsCacheConfig"], result)

    @builtins.property
    def gce_persistent_disk_csi_driver_config(
        self,
    ) -> typing.Optional["ContainerClusterAddonsConfigGcePersistentDiskCsiDriverConfig"]:
        '''gce_persistent_disk_csi_driver_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gce_persistent_disk_csi_driver_config ContainerCluster#gce_persistent_disk_csi_driver_config}
        '''
        result = self._values.get("gce_persistent_disk_csi_driver_config")
        return typing.cast(typing.Optional["ContainerClusterAddonsConfigGcePersistentDiskCsiDriverConfig"], result)

    @builtins.property
    def gcp_filestore_csi_driver_config(
        self,
    ) -> typing.Optional["ContainerClusterAddonsConfigGcpFilestoreCsiDriverConfig"]:
        '''gcp_filestore_csi_driver_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gcp_filestore_csi_driver_config ContainerCluster#gcp_filestore_csi_driver_config}
        '''
        result = self._values.get("gcp_filestore_csi_driver_config")
        return typing.cast(typing.Optional["ContainerClusterAddonsConfigGcpFilestoreCsiDriverConfig"], result)

    @builtins.property
    def gcs_fuse_csi_driver_config(
        self,
    ) -> typing.Optional["ContainerClusterAddonsConfigGcsFuseCsiDriverConfig"]:
        '''gcs_fuse_csi_driver_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gcs_fuse_csi_driver_config ContainerCluster#gcs_fuse_csi_driver_config}
        '''
        result = self._values.get("gcs_fuse_csi_driver_config")
        return typing.cast(typing.Optional["ContainerClusterAddonsConfigGcsFuseCsiDriverConfig"], result)

    @builtins.property
    def gke_backup_agent_config(
        self,
    ) -> typing.Optional["ContainerClusterAddonsConfigGkeBackupAgentConfig"]:
        '''gke_backup_agent_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gke_backup_agent_config ContainerCluster#gke_backup_agent_config}
        '''
        result = self._values.get("gke_backup_agent_config")
        return typing.cast(typing.Optional["ContainerClusterAddonsConfigGkeBackupAgentConfig"], result)

    @builtins.property
    def horizontal_pod_autoscaling(
        self,
    ) -> typing.Optional["ContainerClusterAddonsConfigHorizontalPodAutoscaling"]:
        '''horizontal_pod_autoscaling block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#horizontal_pod_autoscaling ContainerCluster#horizontal_pod_autoscaling}
        '''
        result = self._values.get("horizontal_pod_autoscaling")
        return typing.cast(typing.Optional["ContainerClusterAddonsConfigHorizontalPodAutoscaling"], result)

    @builtins.property
    def http_load_balancing(
        self,
    ) -> typing.Optional["ContainerClusterAddonsConfigHttpLoadBalancing"]:
        '''http_load_balancing block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#http_load_balancing ContainerCluster#http_load_balancing}
        '''
        result = self._values.get("http_load_balancing")
        return typing.cast(typing.Optional["ContainerClusterAddonsConfigHttpLoadBalancing"], result)

    @builtins.property
    def lustre_csi_driver_config(
        self,
    ) -> typing.Optional["ContainerClusterAddonsConfigLustreCsiDriverConfig"]:
        '''lustre_csi_driver_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#lustre_csi_driver_config ContainerCluster#lustre_csi_driver_config}
        '''
        result = self._values.get("lustre_csi_driver_config")
        return typing.cast(typing.Optional["ContainerClusterAddonsConfigLustreCsiDriverConfig"], result)

    @builtins.property
    def network_policy_config(
        self,
    ) -> typing.Optional["ContainerClusterAddonsConfigNetworkPolicyConfig"]:
        '''network_policy_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#network_policy_config ContainerCluster#network_policy_config}
        '''
        result = self._values.get("network_policy_config")
        return typing.cast(typing.Optional["ContainerClusterAddonsConfigNetworkPolicyConfig"], result)

    @builtins.property
    def parallelstore_csi_driver_config(
        self,
    ) -> typing.Optional["ContainerClusterAddonsConfigParallelstoreCsiDriverConfig"]:
        '''parallelstore_csi_driver_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#parallelstore_csi_driver_config ContainerCluster#parallelstore_csi_driver_config}
        '''
        result = self._values.get("parallelstore_csi_driver_config")
        return typing.cast(typing.Optional["ContainerClusterAddonsConfigParallelstoreCsiDriverConfig"], result)

    @builtins.property
    def ray_operator_config(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ContainerClusterAddonsConfigRayOperatorConfig"]]]:
        '''ray_operator_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#ray_operator_config ContainerCluster#ray_operator_config}
        '''
        result = self._values.get("ray_operator_config")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ContainerClusterAddonsConfigRayOperatorConfig"]]], result)

    @builtins.property
    def stateful_ha_config(
        self,
    ) -> typing.Optional["ContainerClusterAddonsConfigStatefulHaConfig"]:
        '''stateful_ha_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#stateful_ha_config ContainerCluster#stateful_ha_config}
        '''
        result = self._values.get("stateful_ha_config")
        return typing.cast(typing.Optional["ContainerClusterAddonsConfigStatefulHaConfig"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterAddonsConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterAddonsConfigCloudrunConfig",
    jsii_struct_bases=[],
    name_mapping={"disabled": "disabled", "load_balancer_type": "loadBalancerType"},
)
class ContainerClusterAddonsConfigCloudrunConfig:
    def __init__(
        self,
        *,
        disabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
        load_balancer_type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param disabled: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#disabled ContainerCluster#disabled}.
        :param load_balancer_type: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#load_balancer_type ContainerCluster#load_balancer_type}.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4c477dd39d2b4195d82d9581e8bc009f264be96b74d042252a807513960ecda1)
            check_type(argname="argument disabled", value=disabled, expected_type=type_hints["disabled"])
            check_type(argname="argument load_balancer_type", value=load_balancer_type, expected_type=type_hints["load_balancer_type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "disabled": disabled,
        }
        if load_balancer_type is not None:
            self._values["load_balancer_type"] = load_balancer_type

    @builtins.property
    def disabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#disabled ContainerCluster#disabled}.'''
        result = self._values.get("disabled")
        assert result is not None, "Required property 'disabled' is missing"
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], result)

    @builtins.property
    def load_balancer_type(self) -> typing.Optional[builtins.str]:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#load_balancer_type ContainerCluster#load_balancer_type}.'''
        result = self._values.get("load_balancer_type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterAddonsConfigCloudrunConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterAddonsConfigCloudrunConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterAddonsConfigCloudrunConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0b348612ee248f3577d1209e8b01ac14028218898bd73127c6ef08b5c4c68771)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetLoadBalancerType")
    def reset_load_balancer_type(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLoadBalancerType", []))

    @builtins.property
    @jsii.member(jsii_name="disabledInput")
    def disabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "disabledInput"))

    @builtins.property
    @jsii.member(jsii_name="loadBalancerTypeInput")
    def load_balancer_type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "loadBalancerTypeInput"))

    @builtins.property
    @jsii.member(jsii_name="disabled")
    def disabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "disabled"))

    @disabled.setter
    def disabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7e97716f0fbf7a136259d00148931a35ae7b37e83985cca0337a6f991ebc9a19)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "disabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="loadBalancerType")
    def load_balancer_type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "loadBalancerType"))

    @load_balancer_type.setter
    def load_balancer_type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e2f912a3189f4c03f495c41da5452c20c0a5286dd0cc3698f51d157929c3a0b0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "loadBalancerType", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterAddonsConfigCloudrunConfig]:
        return typing.cast(typing.Optional[ContainerClusterAddonsConfigCloudrunConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterAddonsConfigCloudrunConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5773740061f75538e42a9646b7645c1c0457f007f46adc3a48e2bd91d935d299)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterAddonsConfigConfigConnectorConfig",
    jsii_struct_bases=[],
    name_mapping={"enabled": "enabled"},
)
class ContainerClusterAddonsConfigConfigConnectorConfig:
    def __init__(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param enabled: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b56afc4251aa6b37c0c26d9e5e32d5313b315f0c2deb3d42b4b0fe9c4d0802b4)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "enabled": enabled,
        }

    @builtins.property
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}.'''
        result = self._values.get("enabled")
        assert result is not None, "Required property 'enabled' is missing"
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterAddonsConfigConfigConnectorConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterAddonsConfigConfigConnectorConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterAddonsConfigConfigConnectorConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cd9883230801d139c01fc31c0ae487c366f256b7c9a7c34f0d5606114f0406cd)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="enabledInput")
    def enabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enabledInput"))

    @builtins.property
    @jsii.member(jsii_name="enabled")
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enabled"))

    @enabled.setter
    def enabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__59790918ba40c43e056513c8a51a461f8ac0ae02b840c7fd86999bd25494c1a8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterAddonsConfigConfigConnectorConfig]:
        return typing.cast(typing.Optional[ContainerClusterAddonsConfigConfigConnectorConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterAddonsConfigConfigConnectorConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3cc143b2c28765ede2f7e862d4130e43b4b11ee57c7c7edd201fa4e979d74d72)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterAddonsConfigDnsCacheConfig",
    jsii_struct_bases=[],
    name_mapping={"enabled": "enabled"},
)
class ContainerClusterAddonsConfigDnsCacheConfig:
    def __init__(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param enabled: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__86bdea2eac5d814741af3c7176f6773d536bac5909110afbbddd08641c1223d7)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "enabled": enabled,
        }

    @builtins.property
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}.'''
        result = self._values.get("enabled")
        assert result is not None, "Required property 'enabled' is missing"
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterAddonsConfigDnsCacheConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterAddonsConfigDnsCacheConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterAddonsConfigDnsCacheConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8e0e870d36b0781735c11536461d8d076d881f78e91c06f7493a0ec43e0128f0)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="enabledInput")
    def enabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enabledInput"))

    @builtins.property
    @jsii.member(jsii_name="enabled")
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enabled"))

    @enabled.setter
    def enabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__200977125aa6f430872fcaf1523197a8a2c58a5d6af48a3b159870fd27bab09d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterAddonsConfigDnsCacheConfig]:
        return typing.cast(typing.Optional[ContainerClusterAddonsConfigDnsCacheConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterAddonsConfigDnsCacheConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9716da4547a51489f372db64921bac26897f524ff205244fb74661807868f166)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterAddonsConfigGcePersistentDiskCsiDriverConfig",
    jsii_struct_bases=[],
    name_mapping={"enabled": "enabled"},
)
class ContainerClusterAddonsConfigGcePersistentDiskCsiDriverConfig:
    def __init__(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param enabled: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6a51b8100b3f4fb89bfe1598e03f9eb3d2b21fc9827146c304c31ab988e7cfa6)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "enabled": enabled,
        }

    @builtins.property
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}.'''
        result = self._values.get("enabled")
        assert result is not None, "Required property 'enabled' is missing"
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterAddonsConfigGcePersistentDiskCsiDriverConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterAddonsConfigGcePersistentDiskCsiDriverConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterAddonsConfigGcePersistentDiskCsiDriverConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__76ed5cd456b2123e56cd7c8b60fe933ef91a97c4b9fb3327660d94676566fb12)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="enabledInput")
    def enabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enabledInput"))

    @builtins.property
    @jsii.member(jsii_name="enabled")
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enabled"))

    @enabled.setter
    def enabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a4d4a7607061a429678e51121ae67b1628b5d7b2d88fa30ba93522142da929cf)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterAddonsConfigGcePersistentDiskCsiDriverConfig]:
        return typing.cast(typing.Optional[ContainerClusterAddonsConfigGcePersistentDiskCsiDriverConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterAddonsConfigGcePersistentDiskCsiDriverConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__68b12d6c6f49da67d106c0800cefbdd26e3cb708c208d0e660344578f6a91f58)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterAddonsConfigGcpFilestoreCsiDriverConfig",
    jsii_struct_bases=[],
    name_mapping={"enabled": "enabled"},
)
class ContainerClusterAddonsConfigGcpFilestoreCsiDriverConfig:
    def __init__(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param enabled: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__150f68648e9c90c0fad5a574d76641e0e05da4e36463a4967c3217221e4fe815)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "enabled": enabled,
        }

    @builtins.property
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}.'''
        result = self._values.get("enabled")
        assert result is not None, "Required property 'enabled' is missing"
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterAddonsConfigGcpFilestoreCsiDriverConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterAddonsConfigGcpFilestoreCsiDriverConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterAddonsConfigGcpFilestoreCsiDriverConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1f8283559e8624e57b354605b2cb68e896a6cb733b76c3c8338ccdc0c2135f71)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="enabledInput")
    def enabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enabledInput"))

    @builtins.property
    @jsii.member(jsii_name="enabled")
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enabled"))

    @enabled.setter
    def enabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1c27d2293acb1863e5764f809cdb7efe427b650605868d9419df3efbef460440)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterAddonsConfigGcpFilestoreCsiDriverConfig]:
        return typing.cast(typing.Optional[ContainerClusterAddonsConfigGcpFilestoreCsiDriverConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterAddonsConfigGcpFilestoreCsiDriverConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e0ebb5fbb94c2fad8b0c53003a219131f1d0bf310e0e6b276d05fc2476da8702)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterAddonsConfigGcsFuseCsiDriverConfig",
    jsii_struct_bases=[],
    name_mapping={"enabled": "enabled"},
)
class ContainerClusterAddonsConfigGcsFuseCsiDriverConfig:
    def __init__(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param enabled: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__644f3396bdaffbafc2a49611d50934397567f5550e4042f6f89659f9ff0e1c9c)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "enabled": enabled,
        }

    @builtins.property
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}.'''
        result = self._values.get("enabled")
        assert result is not None, "Required property 'enabled' is missing"
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterAddonsConfigGcsFuseCsiDriverConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterAddonsConfigGcsFuseCsiDriverConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterAddonsConfigGcsFuseCsiDriverConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a94679b9b5d632a4bad77a0dc648c80ea8d3d125fd3cbb3cc5ccee2aa93f0dd1)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="enabledInput")
    def enabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enabledInput"))

    @builtins.property
    @jsii.member(jsii_name="enabled")
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enabled"))

    @enabled.setter
    def enabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5562250d3bcb1fb28778e597fd26e1609d7ced57c2a26d4844f49904bfed8a5c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterAddonsConfigGcsFuseCsiDriverConfig]:
        return typing.cast(typing.Optional[ContainerClusterAddonsConfigGcsFuseCsiDriverConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterAddonsConfigGcsFuseCsiDriverConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b7427e240ef183d29d7318c126ce00de4a7063df04cf3d16880a6ad687df77cb)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterAddonsConfigGkeBackupAgentConfig",
    jsii_struct_bases=[],
    name_mapping={"enabled": "enabled"},
)
class ContainerClusterAddonsConfigGkeBackupAgentConfig:
    def __init__(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param enabled: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__989f596a11acd76c10a326f34c759a2053d7aea34f7e2e9a05deba6b1bbd66b1)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "enabled": enabled,
        }

    @builtins.property
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}.'''
        result = self._values.get("enabled")
        assert result is not None, "Required property 'enabled' is missing"
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterAddonsConfigGkeBackupAgentConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterAddonsConfigGkeBackupAgentConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterAddonsConfigGkeBackupAgentConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b3bdccd924b462eb999947cda1d97a019ac8af5b885011c2bb66fe24c66689c3)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="enabledInput")
    def enabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enabledInput"))

    @builtins.property
    @jsii.member(jsii_name="enabled")
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enabled"))

    @enabled.setter
    def enabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f164f4aa97f839541ef206406f094a721a72daf1da3d23ac9409e8388e394295)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterAddonsConfigGkeBackupAgentConfig]:
        return typing.cast(typing.Optional[ContainerClusterAddonsConfigGkeBackupAgentConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterAddonsConfigGkeBackupAgentConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dbaa56e118c7f05410da2e85833c938f425029d06a150afad5988344c6b78876)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterAddonsConfigHorizontalPodAutoscaling",
    jsii_struct_bases=[],
    name_mapping={"disabled": "disabled"},
)
class ContainerClusterAddonsConfigHorizontalPodAutoscaling:
    def __init__(
        self,
        *,
        disabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param disabled: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#disabled ContainerCluster#disabled}.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b01935ed28d24ec2099c6dc1a932402c8c8da8e384af529c4c683d1a3060acea)
            check_type(argname="argument disabled", value=disabled, expected_type=type_hints["disabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "disabled": disabled,
        }

    @builtins.property
    def disabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#disabled ContainerCluster#disabled}.'''
        result = self._values.get("disabled")
        assert result is not None, "Required property 'disabled' is missing"
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterAddonsConfigHorizontalPodAutoscaling(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterAddonsConfigHorizontalPodAutoscalingOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterAddonsConfigHorizontalPodAutoscalingOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__efa11872fca046f234fb9628e3404466f6b4545b26354971ab96d055332de4c6)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="disabledInput")
    def disabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "disabledInput"))

    @builtins.property
    @jsii.member(jsii_name="disabled")
    def disabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "disabled"))

    @disabled.setter
    def disabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b8bbb9eaa2d2c79974be760fdde10fcd509788b188e892d766d403e08e149204)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "disabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterAddonsConfigHorizontalPodAutoscaling]:
        return typing.cast(typing.Optional[ContainerClusterAddonsConfigHorizontalPodAutoscaling], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterAddonsConfigHorizontalPodAutoscaling],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a05240c58c16189985b111614a8d90cf4be73a3555999343bbe11210dd057f05)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterAddonsConfigHttpLoadBalancing",
    jsii_struct_bases=[],
    name_mapping={"disabled": "disabled"},
)
class ContainerClusterAddonsConfigHttpLoadBalancing:
    def __init__(
        self,
        *,
        disabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param disabled: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#disabled ContainerCluster#disabled}.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3da9ee6068566b9c546474fc3058017daf9737fb11f363293e05a676b1eeea11)
            check_type(argname="argument disabled", value=disabled, expected_type=type_hints["disabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "disabled": disabled,
        }

    @builtins.property
    def disabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#disabled ContainerCluster#disabled}.'''
        result = self._values.get("disabled")
        assert result is not None, "Required property 'disabled' is missing"
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterAddonsConfigHttpLoadBalancing(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterAddonsConfigHttpLoadBalancingOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterAddonsConfigHttpLoadBalancingOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e165a83a8c4a200fe0527c0d21812ba1eabc7622985b3bcdd4a4e571a01f4810)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="disabledInput")
    def disabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "disabledInput"))

    @builtins.property
    @jsii.member(jsii_name="disabled")
    def disabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "disabled"))

    @disabled.setter
    def disabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9e4f2e684377db24491054ac766901e1ae51aed761b8950a097db395ce7fe6e6)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "disabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterAddonsConfigHttpLoadBalancing]:
        return typing.cast(typing.Optional[ContainerClusterAddonsConfigHttpLoadBalancing], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterAddonsConfigHttpLoadBalancing],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6a8135b71daf78e5df3c91da6a9be0070b6638898371cc3c3bbf56e5384988ab)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterAddonsConfigLustreCsiDriverConfig",
    jsii_struct_bases=[],
    name_mapping={
        "enabled": "enabled",
        "enable_legacy_lustre_port": "enableLegacyLustrePort",
    },
)
class ContainerClusterAddonsConfigLustreCsiDriverConfig:
    def __init__(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
        enable_legacy_lustre_port: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    ) -> None:
        '''
        :param enabled: Whether the Lustre CSI driver is enabled for this cluster. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        :param enable_legacy_lustre_port: If set to true, the Lustre CSI driver will initialize LNet (the virtual network layer for Lustre kernel module) using port 6988. This flag is required to workaround a port conflict with the gke-metadata-server on GKE nodes. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_legacy_lustre_port ContainerCluster#enable_legacy_lustre_port}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2c0cabe685c48877f52f0e4d08da01473cbb29380ce18b3024ec8db01fab1c77)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
            check_type(argname="argument enable_legacy_lustre_port", value=enable_legacy_lustre_port, expected_type=type_hints["enable_legacy_lustre_port"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "enabled": enabled,
        }
        if enable_legacy_lustre_port is not None:
            self._values["enable_legacy_lustre_port"] = enable_legacy_lustre_port

    @builtins.property
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        '''Whether the Lustre CSI driver is enabled for this cluster.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        '''
        result = self._values.get("enabled")
        assert result is not None, "Required property 'enabled' is missing"
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], result)

    @builtins.property
    def enable_legacy_lustre_port(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''If set to true, the Lustre CSI driver will initialize LNet (the virtual network layer for Lustre kernel module) using port 6988.

        This flag is required to workaround a port conflict with the gke-metadata-server on GKE nodes.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_legacy_lustre_port ContainerCluster#enable_legacy_lustre_port}
        '''
        result = self._values.get("enable_legacy_lustre_port")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterAddonsConfigLustreCsiDriverConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterAddonsConfigLustreCsiDriverConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterAddonsConfigLustreCsiDriverConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c5700d2192a39807e6c89763b0bc922cc0349e26fe5fafed88ec44f16499bb0c)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetEnableLegacyLustrePort")
    def reset_enable_legacy_lustre_port(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnableLegacyLustrePort", []))

    @builtins.property
    @jsii.member(jsii_name="enabledInput")
    def enabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enabledInput"))

    @builtins.property
    @jsii.member(jsii_name="enableLegacyLustrePortInput")
    def enable_legacy_lustre_port_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enableLegacyLustrePortInput"))

    @builtins.property
    @jsii.member(jsii_name="enabled")
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enabled"))

    @enabled.setter
    def enabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ac632c3dded9765c8d5ded1a285339a308fc6fe3cf520d9fd330f47f486f0825)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="enableLegacyLustrePort")
    def enable_legacy_lustre_port(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enableLegacyLustrePort"))

    @enable_legacy_lustre_port.setter
    def enable_legacy_lustre_port(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__03a1f57f5af5e149ec617c6c45384d135a20194648439dc46d3ba45c53d3d023)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableLegacyLustrePort", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterAddonsConfigLustreCsiDriverConfig]:
        return typing.cast(typing.Optional[ContainerClusterAddonsConfigLustreCsiDriverConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterAddonsConfigLustreCsiDriverConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__12d1978a1010d9f2d9a0cdb99340f5b1b49cecae6ae31df0c651e549fc32f0bf)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterAddonsConfigNetworkPolicyConfig",
    jsii_struct_bases=[],
    name_mapping={"disabled": "disabled"},
)
class ContainerClusterAddonsConfigNetworkPolicyConfig:
    def __init__(
        self,
        *,
        disabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param disabled: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#disabled ContainerCluster#disabled}.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__80c0b93cfdd2a9b98ae41fe0c3ee4d323639bf447b333a125039875069b36b81)
            check_type(argname="argument disabled", value=disabled, expected_type=type_hints["disabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "disabled": disabled,
        }

    @builtins.property
    def disabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#disabled ContainerCluster#disabled}.'''
        result = self._values.get("disabled")
        assert result is not None, "Required property 'disabled' is missing"
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterAddonsConfigNetworkPolicyConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterAddonsConfigNetworkPolicyConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterAddonsConfigNetworkPolicyConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__17855c4eba19645e88cd40d508f2140501716a550f6f2895e4f0bdd057ef5db6)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="disabledInput")
    def disabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "disabledInput"))

    @builtins.property
    @jsii.member(jsii_name="disabled")
    def disabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "disabled"))

    @disabled.setter
    def disabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__97b7994a2b9992e1009161acd7ab3ae9cdc3343729fb85a0b20dbb46ad30e987)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "disabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterAddonsConfigNetworkPolicyConfig]:
        return typing.cast(typing.Optional[ContainerClusterAddonsConfigNetworkPolicyConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterAddonsConfigNetworkPolicyConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__20a9836a01d40156d3fc1821ca69e04b7bf7bda439b1c0886d2e20782ec4f6e7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ContainerClusterAddonsConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterAddonsConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f39d5b03006661a43a2b9c38effae803b7dc05d85eba319c10a46e32186dabcc)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putCloudrunConfig")
    def put_cloudrun_config(
        self,
        *,
        disabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
        load_balancer_type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param disabled: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#disabled ContainerCluster#disabled}.
        :param load_balancer_type: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#load_balancer_type ContainerCluster#load_balancer_type}.
        '''
        value = ContainerClusterAddonsConfigCloudrunConfig(
            disabled=disabled, load_balancer_type=load_balancer_type
        )

        return typing.cast(None, jsii.invoke(self, "putCloudrunConfig", [value]))

    @jsii.member(jsii_name="putConfigConnectorConfig")
    def put_config_connector_config(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param enabled: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}.
        '''
        value = ContainerClusterAddonsConfigConfigConnectorConfig(enabled=enabled)

        return typing.cast(None, jsii.invoke(self, "putConfigConnectorConfig", [value]))

    @jsii.member(jsii_name="putDnsCacheConfig")
    def put_dns_cache_config(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param enabled: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}.
        '''
        value = ContainerClusterAddonsConfigDnsCacheConfig(enabled=enabled)

        return typing.cast(None, jsii.invoke(self, "putDnsCacheConfig", [value]))

    @jsii.member(jsii_name="putGcePersistentDiskCsiDriverConfig")
    def put_gce_persistent_disk_csi_driver_config(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param enabled: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}.
        '''
        value = ContainerClusterAddonsConfigGcePersistentDiskCsiDriverConfig(
            enabled=enabled
        )

        return typing.cast(None, jsii.invoke(self, "putGcePersistentDiskCsiDriverConfig", [value]))

    @jsii.member(jsii_name="putGcpFilestoreCsiDriverConfig")
    def put_gcp_filestore_csi_driver_config(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param enabled: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}.
        '''
        value = ContainerClusterAddonsConfigGcpFilestoreCsiDriverConfig(
            enabled=enabled
        )

        return typing.cast(None, jsii.invoke(self, "putGcpFilestoreCsiDriverConfig", [value]))

    @jsii.member(jsii_name="putGcsFuseCsiDriverConfig")
    def put_gcs_fuse_csi_driver_config(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param enabled: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}.
        '''
        value = ContainerClusterAddonsConfigGcsFuseCsiDriverConfig(enabled=enabled)

        return typing.cast(None, jsii.invoke(self, "putGcsFuseCsiDriverConfig", [value]))

    @jsii.member(jsii_name="putGkeBackupAgentConfig")
    def put_gke_backup_agent_config(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param enabled: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}.
        '''
        value = ContainerClusterAddonsConfigGkeBackupAgentConfig(enabled=enabled)

        return typing.cast(None, jsii.invoke(self, "putGkeBackupAgentConfig", [value]))

    @jsii.member(jsii_name="putHorizontalPodAutoscaling")
    def put_horizontal_pod_autoscaling(
        self,
        *,
        disabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param disabled: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#disabled ContainerCluster#disabled}.
        '''
        value = ContainerClusterAddonsConfigHorizontalPodAutoscaling(disabled=disabled)

        return typing.cast(None, jsii.invoke(self, "putHorizontalPodAutoscaling", [value]))

    @jsii.member(jsii_name="putHttpLoadBalancing")
    def put_http_load_balancing(
        self,
        *,
        disabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param disabled: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#disabled ContainerCluster#disabled}.
        '''
        value = ContainerClusterAddonsConfigHttpLoadBalancing(disabled=disabled)

        return typing.cast(None, jsii.invoke(self, "putHttpLoadBalancing", [value]))

    @jsii.member(jsii_name="putLustreCsiDriverConfig")
    def put_lustre_csi_driver_config(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
        enable_legacy_lustre_port: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    ) -> None:
        '''
        :param enabled: Whether the Lustre CSI driver is enabled for this cluster. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        :param enable_legacy_lustre_port: If set to true, the Lustre CSI driver will initialize LNet (the virtual network layer for Lustre kernel module) using port 6988. This flag is required to workaround a port conflict with the gke-metadata-server on GKE nodes. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_legacy_lustre_port ContainerCluster#enable_legacy_lustre_port}
        '''
        value = ContainerClusterAddonsConfigLustreCsiDriverConfig(
            enabled=enabled, enable_legacy_lustre_port=enable_legacy_lustre_port
        )

        return typing.cast(None, jsii.invoke(self, "putLustreCsiDriverConfig", [value]))

    @jsii.member(jsii_name="putNetworkPolicyConfig")
    def put_network_policy_config(
        self,
        *,
        disabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param disabled: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#disabled ContainerCluster#disabled}.
        '''
        value = ContainerClusterAddonsConfigNetworkPolicyConfig(disabled=disabled)

        return typing.cast(None, jsii.invoke(self, "putNetworkPolicyConfig", [value]))

    @jsii.member(jsii_name="putParallelstoreCsiDriverConfig")
    def put_parallelstore_csi_driver_config(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param enabled: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}.
        '''
        value = ContainerClusterAddonsConfigParallelstoreCsiDriverConfig(
            enabled=enabled
        )

        return typing.cast(None, jsii.invoke(self, "putParallelstoreCsiDriverConfig", [value]))

    @jsii.member(jsii_name="putRayOperatorConfig")
    def put_ray_operator_config(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ContainerClusterAddonsConfigRayOperatorConfig", typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c391a9eb40a1b3d709719d647144bdb947812c23fec583589307f2374929e9e5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putRayOperatorConfig", [value]))

    @jsii.member(jsii_name="putStatefulHaConfig")
    def put_stateful_ha_config(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param enabled: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}.
        '''
        value = ContainerClusterAddonsConfigStatefulHaConfig(enabled=enabled)

        return typing.cast(None, jsii.invoke(self, "putStatefulHaConfig", [value]))

    @jsii.member(jsii_name="resetCloudrunConfig")
    def reset_cloudrun_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCloudrunConfig", []))

    @jsii.member(jsii_name="resetConfigConnectorConfig")
    def reset_config_connector_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetConfigConnectorConfig", []))

    @jsii.member(jsii_name="resetDnsCacheConfig")
    def reset_dns_cache_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDnsCacheConfig", []))

    @jsii.member(jsii_name="resetGcePersistentDiskCsiDriverConfig")
    def reset_gce_persistent_disk_csi_driver_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGcePersistentDiskCsiDriverConfig", []))

    @jsii.member(jsii_name="resetGcpFilestoreCsiDriverConfig")
    def reset_gcp_filestore_csi_driver_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGcpFilestoreCsiDriverConfig", []))

    @jsii.member(jsii_name="resetGcsFuseCsiDriverConfig")
    def reset_gcs_fuse_csi_driver_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGcsFuseCsiDriverConfig", []))

    @jsii.member(jsii_name="resetGkeBackupAgentConfig")
    def reset_gke_backup_agent_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGkeBackupAgentConfig", []))

    @jsii.member(jsii_name="resetHorizontalPodAutoscaling")
    def reset_horizontal_pod_autoscaling(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHorizontalPodAutoscaling", []))

    @jsii.member(jsii_name="resetHttpLoadBalancing")
    def reset_http_load_balancing(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHttpLoadBalancing", []))

    @jsii.member(jsii_name="resetLustreCsiDriverConfig")
    def reset_lustre_csi_driver_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLustreCsiDriverConfig", []))

    @jsii.member(jsii_name="resetNetworkPolicyConfig")
    def reset_network_policy_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNetworkPolicyConfig", []))

    @jsii.member(jsii_name="resetParallelstoreCsiDriverConfig")
    def reset_parallelstore_csi_driver_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetParallelstoreCsiDriverConfig", []))

    @jsii.member(jsii_name="resetRayOperatorConfig")
    def reset_ray_operator_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRayOperatorConfig", []))

    @jsii.member(jsii_name="resetStatefulHaConfig")
    def reset_stateful_ha_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetStatefulHaConfig", []))

    @builtins.property
    @jsii.member(jsii_name="cloudrunConfig")
    def cloudrun_config(
        self,
    ) -> ContainerClusterAddonsConfigCloudrunConfigOutputReference:
        return typing.cast(ContainerClusterAddonsConfigCloudrunConfigOutputReference, jsii.get(self, "cloudrunConfig"))

    @builtins.property
    @jsii.member(jsii_name="configConnectorConfig")
    def config_connector_config(
        self,
    ) -> ContainerClusterAddonsConfigConfigConnectorConfigOutputReference:
        return typing.cast(ContainerClusterAddonsConfigConfigConnectorConfigOutputReference, jsii.get(self, "configConnectorConfig"))

    @builtins.property
    @jsii.member(jsii_name="dnsCacheConfig")
    def dns_cache_config(
        self,
    ) -> ContainerClusterAddonsConfigDnsCacheConfigOutputReference:
        return typing.cast(ContainerClusterAddonsConfigDnsCacheConfigOutputReference, jsii.get(self, "dnsCacheConfig"))

    @builtins.property
    @jsii.member(jsii_name="gcePersistentDiskCsiDriverConfig")
    def gce_persistent_disk_csi_driver_config(
        self,
    ) -> ContainerClusterAddonsConfigGcePersistentDiskCsiDriverConfigOutputReference:
        return typing.cast(ContainerClusterAddonsConfigGcePersistentDiskCsiDriverConfigOutputReference, jsii.get(self, "gcePersistentDiskCsiDriverConfig"))

    @builtins.property
    @jsii.member(jsii_name="gcpFilestoreCsiDriverConfig")
    def gcp_filestore_csi_driver_config(
        self,
    ) -> ContainerClusterAddonsConfigGcpFilestoreCsiDriverConfigOutputReference:
        return typing.cast(ContainerClusterAddonsConfigGcpFilestoreCsiDriverConfigOutputReference, jsii.get(self, "gcpFilestoreCsiDriverConfig"))

    @builtins.property
    @jsii.member(jsii_name="gcsFuseCsiDriverConfig")
    def gcs_fuse_csi_driver_config(
        self,
    ) -> ContainerClusterAddonsConfigGcsFuseCsiDriverConfigOutputReference:
        return typing.cast(ContainerClusterAddonsConfigGcsFuseCsiDriverConfigOutputReference, jsii.get(self, "gcsFuseCsiDriverConfig"))

    @builtins.property
    @jsii.member(jsii_name="gkeBackupAgentConfig")
    def gke_backup_agent_config(
        self,
    ) -> ContainerClusterAddonsConfigGkeBackupAgentConfigOutputReference:
        return typing.cast(ContainerClusterAddonsConfigGkeBackupAgentConfigOutputReference, jsii.get(self, "gkeBackupAgentConfig"))

    @builtins.property
    @jsii.member(jsii_name="horizontalPodAutoscaling")
    def horizontal_pod_autoscaling(
        self,
    ) -> ContainerClusterAddonsConfigHorizontalPodAutoscalingOutputReference:
        return typing.cast(ContainerClusterAddonsConfigHorizontalPodAutoscalingOutputReference, jsii.get(self, "horizontalPodAutoscaling"))

    @builtins.property
    @jsii.member(jsii_name="httpLoadBalancing")
    def http_load_balancing(
        self,
    ) -> ContainerClusterAddonsConfigHttpLoadBalancingOutputReference:
        return typing.cast(ContainerClusterAddonsConfigHttpLoadBalancingOutputReference, jsii.get(self, "httpLoadBalancing"))

    @builtins.property
    @jsii.member(jsii_name="lustreCsiDriverConfig")
    def lustre_csi_driver_config(
        self,
    ) -> ContainerClusterAddonsConfigLustreCsiDriverConfigOutputReference:
        return typing.cast(ContainerClusterAddonsConfigLustreCsiDriverConfigOutputReference, jsii.get(self, "lustreCsiDriverConfig"))

    @builtins.property
    @jsii.member(jsii_name="networkPolicyConfig")
    def network_policy_config(
        self,
    ) -> ContainerClusterAddonsConfigNetworkPolicyConfigOutputReference:
        return typing.cast(ContainerClusterAddonsConfigNetworkPolicyConfigOutputReference, jsii.get(self, "networkPolicyConfig"))

    @builtins.property
    @jsii.member(jsii_name="parallelstoreCsiDriverConfig")
    def parallelstore_csi_driver_config(
        self,
    ) -> "ContainerClusterAddonsConfigParallelstoreCsiDriverConfigOutputReference":
        return typing.cast("ContainerClusterAddonsConfigParallelstoreCsiDriverConfigOutputReference", jsii.get(self, "parallelstoreCsiDriverConfig"))

    @builtins.property
    @jsii.member(jsii_name="rayOperatorConfig")
    def ray_operator_config(
        self,
    ) -> "ContainerClusterAddonsConfigRayOperatorConfigList":
        return typing.cast("ContainerClusterAddonsConfigRayOperatorConfigList", jsii.get(self, "rayOperatorConfig"))

    @builtins.property
    @jsii.member(jsii_name="statefulHaConfig")
    def stateful_ha_config(
        self,
    ) -> "ContainerClusterAddonsConfigStatefulHaConfigOutputReference":
        return typing.cast("ContainerClusterAddonsConfigStatefulHaConfigOutputReference", jsii.get(self, "statefulHaConfig"))

    @builtins.property
    @jsii.member(jsii_name="cloudrunConfigInput")
    def cloudrun_config_input(
        self,
    ) -> typing.Optional[ContainerClusterAddonsConfigCloudrunConfig]:
        return typing.cast(typing.Optional[ContainerClusterAddonsConfigCloudrunConfig], jsii.get(self, "cloudrunConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="configConnectorConfigInput")
    def config_connector_config_input(
        self,
    ) -> typing.Optional[ContainerClusterAddonsConfigConfigConnectorConfig]:
        return typing.cast(typing.Optional[ContainerClusterAddonsConfigConfigConnectorConfig], jsii.get(self, "configConnectorConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="dnsCacheConfigInput")
    def dns_cache_config_input(
        self,
    ) -> typing.Optional[ContainerClusterAddonsConfigDnsCacheConfig]:
        return typing.cast(typing.Optional[ContainerClusterAddonsConfigDnsCacheConfig], jsii.get(self, "dnsCacheConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="gcePersistentDiskCsiDriverConfigInput")
    def gce_persistent_disk_csi_driver_config_input(
        self,
    ) -> typing.Optional[ContainerClusterAddonsConfigGcePersistentDiskCsiDriverConfig]:
        return typing.cast(typing.Optional[ContainerClusterAddonsConfigGcePersistentDiskCsiDriverConfig], jsii.get(self, "gcePersistentDiskCsiDriverConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="gcpFilestoreCsiDriverConfigInput")
    def gcp_filestore_csi_driver_config_input(
        self,
    ) -> typing.Optional[ContainerClusterAddonsConfigGcpFilestoreCsiDriverConfig]:
        return typing.cast(typing.Optional[ContainerClusterAddonsConfigGcpFilestoreCsiDriverConfig], jsii.get(self, "gcpFilestoreCsiDriverConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="gcsFuseCsiDriverConfigInput")
    def gcs_fuse_csi_driver_config_input(
        self,
    ) -> typing.Optional[ContainerClusterAddonsConfigGcsFuseCsiDriverConfig]:
        return typing.cast(typing.Optional[ContainerClusterAddonsConfigGcsFuseCsiDriverConfig], jsii.get(self, "gcsFuseCsiDriverConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="gkeBackupAgentConfigInput")
    def gke_backup_agent_config_input(
        self,
    ) -> typing.Optional[ContainerClusterAddonsConfigGkeBackupAgentConfig]:
        return typing.cast(typing.Optional[ContainerClusterAddonsConfigGkeBackupAgentConfig], jsii.get(self, "gkeBackupAgentConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="horizontalPodAutoscalingInput")
    def horizontal_pod_autoscaling_input(
        self,
    ) -> typing.Optional[ContainerClusterAddonsConfigHorizontalPodAutoscaling]:
        return typing.cast(typing.Optional[ContainerClusterAddonsConfigHorizontalPodAutoscaling], jsii.get(self, "horizontalPodAutoscalingInput"))

    @builtins.property
    @jsii.member(jsii_name="httpLoadBalancingInput")
    def http_load_balancing_input(
        self,
    ) -> typing.Optional[ContainerClusterAddonsConfigHttpLoadBalancing]:
        return typing.cast(typing.Optional[ContainerClusterAddonsConfigHttpLoadBalancing], jsii.get(self, "httpLoadBalancingInput"))

    @builtins.property
    @jsii.member(jsii_name="lustreCsiDriverConfigInput")
    def lustre_csi_driver_config_input(
        self,
    ) -> typing.Optional[ContainerClusterAddonsConfigLustreCsiDriverConfig]:
        return typing.cast(typing.Optional[ContainerClusterAddonsConfigLustreCsiDriverConfig], jsii.get(self, "lustreCsiDriverConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="networkPolicyConfigInput")
    def network_policy_config_input(
        self,
    ) -> typing.Optional[ContainerClusterAddonsConfigNetworkPolicyConfig]:
        return typing.cast(typing.Optional[ContainerClusterAddonsConfigNetworkPolicyConfig], jsii.get(self, "networkPolicyConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="parallelstoreCsiDriverConfigInput")
    def parallelstore_csi_driver_config_input(
        self,
    ) -> typing.Optional["ContainerClusterAddonsConfigParallelstoreCsiDriverConfig"]:
        return typing.cast(typing.Optional["ContainerClusterAddonsConfigParallelstoreCsiDriverConfig"], jsii.get(self, "parallelstoreCsiDriverConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="rayOperatorConfigInput")
    def ray_operator_config_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ContainerClusterAddonsConfigRayOperatorConfig"]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ContainerClusterAddonsConfigRayOperatorConfig"]]], jsii.get(self, "rayOperatorConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="statefulHaConfigInput")
    def stateful_ha_config_input(
        self,
    ) -> typing.Optional["ContainerClusterAddonsConfigStatefulHaConfig"]:
        return typing.cast(typing.Optional["ContainerClusterAddonsConfigStatefulHaConfig"], jsii.get(self, "statefulHaConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[ContainerClusterAddonsConfig]:
        return typing.cast(typing.Optional[ContainerClusterAddonsConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterAddonsConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d29a68bebb7bb8134bd4f0cf3b09b9543f819953467fdca53f4e63656e0e2c14)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterAddonsConfigParallelstoreCsiDriverConfig",
    jsii_struct_bases=[],
    name_mapping={"enabled": "enabled"},
)
class ContainerClusterAddonsConfigParallelstoreCsiDriverConfig:
    def __init__(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param enabled: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9c630b0d9eba01688e9149d858723a2afb2207540e9be9b5a49d3dcbc0bf4f1d)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "enabled": enabled,
        }

    @builtins.property
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}.'''
        result = self._values.get("enabled")
        assert result is not None, "Required property 'enabled' is missing"
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterAddonsConfigParallelstoreCsiDriverConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterAddonsConfigParallelstoreCsiDriverConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterAddonsConfigParallelstoreCsiDriverConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__69635665349f4cbb0eb4219a207eb0c1c086e1d4a0e8d0ca70f44e28edb6f985)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="enabledInput")
    def enabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enabledInput"))

    @builtins.property
    @jsii.member(jsii_name="enabled")
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enabled"))

    @enabled.setter
    def enabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d7ab155bf9860a70fa14183c099246a3d1c9e0b7e9a1c10dad7a643ccc2fe0b3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterAddonsConfigParallelstoreCsiDriverConfig]:
        return typing.cast(typing.Optional[ContainerClusterAddonsConfigParallelstoreCsiDriverConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterAddonsConfigParallelstoreCsiDriverConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1413430194a1cdb6b3cbbf9045cfb209b88a6c426e694e15f04848702f191e38)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterAddonsConfigRayOperatorConfig",
    jsii_struct_bases=[],
    name_mapping={
        "enabled": "enabled",
        "ray_cluster_logging_config": "rayClusterLoggingConfig",
        "ray_cluster_monitoring_config": "rayClusterMonitoringConfig",
    },
)
class ContainerClusterAddonsConfigRayOperatorConfig:
    def __init__(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
        ray_cluster_logging_config: typing.Optional[typing.Union["ContainerClusterAddonsConfigRayOperatorConfigRayClusterLoggingConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        ray_cluster_monitoring_config: typing.Optional[typing.Union["ContainerClusterAddonsConfigRayOperatorConfigRayClusterMonitoringConfig", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param enabled: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}.
        :param ray_cluster_logging_config: ray_cluster_logging_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#ray_cluster_logging_config ContainerCluster#ray_cluster_logging_config}
        :param ray_cluster_monitoring_config: ray_cluster_monitoring_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#ray_cluster_monitoring_config ContainerCluster#ray_cluster_monitoring_config}
        '''
        if isinstance(ray_cluster_logging_config, dict):
            ray_cluster_logging_config = ContainerClusterAddonsConfigRayOperatorConfigRayClusterLoggingConfig(**ray_cluster_logging_config)
        if isinstance(ray_cluster_monitoring_config, dict):
            ray_cluster_monitoring_config = ContainerClusterAddonsConfigRayOperatorConfigRayClusterMonitoringConfig(**ray_cluster_monitoring_config)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5e691af36ee05ef458a6187fbfed8b405d3671e96d10f030a390b4845a6cea75)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
            check_type(argname="argument ray_cluster_logging_config", value=ray_cluster_logging_config, expected_type=type_hints["ray_cluster_logging_config"])
            check_type(argname="argument ray_cluster_monitoring_config", value=ray_cluster_monitoring_config, expected_type=type_hints["ray_cluster_monitoring_config"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "enabled": enabled,
        }
        if ray_cluster_logging_config is not None:
            self._values["ray_cluster_logging_config"] = ray_cluster_logging_config
        if ray_cluster_monitoring_config is not None:
            self._values["ray_cluster_monitoring_config"] = ray_cluster_monitoring_config

    @builtins.property
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}.'''
        result = self._values.get("enabled")
        assert result is not None, "Required property 'enabled' is missing"
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], result)

    @builtins.property
    def ray_cluster_logging_config(
        self,
    ) -> typing.Optional["ContainerClusterAddonsConfigRayOperatorConfigRayClusterLoggingConfig"]:
        '''ray_cluster_logging_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#ray_cluster_logging_config ContainerCluster#ray_cluster_logging_config}
        '''
        result = self._values.get("ray_cluster_logging_config")
        return typing.cast(typing.Optional["ContainerClusterAddonsConfigRayOperatorConfigRayClusterLoggingConfig"], result)

    @builtins.property
    def ray_cluster_monitoring_config(
        self,
    ) -> typing.Optional["ContainerClusterAddonsConfigRayOperatorConfigRayClusterMonitoringConfig"]:
        '''ray_cluster_monitoring_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#ray_cluster_monitoring_config ContainerCluster#ray_cluster_monitoring_config}
        '''
        result = self._values.get("ray_cluster_monitoring_config")
        return typing.cast(typing.Optional["ContainerClusterAddonsConfigRayOperatorConfigRayClusterMonitoringConfig"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterAddonsConfigRayOperatorConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterAddonsConfigRayOperatorConfigList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterAddonsConfigRayOperatorConfigList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1e0779e681f4d297cb332db6e4b9f52ca6d77ad0542b3691b77d878bc6231077)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ContainerClusterAddonsConfigRayOperatorConfigOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__63cb85a281550fe142765ad25811000e8d448e65930bad8add60202d692fe3a7)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ContainerClusterAddonsConfigRayOperatorConfigOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1f448dc02029cc807ae90bcc2c0052cddce8de7ef30d05368f44160d9ec0c2eb)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__10e48240153b9367dd553bf966485705d9c9f5daec125a24bf45169eeb9ed81d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__76db9258d6f9741345ec10fc605e6e69345ce52259069c06712425dafcdb5e42)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterAddonsConfigRayOperatorConfig]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterAddonsConfigRayOperatorConfig]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterAddonsConfigRayOperatorConfig]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dd350102ec9bb06e87b9a38e26813ccfd76a8b7ab78ce5b59ed3850f4eb9f6db)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ContainerClusterAddonsConfigRayOperatorConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterAddonsConfigRayOperatorConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6ab00aba0c52d8a5359640c949e32eb4044c43a6d27feafeeed2c1256eb3439e)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putRayClusterLoggingConfig")
    def put_ray_cluster_logging_config(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param enabled: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}.
        '''
        value = ContainerClusterAddonsConfigRayOperatorConfigRayClusterLoggingConfig(
            enabled=enabled
        )

        return typing.cast(None, jsii.invoke(self, "putRayClusterLoggingConfig", [value]))

    @jsii.member(jsii_name="putRayClusterMonitoringConfig")
    def put_ray_cluster_monitoring_config(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param enabled: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}.
        '''
        value = ContainerClusterAddonsConfigRayOperatorConfigRayClusterMonitoringConfig(
            enabled=enabled
        )

        return typing.cast(None, jsii.invoke(self, "putRayClusterMonitoringConfig", [value]))

    @jsii.member(jsii_name="resetRayClusterLoggingConfig")
    def reset_ray_cluster_logging_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRayClusterLoggingConfig", []))

    @jsii.member(jsii_name="resetRayClusterMonitoringConfig")
    def reset_ray_cluster_monitoring_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRayClusterMonitoringConfig", []))

    @builtins.property
    @jsii.member(jsii_name="rayClusterLoggingConfig")
    def ray_cluster_logging_config(
        self,
    ) -> "ContainerClusterAddonsConfigRayOperatorConfigRayClusterLoggingConfigOutputReference":
        return typing.cast("ContainerClusterAddonsConfigRayOperatorConfigRayClusterLoggingConfigOutputReference", jsii.get(self, "rayClusterLoggingConfig"))

    @builtins.property
    @jsii.member(jsii_name="rayClusterMonitoringConfig")
    def ray_cluster_monitoring_config(
        self,
    ) -> "ContainerClusterAddonsConfigRayOperatorConfigRayClusterMonitoringConfigOutputReference":
        return typing.cast("ContainerClusterAddonsConfigRayOperatorConfigRayClusterMonitoringConfigOutputReference", jsii.get(self, "rayClusterMonitoringConfig"))

    @builtins.property
    @jsii.member(jsii_name="enabledInput")
    def enabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enabledInput"))

    @builtins.property
    @jsii.member(jsii_name="rayClusterLoggingConfigInput")
    def ray_cluster_logging_config_input(
        self,
    ) -> typing.Optional["ContainerClusterAddonsConfigRayOperatorConfigRayClusterLoggingConfig"]:
        return typing.cast(typing.Optional["ContainerClusterAddonsConfigRayOperatorConfigRayClusterLoggingConfig"], jsii.get(self, "rayClusterLoggingConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="rayClusterMonitoringConfigInput")
    def ray_cluster_monitoring_config_input(
        self,
    ) -> typing.Optional["ContainerClusterAddonsConfigRayOperatorConfigRayClusterMonitoringConfig"]:
        return typing.cast(typing.Optional["ContainerClusterAddonsConfigRayOperatorConfigRayClusterMonitoringConfig"], jsii.get(self, "rayClusterMonitoringConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="enabled")
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enabled"))

    @enabled.setter
    def enabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__06bf63e6aa860c106d7006b1f9ade952d41317a64e08d02ae108e90469ffbc02)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterAddonsConfigRayOperatorConfig]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterAddonsConfigRayOperatorConfig]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterAddonsConfigRayOperatorConfig]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8ec7dece3dd6e0d945902fe2162740a8473c4d4c8ee8a8ac7736163440d6edd1)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterAddonsConfigRayOperatorConfigRayClusterLoggingConfig",
    jsii_struct_bases=[],
    name_mapping={"enabled": "enabled"},
)
class ContainerClusterAddonsConfigRayOperatorConfigRayClusterLoggingConfig:
    def __init__(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param enabled: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ec9bf4a625835b4d93999e27921a395863ef37f89d5b014a00c9b4c98bec0f2d)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "enabled": enabled,
        }

    @builtins.property
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}.'''
        result = self._values.get("enabled")
        assert result is not None, "Required property 'enabled' is missing"
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterAddonsConfigRayOperatorConfigRayClusterLoggingConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterAddonsConfigRayOperatorConfigRayClusterLoggingConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterAddonsConfigRayOperatorConfigRayClusterLoggingConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0f5f852bfc4d1cd50f0a1001744667fc5c003b5a7e2b683aa1ab3e200b2aaed9)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="enabledInput")
    def enabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enabledInput"))

    @builtins.property
    @jsii.member(jsii_name="enabled")
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enabled"))

    @enabled.setter
    def enabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1c1d23b31ead2813fdf143b8be556e67d0790e046060d72f2aaff143ddc30353)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterAddonsConfigRayOperatorConfigRayClusterLoggingConfig]:
        return typing.cast(typing.Optional[ContainerClusterAddonsConfigRayOperatorConfigRayClusterLoggingConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterAddonsConfigRayOperatorConfigRayClusterLoggingConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a317c372c8dbd94e1bf11db928eb748a7987de4d708a269839e250eb52aab55c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterAddonsConfigRayOperatorConfigRayClusterMonitoringConfig",
    jsii_struct_bases=[],
    name_mapping={"enabled": "enabled"},
)
class ContainerClusterAddonsConfigRayOperatorConfigRayClusterMonitoringConfig:
    def __init__(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param enabled: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7a70243680210ec4b25654d007b3da5f5f52f8040f3230336587c89deb496151)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "enabled": enabled,
        }

    @builtins.property
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}.'''
        result = self._values.get("enabled")
        assert result is not None, "Required property 'enabled' is missing"
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterAddonsConfigRayOperatorConfigRayClusterMonitoringConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterAddonsConfigRayOperatorConfigRayClusterMonitoringConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterAddonsConfigRayOperatorConfigRayClusterMonitoringConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__37bb6c91d4d8bd9b48b644b89d2411987a847943b45d75311b7e3056e0074f0a)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="enabledInput")
    def enabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enabledInput"))

    @builtins.property
    @jsii.member(jsii_name="enabled")
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enabled"))

    @enabled.setter
    def enabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c67942bd79368d6e15197080a98d5107497405e4ba694b3caa20f296f0e2fc42)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterAddonsConfigRayOperatorConfigRayClusterMonitoringConfig]:
        return typing.cast(typing.Optional[ContainerClusterAddonsConfigRayOperatorConfigRayClusterMonitoringConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterAddonsConfigRayOperatorConfigRayClusterMonitoringConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2316418e1bbc04a922837b0721879876276e0cdecf9e8c580ca94969786e28a0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterAddonsConfigStatefulHaConfig",
    jsii_struct_bases=[],
    name_mapping={"enabled": "enabled"},
)
class ContainerClusterAddonsConfigStatefulHaConfig:
    def __init__(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param enabled: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5aa68f247db3560a14a74fe0acf6ed9eed30286b4f2e5b6901293d631c6f33fc)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "enabled": enabled,
        }

    @builtins.property
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}.'''
        result = self._values.get("enabled")
        assert result is not None, "Required property 'enabled' is missing"
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterAddonsConfigStatefulHaConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterAddonsConfigStatefulHaConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterAddonsConfigStatefulHaConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__501fc546a2c274b5b28ba62ac712efd69f9766bc9657a69d37b78ffc065e8927)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="enabledInput")
    def enabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enabledInput"))

    @builtins.property
    @jsii.member(jsii_name="enabled")
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enabled"))

    @enabled.setter
    def enabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__076a90986b71f9e4afa7f1b3020e9be00f4862c1c7ea61d60297a89b21927a72)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterAddonsConfigStatefulHaConfig]:
        return typing.cast(typing.Optional[ContainerClusterAddonsConfigStatefulHaConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterAddonsConfigStatefulHaConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c6b0c610bc894798edea347afb83f3066092a67dfc037e627c88b9f2ba15ff76)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterAnonymousAuthenticationConfig",
    jsii_struct_bases=[],
    name_mapping={"mode": "mode"},
)
class ContainerClusterAnonymousAuthenticationConfig:
    def __init__(self, *, mode: builtins.str) -> None:
        '''
        :param mode: Setting this to LIMITED will restrict authentication of anonymous users to health check endpoints only. Accepted values are: - ENABLED: Authentication of anonymous users is enabled for all endpoints. - LIMITED: Anonymous access is only allowed for health check endpoints. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#mode ContainerCluster#mode}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8fedf79bb992981fd4d7aca30a8674f24cf8116e225d00a7ce08e04fc0a1ad0e)
            check_type(argname="argument mode", value=mode, expected_type=type_hints["mode"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "mode": mode,
        }

    @builtins.property
    def mode(self) -> builtins.str:
        '''Setting this to LIMITED will restrict authentication of anonymous users to health check endpoints only.

        Accepted values are:

        - ENABLED: Authentication of anonymous users is enabled for all endpoints.
        - LIMITED: Anonymous access is only allowed for health check endpoints.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#mode ContainerCluster#mode}
        '''
        result = self._values.get("mode")
        assert result is not None, "Required property 'mode' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterAnonymousAuthenticationConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterAnonymousAuthenticationConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterAnonymousAuthenticationConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ea43f9ec240624692693a39ffc3bd6d66495240ccf8871125bb372616efaed00)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="modeInput")
    def mode_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "modeInput"))

    @builtins.property
    @jsii.member(jsii_name="mode")
    def mode(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "mode"))

    @mode.setter
    def mode(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c9068b11a731782ef938d6f846b845d40af6cde97945f72d764efcd59aba56f5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "mode", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterAnonymousAuthenticationConfig]:
        return typing.cast(typing.Optional[ContainerClusterAnonymousAuthenticationConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterAnonymousAuthenticationConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c04a59b37eeeeb3eddac491ce0b0eb3524e24663569cc258cdb8c8942c6a6857)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterAuthenticatorGroupsConfig",
    jsii_struct_bases=[],
    name_mapping={"security_group": "securityGroup"},
)
class ContainerClusterAuthenticatorGroupsConfig:
    def __init__(self, *, security_group: builtins.str) -> None:
        '''
        :param security_group: The name of the RBAC security group for use with Google security groups in Kubernetes RBAC. Group name must be in format gke-security-groups@yourdomain.com. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#security_group ContainerCluster#security_group}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__622fd5b79b23d4cc0de7ab8b47d3a05c014d7c6f6f5f1d50701723af7e4bba5b)
            check_type(argname="argument security_group", value=security_group, expected_type=type_hints["security_group"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "security_group": security_group,
        }

    @builtins.property
    def security_group(self) -> builtins.str:
        '''The name of the RBAC security group for use with Google security groups in Kubernetes RBAC.

        Group name must be in format gke-security-groups@yourdomain.com.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#security_group ContainerCluster#security_group}
        '''
        result = self._values.get("security_group")
        assert result is not None, "Required property 'security_group' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterAuthenticatorGroupsConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterAuthenticatorGroupsConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterAuthenticatorGroupsConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e458c9db8a6dd7e422fab6ce9cce7c22c7fc1df0fd8a34ce939bd291221c3225)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="securityGroupInput")
    def security_group_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "securityGroupInput"))

    @builtins.property
    @jsii.member(jsii_name="securityGroup")
    def security_group(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "securityGroup"))

    @security_group.setter
    def security_group(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3ffa35eab86a93c60a65d3e4508fafb94e597f6ee3dec495e2713bf5cc600279)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "securityGroup", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterAuthenticatorGroupsConfig]:
        return typing.cast(typing.Optional[ContainerClusterAuthenticatorGroupsConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterAuthenticatorGroupsConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__137a7bff00b018827873a10ec827f7ee4942ca200495cd4a100d735c185d6dd2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterBinaryAuthorization",
    jsii_struct_bases=[],
    name_mapping={"enabled": "enabled", "evaluation_mode": "evaluationMode"},
)
class ContainerClusterBinaryAuthorization:
    def __init__(
        self,
        *,
        enabled: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        evaluation_mode: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param enabled: Enable Binary Authorization for this cluster. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        :param evaluation_mode: Mode of operation for Binary Authorization policy evaluation. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#evaluation_mode ContainerCluster#evaluation_mode}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__231c80f1060a38982e2320c8452f5261be47733fbcd906cd0d78d2c3a3d92d54)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
            check_type(argname="argument evaluation_mode", value=evaluation_mode, expected_type=type_hints["evaluation_mode"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if enabled is not None:
            self._values["enabled"] = enabled
        if evaluation_mode is not None:
            self._values["evaluation_mode"] = evaluation_mode

    @builtins.property
    def enabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Enable Binary Authorization for this cluster.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        '''
        result = self._values.get("enabled")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def evaluation_mode(self) -> typing.Optional[builtins.str]:
        '''Mode of operation for Binary Authorization policy evaluation.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#evaluation_mode ContainerCluster#evaluation_mode}
        '''
        result = self._values.get("evaluation_mode")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterBinaryAuthorization(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterBinaryAuthorizationOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterBinaryAuthorizationOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__006d122e9c3b9189ff387b1bdad93f294df12d37204ad0b72f64c306d0189dc9)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetEnabled")
    def reset_enabled(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnabled", []))

    @jsii.member(jsii_name="resetEvaluationMode")
    def reset_evaluation_mode(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEvaluationMode", []))

    @builtins.property
    @jsii.member(jsii_name="enabledInput")
    def enabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enabledInput"))

    @builtins.property
    @jsii.member(jsii_name="evaluationModeInput")
    def evaluation_mode_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "evaluationModeInput"))

    @builtins.property
    @jsii.member(jsii_name="enabled")
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enabled"))

    @enabled.setter
    def enabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b912479483e9d0fc7110c735ca775caf1205b164db3e934296b8a3646b178c19)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="evaluationMode")
    def evaluation_mode(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "evaluationMode"))

    @evaluation_mode.setter
    def evaluation_mode(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b1b352d1834c0a04e73b9f148fcf6aba1f494ad94cdf0b44fd926a61039ae83d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "evaluationMode", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[ContainerClusterBinaryAuthorization]:
        return typing.cast(typing.Optional[ContainerClusterBinaryAuthorization], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterBinaryAuthorization],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__da58dd09e51a0238a84b30edc59e54eccc4a486065d1f77abbf85db9d027b9b0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterClusterAutoscaling",
    jsii_struct_bases=[],
    name_mapping={
        "auto_provisioning_defaults": "autoProvisioningDefaults",
        "auto_provisioning_locations": "autoProvisioningLocations",
        "autoscaling_profile": "autoscalingProfile",
        "enabled": "enabled",
        "resource_limits": "resourceLimits",
    },
)
class ContainerClusterClusterAutoscaling:
    def __init__(
        self,
        *,
        auto_provisioning_defaults: typing.Optional[typing.Union["ContainerClusterClusterAutoscalingAutoProvisioningDefaults", typing.Dict[builtins.str, typing.Any]]] = None,
        auto_provisioning_locations: typing.Optional[typing.Sequence[builtins.str]] = None,
        autoscaling_profile: typing.Optional[builtins.str] = None,
        enabled: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        resource_limits: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ContainerClusterClusterAutoscalingResourceLimits", typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''
        :param auto_provisioning_defaults: auto_provisioning_defaults block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#auto_provisioning_defaults ContainerCluster#auto_provisioning_defaults}
        :param auto_provisioning_locations: The list of Google Compute Engine zones in which the NodePool's nodes can be created by NAP. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#auto_provisioning_locations ContainerCluster#auto_provisioning_locations}
        :param autoscaling_profile: Configuration options for the Autoscaling profile feature, which lets you choose whether the cluster autoscaler should optimize for resource utilization or resource availability when deciding to remove nodes from a cluster. Can be BALANCED or OPTIMIZE_UTILIZATION. Defaults to BALANCED. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#autoscaling_profile ContainerCluster#autoscaling_profile}
        :param enabled: Whether node auto-provisioning is enabled. Resource limits for cpu and memory must be defined to enable node auto-provisioning. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        :param resource_limits: resource_limits block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#resource_limits ContainerCluster#resource_limits}
        '''
        if isinstance(auto_provisioning_defaults, dict):
            auto_provisioning_defaults = ContainerClusterClusterAutoscalingAutoProvisioningDefaults(**auto_provisioning_defaults)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0d25194b7d9cf20caf650f3110c037a567a6e63304005bcecb0325a3a8f849e5)
            check_type(argname="argument auto_provisioning_defaults", value=auto_provisioning_defaults, expected_type=type_hints["auto_provisioning_defaults"])
            check_type(argname="argument auto_provisioning_locations", value=auto_provisioning_locations, expected_type=type_hints["auto_provisioning_locations"])
            check_type(argname="argument autoscaling_profile", value=autoscaling_profile, expected_type=type_hints["autoscaling_profile"])
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
            check_type(argname="argument resource_limits", value=resource_limits, expected_type=type_hints["resource_limits"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if auto_provisioning_defaults is not None:
            self._values["auto_provisioning_defaults"] = auto_provisioning_defaults
        if auto_provisioning_locations is not None:
            self._values["auto_provisioning_locations"] = auto_provisioning_locations
        if autoscaling_profile is not None:
            self._values["autoscaling_profile"] = autoscaling_profile
        if enabled is not None:
            self._values["enabled"] = enabled
        if resource_limits is not None:
            self._values["resource_limits"] = resource_limits

    @builtins.property
    def auto_provisioning_defaults(
        self,
    ) -> typing.Optional["ContainerClusterClusterAutoscalingAutoProvisioningDefaults"]:
        '''auto_provisioning_defaults block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#auto_provisioning_defaults ContainerCluster#auto_provisioning_defaults}
        '''
        result = self._values.get("auto_provisioning_defaults")
        return typing.cast(typing.Optional["ContainerClusterClusterAutoscalingAutoProvisioningDefaults"], result)

    @builtins.property
    def auto_provisioning_locations(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The list of Google Compute Engine zones in which the NodePool's nodes can be created by NAP.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#auto_provisioning_locations ContainerCluster#auto_provisioning_locations}
        '''
        result = self._values.get("auto_provisioning_locations")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def autoscaling_profile(self) -> typing.Optional[builtins.str]:
        '''Configuration options for the Autoscaling profile feature, which lets you choose whether the cluster autoscaler should optimize for resource utilization or resource availability when deciding to remove nodes from a cluster.

        Can be BALANCED or OPTIMIZE_UTILIZATION. Defaults to BALANCED.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#autoscaling_profile ContainerCluster#autoscaling_profile}
        '''
        result = self._values.get("autoscaling_profile")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Whether node auto-provisioning is enabled. Resource limits for cpu and memory must be defined to enable node auto-provisioning.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        '''
        result = self._values.get("enabled")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def resource_limits(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ContainerClusterClusterAutoscalingResourceLimits"]]]:
        '''resource_limits block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#resource_limits ContainerCluster#resource_limits}
        '''
        result = self._values.get("resource_limits")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ContainerClusterClusterAutoscalingResourceLimits"]]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterClusterAutoscaling(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterClusterAutoscalingAutoProvisioningDefaults",
    jsii_struct_bases=[],
    name_mapping={
        "boot_disk_kms_key": "bootDiskKmsKey",
        "disk_size": "diskSize",
        "disk_type": "diskType",
        "image_type": "imageType",
        "management": "management",
        "min_cpu_platform": "minCpuPlatform",
        "oauth_scopes": "oauthScopes",
        "service_account": "serviceAccount",
        "shielded_instance_config": "shieldedInstanceConfig",
        "upgrade_settings": "upgradeSettings",
    },
)
class ContainerClusterClusterAutoscalingAutoProvisioningDefaults:
    def __init__(
        self,
        *,
        boot_disk_kms_key: typing.Optional[builtins.str] = None,
        disk_size: typing.Optional[jsii.Number] = None,
        disk_type: typing.Optional[builtins.str] = None,
        image_type: typing.Optional[builtins.str] = None,
        management: typing.Optional[typing.Union["ContainerClusterClusterAutoscalingAutoProvisioningDefaultsManagement", typing.Dict[builtins.str, typing.Any]]] = None,
        min_cpu_platform: typing.Optional[builtins.str] = None,
        oauth_scopes: typing.Optional[typing.Sequence[builtins.str]] = None,
        service_account: typing.Optional[builtins.str] = None,
        shielded_instance_config: typing.Optional[typing.Union["ContainerClusterClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        upgrade_settings: typing.Optional[typing.Union["ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param boot_disk_kms_key: The Customer Managed Encryption Key used to encrypt the boot disk attached to each node in the node pool. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#boot_disk_kms_key ContainerCluster#boot_disk_kms_key}
        :param disk_size: Size of the disk attached to each node, specified in GB. The smallest allowed disk size is 10GB. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#disk_size ContainerCluster#disk_size}
        :param disk_type: Type of the disk attached to each node. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#disk_type ContainerCluster#disk_type}
        :param image_type: The default image type used by NAP once a new node pool is being created. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#image_type ContainerCluster#image_type}
        :param management: management block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#management ContainerCluster#management}
        :param min_cpu_platform: Minimum CPU platform to be used by this instance. The instance may be scheduled on the specified or newer CPU platform. Applicable values are the friendly names of CPU platforms, such as Intel Haswell. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#min_cpu_platform ContainerCluster#min_cpu_platform}
        :param oauth_scopes: Scopes that are used by NAP when creating node pools. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#oauth_scopes ContainerCluster#oauth_scopes}
        :param service_account: The Google Cloud Platform Service Account to be used by the node VMs. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#service_account ContainerCluster#service_account}
        :param shielded_instance_config: shielded_instance_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#shielded_instance_config ContainerCluster#shielded_instance_config}
        :param upgrade_settings: upgrade_settings block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#upgrade_settings ContainerCluster#upgrade_settings}
        '''
        if isinstance(management, dict):
            management = ContainerClusterClusterAutoscalingAutoProvisioningDefaultsManagement(**management)
        if isinstance(shielded_instance_config, dict):
            shielded_instance_config = ContainerClusterClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig(**shielded_instance_config)
        if isinstance(upgrade_settings, dict):
            upgrade_settings = ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings(**upgrade_settings)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c74b2155b4b89544db85ab5c397b7d5c13c90bc909cf9502de5e3abff9e49285)
            check_type(argname="argument boot_disk_kms_key", value=boot_disk_kms_key, expected_type=type_hints["boot_disk_kms_key"])
            check_type(argname="argument disk_size", value=disk_size, expected_type=type_hints["disk_size"])
            check_type(argname="argument disk_type", value=disk_type, expected_type=type_hints["disk_type"])
            check_type(argname="argument image_type", value=image_type, expected_type=type_hints["image_type"])
            check_type(argname="argument management", value=management, expected_type=type_hints["management"])
            check_type(argname="argument min_cpu_platform", value=min_cpu_platform, expected_type=type_hints["min_cpu_platform"])
            check_type(argname="argument oauth_scopes", value=oauth_scopes, expected_type=type_hints["oauth_scopes"])
            check_type(argname="argument service_account", value=service_account, expected_type=type_hints["service_account"])
            check_type(argname="argument shielded_instance_config", value=shielded_instance_config, expected_type=type_hints["shielded_instance_config"])
            check_type(argname="argument upgrade_settings", value=upgrade_settings, expected_type=type_hints["upgrade_settings"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if boot_disk_kms_key is not None:
            self._values["boot_disk_kms_key"] = boot_disk_kms_key
        if disk_size is not None:
            self._values["disk_size"] = disk_size
        if disk_type is not None:
            self._values["disk_type"] = disk_type
        if image_type is not None:
            self._values["image_type"] = image_type
        if management is not None:
            self._values["management"] = management
        if min_cpu_platform is not None:
            self._values["min_cpu_platform"] = min_cpu_platform
        if oauth_scopes is not None:
            self._values["oauth_scopes"] = oauth_scopes
        if service_account is not None:
            self._values["service_account"] = service_account
        if shielded_instance_config is not None:
            self._values["shielded_instance_config"] = shielded_instance_config
        if upgrade_settings is not None:
            self._values["upgrade_settings"] = upgrade_settings

    @builtins.property
    def boot_disk_kms_key(self) -> typing.Optional[builtins.str]:
        '''The Customer Managed Encryption Key used to encrypt the boot disk attached to each node in the node pool.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#boot_disk_kms_key ContainerCluster#boot_disk_kms_key}
        '''
        result = self._values.get("boot_disk_kms_key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def disk_size(self) -> typing.Optional[jsii.Number]:
        '''Size of the disk attached to each node, specified in GB. The smallest allowed disk size is 10GB.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#disk_size ContainerCluster#disk_size}
        '''
        result = self._values.get("disk_size")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def disk_type(self) -> typing.Optional[builtins.str]:
        '''Type of the disk attached to each node.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#disk_type ContainerCluster#disk_type}
        '''
        result = self._values.get("disk_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def image_type(self) -> typing.Optional[builtins.str]:
        '''The default image type used by NAP once a new node pool is being created.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#image_type ContainerCluster#image_type}
        '''
        result = self._values.get("image_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def management(
        self,
    ) -> typing.Optional["ContainerClusterClusterAutoscalingAutoProvisioningDefaultsManagement"]:
        '''management block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#management ContainerCluster#management}
        '''
        result = self._values.get("management")
        return typing.cast(typing.Optional["ContainerClusterClusterAutoscalingAutoProvisioningDefaultsManagement"], result)

    @builtins.property
    def min_cpu_platform(self) -> typing.Optional[builtins.str]:
        '''Minimum CPU platform to be used by this instance.

        The instance may be scheduled on the specified or newer CPU platform. Applicable values are the friendly names of CPU platforms, such as Intel Haswell.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#min_cpu_platform ContainerCluster#min_cpu_platform}
        '''
        result = self._values.get("min_cpu_platform")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def oauth_scopes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Scopes that are used by NAP when creating node pools.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#oauth_scopes ContainerCluster#oauth_scopes}
        '''
        result = self._values.get("oauth_scopes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def service_account(self) -> typing.Optional[builtins.str]:
        '''The Google Cloud Platform Service Account to be used by the node VMs.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#service_account ContainerCluster#service_account}
        '''
        result = self._values.get("service_account")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def shielded_instance_config(
        self,
    ) -> typing.Optional["ContainerClusterClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig"]:
        '''shielded_instance_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#shielded_instance_config ContainerCluster#shielded_instance_config}
        '''
        result = self._values.get("shielded_instance_config")
        return typing.cast(typing.Optional["ContainerClusterClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig"], result)

    @builtins.property
    def upgrade_settings(
        self,
    ) -> typing.Optional["ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings"]:
        '''upgrade_settings block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#upgrade_settings ContainerCluster#upgrade_settings}
        '''
        result = self._values.get("upgrade_settings")
        return typing.cast(typing.Optional["ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterClusterAutoscalingAutoProvisioningDefaults(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterClusterAutoscalingAutoProvisioningDefaultsManagement",
    jsii_struct_bases=[],
    name_mapping={"auto_repair": "autoRepair", "auto_upgrade": "autoUpgrade"},
)
class ContainerClusterClusterAutoscalingAutoProvisioningDefaultsManagement:
    def __init__(
        self,
        *,
        auto_repair: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        auto_upgrade: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    ) -> None:
        '''
        :param auto_repair: Specifies whether the node auto-repair is enabled for the node pool. If enabled, the nodes in this node pool will be monitored and, if they fail health checks too many times, an automatic repair action will be triggered. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#auto_repair ContainerCluster#auto_repair}
        :param auto_upgrade: Specifies whether node auto-upgrade is enabled for the node pool. If enabled, node auto-upgrade helps keep the nodes in your node pool up to date with the latest release version of Kubernetes. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#auto_upgrade ContainerCluster#auto_upgrade}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3bf9e4f4eb84edbd79450d408b85a28e0e241ea803c4d7514a58455d596da423)
            check_type(argname="argument auto_repair", value=auto_repair, expected_type=type_hints["auto_repair"])
            check_type(argname="argument auto_upgrade", value=auto_upgrade, expected_type=type_hints["auto_upgrade"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if auto_repair is not None:
            self._values["auto_repair"] = auto_repair
        if auto_upgrade is not None:
            self._values["auto_upgrade"] = auto_upgrade

    @builtins.property
    def auto_repair(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Specifies whether the node auto-repair is enabled for the node pool.

        If enabled, the nodes in this node pool will be monitored and, if they fail health checks too many times, an automatic repair action will be triggered.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#auto_repair ContainerCluster#auto_repair}
        '''
        result = self._values.get("auto_repair")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def auto_upgrade(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Specifies whether node auto-upgrade is enabled for the node pool.

        If enabled, node auto-upgrade helps keep the nodes in your node pool up to date with the latest release version of Kubernetes.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#auto_upgrade ContainerCluster#auto_upgrade}
        '''
        result = self._values.get("auto_upgrade")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterClusterAutoscalingAutoProvisioningDefaultsManagement(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterClusterAutoscalingAutoProvisioningDefaultsManagementOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterClusterAutoscalingAutoProvisioningDefaultsManagementOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2f514f563acf67f9169cd9c733365c436c300e541bfe477edbca819a82bcdef3)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetAutoRepair")
    def reset_auto_repair(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAutoRepair", []))

    @jsii.member(jsii_name="resetAutoUpgrade")
    def reset_auto_upgrade(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAutoUpgrade", []))

    @builtins.property
    @jsii.member(jsii_name="upgradeOptions")
    def upgrade_options(
        self,
    ) -> "ContainerClusterClusterAutoscalingAutoProvisioningDefaultsManagementUpgradeOptionsList":
        return typing.cast("ContainerClusterClusterAutoscalingAutoProvisioningDefaultsManagementUpgradeOptionsList", jsii.get(self, "upgradeOptions"))

    @builtins.property
    @jsii.member(jsii_name="autoRepairInput")
    def auto_repair_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "autoRepairInput"))

    @builtins.property
    @jsii.member(jsii_name="autoUpgradeInput")
    def auto_upgrade_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "autoUpgradeInput"))

    @builtins.property
    @jsii.member(jsii_name="autoRepair")
    def auto_repair(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "autoRepair"))

    @auto_repair.setter
    def auto_repair(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__28ab4aba3ea072447f4e798f83f8ec281d173dc6ddd1e743a2bd9efa7fd16685)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "autoRepair", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="autoUpgrade")
    def auto_upgrade(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "autoUpgrade"))

    @auto_upgrade.setter
    def auto_upgrade(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1ffefb8729a466a019472e7deb10a636fe32381b475c127cb8bdbccb99e9e388)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "autoUpgrade", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterClusterAutoscalingAutoProvisioningDefaultsManagement]:
        return typing.cast(typing.Optional[ContainerClusterClusterAutoscalingAutoProvisioningDefaultsManagement], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterClusterAutoscalingAutoProvisioningDefaultsManagement],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6abc2a75ac2bbaae465807d02234c6f3e45f434d1cbcf97acdd7df127dc9466d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterClusterAutoscalingAutoProvisioningDefaultsManagementUpgradeOptions",
    jsii_struct_bases=[],
    name_mapping={},
)
class ContainerClusterClusterAutoscalingAutoProvisioningDefaultsManagementUpgradeOptions:
    def __init__(self) -> None:
        self._values: typing.Dict[builtins.str, typing.Any] = {}

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterClusterAutoscalingAutoProvisioningDefaultsManagementUpgradeOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterClusterAutoscalingAutoProvisioningDefaultsManagementUpgradeOptionsList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterClusterAutoscalingAutoProvisioningDefaultsManagementUpgradeOptionsList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__39f904226154338db3612a21f36ca6df26cc0943f6630de01f1da7f85e4c77e9)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ContainerClusterClusterAutoscalingAutoProvisioningDefaultsManagementUpgradeOptionsOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__52a4506425e95a32761696b5e012f213034dbf90209afaf6d0144b2d067dbd10)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ContainerClusterClusterAutoscalingAutoProvisioningDefaultsManagementUpgradeOptionsOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b9dbc58934ce3b5c7053756499ef05c631e6a894895dabb9c2a6da01e8f6ceea)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__958dc4b1d894fa626b8cc9959ccb3fe1558430f5d79600042647dde6b1a388b9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__89d325fd41507dc8b0e229a77c6b92181f8483dc34751603f4dc605ae82972cc)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]


class ContainerClusterClusterAutoscalingAutoProvisioningDefaultsManagementUpgradeOptionsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterClusterAutoscalingAutoProvisioningDefaultsManagementUpgradeOptionsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__45b930c7cdcc4ed0a34cc2539a31ae9b1900934881420ffb829de9262aa32891)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @builtins.property
    @jsii.member(jsii_name="autoUpgradeStartTime")
    def auto_upgrade_start_time(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "autoUpgradeStartTime"))

    @builtins.property
    @jsii.member(jsii_name="description")
    def description(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "description"))

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterClusterAutoscalingAutoProvisioningDefaultsManagementUpgradeOptions]:
        return typing.cast(typing.Optional[ContainerClusterClusterAutoscalingAutoProvisioningDefaultsManagementUpgradeOptions], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterClusterAutoscalingAutoProvisioningDefaultsManagementUpgradeOptions],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__039d10f88a2d72ceb54c003746658355e5b233f36be2dbec2341e375d4fbeba3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ContainerClusterClusterAutoscalingAutoProvisioningDefaultsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterClusterAutoscalingAutoProvisioningDefaultsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__305c75f62d4ad7c5e00caee370ac194278c620a4c0ebede0e9978f3e7e444347)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putManagement")
    def put_management(
        self,
        *,
        auto_repair: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        auto_upgrade: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    ) -> None:
        '''
        :param auto_repair: Specifies whether the node auto-repair is enabled for the node pool. If enabled, the nodes in this node pool will be monitored and, if they fail health checks too many times, an automatic repair action will be triggered. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#auto_repair ContainerCluster#auto_repair}
        :param auto_upgrade: Specifies whether node auto-upgrade is enabled for the node pool. If enabled, node auto-upgrade helps keep the nodes in your node pool up to date with the latest release version of Kubernetes. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#auto_upgrade ContainerCluster#auto_upgrade}
        '''
        value = ContainerClusterClusterAutoscalingAutoProvisioningDefaultsManagement(
            auto_repair=auto_repair, auto_upgrade=auto_upgrade
        )

        return typing.cast(None, jsii.invoke(self, "putManagement", [value]))

    @jsii.member(jsii_name="putShieldedInstanceConfig")
    def put_shielded_instance_config(
        self,
        *,
        enable_integrity_monitoring: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        enable_secure_boot: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    ) -> None:
        '''
        :param enable_integrity_monitoring: Defines whether the instance has integrity monitoring enabled. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_integrity_monitoring ContainerCluster#enable_integrity_monitoring}
        :param enable_secure_boot: Defines whether the instance has Secure Boot enabled. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_secure_boot ContainerCluster#enable_secure_boot}
        '''
        value = ContainerClusterClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig(
            enable_integrity_monitoring=enable_integrity_monitoring,
            enable_secure_boot=enable_secure_boot,
        )

        return typing.cast(None, jsii.invoke(self, "putShieldedInstanceConfig", [value]))

    @jsii.member(jsii_name="putUpgradeSettings")
    def put_upgrade_settings(
        self,
        *,
        blue_green_settings: typing.Optional[typing.Union["ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings", typing.Dict[builtins.str, typing.Any]]] = None,
        max_surge: typing.Optional[jsii.Number] = None,
        max_unavailable: typing.Optional[jsii.Number] = None,
        strategy: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param blue_green_settings: blue_green_settings block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#blue_green_settings ContainerCluster#blue_green_settings}
        :param max_surge: The maximum number of nodes that can be created beyond the current size of the node pool during the upgrade process. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#max_surge ContainerCluster#max_surge}
        :param max_unavailable: The maximum number of nodes that can be simultaneously unavailable during the upgrade process. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#max_unavailable ContainerCluster#max_unavailable}
        :param strategy: Update strategy of the node pool. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#strategy ContainerCluster#strategy}
        '''
        value = ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings(
            blue_green_settings=blue_green_settings,
            max_surge=max_surge,
            max_unavailable=max_unavailable,
            strategy=strategy,
        )

        return typing.cast(None, jsii.invoke(self, "putUpgradeSettings", [value]))

    @jsii.member(jsii_name="resetBootDiskKmsKey")
    def reset_boot_disk_kms_key(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBootDiskKmsKey", []))

    @jsii.member(jsii_name="resetDiskSize")
    def reset_disk_size(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDiskSize", []))

    @jsii.member(jsii_name="resetDiskType")
    def reset_disk_type(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDiskType", []))

    @jsii.member(jsii_name="resetImageType")
    def reset_image_type(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetImageType", []))

    @jsii.member(jsii_name="resetManagement")
    def reset_management(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetManagement", []))

    @jsii.member(jsii_name="resetMinCpuPlatform")
    def reset_min_cpu_platform(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMinCpuPlatform", []))

    @jsii.member(jsii_name="resetOauthScopes")
    def reset_oauth_scopes(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetOauthScopes", []))

    @jsii.member(jsii_name="resetServiceAccount")
    def reset_service_account(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetServiceAccount", []))

    @jsii.member(jsii_name="resetShieldedInstanceConfig")
    def reset_shielded_instance_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetShieldedInstanceConfig", []))

    @jsii.member(jsii_name="resetUpgradeSettings")
    def reset_upgrade_settings(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetUpgradeSettings", []))

    @builtins.property
    @jsii.member(jsii_name="management")
    def management(
        self,
    ) -> ContainerClusterClusterAutoscalingAutoProvisioningDefaultsManagementOutputReference:
        return typing.cast(ContainerClusterClusterAutoscalingAutoProvisioningDefaultsManagementOutputReference, jsii.get(self, "management"))

    @builtins.property
    @jsii.member(jsii_name="shieldedInstanceConfig")
    def shielded_instance_config(
        self,
    ) -> "ContainerClusterClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfigOutputReference":
        return typing.cast("ContainerClusterClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfigOutputReference", jsii.get(self, "shieldedInstanceConfig"))

    @builtins.property
    @jsii.member(jsii_name="upgradeSettings")
    def upgrade_settings(
        self,
    ) -> "ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsOutputReference":
        return typing.cast("ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsOutputReference", jsii.get(self, "upgradeSettings"))

    @builtins.property
    @jsii.member(jsii_name="bootDiskKmsKeyInput")
    def boot_disk_kms_key_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "bootDiskKmsKeyInput"))

    @builtins.property
    @jsii.member(jsii_name="diskSizeInput")
    def disk_size_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "diskSizeInput"))

    @builtins.property
    @jsii.member(jsii_name="diskTypeInput")
    def disk_type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "diskTypeInput"))

    @builtins.property
    @jsii.member(jsii_name="imageTypeInput")
    def image_type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "imageTypeInput"))

    @builtins.property
    @jsii.member(jsii_name="managementInput")
    def management_input(
        self,
    ) -> typing.Optional[ContainerClusterClusterAutoscalingAutoProvisioningDefaultsManagement]:
        return typing.cast(typing.Optional[ContainerClusterClusterAutoscalingAutoProvisioningDefaultsManagement], jsii.get(self, "managementInput"))

    @builtins.property
    @jsii.member(jsii_name="minCpuPlatformInput")
    def min_cpu_platform_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "minCpuPlatformInput"))

    @builtins.property
    @jsii.member(jsii_name="oauthScopesInput")
    def oauth_scopes_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "oauthScopesInput"))

    @builtins.property
    @jsii.member(jsii_name="serviceAccountInput")
    def service_account_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "serviceAccountInput"))

    @builtins.property
    @jsii.member(jsii_name="shieldedInstanceConfigInput")
    def shielded_instance_config_input(
        self,
    ) -> typing.Optional["ContainerClusterClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig"]:
        return typing.cast(typing.Optional["ContainerClusterClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig"], jsii.get(self, "shieldedInstanceConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="upgradeSettingsInput")
    def upgrade_settings_input(
        self,
    ) -> typing.Optional["ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings"]:
        return typing.cast(typing.Optional["ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings"], jsii.get(self, "upgradeSettingsInput"))

    @builtins.property
    @jsii.member(jsii_name="bootDiskKmsKey")
    def boot_disk_kms_key(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "bootDiskKmsKey"))

    @boot_disk_kms_key.setter
    def boot_disk_kms_key(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b241fea7029d5696976cbcdf7f2c3481ac82d3d9fb74fa7e45f23051cb931d8c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "bootDiskKmsKey", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="diskSize")
    def disk_size(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "diskSize"))

    @disk_size.setter
    def disk_size(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4260cd34d913af8160fd63600d8b7db8e827471d25055ea91d0596e90e6a5d21)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "diskSize", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="diskType")
    def disk_type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "diskType"))

    @disk_type.setter
    def disk_type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__914bcbc8430ccbc828fa56ea8c1ab8b4a022ba4c1ae0d0ad791c4f4b6fa9209f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "diskType", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="imageType")
    def image_type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "imageType"))

    @image_type.setter
    def image_type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__192791ac221dfb6f89365a3d812a8d6d3211fdb95f5939359f54321f5d4023b8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "imageType", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="minCpuPlatform")
    def min_cpu_platform(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "minCpuPlatform"))

    @min_cpu_platform.setter
    def min_cpu_platform(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e97a99f2adf23415cc916dbe0b51a67c9afee2928b79d1efe54499e2a62584e5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "minCpuPlatform", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="oauthScopes")
    def oauth_scopes(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "oauthScopes"))

    @oauth_scopes.setter
    def oauth_scopes(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f61162fc09cc65c4d8fbea82d40b8630894f84eb82418be83b1b2876029c924c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "oauthScopes", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="serviceAccount")
    def service_account(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "serviceAccount"))

    @service_account.setter
    def service_account(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__428882f11777d22b0e65b93b22040568082a20f0e792fd6b359454827f3a61f9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "serviceAccount", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterClusterAutoscalingAutoProvisioningDefaults]:
        return typing.cast(typing.Optional[ContainerClusterClusterAutoscalingAutoProvisioningDefaults], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterClusterAutoscalingAutoProvisioningDefaults],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__38684d28f2226a0d9b10d1b1136e818426e8ac026ea0cb9ffe45d6719e243d80)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig",
    jsii_struct_bases=[],
    name_mapping={
        "enable_integrity_monitoring": "enableIntegrityMonitoring",
        "enable_secure_boot": "enableSecureBoot",
    },
)
class ContainerClusterClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig:
    def __init__(
        self,
        *,
        enable_integrity_monitoring: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        enable_secure_boot: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    ) -> None:
        '''
        :param enable_integrity_monitoring: Defines whether the instance has integrity monitoring enabled. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_integrity_monitoring ContainerCluster#enable_integrity_monitoring}
        :param enable_secure_boot: Defines whether the instance has Secure Boot enabled. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_secure_boot ContainerCluster#enable_secure_boot}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__87e28f88bbbfb1b469c3bb66cb17bc2de1932fcb3b63dfc54a1588aaee1ddfc9)
            check_type(argname="argument enable_integrity_monitoring", value=enable_integrity_monitoring, expected_type=type_hints["enable_integrity_monitoring"])
            check_type(argname="argument enable_secure_boot", value=enable_secure_boot, expected_type=type_hints["enable_secure_boot"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if enable_integrity_monitoring is not None:
            self._values["enable_integrity_monitoring"] = enable_integrity_monitoring
        if enable_secure_boot is not None:
            self._values["enable_secure_boot"] = enable_secure_boot

    @builtins.property
    def enable_integrity_monitoring(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Defines whether the instance has integrity monitoring enabled.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_integrity_monitoring ContainerCluster#enable_integrity_monitoring}
        '''
        result = self._values.get("enable_integrity_monitoring")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def enable_secure_boot(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Defines whether the instance has Secure Boot enabled.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_secure_boot ContainerCluster#enable_secure_boot}
        '''
        result = self._values.get("enable_secure_boot")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__254e08c121849aff16daaa18317c7634ad9b8be1bf723fe3f2b714d9112b6d3d)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetEnableIntegrityMonitoring")
    def reset_enable_integrity_monitoring(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnableIntegrityMonitoring", []))

    @jsii.member(jsii_name="resetEnableSecureBoot")
    def reset_enable_secure_boot(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnableSecureBoot", []))

    @builtins.property
    @jsii.member(jsii_name="enableIntegrityMonitoringInput")
    def enable_integrity_monitoring_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enableIntegrityMonitoringInput"))

    @builtins.property
    @jsii.member(jsii_name="enableSecureBootInput")
    def enable_secure_boot_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enableSecureBootInput"))

    @builtins.property
    @jsii.member(jsii_name="enableIntegrityMonitoring")
    def enable_integrity_monitoring(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enableIntegrityMonitoring"))

    @enable_integrity_monitoring.setter
    def enable_integrity_monitoring(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__64e8ada630c48097efbaa93b384ab99cbb798575828701b294bc866b6fa816fc)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableIntegrityMonitoring", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="enableSecureBoot")
    def enable_secure_boot(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enableSecureBoot"))

    @enable_secure_boot.setter
    def enable_secure_boot(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__630fcc82ec1bf511483d7c7b613a59f3959b9ff928aaa35932ac5af91417a435)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableSecureBoot", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig]:
        return typing.cast(typing.Optional[ContainerClusterClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__32409bbe2453058b65777fdd898f744f81bccd6a18282fd98bcb2e26e15a0cf0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings",
    jsii_struct_bases=[],
    name_mapping={
        "blue_green_settings": "blueGreenSettings",
        "max_surge": "maxSurge",
        "max_unavailable": "maxUnavailable",
        "strategy": "strategy",
    },
)
class ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings:
    def __init__(
        self,
        *,
        blue_green_settings: typing.Optional[typing.Union["ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings", typing.Dict[builtins.str, typing.Any]]] = None,
        max_surge: typing.Optional[jsii.Number] = None,
        max_unavailable: typing.Optional[jsii.Number] = None,
        strategy: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param blue_green_settings: blue_green_settings block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#blue_green_settings ContainerCluster#blue_green_settings}
        :param max_surge: The maximum number of nodes that can be created beyond the current size of the node pool during the upgrade process. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#max_surge ContainerCluster#max_surge}
        :param max_unavailable: The maximum number of nodes that can be simultaneously unavailable during the upgrade process. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#max_unavailable ContainerCluster#max_unavailable}
        :param strategy: Update strategy of the node pool. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#strategy ContainerCluster#strategy}
        '''
        if isinstance(blue_green_settings, dict):
            blue_green_settings = ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings(**blue_green_settings)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8065934130c74122f72c4ff71bd486d68452b181adc2beee88e278b4490b7a1f)
            check_type(argname="argument blue_green_settings", value=blue_green_settings, expected_type=type_hints["blue_green_settings"])
            check_type(argname="argument max_surge", value=max_surge, expected_type=type_hints["max_surge"])
            check_type(argname="argument max_unavailable", value=max_unavailable, expected_type=type_hints["max_unavailable"])
            check_type(argname="argument strategy", value=strategy, expected_type=type_hints["strategy"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if blue_green_settings is not None:
            self._values["blue_green_settings"] = blue_green_settings
        if max_surge is not None:
            self._values["max_surge"] = max_surge
        if max_unavailable is not None:
            self._values["max_unavailable"] = max_unavailable
        if strategy is not None:
            self._values["strategy"] = strategy

    @builtins.property
    def blue_green_settings(
        self,
    ) -> typing.Optional["ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings"]:
        '''blue_green_settings block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#blue_green_settings ContainerCluster#blue_green_settings}
        '''
        result = self._values.get("blue_green_settings")
        return typing.cast(typing.Optional["ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings"], result)

    @builtins.property
    def max_surge(self) -> typing.Optional[jsii.Number]:
        '''The maximum number of nodes that can be created beyond the current size of the node pool during the upgrade process.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#max_surge ContainerCluster#max_surge}
        '''
        result = self._values.get("max_surge")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def max_unavailable(self) -> typing.Optional[jsii.Number]:
        '''The maximum number of nodes that can be simultaneously unavailable during the upgrade process.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#max_unavailable ContainerCluster#max_unavailable}
        '''
        result = self._values.get("max_unavailable")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def strategy(self) -> typing.Optional[builtins.str]:
        '''Update strategy of the node pool.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#strategy ContainerCluster#strategy}
        '''
        result = self._values.get("strategy")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings",
    jsii_struct_bases=[],
    name_mapping={
        "node_pool_soak_duration": "nodePoolSoakDuration",
        "standard_rollout_policy": "standardRolloutPolicy",
    },
)
class ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings:
    def __init__(
        self,
        *,
        node_pool_soak_duration: typing.Optional[builtins.str] = None,
        standard_rollout_policy: typing.Optional[typing.Union["ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param node_pool_soak_duration: Time needed after draining entire blue pool. After this period, blue pool will be cleaned up. A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s". Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#node_pool_soak_duration ContainerCluster#node_pool_soak_duration}
        :param standard_rollout_policy: standard_rollout_policy block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#standard_rollout_policy ContainerCluster#standard_rollout_policy}
        '''
        if isinstance(standard_rollout_policy, dict):
            standard_rollout_policy = ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy(**standard_rollout_policy)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__52034160074bd10cb960d1e16ce0cd4e6c6e37662b2a33e51403918feb095b74)
            check_type(argname="argument node_pool_soak_duration", value=node_pool_soak_duration, expected_type=type_hints["node_pool_soak_duration"])
            check_type(argname="argument standard_rollout_policy", value=standard_rollout_policy, expected_type=type_hints["standard_rollout_policy"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if node_pool_soak_duration is not None:
            self._values["node_pool_soak_duration"] = node_pool_soak_duration
        if standard_rollout_policy is not None:
            self._values["standard_rollout_policy"] = standard_rollout_policy

    @builtins.property
    def node_pool_soak_duration(self) -> typing.Optional[builtins.str]:
        '''Time needed after draining entire blue pool. After this period, blue pool will be cleaned up.

        A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#node_pool_soak_duration ContainerCluster#node_pool_soak_duration}
        '''
        result = self._values.get("node_pool_soak_duration")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def standard_rollout_policy(
        self,
    ) -> typing.Optional["ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy"]:
        '''standard_rollout_policy block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#standard_rollout_policy ContainerCluster#standard_rollout_policy}
        '''
        result = self._values.get("standard_rollout_policy")
        return typing.cast(typing.Optional["ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1c33439da99c9a2a9b93d4bed072b078c24fcfd9340522aed5e17b8b8ab35e28)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putStandardRolloutPolicy")
    def put_standard_rollout_policy(
        self,
        *,
        batch_node_count: typing.Optional[jsii.Number] = None,
        batch_percentage: typing.Optional[jsii.Number] = None,
        batch_soak_duration: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param batch_node_count: Number of blue nodes to drain in a batch. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#batch_node_count ContainerCluster#batch_node_count}
        :param batch_percentage: Percentage of the bool pool nodes to drain in a batch. The range of this field should be (0.0, 1.0]. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#batch_percentage ContainerCluster#batch_percentage}
        :param batch_soak_duration: Soak time after each batch gets drained. A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s". Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#batch_soak_duration ContainerCluster#batch_soak_duration}
        '''
        value = ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy(
            batch_node_count=batch_node_count,
            batch_percentage=batch_percentage,
            batch_soak_duration=batch_soak_duration,
        )

        return typing.cast(None, jsii.invoke(self, "putStandardRolloutPolicy", [value]))

    @jsii.member(jsii_name="resetNodePoolSoakDuration")
    def reset_node_pool_soak_duration(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNodePoolSoakDuration", []))

    @jsii.member(jsii_name="resetStandardRolloutPolicy")
    def reset_standard_rollout_policy(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetStandardRolloutPolicy", []))

    @builtins.property
    @jsii.member(jsii_name="standardRolloutPolicy")
    def standard_rollout_policy(
        self,
    ) -> "ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicyOutputReference":
        return typing.cast("ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicyOutputReference", jsii.get(self, "standardRolloutPolicy"))

    @builtins.property
    @jsii.member(jsii_name="nodePoolSoakDurationInput")
    def node_pool_soak_duration_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nodePoolSoakDurationInput"))

    @builtins.property
    @jsii.member(jsii_name="standardRolloutPolicyInput")
    def standard_rollout_policy_input(
        self,
    ) -> typing.Optional["ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy"]:
        return typing.cast(typing.Optional["ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy"], jsii.get(self, "standardRolloutPolicyInput"))

    @builtins.property
    @jsii.member(jsii_name="nodePoolSoakDuration")
    def node_pool_soak_duration(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "nodePoolSoakDuration"))

    @node_pool_soak_duration.setter
    def node_pool_soak_duration(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__582b2e1795b513abdc7cbc910b792cd8efb564e20bfa8fb4568c9a6d2b243023)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "nodePoolSoakDuration", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings]:
        return typing.cast(typing.Optional[ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__06c0a28c161f26164e3f30eeaa488f577049cb69b0bd16355dc7a76bed8365f4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy",
    jsii_struct_bases=[],
    name_mapping={
        "batch_node_count": "batchNodeCount",
        "batch_percentage": "batchPercentage",
        "batch_soak_duration": "batchSoakDuration",
    },
)
class ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy:
    def __init__(
        self,
        *,
        batch_node_count: typing.Optional[jsii.Number] = None,
        batch_percentage: typing.Optional[jsii.Number] = None,
        batch_soak_duration: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param batch_node_count: Number of blue nodes to drain in a batch. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#batch_node_count ContainerCluster#batch_node_count}
        :param batch_percentage: Percentage of the bool pool nodes to drain in a batch. The range of this field should be (0.0, 1.0]. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#batch_percentage ContainerCluster#batch_percentage}
        :param batch_soak_duration: Soak time after each batch gets drained. A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s". Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#batch_soak_duration ContainerCluster#batch_soak_duration}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__846b0746342b4ffddac22329da27ec4a2771c6488c1fd092d48d9864d247426e)
            check_type(argname="argument batch_node_count", value=batch_node_count, expected_type=type_hints["batch_node_count"])
            check_type(argname="argument batch_percentage", value=batch_percentage, expected_type=type_hints["batch_percentage"])
            check_type(argname="argument batch_soak_duration", value=batch_soak_duration, expected_type=type_hints["batch_soak_duration"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if batch_node_count is not None:
            self._values["batch_node_count"] = batch_node_count
        if batch_percentage is not None:
            self._values["batch_percentage"] = batch_percentage
        if batch_soak_duration is not None:
            self._values["batch_soak_duration"] = batch_soak_duration

    @builtins.property
    def batch_node_count(self) -> typing.Optional[jsii.Number]:
        '''Number of blue nodes to drain in a batch.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#batch_node_count ContainerCluster#batch_node_count}
        '''
        result = self._values.get("batch_node_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def batch_percentage(self) -> typing.Optional[jsii.Number]:
        '''Percentage of the bool pool nodes to drain in a batch.

        The range of this field should be (0.0, 1.0].

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#batch_percentage ContainerCluster#batch_percentage}
        '''
        result = self._values.get("batch_percentage")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def batch_soak_duration(self) -> typing.Optional[builtins.str]:
        '''Soak time after each batch gets drained.

        A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#batch_soak_duration ContainerCluster#batch_soak_duration}
        '''
        result = self._values.get("batch_soak_duration")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicyOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicyOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6dd77cb9733caee1396c665d15fe44865735a321a5e4e2bbbb75039672c45023)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetBatchNodeCount")
    def reset_batch_node_count(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBatchNodeCount", []))

    @jsii.member(jsii_name="resetBatchPercentage")
    def reset_batch_percentage(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBatchPercentage", []))

    @jsii.member(jsii_name="resetBatchSoakDuration")
    def reset_batch_soak_duration(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBatchSoakDuration", []))

    @builtins.property
    @jsii.member(jsii_name="batchNodeCountInput")
    def batch_node_count_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "batchNodeCountInput"))

    @builtins.property
    @jsii.member(jsii_name="batchPercentageInput")
    def batch_percentage_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "batchPercentageInput"))

    @builtins.property
    @jsii.member(jsii_name="batchSoakDurationInput")
    def batch_soak_duration_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "batchSoakDurationInput"))

    @builtins.property
    @jsii.member(jsii_name="batchNodeCount")
    def batch_node_count(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "batchNodeCount"))

    @batch_node_count.setter
    def batch_node_count(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2c74ddbdf6f27a28efd9731832f599c7200fed79f373904fe9dbb273ee7ca00a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "batchNodeCount", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="batchPercentage")
    def batch_percentage(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "batchPercentage"))

    @batch_percentage.setter
    def batch_percentage(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__04ebe6f7667976dab5da6dc82f49724002f43cbc0fd13a77b63c70ed84f7f0e0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "batchPercentage", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="batchSoakDuration")
    def batch_soak_duration(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "batchSoakDuration"))

    @batch_soak_duration.setter
    def batch_soak_duration(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7c44f9020c8fee7930961c69f9e22031c6452325b5379620ab422c57a77c1eaa)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "batchSoakDuration", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy]:
        return typing.cast(typing.Optional[ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fb72006866b5af0f5063edf548bb09fc0bef52692fc3a71ab60ae4d1d8d79b9c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__18396b0f297045d72556cd5d32c4b44f4d404f82ff4caba2a10f6f4df37a25bf)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putBlueGreenSettings")
    def put_blue_green_settings(
        self,
        *,
        node_pool_soak_duration: typing.Optional[builtins.str] = None,
        standard_rollout_policy: typing.Optional[typing.Union[ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param node_pool_soak_duration: Time needed after draining entire blue pool. After this period, blue pool will be cleaned up. A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s". Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#node_pool_soak_duration ContainerCluster#node_pool_soak_duration}
        :param standard_rollout_policy: standard_rollout_policy block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#standard_rollout_policy ContainerCluster#standard_rollout_policy}
        '''
        value = ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings(
            node_pool_soak_duration=node_pool_soak_duration,
            standard_rollout_policy=standard_rollout_policy,
        )

        return typing.cast(None, jsii.invoke(self, "putBlueGreenSettings", [value]))

    @jsii.member(jsii_name="resetBlueGreenSettings")
    def reset_blue_green_settings(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBlueGreenSettings", []))

    @jsii.member(jsii_name="resetMaxSurge")
    def reset_max_surge(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMaxSurge", []))

    @jsii.member(jsii_name="resetMaxUnavailable")
    def reset_max_unavailable(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMaxUnavailable", []))

    @jsii.member(jsii_name="resetStrategy")
    def reset_strategy(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetStrategy", []))

    @builtins.property
    @jsii.member(jsii_name="blueGreenSettings")
    def blue_green_settings(
        self,
    ) -> ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsOutputReference:
        return typing.cast(ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsOutputReference, jsii.get(self, "blueGreenSettings"))

    @builtins.property
    @jsii.member(jsii_name="blueGreenSettingsInput")
    def blue_green_settings_input(
        self,
    ) -> typing.Optional[ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings]:
        return typing.cast(typing.Optional[ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings], jsii.get(self, "blueGreenSettingsInput"))

    @builtins.property
    @jsii.member(jsii_name="maxSurgeInput")
    def max_surge_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "maxSurgeInput"))

    @builtins.property
    @jsii.member(jsii_name="maxUnavailableInput")
    def max_unavailable_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "maxUnavailableInput"))

    @builtins.property
    @jsii.member(jsii_name="strategyInput")
    def strategy_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "strategyInput"))

    @builtins.property
    @jsii.member(jsii_name="maxSurge")
    def max_surge(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "maxSurge"))

    @max_surge.setter
    def max_surge(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f00da0dfc81944ef978e0a83968cdf0c91c32de3c3b91029c8b7438366811148)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "maxSurge", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="maxUnavailable")
    def max_unavailable(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "maxUnavailable"))

    @max_unavailable.setter
    def max_unavailable(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0173e3339f90cfecf3aa3f0783cacdc5ce1063266ac4c450dbcd8cb044378438)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "maxUnavailable", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def strategy(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "strategy"))

    @strategy.setter
    def strategy(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7c0ba61c1ebb03025f54833b9307add892fa8082c2a670758f70cba6ad8f35ad)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "strategy", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings]:
        return typing.cast(typing.Optional[ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7d4f00a288b5cdbd9bc949e8d4fba35c41bb720ea37e64a6e10b125a9f6ab537)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ContainerClusterClusterAutoscalingOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterClusterAutoscalingOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4e8d95af5e1845e22289b374af7f78b0fb9e93922a937adb319fff440d21e510)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putAutoProvisioningDefaults")
    def put_auto_provisioning_defaults(
        self,
        *,
        boot_disk_kms_key: typing.Optional[builtins.str] = None,
        disk_size: typing.Optional[jsii.Number] = None,
        disk_type: typing.Optional[builtins.str] = None,
        image_type: typing.Optional[builtins.str] = None,
        management: typing.Optional[typing.Union[ContainerClusterClusterAutoscalingAutoProvisioningDefaultsManagement, typing.Dict[builtins.str, typing.Any]]] = None,
        min_cpu_platform: typing.Optional[builtins.str] = None,
        oauth_scopes: typing.Optional[typing.Sequence[builtins.str]] = None,
        service_account: typing.Optional[builtins.str] = None,
        shielded_instance_config: typing.Optional[typing.Union[ContainerClusterClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        upgrade_settings: typing.Optional[typing.Union[ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param boot_disk_kms_key: The Customer Managed Encryption Key used to encrypt the boot disk attached to each node in the node pool. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#boot_disk_kms_key ContainerCluster#boot_disk_kms_key}
        :param disk_size: Size of the disk attached to each node, specified in GB. The smallest allowed disk size is 10GB. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#disk_size ContainerCluster#disk_size}
        :param disk_type: Type of the disk attached to each node. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#disk_type ContainerCluster#disk_type}
        :param image_type: The default image type used by NAP once a new node pool is being created. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#image_type ContainerCluster#image_type}
        :param management: management block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#management ContainerCluster#management}
        :param min_cpu_platform: Minimum CPU platform to be used by this instance. The instance may be scheduled on the specified or newer CPU platform. Applicable values are the friendly names of CPU platforms, such as Intel Haswell. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#min_cpu_platform ContainerCluster#min_cpu_platform}
        :param oauth_scopes: Scopes that are used by NAP when creating node pools. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#oauth_scopes ContainerCluster#oauth_scopes}
        :param service_account: The Google Cloud Platform Service Account to be used by the node VMs. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#service_account ContainerCluster#service_account}
        :param shielded_instance_config: shielded_instance_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#shielded_instance_config ContainerCluster#shielded_instance_config}
        :param upgrade_settings: upgrade_settings block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#upgrade_settings ContainerCluster#upgrade_settings}
        '''
        value = ContainerClusterClusterAutoscalingAutoProvisioningDefaults(
            boot_disk_kms_key=boot_disk_kms_key,
            disk_size=disk_size,
            disk_type=disk_type,
            image_type=image_type,
            management=management,
            min_cpu_platform=min_cpu_platform,
            oauth_scopes=oauth_scopes,
            service_account=service_account,
            shielded_instance_config=shielded_instance_config,
            upgrade_settings=upgrade_settings,
        )

        return typing.cast(None, jsii.invoke(self, "putAutoProvisioningDefaults", [value]))

    @jsii.member(jsii_name="putResourceLimits")
    def put_resource_limits(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ContainerClusterClusterAutoscalingResourceLimits", typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__31ec9a56bad94b9d271190676be4a7b364b429122300331d3aa25b4a696cf3bd)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putResourceLimits", [value]))

    @jsii.member(jsii_name="resetAutoProvisioningDefaults")
    def reset_auto_provisioning_defaults(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAutoProvisioningDefaults", []))

    @jsii.member(jsii_name="resetAutoProvisioningLocations")
    def reset_auto_provisioning_locations(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAutoProvisioningLocations", []))

    @jsii.member(jsii_name="resetAutoscalingProfile")
    def reset_autoscaling_profile(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAutoscalingProfile", []))

    @jsii.member(jsii_name="resetEnabled")
    def reset_enabled(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnabled", []))

    @jsii.member(jsii_name="resetResourceLimits")
    def reset_resource_limits(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetResourceLimits", []))

    @builtins.property
    @jsii.member(jsii_name="autoProvisioningDefaults")
    def auto_provisioning_defaults(
        self,
    ) -> ContainerClusterClusterAutoscalingAutoProvisioningDefaultsOutputReference:
        return typing.cast(ContainerClusterClusterAutoscalingAutoProvisioningDefaultsOutputReference, jsii.get(self, "autoProvisioningDefaults"))

    @builtins.property
    @jsii.member(jsii_name="resourceLimits")
    def resource_limits(self) -> "ContainerClusterClusterAutoscalingResourceLimitsList":
        return typing.cast("ContainerClusterClusterAutoscalingResourceLimitsList", jsii.get(self, "resourceLimits"))

    @builtins.property
    @jsii.member(jsii_name="autoProvisioningDefaultsInput")
    def auto_provisioning_defaults_input(
        self,
    ) -> typing.Optional[ContainerClusterClusterAutoscalingAutoProvisioningDefaults]:
        return typing.cast(typing.Optional[ContainerClusterClusterAutoscalingAutoProvisioningDefaults], jsii.get(self, "autoProvisioningDefaultsInput"))

    @builtins.property
    @jsii.member(jsii_name="autoProvisioningLocationsInput")
    def auto_provisioning_locations_input(
        self,
    ) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "autoProvisioningLocationsInput"))

    @builtins.property
    @jsii.member(jsii_name="autoscalingProfileInput")
    def autoscaling_profile_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "autoscalingProfileInput"))

    @builtins.property
    @jsii.member(jsii_name="enabledInput")
    def enabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enabledInput"))

    @builtins.property
    @jsii.member(jsii_name="resourceLimitsInput")
    def resource_limits_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ContainerClusterClusterAutoscalingResourceLimits"]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ContainerClusterClusterAutoscalingResourceLimits"]]], jsii.get(self, "resourceLimitsInput"))

    @builtins.property
    @jsii.member(jsii_name="autoProvisioningLocations")
    def auto_provisioning_locations(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "autoProvisioningLocations"))

    @auto_provisioning_locations.setter
    def auto_provisioning_locations(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__922705163d15f2d9da872c3e97b5570e5af2e81a5cdf6ee6bae0f6ffcd928c9a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "autoProvisioningLocations", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="autoscalingProfile")
    def autoscaling_profile(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "autoscalingProfile"))

    @autoscaling_profile.setter
    def autoscaling_profile(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__316e29e69e433eb2b681de775be238e30b8e80dca1234d791e6fede215c7ce27)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "autoscalingProfile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="enabled")
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enabled"))

    @enabled.setter
    def enabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cf558e68f007248106a98e56b0385517956f11cb24c5465697aa482402239927)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[ContainerClusterClusterAutoscaling]:
        return typing.cast(typing.Optional[ContainerClusterClusterAutoscaling], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterClusterAutoscaling],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5938fd47a50207ed91492229dd2402708d41f8134fa239807debd57f6faf90ee)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterClusterAutoscalingResourceLimits",
    jsii_struct_bases=[],
    name_mapping={
        "maximum": "maximum",
        "resource_type": "resourceType",
        "minimum": "minimum",
    },
)
class ContainerClusterClusterAutoscalingResourceLimits:
    def __init__(
        self,
        *,
        maximum: jsii.Number,
        resource_type: builtins.str,
        minimum: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param maximum: Maximum amount of the resource in the cluster. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#maximum ContainerCluster#maximum}
        :param resource_type: The type of the resource. For example, cpu and memory. See the guide to using Node Auto-Provisioning for a list of types. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#resource_type ContainerCluster#resource_type}
        :param minimum: Minimum amount of the resource in the cluster. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#minimum ContainerCluster#minimum}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f298985a310c2edbe2d0c51da0facddd0d7ae153702fdb975f9c2a7d9032decd)
            check_type(argname="argument maximum", value=maximum, expected_type=type_hints["maximum"])
            check_type(argname="argument resource_type", value=resource_type, expected_type=type_hints["resource_type"])
            check_type(argname="argument minimum", value=minimum, expected_type=type_hints["minimum"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "maximum": maximum,
            "resource_type": resource_type,
        }
        if minimum is not None:
            self._values["minimum"] = minimum

    @builtins.property
    def maximum(self) -> jsii.Number:
        '''Maximum amount of the resource in the cluster.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#maximum ContainerCluster#maximum}
        '''
        result = self._values.get("maximum")
        assert result is not None, "Required property 'maximum' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def resource_type(self) -> builtins.str:
        '''The type of the resource.

        For example, cpu and memory. See the guide to using Node Auto-Provisioning for a list of types.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#resource_type ContainerCluster#resource_type}
        '''
        result = self._values.get("resource_type")
        assert result is not None, "Required property 'resource_type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def minimum(self) -> typing.Optional[jsii.Number]:
        '''Minimum amount of the resource in the cluster.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#minimum ContainerCluster#minimum}
        '''
        result = self._values.get("minimum")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterClusterAutoscalingResourceLimits(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterClusterAutoscalingResourceLimitsList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterClusterAutoscalingResourceLimitsList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__16ef6a2120327c2606d1c8018707a7153f5287ecd704376b75a3582f4e41a7fb)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ContainerClusterClusterAutoscalingResourceLimitsOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__aacc3e4cdec8dcb54d4b1df644b4347ffa7b58db61c67e93863f6e6d90e6253a)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ContainerClusterClusterAutoscalingResourceLimitsOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f2ae9adbf7b9ed228bc9e1b1719a3db1a5ab5d994764cf7984aaa9c0cf878752)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ae879f806176b547b2ec1c210183ffb83168a1e1c52c5cbe038e099fa1f9cc45)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f7fdd40c4e814e3288e5da5ffd6fad8656e016e40bcd8d0b38ae17c0d65a0c6d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterClusterAutoscalingResourceLimits]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterClusterAutoscalingResourceLimits]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterClusterAutoscalingResourceLimits]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f73130eccf6ab704714fd77dcb600a887f4eadb1a57be48c65a4b60719924e0d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ContainerClusterClusterAutoscalingResourceLimitsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterClusterAutoscalingResourceLimitsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__79bb5cf00dca605877d137a244be8467e6ffa50389f279cece9f5a651dee36a5)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="resetMinimum")
    def reset_minimum(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMinimum", []))

    @builtins.property
    @jsii.member(jsii_name="maximumInput")
    def maximum_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "maximumInput"))

    @builtins.property
    @jsii.member(jsii_name="minimumInput")
    def minimum_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "minimumInput"))

    @builtins.property
    @jsii.member(jsii_name="resourceTypeInput")
    def resource_type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "resourceTypeInput"))

    @builtins.property
    @jsii.member(jsii_name="maximum")
    def maximum(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "maximum"))

    @maximum.setter
    def maximum(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2cd4c1bb0889413c909781551388758bdf55f7ed215bc1573c59233f169c1012)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "maximum", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="minimum")
    def minimum(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "minimum"))

    @minimum.setter
    def minimum(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__77f55efd38ed7f4af15d38c459f23babce77b02727b3728397825a0898a2d8cc)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "minimum", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="resourceType")
    def resource_type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "resourceType"))

    @resource_type.setter
    def resource_type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__757bfeb6641b9d78cbf0bcf0141d52d31b5091a90111fc030dc2c4393965d480)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "resourceType", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterClusterAutoscalingResourceLimits]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterClusterAutoscalingResourceLimits]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterClusterAutoscalingResourceLimits]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fe42725cb9692c6b35263c30713d809e780c529fa4615c079e9fdf0539d95177)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterConfidentialNodes",
    jsii_struct_bases=[],
    name_mapping={
        "enabled": "enabled",
        "confidential_instance_type": "confidentialInstanceType",
    },
)
class ContainerClusterConfidentialNodes:
    def __init__(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
        confidential_instance_type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param enabled: Whether Confidential Nodes feature is enabled for all nodes in this cluster. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        :param confidential_instance_type: Defines the type of technology used by the confidential node. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#confidential_instance_type ContainerCluster#confidential_instance_type}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4b3262c9ad6523a323e92c430530922547eef99b6ec92e6e80b0a01397e2c303)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
            check_type(argname="argument confidential_instance_type", value=confidential_instance_type, expected_type=type_hints["confidential_instance_type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "enabled": enabled,
        }
        if confidential_instance_type is not None:
            self._values["confidential_instance_type"] = confidential_instance_type

    @builtins.property
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        '''Whether Confidential Nodes feature is enabled for all nodes in this cluster.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        '''
        result = self._values.get("enabled")
        assert result is not None, "Required property 'enabled' is missing"
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], result)

    @builtins.property
    def confidential_instance_type(self) -> typing.Optional[builtins.str]:
        '''Defines the type of technology used by the confidential node.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#confidential_instance_type ContainerCluster#confidential_instance_type}
        '''
        result = self._values.get("confidential_instance_type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterConfidentialNodes(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterConfidentialNodesOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterConfidentialNodesOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f18d28c3e99b0c50c295ee508e193dbcf9138b6c7bbe0950a5eb3ac5d859176c)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetConfidentialInstanceType")
    def reset_confidential_instance_type(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetConfidentialInstanceType", []))

    @builtins.property
    @jsii.member(jsii_name="confidentialInstanceTypeInput")
    def confidential_instance_type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "confidentialInstanceTypeInput"))

    @builtins.property
    @jsii.member(jsii_name="enabledInput")
    def enabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enabledInput"))

    @builtins.property
    @jsii.member(jsii_name="confidentialInstanceType")
    def confidential_instance_type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "confidentialInstanceType"))

    @confidential_instance_type.setter
    def confidential_instance_type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9b56d84d6fadb2c0ecec03e72ce79e3b3a3e6404fd9095798407ab3e0d4d2912)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "confidentialInstanceType", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="enabled")
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enabled"))

    @enabled.setter
    def enabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d7ae8f58c2e47da85d3626244cb234110ae1d5394a5aeebb109f721f6ba056f0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[ContainerClusterConfidentialNodes]:
        return typing.cast(typing.Optional[ContainerClusterConfidentialNodes], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterConfidentialNodes],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__af3763e29e3e2842e7e864d60aaca9a508eb54e8f37813f0a817c765c1b094da)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterConfig",
    jsii_struct_bases=[_cdktf_9a9027ec.TerraformMetaArguments],
    name_mapping={
        "connection": "connection",
        "count": "count",
        "depends_on": "dependsOn",
        "for_each": "forEach",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "provisioners": "provisioners",
        "name": "name",
        "addons_config": "addonsConfig",
        "allow_net_admin": "allowNetAdmin",
        "anonymous_authentication_config": "anonymousAuthenticationConfig",
        "authenticator_groups_config": "authenticatorGroupsConfig",
        "binary_authorization": "binaryAuthorization",
        "cluster_autoscaling": "clusterAutoscaling",
        "cluster_ipv4_cidr": "clusterIpv4Cidr",
        "confidential_nodes": "confidentialNodes",
        "control_plane_endpoints_config": "controlPlaneEndpointsConfig",
        "cost_management_config": "costManagementConfig",
        "database_encryption": "databaseEncryption",
        "datapath_provider": "datapathProvider",
        "default_max_pods_per_node": "defaultMaxPodsPerNode",
        "default_snat_status": "defaultSnatStatus",
        "deletion_protection": "deletionProtection",
        "description": "description",
        "disable_l4_lb_firewall_reconciliation": "disableL4LbFirewallReconciliation",
        "dns_config": "dnsConfig",
        "enable_autopilot": "enableAutopilot",
        "enable_cilium_clusterwide_network_policy": "enableCiliumClusterwideNetworkPolicy",
        "enable_fqdn_network_policy": "enableFqdnNetworkPolicy",
        "enable_intranode_visibility": "enableIntranodeVisibility",
        "enable_k8_s_beta_apis": "enableK8SBetaApis",
        "enable_kubernetes_alpha": "enableKubernetesAlpha",
        "enable_l4_ilb_subsetting": "enableL4IlbSubsetting",
        "enable_legacy_abac": "enableLegacyAbac",
        "enable_multi_networking": "enableMultiNetworking",
        "enable_shielded_nodes": "enableShieldedNodes",
        "enable_tpu": "enableTpu",
        "enterprise_config": "enterpriseConfig",
        "fleet": "fleet",
        "gateway_api_config": "gatewayApiConfig",
        "gke_auto_upgrade_config": "gkeAutoUpgradeConfig",
        "id": "id",
        "identity_service_config": "identityServiceConfig",
        "initial_node_count": "initialNodeCount",
        "in_transit_encryption_config": "inTransitEncryptionConfig",
        "ip_allocation_policy": "ipAllocationPolicy",
        "location": "location",
        "logging_config": "loggingConfig",
        "logging_service": "loggingService",
        "maintenance_policy": "maintenancePolicy",
        "master_auth": "masterAuth",
        "master_authorized_networks_config": "masterAuthorizedNetworksConfig",
        "mesh_certificates": "meshCertificates",
        "min_master_version": "minMasterVersion",
        "monitoring_config": "monitoringConfig",
        "monitoring_service": "monitoringService",
        "network": "network",
        "networking_mode": "networkingMode",
        "network_performance_config": "networkPerformanceConfig",
        "network_policy": "networkPolicy",
        "node_config": "nodeConfig",
        "node_locations": "nodeLocations",
        "node_pool": "nodePool",
        "node_pool_auto_config": "nodePoolAutoConfig",
        "node_pool_defaults": "nodePoolDefaults",
        "node_version": "nodeVersion",
        "notification_config": "notificationConfig",
        "pod_autoscaling": "podAutoscaling",
        "private_cluster_config": "privateClusterConfig",
        "private_ipv6_google_access": "privateIpv6GoogleAccess",
        "project": "project",
        "rbac_binding_config": "rbacBindingConfig",
        "release_channel": "releaseChannel",
        "remove_default_node_pool": "removeDefaultNodePool",
        "resource_labels": "resourceLabels",
        "resource_usage_export_config": "resourceUsageExportConfig",
        "secret_manager_config": "secretManagerConfig",
        "security_posture_config": "securityPostureConfig",
        "service_external_ips_config": "serviceExternalIpsConfig",
        "subnetwork": "subnetwork",
        "timeouts": "timeouts",
        "user_managed_keys_config": "userManagedKeysConfig",
        "vertical_pod_autoscaling": "verticalPodAutoscaling",
        "workload_identity_config": "workloadIdentityConfig",
    },
)
class ContainerClusterConfig(_cdktf_9a9027ec.TerraformMetaArguments):
    def __init__(
        self,
        *,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
        name: builtins.str,
        addons_config: typing.Optional[typing.Union[ContainerClusterAddonsConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        allow_net_admin: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        anonymous_authentication_config: typing.Optional[typing.Union[ContainerClusterAnonymousAuthenticationConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        authenticator_groups_config: typing.Optional[typing.Union[ContainerClusterAuthenticatorGroupsConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        binary_authorization: typing.Optional[typing.Union[ContainerClusterBinaryAuthorization, typing.Dict[builtins.str, typing.Any]]] = None,
        cluster_autoscaling: typing.Optional[typing.Union[ContainerClusterClusterAutoscaling, typing.Dict[builtins.str, typing.Any]]] = None,
        cluster_ipv4_cidr: typing.Optional[builtins.str] = None,
        confidential_nodes: typing.Optional[typing.Union[ContainerClusterConfidentialNodes, typing.Dict[builtins.str, typing.Any]]] = None,
        control_plane_endpoints_config: typing.Optional[typing.Union["ContainerClusterControlPlaneEndpointsConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        cost_management_config: typing.Optional[typing.Union["ContainerClusterCostManagementConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        database_encryption: typing.Optional[typing.Union["ContainerClusterDatabaseEncryption", typing.Dict[builtins.str, typing.Any]]] = None,
        datapath_provider: typing.Optional[builtins.str] = None,
        default_max_pods_per_node: typing.Optional[jsii.Number] = None,
        default_snat_status: typing.Optional[typing.Union["ContainerClusterDefaultSnatStatus", typing.Dict[builtins.str, typing.Any]]] = None,
        deletion_protection: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        description: typing.Optional[builtins.str] = None,
        disable_l4_lb_firewall_reconciliation: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        dns_config: typing.Optional[typing.Union["ContainerClusterDnsConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        enable_autopilot: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        enable_cilium_clusterwide_network_policy: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        enable_fqdn_network_policy: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        enable_intranode_visibility: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        enable_k8_s_beta_apis: typing.Optional[typing.Union["ContainerClusterEnableK8SBetaApis", typing.Dict[builtins.str, typing.Any]]] = None,
        enable_kubernetes_alpha: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        enable_l4_ilb_subsetting: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        enable_legacy_abac: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        enable_multi_networking: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        enable_shielded_nodes: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        enable_tpu: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        enterprise_config: typing.Optional[typing.Union["ContainerClusterEnterpriseConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        fleet: typing.Optional[typing.Union["ContainerClusterFleet", typing.Dict[builtins.str, typing.Any]]] = None,
        gateway_api_config: typing.Optional[typing.Union["ContainerClusterGatewayApiConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        gke_auto_upgrade_config: typing.Optional[typing.Union["ContainerClusterGkeAutoUpgradeConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        id: typing.Optional[builtins.str] = None,
        identity_service_config: typing.Optional[typing.Union["ContainerClusterIdentityServiceConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        initial_node_count: typing.Optional[jsii.Number] = None,
        in_transit_encryption_config: typing.Optional[builtins.str] = None,
        ip_allocation_policy: typing.Optional[typing.Union["ContainerClusterIpAllocationPolicy", typing.Dict[builtins.str, typing.Any]]] = None,
        location: typing.Optional[builtins.str] = None,
        logging_config: typing.Optional[typing.Union["ContainerClusterLoggingConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        logging_service: typing.Optional[builtins.str] = None,
        maintenance_policy: typing.Optional[typing.Union["ContainerClusterMaintenancePolicy", typing.Dict[builtins.str, typing.Any]]] = None,
        master_auth: typing.Optional[typing.Union["ContainerClusterMasterAuth", typing.Dict[builtins.str, typing.Any]]] = None,
        master_authorized_networks_config: typing.Optional[typing.Union["ContainerClusterMasterAuthorizedNetworksConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        mesh_certificates: typing.Optional[typing.Union["ContainerClusterMeshCertificates", typing.Dict[builtins.str, typing.Any]]] = None,
        min_master_version: typing.Optional[builtins.str] = None,
        monitoring_config: typing.Optional[typing.Union["ContainerClusterMonitoringConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        monitoring_service: typing.Optional[builtins.str] = None,
        network: typing.Optional[builtins.str] = None,
        networking_mode: typing.Optional[builtins.str] = None,
        network_performance_config: typing.Optional[typing.Union["ContainerClusterNetworkPerformanceConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        network_policy: typing.Optional[typing.Union["ContainerClusterNetworkPolicy", typing.Dict[builtins.str, typing.Any]]] = None,
        node_config: typing.Optional[typing.Union["ContainerClusterNodeConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        node_locations: typing.Optional[typing.Sequence[builtins.str]] = None,
        node_pool: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ContainerClusterNodePool", typing.Dict[builtins.str, typing.Any]]]]] = None,
        node_pool_auto_config: typing.Optional[typing.Union["ContainerClusterNodePoolAutoConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        node_pool_defaults: typing.Optional[typing.Union["ContainerClusterNodePoolDefaults", typing.Dict[builtins.str, typing.Any]]] = None,
        node_version: typing.Optional[builtins.str] = None,
        notification_config: typing.Optional[typing.Union["ContainerClusterNotificationConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        pod_autoscaling: typing.Optional[typing.Union["ContainerClusterPodAutoscaling", typing.Dict[builtins.str, typing.Any]]] = None,
        private_cluster_config: typing.Optional[typing.Union["ContainerClusterPrivateClusterConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        private_ipv6_google_access: typing.Optional[builtins.str] = None,
        project: typing.Optional[builtins.str] = None,
        rbac_binding_config: typing.Optional[typing.Union["ContainerClusterRbacBindingConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        release_channel: typing.Optional[typing.Union["ContainerClusterReleaseChannel", typing.Dict[builtins.str, typing.Any]]] = None,
        remove_default_node_pool: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        resource_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        resource_usage_export_config: typing.Optional[typing.Union["ContainerClusterResourceUsageExportConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        secret_manager_config: typing.Optional[typing.Union["ContainerClusterSecretManagerConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        security_posture_config: typing.Optional[typing.Union["ContainerClusterSecurityPostureConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        service_external_ips_config: typing.Optional[typing.Union["ContainerClusterServiceExternalIpsConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        subnetwork: typing.Optional[builtins.str] = None,
        timeouts: typing.Optional[typing.Union["ContainerClusterTimeouts", typing.Dict[builtins.str, typing.Any]]] = None,
        user_managed_keys_config: typing.Optional[typing.Union["ContainerClusterUserManagedKeysConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        vertical_pod_autoscaling: typing.Optional[typing.Union["ContainerClusterVerticalPodAutoscaling", typing.Dict[builtins.str, typing.Any]]] = None,
        workload_identity_config: typing.Optional[typing.Union["ContainerClusterWorkloadIdentityConfig", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        :param name: The name of the cluster, unique within the project and location. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#name ContainerCluster#name}
        :param addons_config: addons_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#addons_config ContainerCluster#addons_config}
        :param allow_net_admin: Enable NET_ADMIN for this cluster. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#allow_net_admin ContainerCluster#allow_net_admin}
        :param anonymous_authentication_config: anonymous_authentication_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#anonymous_authentication_config ContainerCluster#anonymous_authentication_config}
        :param authenticator_groups_config: authenticator_groups_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#authenticator_groups_config ContainerCluster#authenticator_groups_config}
        :param binary_authorization: binary_authorization block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#binary_authorization ContainerCluster#binary_authorization}
        :param cluster_autoscaling: cluster_autoscaling block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cluster_autoscaling ContainerCluster#cluster_autoscaling}
        :param cluster_ipv4_cidr: The IP address range of the Kubernetes pods in this cluster in CIDR notation (e.g. 10.96.0.0/14). Leave blank to have one automatically chosen or specify a /14 block in 10.0.0.0/8. This field will only work for routes-based clusters, where ip_allocation_policy is not defined. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cluster_ipv4_cidr ContainerCluster#cluster_ipv4_cidr}
        :param confidential_nodes: confidential_nodes block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#confidential_nodes ContainerCluster#confidential_nodes}
        :param control_plane_endpoints_config: control_plane_endpoints_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#control_plane_endpoints_config ContainerCluster#control_plane_endpoints_config}
        :param cost_management_config: cost_management_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cost_management_config ContainerCluster#cost_management_config}
        :param database_encryption: database_encryption block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#database_encryption ContainerCluster#database_encryption}
        :param datapath_provider: The desired datapath provider for this cluster. By default, uses the IPTables-based kube-proxy implementation. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#datapath_provider ContainerCluster#datapath_provider}
        :param default_max_pods_per_node: The default maximum number of pods per node in this cluster. This doesn't work on "routes-based" clusters, clusters that don't have IP Aliasing enabled. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#default_max_pods_per_node ContainerCluster#default_max_pods_per_node}
        :param default_snat_status: default_snat_status block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#default_snat_status ContainerCluster#default_snat_status}
        :param deletion_protection: When the field is set to true or unset in Terraform state, a terraform apply or terraform destroy that would delete the cluster will fail. When the field is set to false, deleting the cluster is allowed. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#deletion_protection ContainerCluster#deletion_protection}
        :param description: Description of the cluster. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#description ContainerCluster#description}
        :param disable_l4_lb_firewall_reconciliation: Disable L4 load balancer VPC firewalls to enable firewall policies. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#disable_l4_lb_firewall_reconciliation ContainerCluster#disable_l4_lb_firewall_reconciliation}
        :param dns_config: dns_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#dns_config ContainerCluster#dns_config}
        :param enable_autopilot: Enable Autopilot for this cluster. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_autopilot ContainerCluster#enable_autopilot}
        :param enable_cilium_clusterwide_network_policy: Whether Cilium cluster-wide network policy is enabled on this cluster. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_cilium_clusterwide_network_policy ContainerCluster#enable_cilium_clusterwide_network_policy}
        :param enable_fqdn_network_policy: Whether FQDN Network Policy is enabled on this cluster. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_fqdn_network_policy ContainerCluster#enable_fqdn_network_policy}
        :param enable_intranode_visibility: Whether Intra-node visibility is enabled for this cluster. This makes same node pod to pod traffic visible for VPC network. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_intranode_visibility ContainerCluster#enable_intranode_visibility}
        :param enable_k8_s_beta_apis: enable_k8s_beta_apis block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_k8s_beta_apis ContainerCluster#enable_k8s_beta_apis}
        :param enable_kubernetes_alpha: Whether to enable Kubernetes Alpha features for this cluster. Note that when this option is enabled, the cluster cannot be upgraded and will be automatically deleted after 30 days. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_kubernetes_alpha ContainerCluster#enable_kubernetes_alpha}
        :param enable_l4_ilb_subsetting: Whether L4ILB Subsetting is enabled for this cluster. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_l4_ilb_subsetting ContainerCluster#enable_l4_ilb_subsetting}
        :param enable_legacy_abac: Whether the ABAC authorizer is enabled for this cluster. When enabled, identities in the system, including service accounts, nodes, and controllers, will have statically granted permissions beyond those provided by the RBAC configuration or IAM. Defaults to false. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_legacy_abac ContainerCluster#enable_legacy_abac}
        :param enable_multi_networking: Whether multi-networking is enabled for this cluster. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_multi_networking ContainerCluster#enable_multi_networking}
        :param enable_shielded_nodes: Enable Shielded Nodes features on all nodes in this cluster. Defaults to true. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_shielded_nodes ContainerCluster#enable_shielded_nodes}
        :param enable_tpu: Whether to enable Cloud TPU resources in this cluster. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_tpu ContainerCluster#enable_tpu}
        :param enterprise_config: enterprise_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enterprise_config ContainerCluster#enterprise_config}
        :param fleet: fleet block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#fleet ContainerCluster#fleet}
        :param gateway_api_config: gateway_api_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gateway_api_config ContainerCluster#gateway_api_config}
        :param gke_auto_upgrade_config: gke_auto_upgrade_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gke_auto_upgrade_config ContainerCluster#gke_auto_upgrade_config}
        :param id: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#id ContainerCluster#id}. Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2. If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        :param identity_service_config: identity_service_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#identity_service_config ContainerCluster#identity_service_config}
        :param initial_node_count: The number of nodes to create in this cluster's default node pool. In regional or multi-zonal clusters, this is the number of nodes per zone. Must be set if node_pool is not set. If you're using google_container_node_pool objects with no default node pool, you'll need to set this to a value of at least 1, alongside setting remove_default_node_pool to true. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#initial_node_count ContainerCluster#initial_node_count}
        :param in_transit_encryption_config: Defines the config of in-transit encryption. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#in_transit_encryption_config ContainerCluster#in_transit_encryption_config}
        :param ip_allocation_policy: ip_allocation_policy block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#ip_allocation_policy ContainerCluster#ip_allocation_policy}
        :param location: The location (region or zone) in which the cluster master will be created, as well as the default node location. If you specify a zone (such as us-central1-a), the cluster will be a zonal cluster with a single cluster master. If you specify a region (such as us-west1), the cluster will be a regional cluster with multiple masters spread across zones in the region, and with default node locations in those zones as well. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#location ContainerCluster#location}
        :param logging_config: logging_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#logging_config ContainerCluster#logging_config}
        :param logging_service: The logging service that the cluster should write logs to. Available options include logging.googleapis.com(Legacy Stackdriver), logging.googleapis.com/kubernetes(Stackdriver Kubernetes Engine Logging), and none. Defaults to logging.googleapis.com/kubernetes. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#logging_service ContainerCluster#logging_service}
        :param maintenance_policy: maintenance_policy block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#maintenance_policy ContainerCluster#maintenance_policy}
        :param master_auth: master_auth block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#master_auth ContainerCluster#master_auth}
        :param master_authorized_networks_config: master_authorized_networks_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#master_authorized_networks_config ContainerCluster#master_authorized_networks_config}
        :param mesh_certificates: mesh_certificates block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#mesh_certificates ContainerCluster#mesh_certificates}
        :param min_master_version: The minimum version of the master. GKE will auto-update the master to new versions, so this does not guarantee the current master version--use the read-only master_version field to obtain that. If unset, the cluster's version will be set by GKE to the version of the most recent official release (which is not necessarily the latest version). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#min_master_version ContainerCluster#min_master_version}
        :param monitoring_config: monitoring_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#monitoring_config ContainerCluster#monitoring_config}
        :param monitoring_service: The monitoring service that the cluster should write metrics to. Automatically send metrics from pods in the cluster to the Google Cloud Monitoring API. VM metrics will be collected by Google Compute Engine regardless of this setting Available options include monitoring.googleapis.com(Legacy Stackdriver), monitoring.googleapis.com/kubernetes(Stackdriver Kubernetes Engine Monitoring), and none. Defaults to monitoring.googleapis.com/kubernetes. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#monitoring_service ContainerCluster#monitoring_service}
        :param network: The name or self_link of the Google Compute Engine network to which the cluster is connected. For Shared VPC, set this to the self link of the shared network. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#network ContainerCluster#network}
        :param networking_mode: Determines whether alias IPs or routes will be used for pod IPs in the cluster. Defaults to VPC_NATIVE for new clusters. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#networking_mode ContainerCluster#networking_mode}
        :param network_performance_config: network_performance_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#network_performance_config ContainerCluster#network_performance_config}
        :param network_policy: network_policy block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#network_policy ContainerCluster#network_policy}
        :param node_config: node_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#node_config ContainerCluster#node_config}
        :param node_locations: The list of zones in which the cluster's nodes are located. Nodes must be in the region of their regional cluster or in the same region as their cluster's zone for zonal clusters. If this is specified for a zonal cluster, omit the cluster's zone. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#node_locations ContainerCluster#node_locations}
        :param node_pool: node_pool block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#node_pool ContainerCluster#node_pool}
        :param node_pool_auto_config: node_pool_auto_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#node_pool_auto_config ContainerCluster#node_pool_auto_config}
        :param node_pool_defaults: node_pool_defaults block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#node_pool_defaults ContainerCluster#node_pool_defaults}
        :param node_version: The Kubernetes version on the nodes. Must either be unset or set to the same value as min_master_version on create. Defaults to the default version set by GKE which is not necessarily the latest version. This only affects nodes in the default node pool. While a fuzzy version can be specified, it's recommended that you specify explicit versions as Terraform will see spurious diffs when fuzzy versions are used. See the google_container_engine_versions data source's version_prefix field to approximate fuzzy versions in a Terraform-compatible way. To update nodes in other node pools, use the version attribute on the node pool. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#node_version ContainerCluster#node_version}
        :param notification_config: notification_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#notification_config ContainerCluster#notification_config}
        :param pod_autoscaling: pod_autoscaling block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#pod_autoscaling ContainerCluster#pod_autoscaling}
        :param private_cluster_config: private_cluster_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#private_cluster_config ContainerCluster#private_cluster_config}
        :param private_ipv6_google_access: The desired state of IPv6 connectivity to Google Services. By default, no private IPv6 access to or from Google Services (all access will be via IPv4). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#private_ipv6_google_access ContainerCluster#private_ipv6_google_access}
        :param project: The ID of the project in which the resource belongs. If it is not provided, the provider project is used. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#project ContainerCluster#project}
        :param rbac_binding_config: rbac_binding_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#rbac_binding_config ContainerCluster#rbac_binding_config}
        :param release_channel: release_channel block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#release_channel ContainerCluster#release_channel}
        :param remove_default_node_pool: If true, deletes the default node pool upon cluster creation. If you're using google_container_node_pool resources with no default node pool, this should be set to true, alongside setting initial_node_count to at least 1. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#remove_default_node_pool ContainerCluster#remove_default_node_pool}
        :param resource_labels: The GCE resource labels (a map of key/value pairs) to be applied to the cluster. **Note**: This field is non-authoritative, and will only manage the labels present in your configuration. Please refer to the field 'effective_labels' for all of the labels present on the resource. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#resource_labels ContainerCluster#resource_labels}
        :param resource_usage_export_config: resource_usage_export_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#resource_usage_export_config ContainerCluster#resource_usage_export_config}
        :param secret_manager_config: secret_manager_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#secret_manager_config ContainerCluster#secret_manager_config}
        :param security_posture_config: security_posture_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#security_posture_config ContainerCluster#security_posture_config}
        :param service_external_ips_config: service_external_ips_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#service_external_ips_config ContainerCluster#service_external_ips_config}
        :param subnetwork: The name or self_link of the Google Compute Engine subnetwork in which the cluster's instances are launched. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#subnetwork ContainerCluster#subnetwork}
        :param timeouts: timeouts block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#timeouts ContainerCluster#timeouts}
        :param user_managed_keys_config: user_managed_keys_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#user_managed_keys_config ContainerCluster#user_managed_keys_config}
        :param vertical_pod_autoscaling: vertical_pod_autoscaling block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#vertical_pod_autoscaling ContainerCluster#vertical_pod_autoscaling}
        :param workload_identity_config: workload_identity_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#workload_identity_config ContainerCluster#workload_identity_config}
        '''
        if isinstance(lifecycle, dict):
            lifecycle = _cdktf_9a9027ec.TerraformResourceLifecycle(**lifecycle)
        if isinstance(addons_config, dict):
            addons_config = ContainerClusterAddonsConfig(**addons_config)
        if isinstance(anonymous_authentication_config, dict):
            anonymous_authentication_config = ContainerClusterAnonymousAuthenticationConfig(**anonymous_authentication_config)
        if isinstance(authenticator_groups_config, dict):
            authenticator_groups_config = ContainerClusterAuthenticatorGroupsConfig(**authenticator_groups_config)
        if isinstance(binary_authorization, dict):
            binary_authorization = ContainerClusterBinaryAuthorization(**binary_authorization)
        if isinstance(cluster_autoscaling, dict):
            cluster_autoscaling = ContainerClusterClusterAutoscaling(**cluster_autoscaling)
        if isinstance(confidential_nodes, dict):
            confidential_nodes = ContainerClusterConfidentialNodes(**confidential_nodes)
        if isinstance(control_plane_endpoints_config, dict):
            control_plane_endpoints_config = ContainerClusterControlPlaneEndpointsConfig(**control_plane_endpoints_config)
        if isinstance(cost_management_config, dict):
            cost_management_config = ContainerClusterCostManagementConfig(**cost_management_config)
        if isinstance(database_encryption, dict):
            database_encryption = ContainerClusterDatabaseEncryption(**database_encryption)
        if isinstance(default_snat_status, dict):
            default_snat_status = ContainerClusterDefaultSnatStatus(**default_snat_status)
        if isinstance(dns_config, dict):
            dns_config = ContainerClusterDnsConfig(**dns_config)
        if isinstance(enable_k8_s_beta_apis, dict):
            enable_k8_s_beta_apis = ContainerClusterEnableK8SBetaApis(**enable_k8_s_beta_apis)
        if isinstance(enterprise_config, dict):
            enterprise_config = ContainerClusterEnterpriseConfig(**enterprise_config)
        if isinstance(fleet, dict):
            fleet = ContainerClusterFleet(**fleet)
        if isinstance(gateway_api_config, dict):
            gateway_api_config = ContainerClusterGatewayApiConfig(**gateway_api_config)
        if isinstance(gke_auto_upgrade_config, dict):
            gke_auto_upgrade_config = ContainerClusterGkeAutoUpgradeConfig(**gke_auto_upgrade_config)
        if isinstance(identity_service_config, dict):
            identity_service_config = ContainerClusterIdentityServiceConfig(**identity_service_config)
        if isinstance(ip_allocation_policy, dict):
            ip_allocation_policy = ContainerClusterIpAllocationPolicy(**ip_allocation_policy)
        if isinstance(logging_config, dict):
            logging_config = ContainerClusterLoggingConfig(**logging_config)
        if isinstance(maintenance_policy, dict):
            maintenance_policy = ContainerClusterMaintenancePolicy(**maintenance_policy)
        if isinstance(master_auth, dict):
            master_auth = ContainerClusterMasterAuth(**master_auth)
        if isinstance(master_authorized_networks_config, dict):
            master_authorized_networks_config = ContainerClusterMasterAuthorizedNetworksConfig(**master_authorized_networks_config)
        if isinstance(mesh_certificates, dict):
            mesh_certificates = ContainerClusterMeshCertificates(**mesh_certificates)
        if isinstance(monitoring_config, dict):
            monitoring_config = ContainerClusterMonitoringConfig(**monitoring_config)
        if isinstance(network_performance_config, dict):
            network_performance_config = ContainerClusterNetworkPerformanceConfig(**network_performance_config)
        if isinstance(network_policy, dict):
            network_policy = ContainerClusterNetworkPolicy(**network_policy)
        if isinstance(node_config, dict):
            node_config = ContainerClusterNodeConfig(**node_config)
        if isinstance(node_pool_auto_config, dict):
            node_pool_auto_config = ContainerClusterNodePoolAutoConfig(**node_pool_auto_config)
        if isinstance(node_pool_defaults, dict):
            node_pool_defaults = ContainerClusterNodePoolDefaults(**node_pool_defaults)
        if isinstance(notification_config, dict):
            notification_config = ContainerClusterNotificationConfig(**notification_config)
        if isinstance(pod_autoscaling, dict):
            pod_autoscaling = ContainerClusterPodAutoscaling(**pod_autoscaling)
        if isinstance(private_cluster_config, dict):
            private_cluster_config = ContainerClusterPrivateClusterConfig(**private_cluster_config)
        if isinstance(rbac_binding_config, dict):
            rbac_binding_config = ContainerClusterRbacBindingConfig(**rbac_binding_config)
        if isinstance(release_channel, dict):
            release_channel = ContainerClusterReleaseChannel(**release_channel)
        if isinstance(resource_usage_export_config, dict):
            resource_usage_export_config = ContainerClusterResourceUsageExportConfig(**resource_usage_export_config)
        if isinstance(secret_manager_config, dict):
            secret_manager_config = ContainerClusterSecretManagerConfig(**secret_manager_config)
        if isinstance(security_posture_config, dict):
            security_posture_config = ContainerClusterSecurityPostureConfig(**security_posture_config)
        if isinstance(service_external_ips_config, dict):
            service_external_ips_config = ContainerClusterServiceExternalIpsConfig(**service_external_ips_config)
        if isinstance(timeouts, dict):
            timeouts = ContainerClusterTimeouts(**timeouts)
        if isinstance(user_managed_keys_config, dict):
            user_managed_keys_config = ContainerClusterUserManagedKeysConfig(**user_managed_keys_config)
        if isinstance(vertical_pod_autoscaling, dict):
            vertical_pod_autoscaling = ContainerClusterVerticalPodAutoscaling(**vertical_pod_autoscaling)
        if isinstance(workload_identity_config, dict):
            workload_identity_config = ContainerClusterWorkloadIdentityConfig(**workload_identity_config)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__86583242019dd13fdb8a135b5185f2d527c88d5e9deca2e90bce8e0c8bc7a6b4)
            check_type(argname="argument connection", value=connection, expected_type=type_hints["connection"])
            check_type(argname="argument count", value=count, expected_type=type_hints["count"])
            check_type(argname="argument depends_on", value=depends_on, expected_type=type_hints["depends_on"])
            check_type(argname="argument for_each", value=for_each, expected_type=type_hints["for_each"])
            check_type(argname="argument lifecycle", value=lifecycle, expected_type=type_hints["lifecycle"])
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
            check_type(argname="argument provisioners", value=provisioners, expected_type=type_hints["provisioners"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument addons_config", value=addons_config, expected_type=type_hints["addons_config"])
            check_type(argname="argument allow_net_admin", value=allow_net_admin, expected_type=type_hints["allow_net_admin"])
            check_type(argname="argument anonymous_authentication_config", value=anonymous_authentication_config, expected_type=type_hints["anonymous_authentication_config"])
            check_type(argname="argument authenticator_groups_config", value=authenticator_groups_config, expected_type=type_hints["authenticator_groups_config"])
            check_type(argname="argument binary_authorization", value=binary_authorization, expected_type=type_hints["binary_authorization"])
            check_type(argname="argument cluster_autoscaling", value=cluster_autoscaling, expected_type=type_hints["cluster_autoscaling"])
            check_type(argname="argument cluster_ipv4_cidr", value=cluster_ipv4_cidr, expected_type=type_hints["cluster_ipv4_cidr"])
            check_type(argname="argument confidential_nodes", value=confidential_nodes, expected_type=type_hints["confidential_nodes"])
            check_type(argname="argument control_plane_endpoints_config", value=control_plane_endpoints_config, expected_type=type_hints["control_plane_endpoints_config"])
            check_type(argname="argument cost_management_config", value=cost_management_config, expected_type=type_hints["cost_management_config"])
            check_type(argname="argument database_encryption", value=database_encryption, expected_type=type_hints["database_encryption"])
            check_type(argname="argument datapath_provider", value=datapath_provider, expected_type=type_hints["datapath_provider"])
            check_type(argname="argument default_max_pods_per_node", value=default_max_pods_per_node, expected_type=type_hints["default_max_pods_per_node"])
            check_type(argname="argument default_snat_status", value=default_snat_status, expected_type=type_hints["default_snat_status"])
            check_type(argname="argument deletion_protection", value=deletion_protection, expected_type=type_hints["deletion_protection"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument disable_l4_lb_firewall_reconciliation", value=disable_l4_lb_firewall_reconciliation, expected_type=type_hints["disable_l4_lb_firewall_reconciliation"])
            check_type(argname="argument dns_config", value=dns_config, expected_type=type_hints["dns_config"])
            check_type(argname="argument enable_autopilot", value=enable_autopilot, expected_type=type_hints["enable_autopilot"])
            check_type(argname="argument enable_cilium_clusterwide_network_policy", value=enable_cilium_clusterwide_network_policy, expected_type=type_hints["enable_cilium_clusterwide_network_policy"])
            check_type(argname="argument enable_fqdn_network_policy", value=enable_fqdn_network_policy, expected_type=type_hints["enable_fqdn_network_policy"])
            check_type(argname="argument enable_intranode_visibility", value=enable_intranode_visibility, expected_type=type_hints["enable_intranode_visibility"])
            check_type(argname="argument enable_k8_s_beta_apis", value=enable_k8_s_beta_apis, expected_type=type_hints["enable_k8_s_beta_apis"])
            check_type(argname="argument enable_kubernetes_alpha", value=enable_kubernetes_alpha, expected_type=type_hints["enable_kubernetes_alpha"])
            check_type(argname="argument enable_l4_ilb_subsetting", value=enable_l4_ilb_subsetting, expected_type=type_hints["enable_l4_ilb_subsetting"])
            check_type(argname="argument enable_legacy_abac", value=enable_legacy_abac, expected_type=type_hints["enable_legacy_abac"])
            check_type(argname="argument enable_multi_networking", value=enable_multi_networking, expected_type=type_hints["enable_multi_networking"])
            check_type(argname="argument enable_shielded_nodes", value=enable_shielded_nodes, expected_type=type_hints["enable_shielded_nodes"])
            check_type(argname="argument enable_tpu", value=enable_tpu, expected_type=type_hints["enable_tpu"])
            check_type(argname="argument enterprise_config", value=enterprise_config, expected_type=type_hints["enterprise_config"])
            check_type(argname="argument fleet", value=fleet, expected_type=type_hints["fleet"])
            check_type(argname="argument gateway_api_config", value=gateway_api_config, expected_type=type_hints["gateway_api_config"])
            check_type(argname="argument gke_auto_upgrade_config", value=gke_auto_upgrade_config, expected_type=type_hints["gke_auto_upgrade_config"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument identity_service_config", value=identity_service_config, expected_type=type_hints["identity_service_config"])
            check_type(argname="argument initial_node_count", value=initial_node_count, expected_type=type_hints["initial_node_count"])
            check_type(argname="argument in_transit_encryption_config", value=in_transit_encryption_config, expected_type=type_hints["in_transit_encryption_config"])
            check_type(argname="argument ip_allocation_policy", value=ip_allocation_policy, expected_type=type_hints["ip_allocation_policy"])
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument logging_config", value=logging_config, expected_type=type_hints["logging_config"])
            check_type(argname="argument logging_service", value=logging_service, expected_type=type_hints["logging_service"])
            check_type(argname="argument maintenance_policy", value=maintenance_policy, expected_type=type_hints["maintenance_policy"])
            check_type(argname="argument master_auth", value=master_auth, expected_type=type_hints["master_auth"])
            check_type(argname="argument master_authorized_networks_config", value=master_authorized_networks_config, expected_type=type_hints["master_authorized_networks_config"])
            check_type(argname="argument mesh_certificates", value=mesh_certificates, expected_type=type_hints["mesh_certificates"])
            check_type(argname="argument min_master_version", value=min_master_version, expected_type=type_hints["min_master_version"])
            check_type(argname="argument monitoring_config", value=monitoring_config, expected_type=type_hints["monitoring_config"])
            check_type(argname="argument monitoring_service", value=monitoring_service, expected_type=type_hints["monitoring_service"])
            check_type(argname="argument network", value=network, expected_type=type_hints["network"])
            check_type(argname="argument networking_mode", value=networking_mode, expected_type=type_hints["networking_mode"])
            check_type(argname="argument network_performance_config", value=network_performance_config, expected_type=type_hints["network_performance_config"])
            check_type(argname="argument network_policy", value=network_policy, expected_type=type_hints["network_policy"])
            check_type(argname="argument node_config", value=node_config, expected_type=type_hints["node_config"])
            check_type(argname="argument node_locations", value=node_locations, expected_type=type_hints["node_locations"])
            check_type(argname="argument node_pool", value=node_pool, expected_type=type_hints["node_pool"])
            check_type(argname="argument node_pool_auto_config", value=node_pool_auto_config, expected_type=type_hints["node_pool_auto_config"])
            check_type(argname="argument node_pool_defaults", value=node_pool_defaults, expected_type=type_hints["node_pool_defaults"])
            check_type(argname="argument node_version", value=node_version, expected_type=type_hints["node_version"])
            check_type(argname="argument notification_config", value=notification_config, expected_type=type_hints["notification_config"])
            check_type(argname="argument pod_autoscaling", value=pod_autoscaling, expected_type=type_hints["pod_autoscaling"])
            check_type(argname="argument private_cluster_config", value=private_cluster_config, expected_type=type_hints["private_cluster_config"])
            check_type(argname="argument private_ipv6_google_access", value=private_ipv6_google_access, expected_type=type_hints["private_ipv6_google_access"])
            check_type(argname="argument project", value=project, expected_type=type_hints["project"])
            check_type(argname="argument rbac_binding_config", value=rbac_binding_config, expected_type=type_hints["rbac_binding_config"])
            check_type(argname="argument release_channel", value=release_channel, expected_type=type_hints["release_channel"])
            check_type(argname="argument remove_default_node_pool", value=remove_default_node_pool, expected_type=type_hints["remove_default_node_pool"])
            check_type(argname="argument resource_labels", value=resource_labels, expected_type=type_hints["resource_labels"])
            check_type(argname="argument resource_usage_export_config", value=resource_usage_export_config, expected_type=type_hints["resource_usage_export_config"])
            check_type(argname="argument secret_manager_config", value=secret_manager_config, expected_type=type_hints["secret_manager_config"])
            check_type(argname="argument security_posture_config", value=security_posture_config, expected_type=type_hints["security_posture_config"])
            check_type(argname="argument service_external_ips_config", value=service_external_ips_config, expected_type=type_hints["service_external_ips_config"])
            check_type(argname="argument subnetwork", value=subnetwork, expected_type=type_hints["subnetwork"])
            check_type(argname="argument timeouts", value=timeouts, expected_type=type_hints["timeouts"])
            check_type(argname="argument user_managed_keys_config", value=user_managed_keys_config, expected_type=type_hints["user_managed_keys_config"])
            check_type(argname="argument vertical_pod_autoscaling", value=vertical_pod_autoscaling, expected_type=type_hints["vertical_pod_autoscaling"])
            check_type(argname="argument workload_identity_config", value=workload_identity_config, expected_type=type_hints["workload_identity_config"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if connection is not None:
            self._values["connection"] = connection
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if for_each is not None:
            self._values["for_each"] = for_each
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if provisioners is not None:
            self._values["provisioners"] = provisioners
        if addons_config is not None:
            self._values["addons_config"] = addons_config
        if allow_net_admin is not None:
            self._values["allow_net_admin"] = allow_net_admin
        if anonymous_authentication_config is not None:
            self._values["anonymous_authentication_config"] = anonymous_authentication_config
        if authenticator_groups_config is not None:
            self._values["authenticator_groups_config"] = authenticator_groups_config
        if binary_authorization is not None:
            self._values["binary_authorization"] = binary_authorization
        if cluster_autoscaling is not None:
            self._values["cluster_autoscaling"] = cluster_autoscaling
        if cluster_ipv4_cidr is not None:
            self._values["cluster_ipv4_cidr"] = cluster_ipv4_cidr
        if confidential_nodes is not None:
            self._values["confidential_nodes"] = confidential_nodes
        if control_plane_endpoints_config is not None:
            self._values["control_plane_endpoints_config"] = control_plane_endpoints_config
        if cost_management_config is not None:
            self._values["cost_management_config"] = cost_management_config
        if database_encryption is not None:
            self._values["database_encryption"] = database_encryption
        if datapath_provider is not None:
            self._values["datapath_provider"] = datapath_provider
        if default_max_pods_per_node is not None:
            self._values["default_max_pods_per_node"] = default_max_pods_per_node
        if default_snat_status is not None:
            self._values["default_snat_status"] = default_snat_status
        if deletion_protection is not None:
            self._values["deletion_protection"] = deletion_protection
        if description is not None:
            self._values["description"] = description
        if disable_l4_lb_firewall_reconciliation is not None:
            self._values["disable_l4_lb_firewall_reconciliation"] = disable_l4_lb_firewall_reconciliation
        if dns_config is not None:
            self._values["dns_config"] = dns_config
        if enable_autopilot is not None:
            self._values["enable_autopilot"] = enable_autopilot
        if enable_cilium_clusterwide_network_policy is not None:
            self._values["enable_cilium_clusterwide_network_policy"] = enable_cilium_clusterwide_network_policy
        if enable_fqdn_network_policy is not None:
            self._values["enable_fqdn_network_policy"] = enable_fqdn_network_policy
        if enable_intranode_visibility is not None:
            self._values["enable_intranode_visibility"] = enable_intranode_visibility
        if enable_k8_s_beta_apis is not None:
            self._values["enable_k8_s_beta_apis"] = enable_k8_s_beta_apis
        if enable_kubernetes_alpha is not None:
            self._values["enable_kubernetes_alpha"] = enable_kubernetes_alpha
        if enable_l4_ilb_subsetting is not None:
            self._values["enable_l4_ilb_subsetting"] = enable_l4_ilb_subsetting
        if enable_legacy_abac is not None:
            self._values["enable_legacy_abac"] = enable_legacy_abac
        if enable_multi_networking is not None:
            self._values["enable_multi_networking"] = enable_multi_networking
        if enable_shielded_nodes is not None:
            self._values["enable_shielded_nodes"] = enable_shielded_nodes
        if enable_tpu is not None:
            self._values["enable_tpu"] = enable_tpu
        if enterprise_config is not None:
            self._values["enterprise_config"] = enterprise_config
        if fleet is not None:
            self._values["fleet"] = fleet
        if gateway_api_config is not None:
            self._values["gateway_api_config"] = gateway_api_config
        if gke_auto_upgrade_config is not None:
            self._values["gke_auto_upgrade_config"] = gke_auto_upgrade_config
        if id is not None:
            self._values["id"] = id
        if identity_service_config is not None:
            self._values["identity_service_config"] = identity_service_config
        if initial_node_count is not None:
            self._values["initial_node_count"] = initial_node_count
        if in_transit_encryption_config is not None:
            self._values["in_transit_encryption_config"] = in_transit_encryption_config
        if ip_allocation_policy is not None:
            self._values["ip_allocation_policy"] = ip_allocation_policy
        if location is not None:
            self._values["location"] = location
        if logging_config is not None:
            self._values["logging_config"] = logging_config
        if logging_service is not None:
            self._values["logging_service"] = logging_service
        if maintenance_policy is not None:
            self._values["maintenance_policy"] = maintenance_policy
        if master_auth is not None:
            self._values["master_auth"] = master_auth
        if master_authorized_networks_config is not None:
            self._values["master_authorized_networks_config"] = master_authorized_networks_config
        if mesh_certificates is not None:
            self._values["mesh_certificates"] = mesh_certificates
        if min_master_version is not None:
            self._values["min_master_version"] = min_master_version
        if monitoring_config is not None:
            self._values["monitoring_config"] = monitoring_config
        if monitoring_service is not None:
            self._values["monitoring_service"] = monitoring_service
        if network is not None:
            self._values["network"] = network
        if networking_mode is not None:
            self._values["networking_mode"] = networking_mode
        if network_performance_config is not None:
            self._values["network_performance_config"] = network_performance_config
        if network_policy is not None:
            self._values["network_policy"] = network_policy
        if node_config is not None:
            self._values["node_config"] = node_config
        if node_locations is not None:
            self._values["node_locations"] = node_locations
        if node_pool is not None:
            self._values["node_pool"] = node_pool
        if node_pool_auto_config is not None:
            self._values["node_pool_auto_config"] = node_pool_auto_config
        if node_pool_defaults is not None:
            self._values["node_pool_defaults"] = node_pool_defaults
        if node_version is not None:
            self._values["node_version"] = node_version
        if notification_config is not None:
            self._values["notification_config"] = notification_config
        if pod_autoscaling is not None:
            self._values["pod_autoscaling"] = pod_autoscaling
        if private_cluster_config is not None:
            self._values["private_cluster_config"] = private_cluster_config
        if private_ipv6_google_access is not None:
            self._values["private_ipv6_google_access"] = private_ipv6_google_access
        if project is not None:
            self._values["project"] = project
        if rbac_binding_config is not None:
            self._values["rbac_binding_config"] = rbac_binding_config
        if release_channel is not None:
            self._values["release_channel"] = release_channel
        if remove_default_node_pool is not None:
            self._values["remove_default_node_pool"] = remove_default_node_pool
        if resource_labels is not None:
            self._values["resource_labels"] = resource_labels
        if resource_usage_export_config is not None:
            self._values["resource_usage_export_config"] = resource_usage_export_config
        if secret_manager_config is not None:
            self._values["secret_manager_config"] = secret_manager_config
        if security_posture_config is not None:
            self._values["security_posture_config"] = security_posture_config
        if service_external_ips_config is not None:
            self._values["service_external_ips_config"] = service_external_ips_config
        if subnetwork is not None:
            self._values["subnetwork"] = subnetwork
        if timeouts is not None:
            self._values["timeouts"] = timeouts
        if user_managed_keys_config is not None:
            self._values["user_managed_keys_config"] = user_managed_keys_config
        if vertical_pod_autoscaling is not None:
            self._values["vertical_pod_autoscaling"] = vertical_pod_autoscaling
        if workload_identity_config is not None:
            self._values["workload_identity_config"] = workload_identity_config

    @builtins.property
    def connection(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("connection")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]], result)

    @builtins.property
    def count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]], result)

    @builtins.property
    def depends_on(
        self,
    ) -> typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]], result)

    @builtins.property
    def for_each(self) -> typing.Optional[_cdktf_9a9027ec.ITerraformIterator]:
        '''
        :stability: experimental
        '''
        result = self._values.get("for_each")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.ITerraformIterator], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[_cdktf_9a9027ec.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformProvider], result)

    @builtins.property
    def provisioners(
        self,
    ) -> typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provisioners")
        return typing.cast(typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]], result)

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the cluster, unique within the project and location.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#name ContainerCluster#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def addons_config(self) -> typing.Optional[ContainerClusterAddonsConfig]:
        '''addons_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#addons_config ContainerCluster#addons_config}
        '''
        result = self._values.get("addons_config")
        return typing.cast(typing.Optional[ContainerClusterAddonsConfig], result)

    @builtins.property
    def allow_net_admin(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Enable NET_ADMIN for this cluster.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#allow_net_admin ContainerCluster#allow_net_admin}
        '''
        result = self._values.get("allow_net_admin")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def anonymous_authentication_config(
        self,
    ) -> typing.Optional[ContainerClusterAnonymousAuthenticationConfig]:
        '''anonymous_authentication_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#anonymous_authentication_config ContainerCluster#anonymous_authentication_config}
        '''
        result = self._values.get("anonymous_authentication_config")
        return typing.cast(typing.Optional[ContainerClusterAnonymousAuthenticationConfig], result)

    @builtins.property
    def authenticator_groups_config(
        self,
    ) -> typing.Optional[ContainerClusterAuthenticatorGroupsConfig]:
        '''authenticator_groups_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#authenticator_groups_config ContainerCluster#authenticator_groups_config}
        '''
        result = self._values.get("authenticator_groups_config")
        return typing.cast(typing.Optional[ContainerClusterAuthenticatorGroupsConfig], result)

    @builtins.property
    def binary_authorization(
        self,
    ) -> typing.Optional[ContainerClusterBinaryAuthorization]:
        '''binary_authorization block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#binary_authorization ContainerCluster#binary_authorization}
        '''
        result = self._values.get("binary_authorization")
        return typing.cast(typing.Optional[ContainerClusterBinaryAuthorization], result)

    @builtins.property
    def cluster_autoscaling(
        self,
    ) -> typing.Optional[ContainerClusterClusterAutoscaling]:
        '''cluster_autoscaling block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cluster_autoscaling ContainerCluster#cluster_autoscaling}
        '''
        result = self._values.get("cluster_autoscaling")
        return typing.cast(typing.Optional[ContainerClusterClusterAutoscaling], result)

    @builtins.property
    def cluster_ipv4_cidr(self) -> typing.Optional[builtins.str]:
        '''The IP address range of the Kubernetes pods in this cluster in CIDR notation (e.g. 10.96.0.0/14). Leave blank to have one automatically chosen or specify a /14 block in 10.0.0.0/8. This field will only work for routes-based clusters, where ip_allocation_policy is not defined.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cluster_ipv4_cidr ContainerCluster#cluster_ipv4_cidr}
        '''
        result = self._values.get("cluster_ipv4_cidr")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def confidential_nodes(self) -> typing.Optional[ContainerClusterConfidentialNodes]:
        '''confidential_nodes block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#confidential_nodes ContainerCluster#confidential_nodes}
        '''
        result = self._values.get("confidential_nodes")
        return typing.cast(typing.Optional[ContainerClusterConfidentialNodes], result)

    @builtins.property
    def control_plane_endpoints_config(
        self,
    ) -> typing.Optional["ContainerClusterControlPlaneEndpointsConfig"]:
        '''control_plane_endpoints_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#control_plane_endpoints_config ContainerCluster#control_plane_endpoints_config}
        '''
        result = self._values.get("control_plane_endpoints_config")
        return typing.cast(typing.Optional["ContainerClusterControlPlaneEndpointsConfig"], result)

    @builtins.property
    def cost_management_config(
        self,
    ) -> typing.Optional["ContainerClusterCostManagementConfig"]:
        '''cost_management_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cost_management_config ContainerCluster#cost_management_config}
        '''
        result = self._values.get("cost_management_config")
        return typing.cast(typing.Optional["ContainerClusterCostManagementConfig"], result)

    @builtins.property
    def database_encryption(
        self,
    ) -> typing.Optional["ContainerClusterDatabaseEncryption"]:
        '''database_encryption block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#database_encryption ContainerCluster#database_encryption}
        '''
        result = self._values.get("database_encryption")
        return typing.cast(typing.Optional["ContainerClusterDatabaseEncryption"], result)

    @builtins.property
    def datapath_provider(self) -> typing.Optional[builtins.str]:
        '''The desired datapath provider for this cluster. By default, uses the IPTables-based kube-proxy implementation.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#datapath_provider ContainerCluster#datapath_provider}
        '''
        result = self._values.get("datapath_provider")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def default_max_pods_per_node(self) -> typing.Optional[jsii.Number]:
        '''The default maximum number of pods per node in this cluster.

        This doesn't work on "routes-based" clusters, clusters that don't have IP Aliasing enabled.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#default_max_pods_per_node ContainerCluster#default_max_pods_per_node}
        '''
        result = self._values.get("default_max_pods_per_node")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def default_snat_status(
        self,
    ) -> typing.Optional["ContainerClusterDefaultSnatStatus"]:
        '''default_snat_status block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#default_snat_status ContainerCluster#default_snat_status}
        '''
        result = self._values.get("default_snat_status")
        return typing.cast(typing.Optional["ContainerClusterDefaultSnatStatus"], result)

    @builtins.property
    def deletion_protection(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''When the field is set to true or unset in Terraform state, a terraform apply or terraform destroy that would delete the cluster will fail.

        When the field is set to false, deleting the cluster is allowed.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#deletion_protection ContainerCluster#deletion_protection}
        '''
        result = self._values.get("deletion_protection")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''Description of the cluster.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#description ContainerCluster#description}
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def disable_l4_lb_firewall_reconciliation(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Disable L4 load balancer VPC firewalls to enable firewall policies.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#disable_l4_lb_firewall_reconciliation ContainerCluster#disable_l4_lb_firewall_reconciliation}
        '''
        result = self._values.get("disable_l4_lb_firewall_reconciliation")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def dns_config(self) -> typing.Optional["ContainerClusterDnsConfig"]:
        '''dns_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#dns_config ContainerCluster#dns_config}
        '''
        result = self._values.get("dns_config")
        return typing.cast(typing.Optional["ContainerClusterDnsConfig"], result)

    @builtins.property
    def enable_autopilot(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Enable Autopilot for this cluster.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_autopilot ContainerCluster#enable_autopilot}
        '''
        result = self._values.get("enable_autopilot")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def enable_cilium_clusterwide_network_policy(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Whether Cilium cluster-wide network policy is enabled on this cluster.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_cilium_clusterwide_network_policy ContainerCluster#enable_cilium_clusterwide_network_policy}
        '''
        result = self._values.get("enable_cilium_clusterwide_network_policy")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def enable_fqdn_network_policy(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Whether FQDN Network Policy is enabled on this cluster.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_fqdn_network_policy ContainerCluster#enable_fqdn_network_policy}
        '''
        result = self._values.get("enable_fqdn_network_policy")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def enable_intranode_visibility(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Whether Intra-node visibility is enabled for this cluster.

        This makes same node pod to pod traffic visible for VPC network.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_intranode_visibility ContainerCluster#enable_intranode_visibility}
        '''
        result = self._values.get("enable_intranode_visibility")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def enable_k8_s_beta_apis(
        self,
    ) -> typing.Optional["ContainerClusterEnableK8SBetaApis"]:
        '''enable_k8s_beta_apis block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_k8s_beta_apis ContainerCluster#enable_k8s_beta_apis}
        '''
        result = self._values.get("enable_k8_s_beta_apis")
        return typing.cast(typing.Optional["ContainerClusterEnableK8SBetaApis"], result)

    @builtins.property
    def enable_kubernetes_alpha(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Whether to enable Kubernetes Alpha features for this cluster.

        Note that when this option is enabled, the cluster cannot be upgraded and will be automatically deleted after 30 days.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_kubernetes_alpha ContainerCluster#enable_kubernetes_alpha}
        '''
        result = self._values.get("enable_kubernetes_alpha")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def enable_l4_ilb_subsetting(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Whether L4ILB Subsetting is enabled for this cluster.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_l4_ilb_subsetting ContainerCluster#enable_l4_ilb_subsetting}
        '''
        result = self._values.get("enable_l4_ilb_subsetting")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def enable_legacy_abac(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Whether the ABAC authorizer is enabled for this cluster.

        When enabled, identities in the system, including service accounts, nodes, and controllers, will have statically granted permissions beyond those provided by the RBAC configuration or IAM. Defaults to false.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_legacy_abac ContainerCluster#enable_legacy_abac}
        '''
        result = self._values.get("enable_legacy_abac")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def enable_multi_networking(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Whether multi-networking is enabled for this cluster.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_multi_networking ContainerCluster#enable_multi_networking}
        '''
        result = self._values.get("enable_multi_networking")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def enable_shielded_nodes(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Enable Shielded Nodes features on all nodes in this cluster. Defaults to true.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_shielded_nodes ContainerCluster#enable_shielded_nodes}
        '''
        result = self._values.get("enable_shielded_nodes")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def enable_tpu(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Whether to enable Cloud TPU resources in this cluster.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_tpu ContainerCluster#enable_tpu}
        '''
        result = self._values.get("enable_tpu")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def enterprise_config(self) -> typing.Optional["ContainerClusterEnterpriseConfig"]:
        '''enterprise_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enterprise_config ContainerCluster#enterprise_config}
        '''
        result = self._values.get("enterprise_config")
        return typing.cast(typing.Optional["ContainerClusterEnterpriseConfig"], result)

    @builtins.property
    def fleet(self) -> typing.Optional["ContainerClusterFleet"]:
        '''fleet block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#fleet ContainerCluster#fleet}
        '''
        result = self._values.get("fleet")
        return typing.cast(typing.Optional["ContainerClusterFleet"], result)

    @builtins.property
    def gateway_api_config(self) -> typing.Optional["ContainerClusterGatewayApiConfig"]:
        '''gateway_api_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gateway_api_config ContainerCluster#gateway_api_config}
        '''
        result = self._values.get("gateway_api_config")
        return typing.cast(typing.Optional["ContainerClusterGatewayApiConfig"], result)

    @builtins.property
    def gke_auto_upgrade_config(
        self,
    ) -> typing.Optional["ContainerClusterGkeAutoUpgradeConfig"]:
        '''gke_auto_upgrade_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gke_auto_upgrade_config ContainerCluster#gke_auto_upgrade_config}
        '''
        result = self._values.get("gke_auto_upgrade_config")
        return typing.cast(typing.Optional["ContainerClusterGkeAutoUpgradeConfig"], result)

    @builtins.property
    def id(self) -> typing.Optional[builtins.str]:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#id ContainerCluster#id}.

        Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
        If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
        '''
        result = self._values.get("id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def identity_service_config(
        self,
    ) -> typing.Optional["ContainerClusterIdentityServiceConfig"]:
        '''identity_service_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#identity_service_config ContainerCluster#identity_service_config}
        '''
        result = self._values.get("identity_service_config")
        return typing.cast(typing.Optional["ContainerClusterIdentityServiceConfig"], result)

    @builtins.property
    def initial_node_count(self) -> typing.Optional[jsii.Number]:
        '''The number of nodes to create in this cluster's default node pool.

        In regional or multi-zonal clusters, this is the number of nodes per zone. Must be set if node_pool is not set. If you're using google_container_node_pool objects with no default node pool, you'll need to set this to a value of at least 1, alongside setting remove_default_node_pool to true.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#initial_node_count ContainerCluster#initial_node_count}
        '''
        result = self._values.get("initial_node_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def in_transit_encryption_config(self) -> typing.Optional[builtins.str]:
        '''Defines the config of in-transit encryption.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#in_transit_encryption_config ContainerCluster#in_transit_encryption_config}
        '''
        result = self._values.get("in_transit_encryption_config")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ip_allocation_policy(
        self,
    ) -> typing.Optional["ContainerClusterIpAllocationPolicy"]:
        '''ip_allocation_policy block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#ip_allocation_policy ContainerCluster#ip_allocation_policy}
        '''
        result = self._values.get("ip_allocation_policy")
        return typing.cast(typing.Optional["ContainerClusterIpAllocationPolicy"], result)

    @builtins.property
    def location(self) -> typing.Optional[builtins.str]:
        '''The location (region or zone) in which the cluster master will be created, as well as the default node location.

        If you specify a zone (such as us-central1-a), the cluster will be a zonal cluster with a single cluster master. If you specify a region (such as us-west1), the cluster will be a regional cluster with multiple masters spread across zones in the region, and with default node locations in those zones as well.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#location ContainerCluster#location}
        '''
        result = self._values.get("location")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def logging_config(self) -> typing.Optional["ContainerClusterLoggingConfig"]:
        '''logging_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#logging_config ContainerCluster#logging_config}
        '''
        result = self._values.get("logging_config")
        return typing.cast(typing.Optional["ContainerClusterLoggingConfig"], result)

    @builtins.property
    def logging_service(self) -> typing.Optional[builtins.str]:
        '''The logging service that the cluster should write logs to.

        Available options include logging.googleapis.com(Legacy Stackdriver), logging.googleapis.com/kubernetes(Stackdriver Kubernetes Engine Logging), and none. Defaults to logging.googleapis.com/kubernetes.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#logging_service ContainerCluster#logging_service}
        '''
        result = self._values.get("logging_service")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def maintenance_policy(
        self,
    ) -> typing.Optional["ContainerClusterMaintenancePolicy"]:
        '''maintenance_policy block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#maintenance_policy ContainerCluster#maintenance_policy}
        '''
        result = self._values.get("maintenance_policy")
        return typing.cast(typing.Optional["ContainerClusterMaintenancePolicy"], result)

    @builtins.property
    def master_auth(self) -> typing.Optional["ContainerClusterMasterAuth"]:
        '''master_auth block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#master_auth ContainerCluster#master_auth}
        '''
        result = self._values.get("master_auth")
        return typing.cast(typing.Optional["ContainerClusterMasterAuth"], result)

    @builtins.property
    def master_authorized_networks_config(
        self,
    ) -> typing.Optional["ContainerClusterMasterAuthorizedNetworksConfig"]:
        '''master_authorized_networks_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#master_authorized_networks_config ContainerCluster#master_authorized_networks_config}
        '''
        result = self._values.get("master_authorized_networks_config")
        return typing.cast(typing.Optional["ContainerClusterMasterAuthorizedNetworksConfig"], result)

    @builtins.property
    def mesh_certificates(self) -> typing.Optional["ContainerClusterMeshCertificates"]:
        '''mesh_certificates block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#mesh_certificates ContainerCluster#mesh_certificates}
        '''
        result = self._values.get("mesh_certificates")
        return typing.cast(typing.Optional["ContainerClusterMeshCertificates"], result)

    @builtins.property
    def min_master_version(self) -> typing.Optional[builtins.str]:
        '''The minimum version of the master.

        GKE will auto-update the master to new versions, so this does not guarantee the current master version--use the read-only master_version field to obtain that. If unset, the cluster's version will be set by GKE to the version of the most recent official release (which is not necessarily the latest version).

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#min_master_version ContainerCluster#min_master_version}
        '''
        result = self._values.get("min_master_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def monitoring_config(self) -> typing.Optional["ContainerClusterMonitoringConfig"]:
        '''monitoring_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#monitoring_config ContainerCluster#monitoring_config}
        '''
        result = self._values.get("monitoring_config")
        return typing.cast(typing.Optional["ContainerClusterMonitoringConfig"], result)

    @builtins.property
    def monitoring_service(self) -> typing.Optional[builtins.str]:
        '''The monitoring service that the cluster should write metrics to.

        Automatically send metrics from pods in the cluster to the Google Cloud Monitoring API. VM metrics will be collected by Google Compute Engine regardless of this setting Available options include monitoring.googleapis.com(Legacy Stackdriver), monitoring.googleapis.com/kubernetes(Stackdriver Kubernetes Engine Monitoring), and none. Defaults to monitoring.googleapis.com/kubernetes.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#monitoring_service ContainerCluster#monitoring_service}
        '''
        result = self._values.get("monitoring_service")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def network(self) -> typing.Optional[builtins.str]:
        '''The name or self_link of the Google Compute Engine network to which the cluster is connected.

        For Shared VPC, set this to the self link of the shared network.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#network ContainerCluster#network}
        '''
        result = self._values.get("network")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def networking_mode(self) -> typing.Optional[builtins.str]:
        '''Determines whether alias IPs or routes will be used for pod IPs in the cluster.

        Defaults to VPC_NATIVE for new clusters.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#networking_mode ContainerCluster#networking_mode}
        '''
        result = self._values.get("networking_mode")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def network_performance_config(
        self,
    ) -> typing.Optional["ContainerClusterNetworkPerformanceConfig"]:
        '''network_performance_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#network_performance_config ContainerCluster#network_performance_config}
        '''
        result = self._values.get("network_performance_config")
        return typing.cast(typing.Optional["ContainerClusterNetworkPerformanceConfig"], result)

    @builtins.property
    def network_policy(self) -> typing.Optional["ContainerClusterNetworkPolicy"]:
        '''network_policy block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#network_policy ContainerCluster#network_policy}
        '''
        result = self._values.get("network_policy")
        return typing.cast(typing.Optional["ContainerClusterNetworkPolicy"], result)

    @builtins.property
    def node_config(self) -> typing.Optional["ContainerClusterNodeConfig"]:
        '''node_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#node_config ContainerCluster#node_config}
        '''
        result = self._values.get("node_config")
        return typing.cast(typing.Optional["ContainerClusterNodeConfig"], result)

    @builtins.property
    def node_locations(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The list of zones in which the cluster's nodes are located.

        Nodes must be in the region of their regional cluster or in the same region as their cluster's zone for zonal clusters. If this is specified for a zonal cluster, omit the cluster's zone.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#node_locations ContainerCluster#node_locations}
        '''
        result = self._values.get("node_locations")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def node_pool(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ContainerClusterNodePool"]]]:
        '''node_pool block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#node_pool ContainerCluster#node_pool}
        '''
        result = self._values.get("node_pool")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ContainerClusterNodePool"]]], result)

    @builtins.property
    def node_pool_auto_config(
        self,
    ) -> typing.Optional["ContainerClusterNodePoolAutoConfig"]:
        '''node_pool_auto_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#node_pool_auto_config ContainerCluster#node_pool_auto_config}
        '''
        result = self._values.get("node_pool_auto_config")
        return typing.cast(typing.Optional["ContainerClusterNodePoolAutoConfig"], result)

    @builtins.property
    def node_pool_defaults(self) -> typing.Optional["ContainerClusterNodePoolDefaults"]:
        '''node_pool_defaults block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#node_pool_defaults ContainerCluster#node_pool_defaults}
        '''
        result = self._values.get("node_pool_defaults")
        return typing.cast(typing.Optional["ContainerClusterNodePoolDefaults"], result)

    @builtins.property
    def node_version(self) -> typing.Optional[builtins.str]:
        '''The Kubernetes version on the nodes.

        Must either be unset or set to the same value as min_master_version on create. Defaults to the default version set by GKE which is not necessarily the latest version. This only affects nodes in the default node pool. While a fuzzy version can be specified, it's recommended that you specify explicit versions as Terraform will see spurious diffs when fuzzy versions are used. See the google_container_engine_versions data source's version_prefix field to approximate fuzzy versions in a Terraform-compatible way. To update nodes in other node pools, use the version attribute on the node pool.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#node_version ContainerCluster#node_version}
        '''
        result = self._values.get("node_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def notification_config(
        self,
    ) -> typing.Optional["ContainerClusterNotificationConfig"]:
        '''notification_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#notification_config ContainerCluster#notification_config}
        '''
        result = self._values.get("notification_config")
        return typing.cast(typing.Optional["ContainerClusterNotificationConfig"], result)

    @builtins.property
    def pod_autoscaling(self) -> typing.Optional["ContainerClusterPodAutoscaling"]:
        '''pod_autoscaling block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#pod_autoscaling ContainerCluster#pod_autoscaling}
        '''
        result = self._values.get("pod_autoscaling")
        return typing.cast(typing.Optional["ContainerClusterPodAutoscaling"], result)

    @builtins.property
    def private_cluster_config(
        self,
    ) -> typing.Optional["ContainerClusterPrivateClusterConfig"]:
        '''private_cluster_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#private_cluster_config ContainerCluster#private_cluster_config}
        '''
        result = self._values.get("private_cluster_config")
        return typing.cast(typing.Optional["ContainerClusterPrivateClusterConfig"], result)

    @builtins.property
    def private_ipv6_google_access(self) -> typing.Optional[builtins.str]:
        '''The desired state of IPv6 connectivity to Google Services.

        By default, no private IPv6 access to or from Google Services (all access will be via IPv4).

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#private_ipv6_google_access ContainerCluster#private_ipv6_google_access}
        '''
        result = self._values.get("private_ipv6_google_access")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def project(self) -> typing.Optional[builtins.str]:
        '''The ID of the project in which the resource belongs.

        If it is not provided, the provider project is used.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#project ContainerCluster#project}
        '''
        result = self._values.get("project")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def rbac_binding_config(
        self,
    ) -> typing.Optional["ContainerClusterRbacBindingConfig"]:
        '''rbac_binding_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#rbac_binding_config ContainerCluster#rbac_binding_config}
        '''
        result = self._values.get("rbac_binding_config")
        return typing.cast(typing.Optional["ContainerClusterRbacBindingConfig"], result)

    @builtins.property
    def release_channel(self) -> typing.Optional["ContainerClusterReleaseChannel"]:
        '''release_channel block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#release_channel ContainerCluster#release_channel}
        '''
        result = self._values.get("release_channel")
        return typing.cast(typing.Optional["ContainerClusterReleaseChannel"], result)

    @builtins.property
    def remove_default_node_pool(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''If true, deletes the default node pool upon cluster creation.

        If you're using google_container_node_pool resources with no default node pool, this should be set to true, alongside setting initial_node_count to at least 1.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#remove_default_node_pool ContainerCluster#remove_default_node_pool}
        '''
        result = self._values.get("remove_default_node_pool")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def resource_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''The GCE resource labels (a map of key/value pairs) to be applied to the cluster.

        **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
        Please refer to the field 'effective_labels' for all of the labels present on the resource.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#resource_labels ContainerCluster#resource_labels}
        '''
        result = self._values.get("resource_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def resource_usage_export_config(
        self,
    ) -> typing.Optional["ContainerClusterResourceUsageExportConfig"]:
        '''resource_usage_export_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#resource_usage_export_config ContainerCluster#resource_usage_export_config}
        '''
        result = self._values.get("resource_usage_export_config")
        return typing.cast(typing.Optional["ContainerClusterResourceUsageExportConfig"], result)

    @builtins.property
    def secret_manager_config(
        self,
    ) -> typing.Optional["ContainerClusterSecretManagerConfig"]:
        '''secret_manager_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#secret_manager_config ContainerCluster#secret_manager_config}
        '''
        result = self._values.get("secret_manager_config")
        return typing.cast(typing.Optional["ContainerClusterSecretManagerConfig"], result)

    @builtins.property
    def security_posture_config(
        self,
    ) -> typing.Optional["ContainerClusterSecurityPostureConfig"]:
        '''security_posture_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#security_posture_config ContainerCluster#security_posture_config}
        '''
        result = self._values.get("security_posture_config")
        return typing.cast(typing.Optional["ContainerClusterSecurityPostureConfig"], result)

    @builtins.property
    def service_external_ips_config(
        self,
    ) -> typing.Optional["ContainerClusterServiceExternalIpsConfig"]:
        '''service_external_ips_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#service_external_ips_config ContainerCluster#service_external_ips_config}
        '''
        result = self._values.get("service_external_ips_config")
        return typing.cast(typing.Optional["ContainerClusterServiceExternalIpsConfig"], result)

    @builtins.property
    def subnetwork(self) -> typing.Optional[builtins.str]:
        '''The name or self_link of the Google Compute Engine subnetwork in which the cluster's instances are launched.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#subnetwork ContainerCluster#subnetwork}
        '''
        result = self._values.get("subnetwork")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def timeouts(self) -> typing.Optional["ContainerClusterTimeouts"]:
        '''timeouts block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#timeouts ContainerCluster#timeouts}
        '''
        result = self._values.get("timeouts")
        return typing.cast(typing.Optional["ContainerClusterTimeouts"], result)

    @builtins.property
    def user_managed_keys_config(
        self,
    ) -> typing.Optional["ContainerClusterUserManagedKeysConfig"]:
        '''user_managed_keys_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#user_managed_keys_config ContainerCluster#user_managed_keys_config}
        '''
        result = self._values.get("user_managed_keys_config")
        return typing.cast(typing.Optional["ContainerClusterUserManagedKeysConfig"], result)

    @builtins.property
    def vertical_pod_autoscaling(
        self,
    ) -> typing.Optional["ContainerClusterVerticalPodAutoscaling"]:
        '''vertical_pod_autoscaling block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#vertical_pod_autoscaling ContainerCluster#vertical_pod_autoscaling}
        '''
        result = self._values.get("vertical_pod_autoscaling")
        return typing.cast(typing.Optional["ContainerClusterVerticalPodAutoscaling"], result)

    @builtins.property
    def workload_identity_config(
        self,
    ) -> typing.Optional["ContainerClusterWorkloadIdentityConfig"]:
        '''workload_identity_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#workload_identity_config ContainerCluster#workload_identity_config}
        '''
        result = self._values.get("workload_identity_config")
        return typing.cast(typing.Optional["ContainerClusterWorkloadIdentityConfig"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterControlPlaneEndpointsConfig",
    jsii_struct_bases=[],
    name_mapping={
        "dns_endpoint_config": "dnsEndpointConfig",
        "ip_endpoints_config": "ipEndpointsConfig",
    },
)
class ContainerClusterControlPlaneEndpointsConfig:
    def __init__(
        self,
        *,
        dns_endpoint_config: typing.Optional[typing.Union["ContainerClusterControlPlaneEndpointsConfigDnsEndpointConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        ip_endpoints_config: typing.Optional[typing.Union["ContainerClusterControlPlaneEndpointsConfigIpEndpointsConfig", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param dns_endpoint_config: dns_endpoint_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#dns_endpoint_config ContainerCluster#dns_endpoint_config}
        :param ip_endpoints_config: ip_endpoints_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#ip_endpoints_config ContainerCluster#ip_endpoints_config}
        '''
        if isinstance(dns_endpoint_config, dict):
            dns_endpoint_config = ContainerClusterControlPlaneEndpointsConfigDnsEndpointConfig(**dns_endpoint_config)
        if isinstance(ip_endpoints_config, dict):
            ip_endpoints_config = ContainerClusterControlPlaneEndpointsConfigIpEndpointsConfig(**ip_endpoints_config)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e1269be8ac94e1b6299362e60b3b6e57091417b4f53d3adc695280904e400913)
            check_type(argname="argument dns_endpoint_config", value=dns_endpoint_config, expected_type=type_hints["dns_endpoint_config"])
            check_type(argname="argument ip_endpoints_config", value=ip_endpoints_config, expected_type=type_hints["ip_endpoints_config"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if dns_endpoint_config is not None:
            self._values["dns_endpoint_config"] = dns_endpoint_config
        if ip_endpoints_config is not None:
            self._values["ip_endpoints_config"] = ip_endpoints_config

    @builtins.property
    def dns_endpoint_config(
        self,
    ) -> typing.Optional["ContainerClusterControlPlaneEndpointsConfigDnsEndpointConfig"]:
        '''dns_endpoint_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#dns_endpoint_config ContainerCluster#dns_endpoint_config}
        '''
        result = self._values.get("dns_endpoint_config")
        return typing.cast(typing.Optional["ContainerClusterControlPlaneEndpointsConfigDnsEndpointConfig"], result)

    @builtins.property
    def ip_endpoints_config(
        self,
    ) -> typing.Optional["ContainerClusterControlPlaneEndpointsConfigIpEndpointsConfig"]:
        '''ip_endpoints_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#ip_endpoints_config ContainerCluster#ip_endpoints_config}
        '''
        result = self._values.get("ip_endpoints_config")
        return typing.cast(typing.Optional["ContainerClusterControlPlaneEndpointsConfigIpEndpointsConfig"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterControlPlaneEndpointsConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterControlPlaneEndpointsConfigDnsEndpointConfig",
    jsii_struct_bases=[],
    name_mapping={
        "allow_external_traffic": "allowExternalTraffic",
        "endpoint": "endpoint",
    },
)
class ContainerClusterControlPlaneEndpointsConfigDnsEndpointConfig:
    def __init__(
        self,
        *,
        allow_external_traffic: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        endpoint: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param allow_external_traffic: Controls whether user traffic is allowed over this endpoint. Note that GCP-managed services may still use the endpoint even if this is false. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#allow_external_traffic ContainerCluster#allow_external_traffic}
        :param endpoint: The cluster's DNS endpoint. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#endpoint ContainerCluster#endpoint}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a769311967206be50968be9e800cf5dfe36b48ff96dc22fbb9d552b83e336576)
            check_type(argname="argument allow_external_traffic", value=allow_external_traffic, expected_type=type_hints["allow_external_traffic"])
            check_type(argname="argument endpoint", value=endpoint, expected_type=type_hints["endpoint"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if allow_external_traffic is not None:
            self._values["allow_external_traffic"] = allow_external_traffic
        if endpoint is not None:
            self._values["endpoint"] = endpoint

    @builtins.property
    def allow_external_traffic(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Controls whether user traffic is allowed over this endpoint.

        Note that GCP-managed services may still use the endpoint even if this is false.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#allow_external_traffic ContainerCluster#allow_external_traffic}
        '''
        result = self._values.get("allow_external_traffic")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def endpoint(self) -> typing.Optional[builtins.str]:
        '''The cluster's DNS endpoint.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#endpoint ContainerCluster#endpoint}
        '''
        result = self._values.get("endpoint")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterControlPlaneEndpointsConfigDnsEndpointConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterControlPlaneEndpointsConfigDnsEndpointConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterControlPlaneEndpointsConfigDnsEndpointConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__128c0c91d0464c58859fcfc7af19c00a836b1530de1fd8b22139b57ff924f863)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetAllowExternalTraffic")
    def reset_allow_external_traffic(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAllowExternalTraffic", []))

    @jsii.member(jsii_name="resetEndpoint")
    def reset_endpoint(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEndpoint", []))

    @builtins.property
    @jsii.member(jsii_name="allowExternalTrafficInput")
    def allow_external_traffic_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "allowExternalTrafficInput"))

    @builtins.property
    @jsii.member(jsii_name="endpointInput")
    def endpoint_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "endpointInput"))

    @builtins.property
    @jsii.member(jsii_name="allowExternalTraffic")
    def allow_external_traffic(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "allowExternalTraffic"))

    @allow_external_traffic.setter
    def allow_external_traffic(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ba87e8ec6eda7d51debc7108d4257021a26b96295c0015f225b4dc2af09a7958)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "allowExternalTraffic", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="endpoint")
    def endpoint(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "endpoint"))

    @endpoint.setter
    def endpoint(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dd1d548fc11eebf9bb2409bd761c034d6778309d4294f918459d22af082654b5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "endpoint", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterControlPlaneEndpointsConfigDnsEndpointConfig]:
        return typing.cast(typing.Optional[ContainerClusterControlPlaneEndpointsConfigDnsEndpointConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterControlPlaneEndpointsConfigDnsEndpointConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dc1e9d2145383d47d7d005139d4c305e50332e9357a8abbb22bb26faa22a50d7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterControlPlaneEndpointsConfigIpEndpointsConfig",
    jsii_struct_bases=[],
    name_mapping={"enabled": "enabled"},
)
class ContainerClusterControlPlaneEndpointsConfigIpEndpointsConfig:
    def __init__(
        self,
        *,
        enabled: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    ) -> None:
        '''
        :param enabled: Controls whether to allow direct IP access. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d2e3fd93530086a6bc2dfdbe81706f53f5e0bcb52125fc407bfbee89e2228515)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if enabled is not None:
            self._values["enabled"] = enabled

    @builtins.property
    def enabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Controls whether to allow direct IP access.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        '''
        result = self._values.get("enabled")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterControlPlaneEndpointsConfigIpEndpointsConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterControlPlaneEndpointsConfigIpEndpointsConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterControlPlaneEndpointsConfigIpEndpointsConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0059ad3ff3a7ba4c9ad3df92d42c80d7bf10c4bc52d62cbf8952f91cbe4ddb9d)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetEnabled")
    def reset_enabled(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnabled", []))

    @builtins.property
    @jsii.member(jsii_name="enabledInput")
    def enabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enabledInput"))

    @builtins.property
    @jsii.member(jsii_name="enabled")
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enabled"))

    @enabled.setter
    def enabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c6a0fcd589ede2da31c04003c4e2c44bd355cebfe41917438cdb2f471777ebae)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterControlPlaneEndpointsConfigIpEndpointsConfig]:
        return typing.cast(typing.Optional[ContainerClusterControlPlaneEndpointsConfigIpEndpointsConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterControlPlaneEndpointsConfigIpEndpointsConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1074c362dc3a5edd9137f09503904e6f2b6672e11cc4cb2da827d65401f0044b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ContainerClusterControlPlaneEndpointsConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterControlPlaneEndpointsConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a43d9146e315dfb096571251def552583f806aa77d78ca84d5d36aad486f6782)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putDnsEndpointConfig")
    def put_dns_endpoint_config(
        self,
        *,
        allow_external_traffic: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        endpoint: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param allow_external_traffic: Controls whether user traffic is allowed over this endpoint. Note that GCP-managed services may still use the endpoint even if this is false. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#allow_external_traffic ContainerCluster#allow_external_traffic}
        :param endpoint: The cluster's DNS endpoint. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#endpoint ContainerCluster#endpoint}
        '''
        value = ContainerClusterControlPlaneEndpointsConfigDnsEndpointConfig(
            allow_external_traffic=allow_external_traffic, endpoint=endpoint
        )

        return typing.cast(None, jsii.invoke(self, "putDnsEndpointConfig", [value]))

    @jsii.member(jsii_name="putIpEndpointsConfig")
    def put_ip_endpoints_config(
        self,
        *,
        enabled: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    ) -> None:
        '''
        :param enabled: Controls whether to allow direct IP access. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        '''
        value = ContainerClusterControlPlaneEndpointsConfigIpEndpointsConfig(
            enabled=enabled
        )

        return typing.cast(None, jsii.invoke(self, "putIpEndpointsConfig", [value]))

    @jsii.member(jsii_name="resetDnsEndpointConfig")
    def reset_dns_endpoint_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDnsEndpointConfig", []))

    @jsii.member(jsii_name="resetIpEndpointsConfig")
    def reset_ip_endpoints_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetIpEndpointsConfig", []))

    @builtins.property
    @jsii.member(jsii_name="dnsEndpointConfig")
    def dns_endpoint_config(
        self,
    ) -> ContainerClusterControlPlaneEndpointsConfigDnsEndpointConfigOutputReference:
        return typing.cast(ContainerClusterControlPlaneEndpointsConfigDnsEndpointConfigOutputReference, jsii.get(self, "dnsEndpointConfig"))

    @builtins.property
    @jsii.member(jsii_name="ipEndpointsConfig")
    def ip_endpoints_config(
        self,
    ) -> ContainerClusterControlPlaneEndpointsConfigIpEndpointsConfigOutputReference:
        return typing.cast(ContainerClusterControlPlaneEndpointsConfigIpEndpointsConfigOutputReference, jsii.get(self, "ipEndpointsConfig"))

    @builtins.property
    @jsii.member(jsii_name="dnsEndpointConfigInput")
    def dns_endpoint_config_input(
        self,
    ) -> typing.Optional[ContainerClusterControlPlaneEndpointsConfigDnsEndpointConfig]:
        return typing.cast(typing.Optional[ContainerClusterControlPlaneEndpointsConfigDnsEndpointConfig], jsii.get(self, "dnsEndpointConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="ipEndpointsConfigInput")
    def ip_endpoints_config_input(
        self,
    ) -> typing.Optional[ContainerClusterControlPlaneEndpointsConfigIpEndpointsConfig]:
        return typing.cast(typing.Optional[ContainerClusterControlPlaneEndpointsConfigIpEndpointsConfig], jsii.get(self, "ipEndpointsConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterControlPlaneEndpointsConfig]:
        return typing.cast(typing.Optional[ContainerClusterControlPlaneEndpointsConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterControlPlaneEndpointsConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9d2f5a95e3d2ed5318e1d8313741dcd8fe627fb90456fc9f7dc592cca013f4e7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterCostManagementConfig",
    jsii_struct_bases=[],
    name_mapping={"enabled": "enabled"},
)
class ContainerClusterCostManagementConfig:
    def __init__(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param enabled: Whether to enable GKE cost allocation. When you enable GKE cost allocation, the cluster name and namespace of your GKE workloads appear in the labels field of the billing export to BigQuery. Defaults to false. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__53f94f622604f508c61a26dafac9189b13186d0494e1bb527c6169284eb3172d)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "enabled": enabled,
        }

    @builtins.property
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        '''Whether to enable GKE cost allocation.

        When you enable GKE cost allocation, the cluster name and namespace of your GKE workloads appear in the labels field of the billing export to BigQuery. Defaults to false.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        '''
        result = self._values.get("enabled")
        assert result is not None, "Required property 'enabled' is missing"
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterCostManagementConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterCostManagementConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterCostManagementConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c4ae1f8632618dc8678ab8b94841c62e5b47f078804f7d658094ca9adace050a)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="enabledInput")
    def enabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enabledInput"))

    @builtins.property
    @jsii.member(jsii_name="enabled")
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enabled"))

    @enabled.setter
    def enabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__085919719eb66df9bc48d11cf3fa1923d97a49f32fc2e8d81de77211c988009f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[ContainerClusterCostManagementConfig]:
        return typing.cast(typing.Optional[ContainerClusterCostManagementConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterCostManagementConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__33c06c5851952876184de73102553f77db3bfa84fc2aabd9ef91457f74ebf246)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterDatabaseEncryption",
    jsii_struct_bases=[],
    name_mapping={"state": "state", "key_name": "keyName"},
)
class ContainerClusterDatabaseEncryption:
    def __init__(
        self,
        *,
        state: builtins.str,
        key_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param state: ENCRYPTED or DECRYPTED. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#state ContainerCluster#state}
        :param key_name: The key to use to encrypt/decrypt secrets. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#key_name ContainerCluster#key_name}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b4203bf92b9a35241e2b86718f171be7ad42ed110398d6641d6b16457828693f)
            check_type(argname="argument state", value=state, expected_type=type_hints["state"])
            check_type(argname="argument key_name", value=key_name, expected_type=type_hints["key_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "state": state,
        }
        if key_name is not None:
            self._values["key_name"] = key_name

    @builtins.property
    def state(self) -> builtins.str:
        '''ENCRYPTED or DECRYPTED.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#state ContainerCluster#state}
        '''
        result = self._values.get("state")
        assert result is not None, "Required property 'state' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def key_name(self) -> typing.Optional[builtins.str]:
        '''The key to use to encrypt/decrypt secrets.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#key_name ContainerCluster#key_name}
        '''
        result = self._values.get("key_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterDatabaseEncryption(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterDatabaseEncryptionOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterDatabaseEncryptionOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e50e25d5af0319f7e23d6213366afbd5edaadc7b71bae807d24c1cd5ecc6f806)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetKeyName")
    def reset_key_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKeyName", []))

    @builtins.property
    @jsii.member(jsii_name="keyNameInput")
    def key_name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyNameInput"))

    @builtins.property
    @jsii.member(jsii_name="stateInput")
    def state_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "stateInput"))

    @builtins.property
    @jsii.member(jsii_name="keyName")
    def key_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "keyName"))

    @key_name.setter
    def key_name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__69a15842a9c1933078a389209bd015aa70f380ea03f6d2c9c38faec860815f39)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "keyName", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="state")
    def state(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "state"))

    @state.setter
    def state(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dd120cf9cf115d833106a15e8b2ce8a206f1e1806cf9d73af7b1964a02e554b1)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "state", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[ContainerClusterDatabaseEncryption]:
        return typing.cast(typing.Optional[ContainerClusterDatabaseEncryption], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterDatabaseEncryption],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__df1eee8d9911a1c36692753649dc91f7a54a0c5c2fa1a18981bc835f62296502)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterDefaultSnatStatus",
    jsii_struct_bases=[],
    name_mapping={"disabled": "disabled"},
)
class ContainerClusterDefaultSnatStatus:
    def __init__(
        self,
        *,
        disabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param disabled: When disabled is set to false, default IP masquerade rules will be applied to the nodes to prevent sNAT on cluster internal traffic. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#disabled ContainerCluster#disabled}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e5a3b8b4e99414f7b195db122b48d3b2d0bc6e27d68415557df17c9c2f3b8386)
            check_type(argname="argument disabled", value=disabled, expected_type=type_hints["disabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "disabled": disabled,
        }

    @builtins.property
    def disabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        '''When disabled is set to false, default IP masquerade rules will be applied to the nodes to prevent sNAT on cluster internal traffic.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#disabled ContainerCluster#disabled}
        '''
        result = self._values.get("disabled")
        assert result is not None, "Required property 'disabled' is missing"
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterDefaultSnatStatus(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterDefaultSnatStatusOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterDefaultSnatStatusOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d3d10964004d66068c90b9084a031fac04327bc643e5a21b04823a92ab651b72)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="disabledInput")
    def disabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "disabledInput"))

    @builtins.property
    @jsii.member(jsii_name="disabled")
    def disabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "disabled"))

    @disabled.setter
    def disabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d39e501a5efafe90f40292a4971b0f91cd7cc194b57b3bd45270ff03966a25ce)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "disabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[ContainerClusterDefaultSnatStatus]:
        return typing.cast(typing.Optional[ContainerClusterDefaultSnatStatus], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterDefaultSnatStatus],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3924acd8dfe4a7ce7eb998500b2c1c11ef4ec99fd17b5f3420707d45a290fa5e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterDnsConfig",
    jsii_struct_bases=[],
    name_mapping={
        "additive_vpc_scope_dns_domain": "additiveVpcScopeDnsDomain",
        "cluster_dns": "clusterDns",
        "cluster_dns_domain": "clusterDnsDomain",
        "cluster_dns_scope": "clusterDnsScope",
    },
)
class ContainerClusterDnsConfig:
    def __init__(
        self,
        *,
        additive_vpc_scope_dns_domain: typing.Optional[builtins.str] = None,
        cluster_dns: typing.Optional[builtins.str] = None,
        cluster_dns_domain: typing.Optional[builtins.str] = None,
        cluster_dns_scope: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param additive_vpc_scope_dns_domain: Enable additive VPC scope DNS in a GKE cluster. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#additive_vpc_scope_dns_domain ContainerCluster#additive_vpc_scope_dns_domain}
        :param cluster_dns: Which in-cluster DNS provider should be used. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cluster_dns ContainerCluster#cluster_dns}
        :param cluster_dns_domain: The suffix used for all cluster service records. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cluster_dns_domain ContainerCluster#cluster_dns_domain}
        :param cluster_dns_scope: The scope of access to cluster DNS records. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cluster_dns_scope ContainerCluster#cluster_dns_scope}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__155d0834b0bfacd35418367002f3a8a4fb1a087c15bdad407b1e4cb4d1b05602)
            check_type(argname="argument additive_vpc_scope_dns_domain", value=additive_vpc_scope_dns_domain, expected_type=type_hints["additive_vpc_scope_dns_domain"])
            check_type(argname="argument cluster_dns", value=cluster_dns, expected_type=type_hints["cluster_dns"])
            check_type(argname="argument cluster_dns_domain", value=cluster_dns_domain, expected_type=type_hints["cluster_dns_domain"])
            check_type(argname="argument cluster_dns_scope", value=cluster_dns_scope, expected_type=type_hints["cluster_dns_scope"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if additive_vpc_scope_dns_domain is not None:
            self._values["additive_vpc_scope_dns_domain"] = additive_vpc_scope_dns_domain
        if cluster_dns is not None:
            self._values["cluster_dns"] = cluster_dns
        if cluster_dns_domain is not None:
            self._values["cluster_dns_domain"] = cluster_dns_domain
        if cluster_dns_scope is not None:
            self._values["cluster_dns_scope"] = cluster_dns_scope

    @builtins.property
    def additive_vpc_scope_dns_domain(self) -> typing.Optional[builtins.str]:
        '''Enable additive VPC scope DNS in a GKE cluster.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#additive_vpc_scope_dns_domain ContainerCluster#additive_vpc_scope_dns_domain}
        '''
        result = self._values.get("additive_vpc_scope_dns_domain")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def cluster_dns(self) -> typing.Optional[builtins.str]:
        '''Which in-cluster DNS provider should be used.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cluster_dns ContainerCluster#cluster_dns}
        '''
        result = self._values.get("cluster_dns")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def cluster_dns_domain(self) -> typing.Optional[builtins.str]:
        '''The suffix used for all cluster service records.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cluster_dns_domain ContainerCluster#cluster_dns_domain}
        '''
        result = self._values.get("cluster_dns_domain")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def cluster_dns_scope(self) -> typing.Optional[builtins.str]:
        '''The scope of access to cluster DNS records.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cluster_dns_scope ContainerCluster#cluster_dns_scope}
        '''
        result = self._values.get("cluster_dns_scope")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterDnsConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterDnsConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterDnsConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5ad89177ab8b61f1e91912886784b26ef403fbdd2283499a1a2ba0fec73ac270)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetAdditiveVpcScopeDnsDomain")
    def reset_additive_vpc_scope_dns_domain(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAdditiveVpcScopeDnsDomain", []))

    @jsii.member(jsii_name="resetClusterDns")
    def reset_cluster_dns(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetClusterDns", []))

    @jsii.member(jsii_name="resetClusterDnsDomain")
    def reset_cluster_dns_domain(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetClusterDnsDomain", []))

    @jsii.member(jsii_name="resetClusterDnsScope")
    def reset_cluster_dns_scope(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetClusterDnsScope", []))

    @builtins.property
    @jsii.member(jsii_name="additiveVpcScopeDnsDomainInput")
    def additive_vpc_scope_dns_domain_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "additiveVpcScopeDnsDomainInput"))

    @builtins.property
    @jsii.member(jsii_name="clusterDnsDomainInput")
    def cluster_dns_domain_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "clusterDnsDomainInput"))

    @builtins.property
    @jsii.member(jsii_name="clusterDnsInput")
    def cluster_dns_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "clusterDnsInput"))

    @builtins.property
    @jsii.member(jsii_name="clusterDnsScopeInput")
    def cluster_dns_scope_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "clusterDnsScopeInput"))

    @builtins.property
    @jsii.member(jsii_name="additiveVpcScopeDnsDomain")
    def additive_vpc_scope_dns_domain(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "additiveVpcScopeDnsDomain"))

    @additive_vpc_scope_dns_domain.setter
    def additive_vpc_scope_dns_domain(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0a807bd21410bc911c476585ab0bbd3e5947ff9817ea1644c1288a9aa16e5c1b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "additiveVpcScopeDnsDomain", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="clusterDns")
    def cluster_dns(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "clusterDns"))

    @cluster_dns.setter
    def cluster_dns(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5d2d03462df744d03c381d7cd24103a450ee14ace85e9bfc7d03687efc4dca59)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "clusterDns", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="clusterDnsDomain")
    def cluster_dns_domain(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "clusterDnsDomain"))

    @cluster_dns_domain.setter
    def cluster_dns_domain(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7aeca965c5e56db8d1273a185037e6e7f21f7fdb3f5fa8a3d8903816296b58e7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "clusterDnsDomain", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="clusterDnsScope")
    def cluster_dns_scope(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "clusterDnsScope"))

    @cluster_dns_scope.setter
    def cluster_dns_scope(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3405ccb32ca7ca987cc637cb23862a38fb307075ff457862fba5e9ab2031b1cd)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "clusterDnsScope", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[ContainerClusterDnsConfig]:
        return typing.cast(typing.Optional[ContainerClusterDnsConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(self, value: typing.Optional[ContainerClusterDnsConfig]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4453ba5cd82bfe07d011f2dd3bbe3d907eb36f052c6c028a4faa265cf33de32a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterEnableK8SBetaApis",
    jsii_struct_bases=[],
    name_mapping={"enabled_apis": "enabledApis"},
)
class ContainerClusterEnableK8SBetaApis:
    def __init__(self, *, enabled_apis: typing.Sequence[builtins.str]) -> None:
        '''
        :param enabled_apis: Enabled Kubernetes Beta APIs. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled_apis ContainerCluster#enabled_apis}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__17e8e3d61ea9cec84aaec791a29a95c292d696a3f2651a3cbc2caacf016e1e17)
            check_type(argname="argument enabled_apis", value=enabled_apis, expected_type=type_hints["enabled_apis"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "enabled_apis": enabled_apis,
        }

    @builtins.property
    def enabled_apis(self) -> typing.List[builtins.str]:
        '''Enabled Kubernetes Beta APIs.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled_apis ContainerCluster#enabled_apis}
        '''
        result = self._values.get("enabled_apis")
        assert result is not None, "Required property 'enabled_apis' is missing"
        return typing.cast(typing.List[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterEnableK8SBetaApis(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterEnableK8SBetaApisOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterEnableK8SBetaApisOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__854f61857974b7c4de758e456c53320ab1f70f3817420b1ee9068f3ee8d13a05)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="enabledApisInput")
    def enabled_apis_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "enabledApisInput"))

    @builtins.property
    @jsii.member(jsii_name="enabledApis")
    def enabled_apis(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "enabledApis"))

    @enabled_apis.setter
    def enabled_apis(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6841bbc4340f5c758f5018db4dfccd36d9b4b9881fba5c9aa6d5365c7bdbc069)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enabledApis", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[ContainerClusterEnableK8SBetaApis]:
        return typing.cast(typing.Optional[ContainerClusterEnableK8SBetaApis], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterEnableK8SBetaApis],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ebd9dccaeb8cca687d21c9f6e689e7daff8b690858dc167a6bd0dbc75d9ac751)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterEnterpriseConfig",
    jsii_struct_bases=[],
    name_mapping={"desired_tier": "desiredTier"},
)
class ContainerClusterEnterpriseConfig:
    def __init__(self, *, desired_tier: typing.Optional[builtins.str] = None) -> None:
        '''
        :param desired_tier: Indicates the desired cluster tier. Available options include STANDARD and ENTERPRISE. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#desired_tier ContainerCluster#desired_tier}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9119beeca678b9e9a7f49519a8ff230f9d11e95cf6fd085e8d490d9ebdfa32cf)
            check_type(argname="argument desired_tier", value=desired_tier, expected_type=type_hints["desired_tier"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if desired_tier is not None:
            self._values["desired_tier"] = desired_tier

    @builtins.property
    def desired_tier(self) -> typing.Optional[builtins.str]:
        '''Indicates the desired cluster tier. Available options include STANDARD and ENTERPRISE.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#desired_tier ContainerCluster#desired_tier}
        '''
        result = self._values.get("desired_tier")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterEnterpriseConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterEnterpriseConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterEnterpriseConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d70b402e32809ad6ff2305277de9feb54d1d930eb52378461371a72e6365edec)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetDesiredTier")
    def reset_desired_tier(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDesiredTier", []))

    @builtins.property
    @jsii.member(jsii_name="clusterTier")
    def cluster_tier(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "clusterTier"))

    @builtins.property
    @jsii.member(jsii_name="desiredTierInput")
    def desired_tier_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "desiredTierInput"))

    @builtins.property
    @jsii.member(jsii_name="desiredTier")
    def desired_tier(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "desiredTier"))

    @desired_tier.setter
    def desired_tier(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7194abcbd09d7e731b31db23818e0c80c93b8d5ea87a5ed44309c1aafd331c7a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "desiredTier", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[ContainerClusterEnterpriseConfig]:
        return typing.cast(typing.Optional[ContainerClusterEnterpriseConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterEnterpriseConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__67643b6611fc6f6eccd92db59351871152682e525714f55d390f7d2f5fc641bc)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterFleet",
    jsii_struct_bases=[],
    name_mapping={"project": "project"},
)
class ContainerClusterFleet:
    def __init__(self, *, project: typing.Optional[builtins.str] = None) -> None:
        '''
        :param project: The Fleet host project of the cluster. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#project ContainerCluster#project}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6d3925f1d0bbb0310d2055b98284eb9428aaa5886c6714a3636b7f4419b7cae9)
            check_type(argname="argument project", value=project, expected_type=type_hints["project"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if project is not None:
            self._values["project"] = project

    @builtins.property
    def project(self) -> typing.Optional[builtins.str]:
        '''The Fleet host project of the cluster.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#project ContainerCluster#project}
        '''
        result = self._values.get("project")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterFleet(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterFleetOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterFleetOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__91e482a8e2c45a41e6ff9510219eb2f4e2160cc26b5fd8679a1fb9e7adc0927d)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetProject")
    def reset_project(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetProject", []))

    @builtins.property
    @jsii.member(jsii_name="membership")
    def membership(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "membership"))

    @builtins.property
    @jsii.member(jsii_name="membershipId")
    def membership_id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "membershipId"))

    @builtins.property
    @jsii.member(jsii_name="membershipLocation")
    def membership_location(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "membershipLocation"))

    @builtins.property
    @jsii.member(jsii_name="preRegistered")
    def pre_registered(self) -> _cdktf_9a9027ec.IResolvable:
        return typing.cast(_cdktf_9a9027ec.IResolvable, jsii.get(self, "preRegistered"))

    @builtins.property
    @jsii.member(jsii_name="projectInput")
    def project_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "projectInput"))

    @builtins.property
    @jsii.member(jsii_name="project")
    def project(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "project"))

    @project.setter
    def project(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__827ac1b2b5a2c8a3b9c048b8b0a4de25d6001933435d55a1a564385c76ab1535)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "project", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[ContainerClusterFleet]:
        return typing.cast(typing.Optional[ContainerClusterFleet], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(self, value: typing.Optional[ContainerClusterFleet]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1422273da7bf5f6c6e5141eca43a946c73c8b5dbc62d365a9656a9be8e1a023c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterGatewayApiConfig",
    jsii_struct_bases=[],
    name_mapping={"channel": "channel"},
)
class ContainerClusterGatewayApiConfig:
    def __init__(self, *, channel: builtins.str) -> None:
        '''
        :param channel: The Gateway API release channel to use for Gateway API. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#channel ContainerCluster#channel}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0578535ebb5b2405b26c23a6217d0fb4f0510595231fdfebdf88a5530ddbfb1f)
            check_type(argname="argument channel", value=channel, expected_type=type_hints["channel"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "channel": channel,
        }

    @builtins.property
    def channel(self) -> builtins.str:
        '''The Gateway API release channel to use for Gateway API.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#channel ContainerCluster#channel}
        '''
        result = self._values.get("channel")
        assert result is not None, "Required property 'channel' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterGatewayApiConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterGatewayApiConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterGatewayApiConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__86eb46426d75c2c04d73989d0c08f2804e583099c051cae35d60c77bfb3fbbe8)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="channelInput")
    def channel_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "channelInput"))

    @builtins.property
    @jsii.member(jsii_name="channel")
    def channel(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "channel"))

    @channel.setter
    def channel(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__355efbb62ea1178a864e32727b64223c26bc49489b5cfab8d8b29ef6f77ec837)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "channel", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[ContainerClusterGatewayApiConfig]:
        return typing.cast(typing.Optional[ContainerClusterGatewayApiConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterGatewayApiConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__83006e163075035aed8eb10f20d392c025321a1f656e4539998c824fe1920c07)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterGkeAutoUpgradeConfig",
    jsii_struct_bases=[],
    name_mapping={"patch_mode": "patchMode"},
)
class ContainerClusterGkeAutoUpgradeConfig:
    def __init__(self, *, patch_mode: builtins.str) -> None:
        '''
        :param patch_mode: The selected auto-upgrade patch type. Accepted values are: - ACCELERATED: Upgrades to the latest available patch version in a given minor and release channel. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#patch_mode ContainerCluster#patch_mode}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__53c11213c323c84a3d0915dabb481d7dfa0c6d668663ed1782c419a04146515d)
            check_type(argname="argument patch_mode", value=patch_mode, expected_type=type_hints["patch_mode"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "patch_mode": patch_mode,
        }

    @builtins.property
    def patch_mode(self) -> builtins.str:
        '''The selected auto-upgrade patch type.

        Accepted values are:

        - ACCELERATED: Upgrades to the latest available patch version in a given minor and release channel.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#patch_mode ContainerCluster#patch_mode}
        '''
        result = self._values.get("patch_mode")
        assert result is not None, "Required property 'patch_mode' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterGkeAutoUpgradeConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterGkeAutoUpgradeConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterGkeAutoUpgradeConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2be7248baf577e7d2bbe5871c7e3e22992b907d60f83ddae477e81e068e43486)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="patchModeInput")
    def patch_mode_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "patchModeInput"))

    @builtins.property
    @jsii.member(jsii_name="patchMode")
    def patch_mode(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "patchMode"))

    @patch_mode.setter
    def patch_mode(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1b3e395b1d253f431120b4cc38a951768d79a63df027a48381c9265265ea7b44)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "patchMode", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[ContainerClusterGkeAutoUpgradeConfig]:
        return typing.cast(typing.Optional[ContainerClusterGkeAutoUpgradeConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterGkeAutoUpgradeConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cceae5ee2f69495bbacaa6f9ca414a84d07f7d82c38d1e22d944ac096053c9a6)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterIdentityServiceConfig",
    jsii_struct_bases=[],
    name_mapping={"enabled": "enabled"},
)
class ContainerClusterIdentityServiceConfig:
    def __init__(
        self,
        *,
        enabled: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    ) -> None:
        '''
        :param enabled: Whether to enable the Identity Service component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4eae44db020422f9295523b416de4d8132bfb46958dd382c163dbe51972e99f0)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if enabled is not None:
            self._values["enabled"] = enabled

    @builtins.property
    def enabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Whether to enable the Identity Service component.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        '''
        result = self._values.get("enabled")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterIdentityServiceConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterIdentityServiceConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterIdentityServiceConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3c81fa1bfefd0a12da56ac59a1b026d80a2268845377508fbc1b295bc81a5e6f)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetEnabled")
    def reset_enabled(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnabled", []))

    @builtins.property
    @jsii.member(jsii_name="enabledInput")
    def enabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enabledInput"))

    @builtins.property
    @jsii.member(jsii_name="enabled")
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enabled"))

    @enabled.setter
    def enabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1dd954f86defaa8787e97fc95c154a7f8df3f8db9b3bd277b6e5d3ef5b885423)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[ContainerClusterIdentityServiceConfig]:
        return typing.cast(typing.Optional[ContainerClusterIdentityServiceConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterIdentityServiceConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1c36546adc0a09f132ed3e05ed4598eda370ffff1fd5ce296f60606771a189d3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterIpAllocationPolicy",
    jsii_struct_bases=[],
    name_mapping={
        "additional_ip_ranges_config": "additionalIpRangesConfig",
        "additional_pod_ranges_config": "additionalPodRangesConfig",
        "cluster_ipv4_cidr_block": "clusterIpv4CidrBlock",
        "cluster_secondary_range_name": "clusterSecondaryRangeName",
        "pod_cidr_overprovision_config": "podCidrOverprovisionConfig",
        "services_ipv4_cidr_block": "servicesIpv4CidrBlock",
        "services_secondary_range_name": "servicesSecondaryRangeName",
        "stack_type": "stackType",
    },
)
class ContainerClusterIpAllocationPolicy:
    def __init__(
        self,
        *,
        additional_ip_ranges_config: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ContainerClusterIpAllocationPolicyAdditionalIpRangesConfig", typing.Dict[builtins.str, typing.Any]]]]] = None,
        additional_pod_ranges_config: typing.Optional[typing.Union["ContainerClusterIpAllocationPolicyAdditionalPodRangesConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        cluster_ipv4_cidr_block: typing.Optional[builtins.str] = None,
        cluster_secondary_range_name: typing.Optional[builtins.str] = None,
        pod_cidr_overprovision_config: typing.Optional[typing.Union["ContainerClusterIpAllocationPolicyPodCidrOverprovisionConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        services_ipv4_cidr_block: typing.Optional[builtins.str] = None,
        services_secondary_range_name: typing.Optional[builtins.str] = None,
        stack_type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param additional_ip_ranges_config: additional_ip_ranges_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#additional_ip_ranges_config ContainerCluster#additional_ip_ranges_config}
        :param additional_pod_ranges_config: additional_pod_ranges_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#additional_pod_ranges_config ContainerCluster#additional_pod_ranges_config}
        :param cluster_ipv4_cidr_block: The IP address range for the cluster pod IPs. Set to blank to have a range chosen with the default size. Set to /netmask (e.g. /14) to have a range chosen with a specific netmask. Set to a CIDR notation (e.g. 10.96.0.0/14) from the RFC-1918 private networks (e.g. 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16) to pick a specific range to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cluster_ipv4_cidr_block ContainerCluster#cluster_ipv4_cidr_block}
        :param cluster_secondary_range_name: The name of the existing secondary range in the cluster's subnetwork to use for pod IP addresses. Alternatively, cluster_ipv4_cidr_block can be used to automatically create a GKE-managed one. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cluster_secondary_range_name ContainerCluster#cluster_secondary_range_name}
        :param pod_cidr_overprovision_config: pod_cidr_overprovision_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#pod_cidr_overprovision_config ContainerCluster#pod_cidr_overprovision_config}
        :param services_ipv4_cidr_block: The IP address range of the services IPs in this cluster. Set to blank to have a range chosen with the default size. Set to /netmask (e.g. /14) to have a range chosen with a specific netmask. Set to a CIDR notation (e.g. 10.96.0.0/14) from the RFC-1918 private networks (e.g. 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16) to pick a specific range to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#services_ipv4_cidr_block ContainerCluster#services_ipv4_cidr_block}
        :param services_secondary_range_name: The name of the existing secondary range in the cluster's subnetwork to use for service ClusterIPs. Alternatively, services_ipv4_cidr_block can be used to automatically create a GKE-managed one. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#services_secondary_range_name ContainerCluster#services_secondary_range_name}
        :param stack_type: The IP Stack type of the cluster. Choose between IPV4 and IPV4_IPV6. Default type is IPV4 Only if not set Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#stack_type ContainerCluster#stack_type}
        '''
        if isinstance(additional_pod_ranges_config, dict):
            additional_pod_ranges_config = ContainerClusterIpAllocationPolicyAdditionalPodRangesConfig(**additional_pod_ranges_config)
        if isinstance(pod_cidr_overprovision_config, dict):
            pod_cidr_overprovision_config = ContainerClusterIpAllocationPolicyPodCidrOverprovisionConfig(**pod_cidr_overprovision_config)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c6c3a74e37b7ba5b8cae681999b3a7b285f08704c47d23563b47ced34374b444)
            check_type(argname="argument additional_ip_ranges_config", value=additional_ip_ranges_config, expected_type=type_hints["additional_ip_ranges_config"])
            check_type(argname="argument additional_pod_ranges_config", value=additional_pod_ranges_config, expected_type=type_hints["additional_pod_ranges_config"])
            check_type(argname="argument cluster_ipv4_cidr_block", value=cluster_ipv4_cidr_block, expected_type=type_hints["cluster_ipv4_cidr_block"])
            check_type(argname="argument cluster_secondary_range_name", value=cluster_secondary_range_name, expected_type=type_hints["cluster_secondary_range_name"])
            check_type(argname="argument pod_cidr_overprovision_config", value=pod_cidr_overprovision_config, expected_type=type_hints["pod_cidr_overprovision_config"])
            check_type(argname="argument services_ipv4_cidr_block", value=services_ipv4_cidr_block, expected_type=type_hints["services_ipv4_cidr_block"])
            check_type(argname="argument services_secondary_range_name", value=services_secondary_range_name, expected_type=type_hints["services_secondary_range_name"])
            check_type(argname="argument stack_type", value=stack_type, expected_type=type_hints["stack_type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if additional_ip_ranges_config is not None:
            self._values["additional_ip_ranges_config"] = additional_ip_ranges_config
        if additional_pod_ranges_config is not None:
            self._values["additional_pod_ranges_config"] = additional_pod_ranges_config
        if cluster_ipv4_cidr_block is not None:
            self._values["cluster_ipv4_cidr_block"] = cluster_ipv4_cidr_block
        if cluster_secondary_range_name is not None:
            self._values["cluster_secondary_range_name"] = cluster_secondary_range_name
        if pod_cidr_overprovision_config is not None:
            self._values["pod_cidr_overprovision_config"] = pod_cidr_overprovision_config
        if services_ipv4_cidr_block is not None:
            self._values["services_ipv4_cidr_block"] = services_ipv4_cidr_block
        if services_secondary_range_name is not None:
            self._values["services_secondary_range_name"] = services_secondary_range_name
        if stack_type is not None:
            self._values["stack_type"] = stack_type

    @builtins.property
    def additional_ip_ranges_config(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ContainerClusterIpAllocationPolicyAdditionalIpRangesConfig"]]]:
        '''additional_ip_ranges_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#additional_ip_ranges_config ContainerCluster#additional_ip_ranges_config}
        '''
        result = self._values.get("additional_ip_ranges_config")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ContainerClusterIpAllocationPolicyAdditionalIpRangesConfig"]]], result)

    @builtins.property
    def additional_pod_ranges_config(
        self,
    ) -> typing.Optional["ContainerClusterIpAllocationPolicyAdditionalPodRangesConfig"]:
        '''additional_pod_ranges_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#additional_pod_ranges_config ContainerCluster#additional_pod_ranges_config}
        '''
        result = self._values.get("additional_pod_ranges_config")
        return typing.cast(typing.Optional["ContainerClusterIpAllocationPolicyAdditionalPodRangesConfig"], result)

    @builtins.property
    def cluster_ipv4_cidr_block(self) -> typing.Optional[builtins.str]:
        '''The IP address range for the cluster pod IPs.

        Set to blank to have a range chosen with the default size. Set to /netmask (e.g. /14) to have a range chosen with a specific netmask. Set to a CIDR notation (e.g. 10.96.0.0/14) from the RFC-1918 private networks (e.g. 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16) to pick a specific range to use.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cluster_ipv4_cidr_block ContainerCluster#cluster_ipv4_cidr_block}
        '''
        result = self._values.get("cluster_ipv4_cidr_block")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def cluster_secondary_range_name(self) -> typing.Optional[builtins.str]:
        '''The name of the existing secondary range in the cluster's subnetwork to use for pod IP addresses.

        Alternatively, cluster_ipv4_cidr_block can be used to automatically create a GKE-managed one.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cluster_secondary_range_name ContainerCluster#cluster_secondary_range_name}
        '''
        result = self._values.get("cluster_secondary_range_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def pod_cidr_overprovision_config(
        self,
    ) -> typing.Optional["ContainerClusterIpAllocationPolicyPodCidrOverprovisionConfig"]:
        '''pod_cidr_overprovision_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#pod_cidr_overprovision_config ContainerCluster#pod_cidr_overprovision_config}
        '''
        result = self._values.get("pod_cidr_overprovision_config")
        return typing.cast(typing.Optional["ContainerClusterIpAllocationPolicyPodCidrOverprovisionConfig"], result)

    @builtins.property
    def services_ipv4_cidr_block(self) -> typing.Optional[builtins.str]:
        '''The IP address range of the services IPs in this cluster.

        Set to blank to have a range chosen with the default size. Set to /netmask (e.g. /14) to have a range chosen with a specific netmask. Set to a CIDR notation (e.g. 10.96.0.0/14) from the RFC-1918 private networks (e.g. 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16) to pick a specific range to use.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#services_ipv4_cidr_block ContainerCluster#services_ipv4_cidr_block}
        '''
        result = self._values.get("services_ipv4_cidr_block")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def services_secondary_range_name(self) -> typing.Optional[builtins.str]:
        '''The name of the existing secondary range in the cluster's subnetwork to use for service ClusterIPs.

        Alternatively, services_ipv4_cidr_block can be used to automatically create a GKE-managed one.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#services_secondary_range_name ContainerCluster#services_secondary_range_name}
        '''
        result = self._values.get("services_secondary_range_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def stack_type(self) -> typing.Optional[builtins.str]:
        '''The IP Stack type of the cluster.

        Choose between IPV4 and IPV4_IPV6. Default type is IPV4 Only if not set

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#stack_type ContainerCluster#stack_type}
        '''
        result = self._values.get("stack_type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterIpAllocationPolicy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterIpAllocationPolicyAdditionalIpRangesConfig",
    jsii_struct_bases=[],
    name_mapping={
        "subnetwork": "subnetwork",
        "pod_ipv4_range_names": "podIpv4RangeNames",
    },
)
class ContainerClusterIpAllocationPolicyAdditionalIpRangesConfig:
    def __init__(
        self,
        *,
        subnetwork: builtins.str,
        pod_ipv4_range_names: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param subnetwork: Name of the subnetwork. This can be the full path of the subnetwork or just the name. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#subnetwork ContainerCluster#subnetwork}
        :param pod_ipv4_range_names: List of secondary ranges names within this subnetwork that can be used for pod IPs. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#pod_ipv4_range_names ContainerCluster#pod_ipv4_range_names}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__22bce20eced8a5c2b2457e3433e8dc1342579d0ad7d7d659de953706a041c3a8)
            check_type(argname="argument subnetwork", value=subnetwork, expected_type=type_hints["subnetwork"])
            check_type(argname="argument pod_ipv4_range_names", value=pod_ipv4_range_names, expected_type=type_hints["pod_ipv4_range_names"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "subnetwork": subnetwork,
        }
        if pod_ipv4_range_names is not None:
            self._values["pod_ipv4_range_names"] = pod_ipv4_range_names

    @builtins.property
    def subnetwork(self) -> builtins.str:
        '''Name of the subnetwork. This can be the full path of the subnetwork or just the name.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#subnetwork ContainerCluster#subnetwork}
        '''
        result = self._values.get("subnetwork")
        assert result is not None, "Required property 'subnetwork' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def pod_ipv4_range_names(self) -> typing.Optional[typing.List[builtins.str]]:
        '''List of secondary ranges names within this subnetwork that can be used for pod IPs.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#pod_ipv4_range_names ContainerCluster#pod_ipv4_range_names}
        '''
        result = self._values.get("pod_ipv4_range_names")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterIpAllocationPolicyAdditionalIpRangesConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterIpAllocationPolicyAdditionalIpRangesConfigList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterIpAllocationPolicyAdditionalIpRangesConfigList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__23674470711cc82411b2b2a80661f6fe90a00727450a709090ae13cc47b9f91d)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ContainerClusterIpAllocationPolicyAdditionalIpRangesConfigOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__202bf4bcb35b00830bbb3ae7c06012aa08f4220cf30e4e10a332322860a8b5f4)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ContainerClusterIpAllocationPolicyAdditionalIpRangesConfigOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e7b8bc2fa2421804b1b4e6ce1ce456ea42db02516bbe646bb5e147542d40dfb6)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c5d2f41d8b7345bd7a44aa7b73165c3a67ff5a3e4de0b24e2db3b79a87538cfd)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bf5ee652e20abbc8b4ce4d4b1000bb39febffee193c21070904c954dfc981683)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterIpAllocationPolicyAdditionalIpRangesConfig]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterIpAllocationPolicyAdditionalIpRangesConfig]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterIpAllocationPolicyAdditionalIpRangesConfig]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__02e97ab68752659eeda82fcaf649f47ea68af4d81da3414e00227260f4afa299)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ContainerClusterIpAllocationPolicyAdditionalIpRangesConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterIpAllocationPolicyAdditionalIpRangesConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6f7f6745be3eb01246555a01bcd97374c06f0765d5026f13acb5f24514e38ce6)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="resetPodIpv4RangeNames")
    def reset_pod_ipv4_range_names(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPodIpv4RangeNames", []))

    @builtins.property
    @jsii.member(jsii_name="podIpv4RangeNamesInput")
    def pod_ipv4_range_names_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "podIpv4RangeNamesInput"))

    @builtins.property
    @jsii.member(jsii_name="subnetworkInput")
    def subnetwork_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "subnetworkInput"))

    @builtins.property
    @jsii.member(jsii_name="podIpv4RangeNames")
    def pod_ipv4_range_names(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "podIpv4RangeNames"))

    @pod_ipv4_range_names.setter
    def pod_ipv4_range_names(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dcdf31f406d723c18b774e705f155989df75d25734de2f8c14cf113beeef3bc2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "podIpv4RangeNames", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="subnetwork")
    def subnetwork(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "subnetwork"))

    @subnetwork.setter
    def subnetwork(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a814e5bba44ff5cbc789eb040e3b8f18b41a7601108adfec06d369cfe1e56da8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "subnetwork", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterIpAllocationPolicyAdditionalIpRangesConfig]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterIpAllocationPolicyAdditionalIpRangesConfig]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterIpAllocationPolicyAdditionalIpRangesConfig]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6d6541a2433dcec497071db9b204420261f74955926273a09ef112346158ce5f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterIpAllocationPolicyAdditionalPodRangesConfig",
    jsii_struct_bases=[],
    name_mapping={"pod_range_names": "podRangeNames"},
)
class ContainerClusterIpAllocationPolicyAdditionalPodRangesConfig:
    def __init__(self, *, pod_range_names: typing.Sequence[builtins.str]) -> None:
        '''
        :param pod_range_names: Name for pod secondary ipv4 range which has the actual range defined ahead. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#pod_range_names ContainerCluster#pod_range_names}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dc2ea5d3bc702f7e6abd081fa46e851cc16124806f874ef75c2552888afa7866)
            check_type(argname="argument pod_range_names", value=pod_range_names, expected_type=type_hints["pod_range_names"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "pod_range_names": pod_range_names,
        }

    @builtins.property
    def pod_range_names(self) -> typing.List[builtins.str]:
        '''Name for pod secondary ipv4 range which has the actual range defined ahead.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#pod_range_names ContainerCluster#pod_range_names}
        '''
        result = self._values.get("pod_range_names")
        assert result is not None, "Required property 'pod_range_names' is missing"
        return typing.cast(typing.List[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterIpAllocationPolicyAdditionalPodRangesConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterIpAllocationPolicyAdditionalPodRangesConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterIpAllocationPolicyAdditionalPodRangesConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1e4bc979083d2f868bea5d1013876a02ffb0d61d63bfbe8fdeb8677f653ff627)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="podRangeNamesInput")
    def pod_range_names_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "podRangeNamesInput"))

    @builtins.property
    @jsii.member(jsii_name="podRangeNames")
    def pod_range_names(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "podRangeNames"))

    @pod_range_names.setter
    def pod_range_names(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__371f59eab3caec4893a99b5a6a85d0085b70ef05fed048274a6e7a8a7ddc0694)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "podRangeNames", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterIpAllocationPolicyAdditionalPodRangesConfig]:
        return typing.cast(typing.Optional[ContainerClusterIpAllocationPolicyAdditionalPodRangesConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterIpAllocationPolicyAdditionalPodRangesConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__55fbe27f848c40e9b6d0f5323607953a819ceee923c896022cdc00d337dececb)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ContainerClusterIpAllocationPolicyOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterIpAllocationPolicyOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__11b75519f866737d8a5444dd8b7d0eea2fe21007f173e06efc02a9d315313911)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putAdditionalIpRangesConfig")
    def put_additional_ip_ranges_config(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ContainerClusterIpAllocationPolicyAdditionalIpRangesConfig, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ae9813d02888749790c14be240524df40ce48d7560344b8b931d79ef97911fc7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putAdditionalIpRangesConfig", [value]))

    @jsii.member(jsii_name="putAdditionalPodRangesConfig")
    def put_additional_pod_ranges_config(
        self,
        *,
        pod_range_names: typing.Sequence[builtins.str],
    ) -> None:
        '''
        :param pod_range_names: Name for pod secondary ipv4 range which has the actual range defined ahead. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#pod_range_names ContainerCluster#pod_range_names}
        '''
        value = ContainerClusterIpAllocationPolicyAdditionalPodRangesConfig(
            pod_range_names=pod_range_names
        )

        return typing.cast(None, jsii.invoke(self, "putAdditionalPodRangesConfig", [value]))

    @jsii.member(jsii_name="putPodCidrOverprovisionConfig")
    def put_pod_cidr_overprovision_config(
        self,
        *,
        disabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param disabled: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#disabled ContainerCluster#disabled}.
        '''
        value = ContainerClusterIpAllocationPolicyPodCidrOverprovisionConfig(
            disabled=disabled
        )

        return typing.cast(None, jsii.invoke(self, "putPodCidrOverprovisionConfig", [value]))

    @jsii.member(jsii_name="resetAdditionalIpRangesConfig")
    def reset_additional_ip_ranges_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAdditionalIpRangesConfig", []))

    @jsii.member(jsii_name="resetAdditionalPodRangesConfig")
    def reset_additional_pod_ranges_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAdditionalPodRangesConfig", []))

    @jsii.member(jsii_name="resetClusterIpv4CidrBlock")
    def reset_cluster_ipv4_cidr_block(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetClusterIpv4CidrBlock", []))

    @jsii.member(jsii_name="resetClusterSecondaryRangeName")
    def reset_cluster_secondary_range_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetClusterSecondaryRangeName", []))

    @jsii.member(jsii_name="resetPodCidrOverprovisionConfig")
    def reset_pod_cidr_overprovision_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPodCidrOverprovisionConfig", []))

    @jsii.member(jsii_name="resetServicesIpv4CidrBlock")
    def reset_services_ipv4_cidr_block(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetServicesIpv4CidrBlock", []))

    @jsii.member(jsii_name="resetServicesSecondaryRangeName")
    def reset_services_secondary_range_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetServicesSecondaryRangeName", []))

    @jsii.member(jsii_name="resetStackType")
    def reset_stack_type(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetStackType", []))

    @builtins.property
    @jsii.member(jsii_name="additionalIpRangesConfig")
    def additional_ip_ranges_config(
        self,
    ) -> ContainerClusterIpAllocationPolicyAdditionalIpRangesConfigList:
        return typing.cast(ContainerClusterIpAllocationPolicyAdditionalIpRangesConfigList, jsii.get(self, "additionalIpRangesConfig"))

    @builtins.property
    @jsii.member(jsii_name="additionalPodRangesConfig")
    def additional_pod_ranges_config(
        self,
    ) -> ContainerClusterIpAllocationPolicyAdditionalPodRangesConfigOutputReference:
        return typing.cast(ContainerClusterIpAllocationPolicyAdditionalPodRangesConfigOutputReference, jsii.get(self, "additionalPodRangesConfig"))

    @builtins.property
    @jsii.member(jsii_name="podCidrOverprovisionConfig")
    def pod_cidr_overprovision_config(
        self,
    ) -> "ContainerClusterIpAllocationPolicyPodCidrOverprovisionConfigOutputReference":
        return typing.cast("ContainerClusterIpAllocationPolicyPodCidrOverprovisionConfigOutputReference", jsii.get(self, "podCidrOverprovisionConfig"))

    @builtins.property
    @jsii.member(jsii_name="additionalIpRangesConfigInput")
    def additional_ip_ranges_config_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterIpAllocationPolicyAdditionalIpRangesConfig]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterIpAllocationPolicyAdditionalIpRangesConfig]]], jsii.get(self, "additionalIpRangesConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="additionalPodRangesConfigInput")
    def additional_pod_ranges_config_input(
        self,
    ) -> typing.Optional[ContainerClusterIpAllocationPolicyAdditionalPodRangesConfig]:
        return typing.cast(typing.Optional[ContainerClusterIpAllocationPolicyAdditionalPodRangesConfig], jsii.get(self, "additionalPodRangesConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="clusterIpv4CidrBlockInput")
    def cluster_ipv4_cidr_block_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "clusterIpv4CidrBlockInput"))

    @builtins.property
    @jsii.member(jsii_name="clusterSecondaryRangeNameInput")
    def cluster_secondary_range_name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "clusterSecondaryRangeNameInput"))

    @builtins.property
    @jsii.member(jsii_name="podCidrOverprovisionConfigInput")
    def pod_cidr_overprovision_config_input(
        self,
    ) -> typing.Optional["ContainerClusterIpAllocationPolicyPodCidrOverprovisionConfig"]:
        return typing.cast(typing.Optional["ContainerClusterIpAllocationPolicyPodCidrOverprovisionConfig"], jsii.get(self, "podCidrOverprovisionConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="servicesIpv4CidrBlockInput")
    def services_ipv4_cidr_block_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "servicesIpv4CidrBlockInput"))

    @builtins.property
    @jsii.member(jsii_name="servicesSecondaryRangeNameInput")
    def services_secondary_range_name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "servicesSecondaryRangeNameInput"))

    @builtins.property
    @jsii.member(jsii_name="stackTypeInput")
    def stack_type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "stackTypeInput"))

    @builtins.property
    @jsii.member(jsii_name="clusterIpv4CidrBlock")
    def cluster_ipv4_cidr_block(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "clusterIpv4CidrBlock"))

    @cluster_ipv4_cidr_block.setter
    def cluster_ipv4_cidr_block(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d2e6d52678821d732a0e3e2f35ae74e543d4ccd885626d9100e237c470acedc7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "clusterIpv4CidrBlock", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="clusterSecondaryRangeName")
    def cluster_secondary_range_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "clusterSecondaryRangeName"))

    @cluster_secondary_range_name.setter
    def cluster_secondary_range_name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a053976795ee791290238e6d8a8477c9ead942345736d6a3a0f22f4056120542)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "clusterSecondaryRangeName", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="servicesIpv4CidrBlock")
    def services_ipv4_cidr_block(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "servicesIpv4CidrBlock"))

    @services_ipv4_cidr_block.setter
    def services_ipv4_cidr_block(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bca27133200ea17c6b362823da2f4c84bae6373275f817501f07e59f5b1849c3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "servicesIpv4CidrBlock", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="servicesSecondaryRangeName")
    def services_secondary_range_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "servicesSecondaryRangeName"))

    @services_secondary_range_name.setter
    def services_secondary_range_name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__97e8dc2e462a7622a344989ee853fb301bd422519d842a5d3c26fd20764f5296)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "servicesSecondaryRangeName", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="stackType")
    def stack_type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "stackType"))

    @stack_type.setter
    def stack_type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0f85a718f23806dd2898490273a40da7fe87a10d35d2656dc764a2f53e89cd84)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "stackType", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[ContainerClusterIpAllocationPolicy]:
        return typing.cast(typing.Optional[ContainerClusterIpAllocationPolicy], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterIpAllocationPolicy],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ea8674fc107cadc5afd7e6f3952ed350fe0fa3325ee11c9a615466db7c490923)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterIpAllocationPolicyPodCidrOverprovisionConfig",
    jsii_struct_bases=[],
    name_mapping={"disabled": "disabled"},
)
class ContainerClusterIpAllocationPolicyPodCidrOverprovisionConfig:
    def __init__(
        self,
        *,
        disabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param disabled: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#disabled ContainerCluster#disabled}.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__907c3fd004d203ee37b586ea9361981a269e14332717f8fbd0a41f9bb7ef1de6)
            check_type(argname="argument disabled", value=disabled, expected_type=type_hints["disabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "disabled": disabled,
        }

    @builtins.property
    def disabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#disabled ContainerCluster#disabled}.'''
        result = self._values.get("disabled")
        assert result is not None, "Required property 'disabled' is missing"
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterIpAllocationPolicyPodCidrOverprovisionConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterIpAllocationPolicyPodCidrOverprovisionConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterIpAllocationPolicyPodCidrOverprovisionConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2cf0566144b2904576dc2b86ad81bd4a39dcd613cf2a0ca825dc86f3f934e94f)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="disabledInput")
    def disabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "disabledInput"))

    @builtins.property
    @jsii.member(jsii_name="disabled")
    def disabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "disabled"))

    @disabled.setter
    def disabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cf5496ffb7055b26dc73996209f3f5f042acf2cda2b6168484d4408a3f280587)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "disabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterIpAllocationPolicyPodCidrOverprovisionConfig]:
        return typing.cast(typing.Optional[ContainerClusterIpAllocationPolicyPodCidrOverprovisionConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterIpAllocationPolicyPodCidrOverprovisionConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__00665f6cbe8deee0003306461fe5e6a2ac5827738d71d78784d10002f829855b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterLoggingConfig",
    jsii_struct_bases=[],
    name_mapping={"enable_components": "enableComponents"},
)
class ContainerClusterLoggingConfig:
    def __init__(self, *, enable_components: typing.Sequence[builtins.str]) -> None:
        '''
        :param enable_components: GKE components exposing logs. Valid values include SYSTEM_COMPONENTS, APISERVER, CONTROLLER_MANAGER, KCP_CONNECTION, KCP_SSHD, KCP_HPA, SCHEDULER, and WORKLOADS. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_components ContainerCluster#enable_components}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f1d09b4715752fdd3d7ea5d6a71f05b22ddf89b8164a6bc3a51cb78c1a02e5ac)
            check_type(argname="argument enable_components", value=enable_components, expected_type=type_hints["enable_components"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "enable_components": enable_components,
        }

    @builtins.property
    def enable_components(self) -> typing.List[builtins.str]:
        '''GKE components exposing logs. Valid values include SYSTEM_COMPONENTS, APISERVER, CONTROLLER_MANAGER, KCP_CONNECTION, KCP_SSHD, KCP_HPA, SCHEDULER, and WORKLOADS.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_components ContainerCluster#enable_components}
        '''
        result = self._values.get("enable_components")
        assert result is not None, "Required property 'enable_components' is missing"
        return typing.cast(typing.List[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterLoggingConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterLoggingConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterLoggingConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d35f9d6a0af2283b399108fa5615e7274d44be4758522edad591eac4f6739100)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="enableComponentsInput")
    def enable_components_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "enableComponentsInput"))

    @builtins.property
    @jsii.member(jsii_name="enableComponents")
    def enable_components(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "enableComponents"))

    @enable_components.setter
    def enable_components(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d828e9a97639b895a439d4987309b5fdb19e2eb48953f26ac58d8c381061f5b5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableComponents", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[ContainerClusterLoggingConfig]:
        return typing.cast(typing.Optional[ContainerClusterLoggingConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterLoggingConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e30ab8d5171bf9f3b30d1ebfed57301771a4061e1e1b983a9831eec901724bb2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterMaintenancePolicy",
    jsii_struct_bases=[],
    name_mapping={
        "daily_maintenance_window": "dailyMaintenanceWindow",
        "maintenance_exclusion": "maintenanceExclusion",
        "recurring_window": "recurringWindow",
    },
)
class ContainerClusterMaintenancePolicy:
    def __init__(
        self,
        *,
        daily_maintenance_window: typing.Optional[typing.Union["ContainerClusterMaintenancePolicyDailyMaintenanceWindow", typing.Dict[builtins.str, typing.Any]]] = None,
        maintenance_exclusion: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ContainerClusterMaintenancePolicyMaintenanceExclusion", typing.Dict[builtins.str, typing.Any]]]]] = None,
        recurring_window: typing.Optional[typing.Union["ContainerClusterMaintenancePolicyRecurringWindow", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param daily_maintenance_window: daily_maintenance_window block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#daily_maintenance_window ContainerCluster#daily_maintenance_window}
        :param maintenance_exclusion: maintenance_exclusion block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#maintenance_exclusion ContainerCluster#maintenance_exclusion}
        :param recurring_window: recurring_window block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#recurring_window ContainerCluster#recurring_window}
        '''
        if isinstance(daily_maintenance_window, dict):
            daily_maintenance_window = ContainerClusterMaintenancePolicyDailyMaintenanceWindow(**daily_maintenance_window)
        if isinstance(recurring_window, dict):
            recurring_window = ContainerClusterMaintenancePolicyRecurringWindow(**recurring_window)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__85e86e040fceb174eee2a58a8eb4b4806c4ce36aed9b0595689073b958d5c84a)
            check_type(argname="argument daily_maintenance_window", value=daily_maintenance_window, expected_type=type_hints["daily_maintenance_window"])
            check_type(argname="argument maintenance_exclusion", value=maintenance_exclusion, expected_type=type_hints["maintenance_exclusion"])
            check_type(argname="argument recurring_window", value=recurring_window, expected_type=type_hints["recurring_window"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if daily_maintenance_window is not None:
            self._values["daily_maintenance_window"] = daily_maintenance_window
        if maintenance_exclusion is not None:
            self._values["maintenance_exclusion"] = maintenance_exclusion
        if recurring_window is not None:
            self._values["recurring_window"] = recurring_window

    @builtins.property
    def daily_maintenance_window(
        self,
    ) -> typing.Optional["ContainerClusterMaintenancePolicyDailyMaintenanceWindow"]:
        '''daily_maintenance_window block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#daily_maintenance_window ContainerCluster#daily_maintenance_window}
        '''
        result = self._values.get("daily_maintenance_window")
        return typing.cast(typing.Optional["ContainerClusterMaintenancePolicyDailyMaintenanceWindow"], result)

    @builtins.property
    def maintenance_exclusion(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ContainerClusterMaintenancePolicyMaintenanceExclusion"]]]:
        '''maintenance_exclusion block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#maintenance_exclusion ContainerCluster#maintenance_exclusion}
        '''
        result = self._values.get("maintenance_exclusion")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ContainerClusterMaintenancePolicyMaintenanceExclusion"]]], result)

    @builtins.property
    def recurring_window(
        self,
    ) -> typing.Optional["ContainerClusterMaintenancePolicyRecurringWindow"]:
        '''recurring_window block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#recurring_window ContainerCluster#recurring_window}
        '''
        result = self._values.get("recurring_window")
        return typing.cast(typing.Optional["ContainerClusterMaintenancePolicyRecurringWindow"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterMaintenancePolicy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterMaintenancePolicyDailyMaintenanceWindow",
    jsii_struct_bases=[],
    name_mapping={"start_time": "startTime"},
)
class ContainerClusterMaintenancePolicyDailyMaintenanceWindow:
    def __init__(self, *, start_time: builtins.str) -> None:
        '''
        :param start_time: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#start_time ContainerCluster#start_time}.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ce4404d63aa1b33e3bcd14975f1f7def2297b13f9f9359b28b9ddeaa951df145)
            check_type(argname="argument start_time", value=start_time, expected_type=type_hints["start_time"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "start_time": start_time,
        }

    @builtins.property
    def start_time(self) -> builtins.str:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#start_time ContainerCluster#start_time}.'''
        result = self._values.get("start_time")
        assert result is not None, "Required property 'start_time' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterMaintenancePolicyDailyMaintenanceWindow(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterMaintenancePolicyDailyMaintenanceWindowOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterMaintenancePolicyDailyMaintenanceWindowOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__65bc866d9fcb2720c072385614d29c4fa364dc93c011f41d44a5d5d08c08fd74)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="duration")
    def duration(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "duration"))

    @builtins.property
    @jsii.member(jsii_name="startTimeInput")
    def start_time_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "startTimeInput"))

    @builtins.property
    @jsii.member(jsii_name="startTime")
    def start_time(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "startTime"))

    @start_time.setter
    def start_time(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2c7c8da9e827ff7e4ed73c3fdfb1fb3f31513357b34798452121634e617bb2e0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "startTime", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterMaintenancePolicyDailyMaintenanceWindow]:
        return typing.cast(typing.Optional[ContainerClusterMaintenancePolicyDailyMaintenanceWindow], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterMaintenancePolicyDailyMaintenanceWindow],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d13091c879afced2b7c59ff4ebb331ca0c3aa239d0934ab9877097c4aa9692f5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterMaintenancePolicyMaintenanceExclusion",
    jsii_struct_bases=[],
    name_mapping={
        "end_time": "endTime",
        "exclusion_name": "exclusionName",
        "start_time": "startTime",
        "exclusion_options": "exclusionOptions",
    },
)
class ContainerClusterMaintenancePolicyMaintenanceExclusion:
    def __init__(
        self,
        *,
        end_time: builtins.str,
        exclusion_name: builtins.str,
        start_time: builtins.str,
        exclusion_options: typing.Optional[typing.Union["ContainerClusterMaintenancePolicyMaintenanceExclusionExclusionOptions", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param end_time: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#end_time ContainerCluster#end_time}.
        :param exclusion_name: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#exclusion_name ContainerCluster#exclusion_name}.
        :param start_time: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#start_time ContainerCluster#start_time}.
        :param exclusion_options: exclusion_options block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#exclusion_options ContainerCluster#exclusion_options}
        '''
        if isinstance(exclusion_options, dict):
            exclusion_options = ContainerClusterMaintenancePolicyMaintenanceExclusionExclusionOptions(**exclusion_options)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__04cc040b8ef035c4322e5e0c555739edacb0c80d1058584bcafa9b365dabd68a)
            check_type(argname="argument end_time", value=end_time, expected_type=type_hints["end_time"])
            check_type(argname="argument exclusion_name", value=exclusion_name, expected_type=type_hints["exclusion_name"])
            check_type(argname="argument start_time", value=start_time, expected_type=type_hints["start_time"])
            check_type(argname="argument exclusion_options", value=exclusion_options, expected_type=type_hints["exclusion_options"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "end_time": end_time,
            "exclusion_name": exclusion_name,
            "start_time": start_time,
        }
        if exclusion_options is not None:
            self._values["exclusion_options"] = exclusion_options

    @builtins.property
    def end_time(self) -> builtins.str:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#end_time ContainerCluster#end_time}.'''
        result = self._values.get("end_time")
        assert result is not None, "Required property 'end_time' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def exclusion_name(self) -> builtins.str:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#exclusion_name ContainerCluster#exclusion_name}.'''
        result = self._values.get("exclusion_name")
        assert result is not None, "Required property 'exclusion_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def start_time(self) -> builtins.str:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#start_time ContainerCluster#start_time}.'''
        result = self._values.get("start_time")
        assert result is not None, "Required property 'start_time' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def exclusion_options(
        self,
    ) -> typing.Optional["ContainerClusterMaintenancePolicyMaintenanceExclusionExclusionOptions"]:
        '''exclusion_options block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#exclusion_options ContainerCluster#exclusion_options}
        '''
        result = self._values.get("exclusion_options")
        return typing.cast(typing.Optional["ContainerClusterMaintenancePolicyMaintenanceExclusionExclusionOptions"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterMaintenancePolicyMaintenanceExclusion(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterMaintenancePolicyMaintenanceExclusionExclusionOptions",
    jsii_struct_bases=[],
    name_mapping={"scope": "scope"},
)
class ContainerClusterMaintenancePolicyMaintenanceExclusionExclusionOptions:
    def __init__(self, *, scope: builtins.str) -> None:
        '''
        :param scope: The scope of automatic upgrades to restrict in the exclusion window. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#scope ContainerCluster#scope}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b3561e0f4f6fb3cd8220551c023272f2ae849bbef4736cfc783d2490ba2843d2)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "scope": scope,
        }

    @builtins.property
    def scope(self) -> builtins.str:
        '''The scope of automatic upgrades to restrict in the exclusion window.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#scope ContainerCluster#scope}
        '''
        result = self._values.get("scope")
        assert result is not None, "Required property 'scope' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterMaintenancePolicyMaintenanceExclusionExclusionOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterMaintenancePolicyMaintenanceExclusionExclusionOptionsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterMaintenancePolicyMaintenanceExclusionExclusionOptionsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__600a65ce65f6c45ad1696ebc8447aad4034972ab4077e22dd23c1aeab9b2b962)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="scopeInput")
    def scope_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "scopeInput"))

    @builtins.property
    @jsii.member(jsii_name="scope")
    def scope(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "scope"))

    @scope.setter
    def scope(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f15411f938956a90e1649f0c769bd0215435d42b0ce9d3241f55bfd2dfad8e17)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "scope", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterMaintenancePolicyMaintenanceExclusionExclusionOptions]:
        return typing.cast(typing.Optional[ContainerClusterMaintenancePolicyMaintenanceExclusionExclusionOptions], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterMaintenancePolicyMaintenanceExclusionExclusionOptions],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8c86904886b506d47ba0eb5dd8ca2fad22092eb3dab94341893e23cb5aeafcd9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ContainerClusterMaintenancePolicyMaintenanceExclusionList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterMaintenancePolicyMaintenanceExclusionList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__afcacc9cd484fbc361de7032aa35fe9b3ee7cf433d9d495427cf9d77c721a085)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ContainerClusterMaintenancePolicyMaintenanceExclusionOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__35178713abd07f5fb7263aac550caf2299170703ddfdd94cb92970d7228db8cc)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ContainerClusterMaintenancePolicyMaintenanceExclusionOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__df0d41c5527270e9b78de139cfc59b63cf8048caaaf76f4d88ad857d3eb4a6c4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8565fec3d3aa636427178e2697dab2b1d059e616056f2b000e86b4d4dd552c62)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__06c611b92bd544d939b4972ba6076cf8044b459a49d9009dad5f0aae412f80c2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterMaintenancePolicyMaintenanceExclusion]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterMaintenancePolicyMaintenanceExclusion]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterMaintenancePolicyMaintenanceExclusion]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__51019af4065118393ad60f78da5079ad3e2977391d8ea47b359b574bfddec91f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ContainerClusterMaintenancePolicyMaintenanceExclusionOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterMaintenancePolicyMaintenanceExclusionOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__63eb1a6abe19edf7f4c43a83cd97f2c8a0a16cdbff5af43e056e8f89dd8ebbbf)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putExclusionOptions")
    def put_exclusion_options(self, *, scope: builtins.str) -> None:
        '''
        :param scope: The scope of automatic upgrades to restrict in the exclusion window. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#scope ContainerCluster#scope}
        '''
        value = ContainerClusterMaintenancePolicyMaintenanceExclusionExclusionOptions(
            scope=scope
        )

        return typing.cast(None, jsii.invoke(self, "putExclusionOptions", [value]))

    @jsii.member(jsii_name="resetExclusionOptions")
    def reset_exclusion_options(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetExclusionOptions", []))

    @builtins.property
    @jsii.member(jsii_name="exclusionOptions")
    def exclusion_options(
        self,
    ) -> ContainerClusterMaintenancePolicyMaintenanceExclusionExclusionOptionsOutputReference:
        return typing.cast(ContainerClusterMaintenancePolicyMaintenanceExclusionExclusionOptionsOutputReference, jsii.get(self, "exclusionOptions"))

    @builtins.property
    @jsii.member(jsii_name="endTimeInput")
    def end_time_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "endTimeInput"))

    @builtins.property
    @jsii.member(jsii_name="exclusionNameInput")
    def exclusion_name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "exclusionNameInput"))

    @builtins.property
    @jsii.member(jsii_name="exclusionOptionsInput")
    def exclusion_options_input(
        self,
    ) -> typing.Optional[ContainerClusterMaintenancePolicyMaintenanceExclusionExclusionOptions]:
        return typing.cast(typing.Optional[ContainerClusterMaintenancePolicyMaintenanceExclusionExclusionOptions], jsii.get(self, "exclusionOptionsInput"))

    @builtins.property
    @jsii.member(jsii_name="startTimeInput")
    def start_time_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "startTimeInput"))

    @builtins.property
    @jsii.member(jsii_name="endTime")
    def end_time(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "endTime"))

    @end_time.setter
    def end_time(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ba4a997bb50bbafab9253ab6b1d62c700377f32ffc02e1414694d9a559020654)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "endTime", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="exclusionName")
    def exclusion_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "exclusionName"))

    @exclusion_name.setter
    def exclusion_name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__511e57219aae2f0a510da1bb72352ee747d602897eba441efd16e632a969d42b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "exclusionName", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="startTime")
    def start_time(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "startTime"))

    @start_time.setter
    def start_time(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0400251c13efede28160ca7e9bb406b431ce2b97c76a43663007b789276c9d74)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "startTime", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterMaintenancePolicyMaintenanceExclusion]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterMaintenancePolicyMaintenanceExclusion]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterMaintenancePolicyMaintenanceExclusion]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__aaabce3faa108a8c5c7315d14edecc6b26b9280e2df56797c18a39847c911e58)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ContainerClusterMaintenancePolicyOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterMaintenancePolicyOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1912b39503a0bb65bd34adf07f1ef91eebf64e987eefee2ad4ff6058b41b1834)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putDailyMaintenanceWindow")
    def put_daily_maintenance_window(self, *, start_time: builtins.str) -> None:
        '''
        :param start_time: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#start_time ContainerCluster#start_time}.
        '''
        value = ContainerClusterMaintenancePolicyDailyMaintenanceWindow(
            start_time=start_time
        )

        return typing.cast(None, jsii.invoke(self, "putDailyMaintenanceWindow", [value]))

    @jsii.member(jsii_name="putMaintenanceExclusion")
    def put_maintenance_exclusion(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ContainerClusterMaintenancePolicyMaintenanceExclusion, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__88246072852858dca0dc1f14f02d611d032264e9ecbc1e355a8794b0b963dfe2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putMaintenanceExclusion", [value]))

    @jsii.member(jsii_name="putRecurringWindow")
    def put_recurring_window(
        self,
        *,
        end_time: builtins.str,
        recurrence: builtins.str,
        start_time: builtins.str,
    ) -> None:
        '''
        :param end_time: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#end_time ContainerCluster#end_time}.
        :param recurrence: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#recurrence ContainerCluster#recurrence}.
        :param start_time: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#start_time ContainerCluster#start_time}.
        '''
        value = ContainerClusterMaintenancePolicyRecurringWindow(
            end_time=end_time, recurrence=recurrence, start_time=start_time
        )

        return typing.cast(None, jsii.invoke(self, "putRecurringWindow", [value]))

    @jsii.member(jsii_name="resetDailyMaintenanceWindow")
    def reset_daily_maintenance_window(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDailyMaintenanceWindow", []))

    @jsii.member(jsii_name="resetMaintenanceExclusion")
    def reset_maintenance_exclusion(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMaintenanceExclusion", []))

    @jsii.member(jsii_name="resetRecurringWindow")
    def reset_recurring_window(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRecurringWindow", []))

    @builtins.property
    @jsii.member(jsii_name="dailyMaintenanceWindow")
    def daily_maintenance_window(
        self,
    ) -> ContainerClusterMaintenancePolicyDailyMaintenanceWindowOutputReference:
        return typing.cast(ContainerClusterMaintenancePolicyDailyMaintenanceWindowOutputReference, jsii.get(self, "dailyMaintenanceWindow"))

    @builtins.property
    @jsii.member(jsii_name="maintenanceExclusion")
    def maintenance_exclusion(
        self,
    ) -> ContainerClusterMaintenancePolicyMaintenanceExclusionList:
        return typing.cast(ContainerClusterMaintenancePolicyMaintenanceExclusionList, jsii.get(self, "maintenanceExclusion"))

    @builtins.property
    @jsii.member(jsii_name="recurringWindow")
    def recurring_window(
        self,
    ) -> "ContainerClusterMaintenancePolicyRecurringWindowOutputReference":
        return typing.cast("ContainerClusterMaintenancePolicyRecurringWindowOutputReference", jsii.get(self, "recurringWindow"))

    @builtins.property
    @jsii.member(jsii_name="dailyMaintenanceWindowInput")
    def daily_maintenance_window_input(
        self,
    ) -> typing.Optional[ContainerClusterMaintenancePolicyDailyMaintenanceWindow]:
        return typing.cast(typing.Optional[ContainerClusterMaintenancePolicyDailyMaintenanceWindow], jsii.get(self, "dailyMaintenanceWindowInput"))

    @builtins.property
    @jsii.member(jsii_name="maintenanceExclusionInput")
    def maintenance_exclusion_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterMaintenancePolicyMaintenanceExclusion]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterMaintenancePolicyMaintenanceExclusion]]], jsii.get(self, "maintenanceExclusionInput"))

    @builtins.property
    @jsii.member(jsii_name="recurringWindowInput")
    def recurring_window_input(
        self,
    ) -> typing.Optional["ContainerClusterMaintenancePolicyRecurringWindow"]:
        return typing.cast(typing.Optional["ContainerClusterMaintenancePolicyRecurringWindow"], jsii.get(self, "recurringWindowInput"))

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[ContainerClusterMaintenancePolicy]:
        return typing.cast(typing.Optional[ContainerClusterMaintenancePolicy], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterMaintenancePolicy],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__67f0ad35f8a6f6fbc4acf00948024aa2e0a2a5a166981b5bf64d8590626caed9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterMaintenancePolicyRecurringWindow",
    jsii_struct_bases=[],
    name_mapping={
        "end_time": "endTime",
        "recurrence": "recurrence",
        "start_time": "startTime",
    },
)
class ContainerClusterMaintenancePolicyRecurringWindow:
    def __init__(
        self,
        *,
        end_time: builtins.str,
        recurrence: builtins.str,
        start_time: builtins.str,
    ) -> None:
        '''
        :param end_time: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#end_time ContainerCluster#end_time}.
        :param recurrence: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#recurrence ContainerCluster#recurrence}.
        :param start_time: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#start_time ContainerCluster#start_time}.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e3d103324de579b4e34d42ac2f8c90c56f97d541c3dee2e1fcecc2b581c22391)
            check_type(argname="argument end_time", value=end_time, expected_type=type_hints["end_time"])
            check_type(argname="argument recurrence", value=recurrence, expected_type=type_hints["recurrence"])
            check_type(argname="argument start_time", value=start_time, expected_type=type_hints["start_time"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "end_time": end_time,
            "recurrence": recurrence,
            "start_time": start_time,
        }

    @builtins.property
    def end_time(self) -> builtins.str:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#end_time ContainerCluster#end_time}.'''
        result = self._values.get("end_time")
        assert result is not None, "Required property 'end_time' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def recurrence(self) -> builtins.str:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#recurrence ContainerCluster#recurrence}.'''
        result = self._values.get("recurrence")
        assert result is not None, "Required property 'recurrence' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def start_time(self) -> builtins.str:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#start_time ContainerCluster#start_time}.'''
        result = self._values.get("start_time")
        assert result is not None, "Required property 'start_time' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterMaintenancePolicyRecurringWindow(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterMaintenancePolicyRecurringWindowOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterMaintenancePolicyRecurringWindowOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9db128fc349e0c249b18320aa00954d6ee982c0ddd52a0d68b0532b2622dfff6)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="endTimeInput")
    def end_time_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "endTimeInput"))

    @builtins.property
    @jsii.member(jsii_name="recurrenceInput")
    def recurrence_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "recurrenceInput"))

    @builtins.property
    @jsii.member(jsii_name="startTimeInput")
    def start_time_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "startTimeInput"))

    @builtins.property
    @jsii.member(jsii_name="endTime")
    def end_time(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "endTime"))

    @end_time.setter
    def end_time(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f84c24eba6534a419c9d20b0bb4ad808aae921eaa91e63469beb2ee98bc186ff)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "endTime", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="recurrence")
    def recurrence(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "recurrence"))

    @recurrence.setter
    def recurrence(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0f3bb7aeec1cee371b184f50ed9bfc71c9713883f3e12d89710563d45833c353)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "recurrence", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="startTime")
    def start_time(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "startTime"))

    @start_time.setter
    def start_time(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2384e075f15f9746b1abe48b35a8cd26bf49a466a22c26d39721e5b37cd4e93d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "startTime", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterMaintenancePolicyRecurringWindow]:
        return typing.cast(typing.Optional[ContainerClusterMaintenancePolicyRecurringWindow], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterMaintenancePolicyRecurringWindow],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__591510413922d594441f7cba9d92c1485aa070ecdcb093af204c794c838d4355)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterMasterAuth",
    jsii_struct_bases=[],
    name_mapping={"client_certificate_config": "clientCertificateConfig"},
)
class ContainerClusterMasterAuth:
    def __init__(
        self,
        *,
        client_certificate_config: typing.Union["ContainerClusterMasterAuthClientCertificateConfig", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''
        :param client_certificate_config: client_certificate_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#client_certificate_config ContainerCluster#client_certificate_config}
        '''
        if isinstance(client_certificate_config, dict):
            client_certificate_config = ContainerClusterMasterAuthClientCertificateConfig(**client_certificate_config)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__968fe97dd5834db895800250ef761af272f871bb557690f7dd131dcdc6517e95)
            check_type(argname="argument client_certificate_config", value=client_certificate_config, expected_type=type_hints["client_certificate_config"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "client_certificate_config": client_certificate_config,
        }

    @builtins.property
    def client_certificate_config(
        self,
    ) -> "ContainerClusterMasterAuthClientCertificateConfig":
        '''client_certificate_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#client_certificate_config ContainerCluster#client_certificate_config}
        '''
        result = self._values.get("client_certificate_config")
        assert result is not None, "Required property 'client_certificate_config' is missing"
        return typing.cast("ContainerClusterMasterAuthClientCertificateConfig", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterMasterAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterMasterAuthClientCertificateConfig",
    jsii_struct_bases=[],
    name_mapping={"issue_client_certificate": "issueClientCertificate"},
)
class ContainerClusterMasterAuthClientCertificateConfig:
    def __init__(
        self,
        *,
        issue_client_certificate: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param issue_client_certificate: Whether client certificate authorization is enabled for this cluster. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#issue_client_certificate ContainerCluster#issue_client_certificate}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d2161a6f2f26a1c4f286d9bb1b59387070bee814b44073b9c9a92c39a4128a61)
            check_type(argname="argument issue_client_certificate", value=issue_client_certificate, expected_type=type_hints["issue_client_certificate"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "issue_client_certificate": issue_client_certificate,
        }

    @builtins.property
    def issue_client_certificate(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        '''Whether client certificate authorization is enabled for this cluster.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#issue_client_certificate ContainerCluster#issue_client_certificate}
        '''
        result = self._values.get("issue_client_certificate")
        assert result is not None, "Required property 'issue_client_certificate' is missing"
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterMasterAuthClientCertificateConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterMasterAuthClientCertificateConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterMasterAuthClientCertificateConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9e149c6c9b87a481cab1680b6575aac108dccd98374d10f607383bd2a05398b9)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="issueClientCertificateInput")
    def issue_client_certificate_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "issueClientCertificateInput"))

    @builtins.property
    @jsii.member(jsii_name="issueClientCertificate")
    def issue_client_certificate(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "issueClientCertificate"))

    @issue_client_certificate.setter
    def issue_client_certificate(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__daaabc6e99fd723a1eccdfbc94f1e90986d9414c112b10df622415e4310169e3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "issueClientCertificate", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterMasterAuthClientCertificateConfig]:
        return typing.cast(typing.Optional[ContainerClusterMasterAuthClientCertificateConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterMasterAuthClientCertificateConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fd4bfc5857afb5732ced1a0d66268dc78a8add8f3b5ca913ca633e697a189cc1)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ContainerClusterMasterAuthOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterMasterAuthOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__016d715602ebc797c5c130863ab6295d589e26a1a79050e42aac509dc6ef431c)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putClientCertificateConfig")
    def put_client_certificate_config(
        self,
        *,
        issue_client_certificate: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param issue_client_certificate: Whether client certificate authorization is enabled for this cluster. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#issue_client_certificate ContainerCluster#issue_client_certificate}
        '''
        value = ContainerClusterMasterAuthClientCertificateConfig(
            issue_client_certificate=issue_client_certificate
        )

        return typing.cast(None, jsii.invoke(self, "putClientCertificateConfig", [value]))

    @builtins.property
    @jsii.member(jsii_name="clientCertificate")
    def client_certificate(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "clientCertificate"))

    @builtins.property
    @jsii.member(jsii_name="clientCertificateConfig")
    def client_certificate_config(
        self,
    ) -> ContainerClusterMasterAuthClientCertificateConfigOutputReference:
        return typing.cast(ContainerClusterMasterAuthClientCertificateConfigOutputReference, jsii.get(self, "clientCertificateConfig"))

    @builtins.property
    @jsii.member(jsii_name="clientKey")
    def client_key(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "clientKey"))

    @builtins.property
    @jsii.member(jsii_name="clusterCaCertificate")
    def cluster_ca_certificate(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "clusterCaCertificate"))

    @builtins.property
    @jsii.member(jsii_name="clientCertificateConfigInput")
    def client_certificate_config_input(
        self,
    ) -> typing.Optional[ContainerClusterMasterAuthClientCertificateConfig]:
        return typing.cast(typing.Optional[ContainerClusterMasterAuthClientCertificateConfig], jsii.get(self, "clientCertificateConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[ContainerClusterMasterAuth]:
        return typing.cast(typing.Optional[ContainerClusterMasterAuth], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterMasterAuth],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__22c725bca29b2261fd094ce699f851a117ce80cd63cfe9a79de9be95bdbda136)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterMasterAuthorizedNetworksConfig",
    jsii_struct_bases=[],
    name_mapping={
        "cidr_blocks": "cidrBlocks",
        "gcp_public_cidrs_access_enabled": "gcpPublicCidrsAccessEnabled",
        "private_endpoint_enforcement_enabled": "privateEndpointEnforcementEnabled",
    },
)
class ContainerClusterMasterAuthorizedNetworksConfig:
    def __init__(
        self,
        *,
        cidr_blocks: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ContainerClusterMasterAuthorizedNetworksConfigCidrBlocks", typing.Dict[builtins.str, typing.Any]]]]] = None,
        gcp_public_cidrs_access_enabled: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        private_endpoint_enforcement_enabled: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    ) -> None:
        '''
        :param cidr_blocks: cidr_blocks block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cidr_blocks ContainerCluster#cidr_blocks}
        :param gcp_public_cidrs_access_enabled: Whether Kubernetes master is accessible via Google Compute Engine Public IPs. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gcp_public_cidrs_access_enabled ContainerCluster#gcp_public_cidrs_access_enabled}
        :param private_endpoint_enforcement_enabled: Whether authorized networks is enforced on the private endpoint or not. Defaults to false. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#private_endpoint_enforcement_enabled ContainerCluster#private_endpoint_enforcement_enabled}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__32f3ad8ce6e91df3db7d74e3463a91e10fb984b33b36d0c7080c67b6faa322bc)
            check_type(argname="argument cidr_blocks", value=cidr_blocks, expected_type=type_hints["cidr_blocks"])
            check_type(argname="argument gcp_public_cidrs_access_enabled", value=gcp_public_cidrs_access_enabled, expected_type=type_hints["gcp_public_cidrs_access_enabled"])
            check_type(argname="argument private_endpoint_enforcement_enabled", value=private_endpoint_enforcement_enabled, expected_type=type_hints["private_endpoint_enforcement_enabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if cidr_blocks is not None:
            self._values["cidr_blocks"] = cidr_blocks
        if gcp_public_cidrs_access_enabled is not None:
            self._values["gcp_public_cidrs_access_enabled"] = gcp_public_cidrs_access_enabled
        if private_endpoint_enforcement_enabled is not None:
            self._values["private_endpoint_enforcement_enabled"] = private_endpoint_enforcement_enabled

    @builtins.property
    def cidr_blocks(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ContainerClusterMasterAuthorizedNetworksConfigCidrBlocks"]]]:
        '''cidr_blocks block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cidr_blocks ContainerCluster#cidr_blocks}
        '''
        result = self._values.get("cidr_blocks")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ContainerClusterMasterAuthorizedNetworksConfigCidrBlocks"]]], result)

    @builtins.property
    def gcp_public_cidrs_access_enabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Whether Kubernetes master is accessible via Google Compute Engine Public IPs.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gcp_public_cidrs_access_enabled ContainerCluster#gcp_public_cidrs_access_enabled}
        '''
        result = self._values.get("gcp_public_cidrs_access_enabled")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def private_endpoint_enforcement_enabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Whether authorized networks is enforced on the private endpoint or not. Defaults to false.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#private_endpoint_enforcement_enabled ContainerCluster#private_endpoint_enforcement_enabled}
        '''
        result = self._values.get("private_endpoint_enforcement_enabled")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterMasterAuthorizedNetworksConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterMasterAuthorizedNetworksConfigCidrBlocks",
    jsii_struct_bases=[],
    name_mapping={"cidr_block": "cidrBlock", "display_name": "displayName"},
)
class ContainerClusterMasterAuthorizedNetworksConfigCidrBlocks:
    def __init__(
        self,
        *,
        cidr_block: builtins.str,
        display_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param cidr_block: External network that can access Kubernetes master through HTTPS. Must be specified in CIDR notation. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cidr_block ContainerCluster#cidr_block}
        :param display_name: Field for users to identify CIDR blocks. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#display_name ContainerCluster#display_name}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6f530592e6029be37494b2762be789c9cdb1933c3a1ae623d0912fdfa823bf77)
            check_type(argname="argument cidr_block", value=cidr_block, expected_type=type_hints["cidr_block"])
            check_type(argname="argument display_name", value=display_name, expected_type=type_hints["display_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "cidr_block": cidr_block,
        }
        if display_name is not None:
            self._values["display_name"] = display_name

    @builtins.property
    def cidr_block(self) -> builtins.str:
        '''External network that can access Kubernetes master through HTTPS. Must be specified in CIDR notation.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cidr_block ContainerCluster#cidr_block}
        '''
        result = self._values.get("cidr_block")
        assert result is not None, "Required property 'cidr_block' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def display_name(self) -> typing.Optional[builtins.str]:
        '''Field for users to identify CIDR blocks.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#display_name ContainerCluster#display_name}
        '''
        result = self._values.get("display_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterMasterAuthorizedNetworksConfigCidrBlocks(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterMasterAuthorizedNetworksConfigCidrBlocksList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterMasterAuthorizedNetworksConfigCidrBlocksList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f0939365b520ae951104c295b4787984444f0f14a41ec618af91854e90be1afb)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ContainerClusterMasterAuthorizedNetworksConfigCidrBlocksOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dbf8407230043669fd46ae610e995897f6862babb21429d492ef85011eee2627)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ContainerClusterMasterAuthorizedNetworksConfigCidrBlocksOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1a71600061d2dfd54a519638376e16c5821119f9f9bef5d791d32a0c3d9c3452)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d64fc636eaeccca6794fdb4432e4c7122601de8d66a893c425c3f99689664c5f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cf6e3b39b586f86a34c8a96aa7b2e8486fc3122567db58d8717016cee3e19770)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterMasterAuthorizedNetworksConfigCidrBlocks]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterMasterAuthorizedNetworksConfigCidrBlocks]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterMasterAuthorizedNetworksConfigCidrBlocks]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9b99774016051e3e7a23fb255ebd6f31071106728c404d103ceb5f344d773f8e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ContainerClusterMasterAuthorizedNetworksConfigCidrBlocksOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterMasterAuthorizedNetworksConfigCidrBlocksOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__08c499c5ed3f1edfc969f398190bf2053cbaf8fdae4233f420976678ad0d200d)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="resetDisplayName")
    def reset_display_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDisplayName", []))

    @builtins.property
    @jsii.member(jsii_name="cidrBlockInput")
    def cidr_block_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "cidrBlockInput"))

    @builtins.property
    @jsii.member(jsii_name="displayNameInput")
    def display_name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "displayNameInput"))

    @builtins.property
    @jsii.member(jsii_name="cidrBlock")
    def cidr_block(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "cidrBlock"))

    @cidr_block.setter
    def cidr_block(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ded229e793d9768fc768cc02886a0fe259ae335079e2bcf17ed34b437430cc57)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "cidrBlock", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="displayName")
    def display_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "displayName"))

    @display_name.setter
    def display_name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b633fd3f1667bef0e5e0b7a2c69159de8c03ecad2d27ae6ca9b849ec2de1e1c1)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "displayName", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterMasterAuthorizedNetworksConfigCidrBlocks]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterMasterAuthorizedNetworksConfigCidrBlocks]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterMasterAuthorizedNetworksConfigCidrBlocks]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__692d208b2fac89bb9b63cb01e4e418719861be04a0467054616c1c1a70abdba4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ContainerClusterMasterAuthorizedNetworksConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterMasterAuthorizedNetworksConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__222a6a47e1902d37d8589ca25cae3f893f07f8023f4932cd12a0c6d49208b766)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putCidrBlocks")
    def put_cidr_blocks(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ContainerClusterMasterAuthorizedNetworksConfigCidrBlocks, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7171fbe7f2297fb504b96290326e963f326ed86a700f19a187698f91c0224f91)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putCidrBlocks", [value]))

    @jsii.member(jsii_name="resetCidrBlocks")
    def reset_cidr_blocks(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCidrBlocks", []))

    @jsii.member(jsii_name="resetGcpPublicCidrsAccessEnabled")
    def reset_gcp_public_cidrs_access_enabled(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGcpPublicCidrsAccessEnabled", []))

    @jsii.member(jsii_name="resetPrivateEndpointEnforcementEnabled")
    def reset_private_endpoint_enforcement_enabled(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPrivateEndpointEnforcementEnabled", []))

    @builtins.property
    @jsii.member(jsii_name="cidrBlocks")
    def cidr_blocks(
        self,
    ) -> ContainerClusterMasterAuthorizedNetworksConfigCidrBlocksList:
        return typing.cast(ContainerClusterMasterAuthorizedNetworksConfigCidrBlocksList, jsii.get(self, "cidrBlocks"))

    @builtins.property
    @jsii.member(jsii_name="cidrBlocksInput")
    def cidr_blocks_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterMasterAuthorizedNetworksConfigCidrBlocks]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterMasterAuthorizedNetworksConfigCidrBlocks]]], jsii.get(self, "cidrBlocksInput"))

    @builtins.property
    @jsii.member(jsii_name="gcpPublicCidrsAccessEnabledInput")
    def gcp_public_cidrs_access_enabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "gcpPublicCidrsAccessEnabledInput"))

    @builtins.property
    @jsii.member(jsii_name="privateEndpointEnforcementEnabledInput")
    def private_endpoint_enforcement_enabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "privateEndpointEnforcementEnabledInput"))

    @builtins.property
    @jsii.member(jsii_name="gcpPublicCidrsAccessEnabled")
    def gcp_public_cidrs_access_enabled(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "gcpPublicCidrsAccessEnabled"))

    @gcp_public_cidrs_access_enabled.setter
    def gcp_public_cidrs_access_enabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fa3ebdb87ccaeacac2717ca6311ae34c865874bf394033b3d3a7462d489c7c82)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "gcpPublicCidrsAccessEnabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="privateEndpointEnforcementEnabled")
    def private_endpoint_enforcement_enabled(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "privateEndpointEnforcementEnabled"))

    @private_endpoint_enforcement_enabled.setter
    def private_endpoint_enforcement_enabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6466b7b570f5d1db754dae8a755c69a2db111dba47118687031c47462eb7cde2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "privateEndpointEnforcementEnabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterMasterAuthorizedNetworksConfig]:
        return typing.cast(typing.Optional[ContainerClusterMasterAuthorizedNetworksConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterMasterAuthorizedNetworksConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2c5ce0e36b2047a6a2534918a355243edde20a442de3b0dd9a41790f9c07a5dc)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterMeshCertificates",
    jsii_struct_bases=[],
    name_mapping={"enable_certificates": "enableCertificates"},
)
class ContainerClusterMeshCertificates:
    def __init__(
        self,
        *,
        enable_certificates: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param enable_certificates: When enabled the GKE Workload Identity Certificates controller and node agent will be deployed in the cluster. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_certificates ContainerCluster#enable_certificates}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7437f2259f2fc7a0f3f0acec8a169ac131aeea3bdce3341755da2ada077ac18b)
            check_type(argname="argument enable_certificates", value=enable_certificates, expected_type=type_hints["enable_certificates"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "enable_certificates": enable_certificates,
        }

    @builtins.property
    def enable_certificates(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        '''When enabled the GKE Workload Identity Certificates controller and node agent will be deployed in the cluster.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_certificates ContainerCluster#enable_certificates}
        '''
        result = self._values.get("enable_certificates")
        assert result is not None, "Required property 'enable_certificates' is missing"
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterMeshCertificates(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterMeshCertificatesOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterMeshCertificatesOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__318aa1e1a871b6abe5c54656c5590768596c12d1e9c10a24ddfb0642a8eb1916)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="enableCertificatesInput")
    def enable_certificates_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enableCertificatesInput"))

    @builtins.property
    @jsii.member(jsii_name="enableCertificates")
    def enable_certificates(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enableCertificates"))

    @enable_certificates.setter
    def enable_certificates(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__530cb3a266a6cf0e0fd6e5fa13e10d00220f5db4192c707aa4774b25528c1096)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableCertificates", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[ContainerClusterMeshCertificates]:
        return typing.cast(typing.Optional[ContainerClusterMeshCertificates], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterMeshCertificates],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__67375068bcad5601fb6daef18245f06e1be8a8bd09939dec1bf6bfbd69fdaf4e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterMonitoringConfig",
    jsii_struct_bases=[],
    name_mapping={
        "advanced_datapath_observability_config": "advancedDatapathObservabilityConfig",
        "enable_components": "enableComponents",
        "managed_prometheus": "managedPrometheus",
    },
)
class ContainerClusterMonitoringConfig:
    def __init__(
        self,
        *,
        advanced_datapath_observability_config: typing.Optional[typing.Union["ContainerClusterMonitoringConfigAdvancedDatapathObservabilityConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        enable_components: typing.Optional[typing.Sequence[builtins.str]] = None,
        managed_prometheus: typing.Optional[typing.Union["ContainerClusterMonitoringConfigManagedPrometheus", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param advanced_datapath_observability_config: advanced_datapath_observability_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#advanced_datapath_observability_config ContainerCluster#advanced_datapath_observability_config}
        :param enable_components: GKE components exposing metrics. Valid values include SYSTEM_COMPONENTS, APISERVER, SCHEDULER, CONTROLLER_MANAGER, STORAGE, HPA, POD, DAEMONSET, DEPLOYMENT, STATEFULSET, KUBELET, CADVISOR, DCGM and JOBSET. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_components ContainerCluster#enable_components}
        :param managed_prometheus: managed_prometheus block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#managed_prometheus ContainerCluster#managed_prometheus}
        '''
        if isinstance(advanced_datapath_observability_config, dict):
            advanced_datapath_observability_config = ContainerClusterMonitoringConfigAdvancedDatapathObservabilityConfig(**advanced_datapath_observability_config)
        if isinstance(managed_prometheus, dict):
            managed_prometheus = ContainerClusterMonitoringConfigManagedPrometheus(**managed_prometheus)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d13e042cc0983ab440c8f25b5617c09f9dba19dd3a974a078ab8f066100b1a0e)
            check_type(argname="argument advanced_datapath_observability_config", value=advanced_datapath_observability_config, expected_type=type_hints["advanced_datapath_observability_config"])
            check_type(argname="argument enable_components", value=enable_components, expected_type=type_hints["enable_components"])
            check_type(argname="argument managed_prometheus", value=managed_prometheus, expected_type=type_hints["managed_prometheus"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if advanced_datapath_observability_config is not None:
            self._values["advanced_datapath_observability_config"] = advanced_datapath_observability_config
        if enable_components is not None:
            self._values["enable_components"] = enable_components
        if managed_prometheus is not None:
            self._values["managed_prometheus"] = managed_prometheus

    @builtins.property
    def advanced_datapath_observability_config(
        self,
    ) -> typing.Optional["ContainerClusterMonitoringConfigAdvancedDatapathObservabilityConfig"]:
        '''advanced_datapath_observability_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#advanced_datapath_observability_config ContainerCluster#advanced_datapath_observability_config}
        '''
        result = self._values.get("advanced_datapath_observability_config")
        return typing.cast(typing.Optional["ContainerClusterMonitoringConfigAdvancedDatapathObservabilityConfig"], result)

    @builtins.property
    def enable_components(self) -> typing.Optional[typing.List[builtins.str]]:
        '''GKE components exposing metrics.

        Valid values include SYSTEM_COMPONENTS, APISERVER, SCHEDULER, CONTROLLER_MANAGER, STORAGE, HPA, POD, DAEMONSET, DEPLOYMENT, STATEFULSET, KUBELET, CADVISOR, DCGM and JOBSET.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_components ContainerCluster#enable_components}
        '''
        result = self._values.get("enable_components")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def managed_prometheus(
        self,
    ) -> typing.Optional["ContainerClusterMonitoringConfigManagedPrometheus"]:
        '''managed_prometheus block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#managed_prometheus ContainerCluster#managed_prometheus}
        '''
        result = self._values.get("managed_prometheus")
        return typing.cast(typing.Optional["ContainerClusterMonitoringConfigManagedPrometheus"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterMonitoringConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterMonitoringConfigAdvancedDatapathObservabilityConfig",
    jsii_struct_bases=[],
    name_mapping={"enable_metrics": "enableMetrics", "enable_relay": "enableRelay"},
)
class ContainerClusterMonitoringConfigAdvancedDatapathObservabilityConfig:
    def __init__(
        self,
        *,
        enable_metrics: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
        enable_relay: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param enable_metrics: Whether or not the advanced datapath metrics are enabled. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_metrics ContainerCluster#enable_metrics}
        :param enable_relay: Whether or not Relay is enabled. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_relay ContainerCluster#enable_relay}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__87236b98735081096d9dbd991112ea1fbecdd7f8d800e972639ef47c190c0f16)
            check_type(argname="argument enable_metrics", value=enable_metrics, expected_type=type_hints["enable_metrics"])
            check_type(argname="argument enable_relay", value=enable_relay, expected_type=type_hints["enable_relay"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "enable_metrics": enable_metrics,
            "enable_relay": enable_relay,
        }

    @builtins.property
    def enable_metrics(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        '''Whether or not the advanced datapath metrics are enabled.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_metrics ContainerCluster#enable_metrics}
        '''
        result = self._values.get("enable_metrics")
        assert result is not None, "Required property 'enable_metrics' is missing"
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], result)

    @builtins.property
    def enable_relay(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        '''Whether or not Relay is enabled.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_relay ContainerCluster#enable_relay}
        '''
        result = self._values.get("enable_relay")
        assert result is not None, "Required property 'enable_relay' is missing"
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterMonitoringConfigAdvancedDatapathObservabilityConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterMonitoringConfigAdvancedDatapathObservabilityConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterMonitoringConfigAdvancedDatapathObservabilityConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f120ad08aecbde74c7f30c6015fccf960d2022fd9b9542985a9dda8f93f203b0)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="enableMetricsInput")
    def enable_metrics_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enableMetricsInput"))

    @builtins.property
    @jsii.member(jsii_name="enableRelayInput")
    def enable_relay_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enableRelayInput"))

    @builtins.property
    @jsii.member(jsii_name="enableMetrics")
    def enable_metrics(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enableMetrics"))

    @enable_metrics.setter
    def enable_metrics(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c35a065fc36701963a8bea5a7630a089be6cd4dc4689acc90d658162fb0f13eb)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableMetrics", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="enableRelay")
    def enable_relay(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enableRelay"))

    @enable_relay.setter
    def enable_relay(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__32e8248060a9d87747e21bb1f628a0d5fd55c1063116413ce86c6732899fd985)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableRelay", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterMonitoringConfigAdvancedDatapathObservabilityConfig]:
        return typing.cast(typing.Optional[ContainerClusterMonitoringConfigAdvancedDatapathObservabilityConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterMonitoringConfigAdvancedDatapathObservabilityConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4fc22ba6f17891a567fd0c98aee2be09d015172105e7c7df32b4d7c5912e7020)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterMonitoringConfigManagedPrometheus",
    jsii_struct_bases=[],
    name_mapping={
        "enabled": "enabled",
        "auto_monitoring_config": "autoMonitoringConfig",
    },
)
class ContainerClusterMonitoringConfigManagedPrometheus:
    def __init__(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
        auto_monitoring_config: typing.Optional[typing.Union["ContainerClusterMonitoringConfigManagedPrometheusAutoMonitoringConfig", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param enabled: Whether or not the managed collection is enabled. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        :param auto_monitoring_config: auto_monitoring_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#auto_monitoring_config ContainerCluster#auto_monitoring_config}
        '''
        if isinstance(auto_monitoring_config, dict):
            auto_monitoring_config = ContainerClusterMonitoringConfigManagedPrometheusAutoMonitoringConfig(**auto_monitoring_config)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ce1ece3de3c33954c9ed5ebe2dec28b8787ad86fa496ecc450352c7460e5410a)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
            check_type(argname="argument auto_monitoring_config", value=auto_monitoring_config, expected_type=type_hints["auto_monitoring_config"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "enabled": enabled,
        }
        if auto_monitoring_config is not None:
            self._values["auto_monitoring_config"] = auto_monitoring_config

    @builtins.property
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        '''Whether or not the managed collection is enabled.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        '''
        result = self._values.get("enabled")
        assert result is not None, "Required property 'enabled' is missing"
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], result)

    @builtins.property
    def auto_monitoring_config(
        self,
    ) -> typing.Optional["ContainerClusterMonitoringConfigManagedPrometheusAutoMonitoringConfig"]:
        '''auto_monitoring_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#auto_monitoring_config ContainerCluster#auto_monitoring_config}
        '''
        result = self._values.get("auto_monitoring_config")
        return typing.cast(typing.Optional["ContainerClusterMonitoringConfigManagedPrometheusAutoMonitoringConfig"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterMonitoringConfigManagedPrometheus(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterMonitoringConfigManagedPrometheusAutoMonitoringConfig",
    jsii_struct_bases=[],
    name_mapping={"scope": "scope"},
)
class ContainerClusterMonitoringConfigManagedPrometheusAutoMonitoringConfig:
    def __init__(self, *, scope: builtins.str) -> None:
        '''
        :param scope: The scope of auto-monitoring. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#scope ContainerCluster#scope}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cec1671713fc86719cb92f6e45257fd2029219f1f724630c46b3356f3b67838b)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "scope": scope,
        }

    @builtins.property
    def scope(self) -> builtins.str:
        '''The scope of auto-monitoring.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#scope ContainerCluster#scope}
        '''
        result = self._values.get("scope")
        assert result is not None, "Required property 'scope' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterMonitoringConfigManagedPrometheusAutoMonitoringConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterMonitoringConfigManagedPrometheusAutoMonitoringConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterMonitoringConfigManagedPrometheusAutoMonitoringConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6ccab2cb0ecddad078c2daeb63496cef569b33636e936ba96c62a18ee8a5feb3)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="scopeInput")
    def scope_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "scopeInput"))

    @builtins.property
    @jsii.member(jsii_name="scope")
    def scope(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "scope"))

    @scope.setter
    def scope(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6f2f548b779a87dea8e74b31a3b612c68a3f04383d728087eef9f28dadda5343)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "scope", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterMonitoringConfigManagedPrometheusAutoMonitoringConfig]:
        return typing.cast(typing.Optional[ContainerClusterMonitoringConfigManagedPrometheusAutoMonitoringConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterMonitoringConfigManagedPrometheusAutoMonitoringConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__362faebf9d74569890520b389340e83f5bb972c6f861971394299a0cfddbf49d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ContainerClusterMonitoringConfigManagedPrometheusOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterMonitoringConfigManagedPrometheusOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2b8e2883bb04f0f48b3458f9b76e670994a149ccb4d26607d94a1afe593f033f)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putAutoMonitoringConfig")
    def put_auto_monitoring_config(self, *, scope: builtins.str) -> None:
        '''
        :param scope: The scope of auto-monitoring. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#scope ContainerCluster#scope}
        '''
        value = ContainerClusterMonitoringConfigManagedPrometheusAutoMonitoringConfig(
            scope=scope
        )

        return typing.cast(None, jsii.invoke(self, "putAutoMonitoringConfig", [value]))

    @jsii.member(jsii_name="resetAutoMonitoringConfig")
    def reset_auto_monitoring_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAutoMonitoringConfig", []))

    @builtins.property
    @jsii.member(jsii_name="autoMonitoringConfig")
    def auto_monitoring_config(
        self,
    ) -> ContainerClusterMonitoringConfigManagedPrometheusAutoMonitoringConfigOutputReference:
        return typing.cast(ContainerClusterMonitoringConfigManagedPrometheusAutoMonitoringConfigOutputReference, jsii.get(self, "autoMonitoringConfig"))

    @builtins.property
    @jsii.member(jsii_name="autoMonitoringConfigInput")
    def auto_monitoring_config_input(
        self,
    ) -> typing.Optional[ContainerClusterMonitoringConfigManagedPrometheusAutoMonitoringConfig]:
        return typing.cast(typing.Optional[ContainerClusterMonitoringConfigManagedPrometheusAutoMonitoringConfig], jsii.get(self, "autoMonitoringConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="enabledInput")
    def enabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enabledInput"))

    @builtins.property
    @jsii.member(jsii_name="enabled")
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enabled"))

    @enabled.setter
    def enabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__92637993d44b4b70057b82edf2624928e34501c97c501ec385d4e28fd7c06f19)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterMonitoringConfigManagedPrometheus]:
        return typing.cast(typing.Optional[ContainerClusterMonitoringConfigManagedPrometheus], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterMonitoringConfigManagedPrometheus],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b98dd6537e46d32666df968dafb88bdc7a3d2d9c9b62ef4bfff68a46770df4a4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ContainerClusterMonitoringConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterMonitoringConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4917923504de9de8a2c649aaff32d40e4c2cfeb7d596ff88d9a2eb8f1c478f3f)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putAdvancedDatapathObservabilityConfig")
    def put_advanced_datapath_observability_config(
        self,
        *,
        enable_metrics: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
        enable_relay: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param enable_metrics: Whether or not the advanced datapath metrics are enabled. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_metrics ContainerCluster#enable_metrics}
        :param enable_relay: Whether or not Relay is enabled. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_relay ContainerCluster#enable_relay}
        '''
        value = ContainerClusterMonitoringConfigAdvancedDatapathObservabilityConfig(
            enable_metrics=enable_metrics, enable_relay=enable_relay
        )

        return typing.cast(None, jsii.invoke(self, "putAdvancedDatapathObservabilityConfig", [value]))

    @jsii.member(jsii_name="putManagedPrometheus")
    def put_managed_prometheus(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
        auto_monitoring_config: typing.Optional[typing.Union[ContainerClusterMonitoringConfigManagedPrometheusAutoMonitoringConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param enabled: Whether or not the managed collection is enabled. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        :param auto_monitoring_config: auto_monitoring_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#auto_monitoring_config ContainerCluster#auto_monitoring_config}
        '''
        value = ContainerClusterMonitoringConfigManagedPrometheus(
            enabled=enabled, auto_monitoring_config=auto_monitoring_config
        )

        return typing.cast(None, jsii.invoke(self, "putManagedPrometheus", [value]))

    @jsii.member(jsii_name="resetAdvancedDatapathObservabilityConfig")
    def reset_advanced_datapath_observability_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAdvancedDatapathObservabilityConfig", []))

    @jsii.member(jsii_name="resetEnableComponents")
    def reset_enable_components(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnableComponents", []))

    @jsii.member(jsii_name="resetManagedPrometheus")
    def reset_managed_prometheus(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetManagedPrometheus", []))

    @builtins.property
    @jsii.member(jsii_name="advancedDatapathObservabilityConfig")
    def advanced_datapath_observability_config(
        self,
    ) -> ContainerClusterMonitoringConfigAdvancedDatapathObservabilityConfigOutputReference:
        return typing.cast(ContainerClusterMonitoringConfigAdvancedDatapathObservabilityConfigOutputReference, jsii.get(self, "advancedDatapathObservabilityConfig"))

    @builtins.property
    @jsii.member(jsii_name="managedPrometheus")
    def managed_prometheus(
        self,
    ) -> ContainerClusterMonitoringConfigManagedPrometheusOutputReference:
        return typing.cast(ContainerClusterMonitoringConfigManagedPrometheusOutputReference, jsii.get(self, "managedPrometheus"))

    @builtins.property
    @jsii.member(jsii_name="advancedDatapathObservabilityConfigInput")
    def advanced_datapath_observability_config_input(
        self,
    ) -> typing.Optional[ContainerClusterMonitoringConfigAdvancedDatapathObservabilityConfig]:
        return typing.cast(typing.Optional[ContainerClusterMonitoringConfigAdvancedDatapathObservabilityConfig], jsii.get(self, "advancedDatapathObservabilityConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="enableComponentsInput")
    def enable_components_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "enableComponentsInput"))

    @builtins.property
    @jsii.member(jsii_name="managedPrometheusInput")
    def managed_prometheus_input(
        self,
    ) -> typing.Optional[ContainerClusterMonitoringConfigManagedPrometheus]:
        return typing.cast(typing.Optional[ContainerClusterMonitoringConfigManagedPrometheus], jsii.get(self, "managedPrometheusInput"))

    @builtins.property
    @jsii.member(jsii_name="enableComponents")
    def enable_components(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "enableComponents"))

    @enable_components.setter
    def enable_components(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8b5c512cd5b80b0b74fc0a4f964035d88594dd2fa25390b165fb96c5c38809ec)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableComponents", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[ContainerClusterMonitoringConfig]:
        return typing.cast(typing.Optional[ContainerClusterMonitoringConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterMonitoringConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e34b5cb4937fbdb20e85ee3c1d157599e958264947856d8307872592245980bc)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNetworkPerformanceConfig",
    jsii_struct_bases=[],
    name_mapping={"total_egress_bandwidth_tier": "totalEgressBandwidthTier"},
)
class ContainerClusterNetworkPerformanceConfig:
    def __init__(self, *, total_egress_bandwidth_tier: builtins.str) -> None:
        '''
        :param total_egress_bandwidth_tier: Specifies the total network bandwidth tier for NodePools in the cluster. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#total_egress_bandwidth_tier ContainerCluster#total_egress_bandwidth_tier}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__402e8d15351d6e3309ab425c11e318c87375f8258ef18a9a3b9bea6f82431baa)
            check_type(argname="argument total_egress_bandwidth_tier", value=total_egress_bandwidth_tier, expected_type=type_hints["total_egress_bandwidth_tier"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "total_egress_bandwidth_tier": total_egress_bandwidth_tier,
        }

    @builtins.property
    def total_egress_bandwidth_tier(self) -> builtins.str:
        '''Specifies the total network bandwidth tier for NodePools in the cluster.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#total_egress_bandwidth_tier ContainerCluster#total_egress_bandwidth_tier}
        '''
        result = self._values.get("total_egress_bandwidth_tier")
        assert result is not None, "Required property 'total_egress_bandwidth_tier' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNetworkPerformanceConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNetworkPerformanceConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNetworkPerformanceConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0d02a6d2a9ec82fbd232f0d00926da6904804929be421eb492ce4d69391ff792)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="totalEgressBandwidthTierInput")
    def total_egress_bandwidth_tier_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "totalEgressBandwidthTierInput"))

    @builtins.property
    @jsii.member(jsii_name="totalEgressBandwidthTier")
    def total_egress_bandwidth_tier(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "totalEgressBandwidthTier"))

    @total_egress_bandwidth_tier.setter
    def total_egress_bandwidth_tier(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9684012e2f91af8b004f7c340b9be5e974dce6dbac096836837c9f594291bae5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "totalEgressBandwidthTier", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNetworkPerformanceConfig]:
        return typing.cast(typing.Optional[ContainerClusterNetworkPerformanceConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNetworkPerformanceConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__15d5402addb7dcc981ef855a71a63ccff319d1b647c301be9eaf3c6293da8117)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNetworkPolicy",
    jsii_struct_bases=[],
    name_mapping={"enabled": "enabled", "provider": "provider"},
)
class ContainerClusterNetworkPolicy:
    def __init__(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
        provider: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param enabled: Whether network policy is enabled on the cluster. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        :param provider: The selected network policy provider. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#provider ContainerCluster#provider}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__774f983346304a3a8a094ee9aca160236945223a9f9b714fe1b50465882228f6)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "enabled": enabled,
        }
        if provider is not None:
            self._values["provider"] = provider

    @builtins.property
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        '''Whether network policy is enabled on the cluster.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        '''
        result = self._values.get("enabled")
        assert result is not None, "Required property 'enabled' is missing"
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], result)

    @builtins.property
    def provider(self) -> typing.Optional[builtins.str]:
        '''The selected network policy provider.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#provider ContainerCluster#provider}
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNetworkPolicy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNetworkPolicyOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNetworkPolicyOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__aae757873a58d74781d2c35e39f0983b428b327582f8a7dfad993d3824e01201)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetProvider")
    def reset_provider(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetProvider", []))

    @builtins.property
    @jsii.member(jsii_name="enabledInput")
    def enabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enabledInput"))

    @builtins.property
    @jsii.member(jsii_name="providerInput")
    def provider_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "providerInput"))

    @builtins.property
    @jsii.member(jsii_name="enabled")
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enabled"))

    @enabled.setter
    def enabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f553923b01971069b14a7756e7e871e94a3058b5c432cc08222307bc5879d5df)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="provider")
    def provider(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "provider"))

    @provider.setter
    def provider(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__98a6822dd3d51eaa91290a42b751fb1c54e01fd0e061e494800e6ac65a0c0089)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "provider", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[ContainerClusterNetworkPolicy]:
        return typing.cast(typing.Optional[ContainerClusterNetworkPolicy], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNetworkPolicy],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eda4e6dba835ba2f35b5cf8645181641d125f6b4ee46173eb1432f4e858dc807)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfig",
    jsii_struct_bases=[],
    name_mapping={
        "advanced_machine_features": "advancedMachineFeatures",
        "boot_disk": "bootDisk",
        "boot_disk_kms_key": "bootDiskKmsKey",
        "confidential_nodes": "confidentialNodes",
        "containerd_config": "containerdConfig",
        "disk_size_gb": "diskSizeGb",
        "disk_type": "diskType",
        "enable_confidential_storage": "enableConfidentialStorage",
        "ephemeral_storage_local_ssd_config": "ephemeralStorageLocalSsdConfig",
        "fast_socket": "fastSocket",
        "flex_start": "flexStart",
        "gcfs_config": "gcfsConfig",
        "guest_accelerator": "guestAccelerator",
        "gvnic": "gvnic",
        "host_maintenance_policy": "hostMaintenancePolicy",
        "image_type": "imageType",
        "kubelet_config": "kubeletConfig",
        "labels": "labels",
        "linux_node_config": "linuxNodeConfig",
        "local_nvme_ssd_block_config": "localNvmeSsdBlockConfig",
        "local_ssd_count": "localSsdCount",
        "local_ssd_encryption_mode": "localSsdEncryptionMode",
        "logging_variant": "loggingVariant",
        "machine_type": "machineType",
        "max_run_duration": "maxRunDuration",
        "metadata": "metadata",
        "min_cpu_platform": "minCpuPlatform",
        "node_group": "nodeGroup",
        "oauth_scopes": "oauthScopes",
        "preemptible": "preemptible",
        "reservation_affinity": "reservationAffinity",
        "resource_labels": "resourceLabels",
        "resource_manager_tags": "resourceManagerTags",
        "secondary_boot_disks": "secondaryBootDisks",
        "service_account": "serviceAccount",
        "shielded_instance_config": "shieldedInstanceConfig",
        "sole_tenant_config": "soleTenantConfig",
        "spot": "spot",
        "storage_pools": "storagePools",
        "tags": "tags",
        "taint": "taint",
        "windows_node_config": "windowsNodeConfig",
        "workload_metadata_config": "workloadMetadataConfig",
    },
)
class ContainerClusterNodeConfig:
    def __init__(
        self,
        *,
        advanced_machine_features: typing.Optional[typing.Union["ContainerClusterNodeConfigAdvancedMachineFeatures", typing.Dict[builtins.str, typing.Any]]] = None,
        boot_disk: typing.Optional[typing.Union["ContainerClusterNodeConfigBootDisk", typing.Dict[builtins.str, typing.Any]]] = None,
        boot_disk_kms_key: typing.Optional[builtins.str] = None,
        confidential_nodes: typing.Optional[typing.Union["ContainerClusterNodeConfigConfidentialNodes", typing.Dict[builtins.str, typing.Any]]] = None,
        containerd_config: typing.Optional[typing.Union["ContainerClusterNodeConfigContainerdConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        disk_size_gb: typing.Optional[jsii.Number] = None,
        disk_type: typing.Optional[builtins.str] = None,
        enable_confidential_storage: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        ephemeral_storage_local_ssd_config: typing.Optional[typing.Union["ContainerClusterNodeConfigEphemeralStorageLocalSsdConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        fast_socket: typing.Optional[typing.Union["ContainerClusterNodeConfigFastSocket", typing.Dict[builtins.str, typing.Any]]] = None,
        flex_start: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        gcfs_config: typing.Optional[typing.Union["ContainerClusterNodeConfigGcfsConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        guest_accelerator: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ContainerClusterNodeConfigGuestAccelerator", typing.Dict[builtins.str, typing.Any]]]]] = None,
        gvnic: typing.Optional[typing.Union["ContainerClusterNodeConfigGvnic", typing.Dict[builtins.str, typing.Any]]] = None,
        host_maintenance_policy: typing.Optional[typing.Union["ContainerClusterNodeConfigHostMaintenancePolicy", typing.Dict[builtins.str, typing.Any]]] = None,
        image_type: typing.Optional[builtins.str] = None,
        kubelet_config: typing.Optional[typing.Union["ContainerClusterNodeConfigKubeletConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        linux_node_config: typing.Optional[typing.Union["ContainerClusterNodeConfigLinuxNodeConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        local_nvme_ssd_block_config: typing.Optional[typing.Union["ContainerClusterNodeConfigLocalNvmeSsdBlockConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        local_ssd_count: typing.Optional[jsii.Number] = None,
        local_ssd_encryption_mode: typing.Optional[builtins.str] = None,
        logging_variant: typing.Optional[builtins.str] = None,
        machine_type: typing.Optional[builtins.str] = None,
        max_run_duration: typing.Optional[builtins.str] = None,
        metadata: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        min_cpu_platform: typing.Optional[builtins.str] = None,
        node_group: typing.Optional[builtins.str] = None,
        oauth_scopes: typing.Optional[typing.Sequence[builtins.str]] = None,
        preemptible: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        reservation_affinity: typing.Optional[typing.Union["ContainerClusterNodeConfigReservationAffinity", typing.Dict[builtins.str, typing.Any]]] = None,
        resource_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        resource_manager_tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        secondary_boot_disks: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ContainerClusterNodeConfigSecondaryBootDisks", typing.Dict[builtins.str, typing.Any]]]]] = None,
        service_account: typing.Optional[builtins.str] = None,
        shielded_instance_config: typing.Optional[typing.Union["ContainerClusterNodeConfigShieldedInstanceConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        sole_tenant_config: typing.Optional[typing.Union["ContainerClusterNodeConfigSoleTenantConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        spot: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        storage_pools: typing.Optional[typing.Sequence[builtins.str]] = None,
        tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        taint: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ContainerClusterNodeConfigTaint", typing.Dict[builtins.str, typing.Any]]]]] = None,
        windows_node_config: typing.Optional[typing.Union["ContainerClusterNodeConfigWindowsNodeConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        workload_metadata_config: typing.Optional[typing.Union["ContainerClusterNodeConfigWorkloadMetadataConfig", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param advanced_machine_features: advanced_machine_features block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#advanced_machine_features ContainerCluster#advanced_machine_features}
        :param boot_disk: boot_disk block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#boot_disk ContainerCluster#boot_disk}
        :param boot_disk_kms_key: The Customer Managed Encryption Key used to encrypt the boot disk attached to each node in the node pool. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#boot_disk_kms_key ContainerCluster#boot_disk_kms_key}
        :param confidential_nodes: confidential_nodes block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#confidential_nodes ContainerCluster#confidential_nodes}
        :param containerd_config: containerd_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#containerd_config ContainerCluster#containerd_config}
        :param disk_size_gb: Size of the disk attached to each node, specified in GB. The smallest allowed disk size is 10GB. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#disk_size_gb ContainerCluster#disk_size_gb}
        :param disk_type: Type of the disk attached to each node. Such as pd-standard, pd-balanced or pd-ssd. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#disk_type ContainerCluster#disk_type}
        :param enable_confidential_storage: If enabled boot disks are configured with confidential mode. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_confidential_storage ContainerCluster#enable_confidential_storage}
        :param ephemeral_storage_local_ssd_config: ephemeral_storage_local_ssd_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#ephemeral_storage_local_ssd_config ContainerCluster#ephemeral_storage_local_ssd_config}
        :param fast_socket: fast_socket block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#fast_socket ContainerCluster#fast_socket}
        :param flex_start: Enables Flex Start provisioning model for the node pool. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#flex_start ContainerCluster#flex_start}
        :param gcfs_config: gcfs_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gcfs_config ContainerCluster#gcfs_config}
        :param guest_accelerator: guest_accelerator block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#guest_accelerator ContainerCluster#guest_accelerator}
        :param gvnic: gvnic block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gvnic ContainerCluster#gvnic}
        :param host_maintenance_policy: host_maintenance_policy block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#host_maintenance_policy ContainerCluster#host_maintenance_policy}
        :param image_type: The image type to use for this node. Note that for a given image type, the latest version of it will be used. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#image_type ContainerCluster#image_type}
        :param kubelet_config: kubelet_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#kubelet_config ContainerCluster#kubelet_config}
        :param labels: The map of Kubernetes labels (key/value pairs) to be applied to each node. These will added in addition to any default label(s) that Kubernetes may apply to the node. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#labels ContainerCluster#labels}
        :param linux_node_config: linux_node_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#linux_node_config ContainerCluster#linux_node_config}
        :param local_nvme_ssd_block_config: local_nvme_ssd_block_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#local_nvme_ssd_block_config ContainerCluster#local_nvme_ssd_block_config}
        :param local_ssd_count: The number of local SSD disks to be attached to the node. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#local_ssd_count ContainerCluster#local_ssd_count}
        :param local_ssd_encryption_mode: LocalSsdEncryptionMode specified the method used for encrypting the local SSDs attached to the node. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#local_ssd_encryption_mode ContainerCluster#local_ssd_encryption_mode}
        :param logging_variant: Type of logging agent that is used as the default value for node pools in the cluster. Valid values include DEFAULT and MAX_THROUGHPUT. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#logging_variant ContainerCluster#logging_variant}
        :param machine_type: The name of a Google Compute Engine machine type. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#machine_type ContainerCluster#machine_type}
        :param max_run_duration: The runtime of each node in the node pool in seconds, terminated by 's'. Example: "3600s". Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#max_run_duration ContainerCluster#max_run_duration}
        :param metadata: The metadata key/value pairs assigned to instances in the cluster. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#metadata ContainerCluster#metadata}
        :param min_cpu_platform: Minimum CPU platform to be used by this instance. The instance may be scheduled on the specified or newer CPU platform. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#min_cpu_platform ContainerCluster#min_cpu_platform}
        :param node_group: Setting this field will assign instances of this pool to run on the specified node group. This is useful for running workloads on sole tenant nodes. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#node_group ContainerCluster#node_group}
        :param oauth_scopes: The set of Google API scopes to be made available on all of the node VMs. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#oauth_scopes ContainerCluster#oauth_scopes}
        :param preemptible: Whether the nodes are created as preemptible VM instances. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#preemptible ContainerCluster#preemptible}
        :param reservation_affinity: reservation_affinity block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#reservation_affinity ContainerCluster#reservation_affinity}
        :param resource_labels: The GCE resource labels (a map of key/value pairs) to be applied to the node pool. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#resource_labels ContainerCluster#resource_labels}
        :param resource_manager_tags: A map of resource manager tags. Resource manager tag keys and values have the same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id}, and values are in the format tagValues/456. The field is ignored (both PUT & PATCH) when empty. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#resource_manager_tags ContainerCluster#resource_manager_tags}
        :param secondary_boot_disks: secondary_boot_disks block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#secondary_boot_disks ContainerCluster#secondary_boot_disks}
        :param service_account: The Google Cloud Platform Service Account to be used by the node VMs. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#service_account ContainerCluster#service_account}
        :param shielded_instance_config: shielded_instance_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#shielded_instance_config ContainerCluster#shielded_instance_config}
        :param sole_tenant_config: sole_tenant_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#sole_tenant_config ContainerCluster#sole_tenant_config}
        :param spot: Whether the nodes are created as spot VM instances. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#spot ContainerCluster#spot}
        :param storage_pools: The list of Storage Pools where boot disks are provisioned. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#storage_pools ContainerCluster#storage_pools}
        :param tags: The list of instance tags applied to all nodes. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#tags ContainerCluster#tags}
        :param taint: taint block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#taint ContainerCluster#taint}
        :param windows_node_config: windows_node_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#windows_node_config ContainerCluster#windows_node_config}
        :param workload_metadata_config: workload_metadata_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#workload_metadata_config ContainerCluster#workload_metadata_config}
        '''
        if isinstance(advanced_machine_features, dict):
            advanced_machine_features = ContainerClusterNodeConfigAdvancedMachineFeatures(**advanced_machine_features)
        if isinstance(boot_disk, dict):
            boot_disk = ContainerClusterNodeConfigBootDisk(**boot_disk)
        if isinstance(confidential_nodes, dict):
            confidential_nodes = ContainerClusterNodeConfigConfidentialNodes(**confidential_nodes)
        if isinstance(containerd_config, dict):
            containerd_config = ContainerClusterNodeConfigContainerdConfig(**containerd_config)
        if isinstance(ephemeral_storage_local_ssd_config, dict):
            ephemeral_storage_local_ssd_config = ContainerClusterNodeConfigEphemeralStorageLocalSsdConfig(**ephemeral_storage_local_ssd_config)
        if isinstance(fast_socket, dict):
            fast_socket = ContainerClusterNodeConfigFastSocket(**fast_socket)
        if isinstance(gcfs_config, dict):
            gcfs_config = ContainerClusterNodeConfigGcfsConfig(**gcfs_config)
        if isinstance(gvnic, dict):
            gvnic = ContainerClusterNodeConfigGvnic(**gvnic)
        if isinstance(host_maintenance_policy, dict):
            host_maintenance_policy = ContainerClusterNodeConfigHostMaintenancePolicy(**host_maintenance_policy)
        if isinstance(kubelet_config, dict):
            kubelet_config = ContainerClusterNodeConfigKubeletConfig(**kubelet_config)
        if isinstance(linux_node_config, dict):
            linux_node_config = ContainerClusterNodeConfigLinuxNodeConfig(**linux_node_config)
        if isinstance(local_nvme_ssd_block_config, dict):
            local_nvme_ssd_block_config = ContainerClusterNodeConfigLocalNvmeSsdBlockConfig(**local_nvme_ssd_block_config)
        if isinstance(reservation_affinity, dict):
            reservation_affinity = ContainerClusterNodeConfigReservationAffinity(**reservation_affinity)
        if isinstance(shielded_instance_config, dict):
            shielded_instance_config = ContainerClusterNodeConfigShieldedInstanceConfig(**shielded_instance_config)
        if isinstance(sole_tenant_config, dict):
            sole_tenant_config = ContainerClusterNodeConfigSoleTenantConfig(**sole_tenant_config)
        if isinstance(windows_node_config, dict):
            windows_node_config = ContainerClusterNodeConfigWindowsNodeConfig(**windows_node_config)
        if isinstance(workload_metadata_config, dict):
            workload_metadata_config = ContainerClusterNodeConfigWorkloadMetadataConfig(**workload_metadata_config)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__448963f7ee6542097477681f0898df77bb3ea4f85eee2dab7e70fbbef0d9b48d)
            check_type(argname="argument advanced_machine_features", value=advanced_machine_features, expected_type=type_hints["advanced_machine_features"])
            check_type(argname="argument boot_disk", value=boot_disk, expected_type=type_hints["boot_disk"])
            check_type(argname="argument boot_disk_kms_key", value=boot_disk_kms_key, expected_type=type_hints["boot_disk_kms_key"])
            check_type(argname="argument confidential_nodes", value=confidential_nodes, expected_type=type_hints["confidential_nodes"])
            check_type(argname="argument containerd_config", value=containerd_config, expected_type=type_hints["containerd_config"])
            check_type(argname="argument disk_size_gb", value=disk_size_gb, expected_type=type_hints["disk_size_gb"])
            check_type(argname="argument disk_type", value=disk_type, expected_type=type_hints["disk_type"])
            check_type(argname="argument enable_confidential_storage", value=enable_confidential_storage, expected_type=type_hints["enable_confidential_storage"])
            check_type(argname="argument ephemeral_storage_local_ssd_config", value=ephemeral_storage_local_ssd_config, expected_type=type_hints["ephemeral_storage_local_ssd_config"])
            check_type(argname="argument fast_socket", value=fast_socket, expected_type=type_hints["fast_socket"])
            check_type(argname="argument flex_start", value=flex_start, expected_type=type_hints["flex_start"])
            check_type(argname="argument gcfs_config", value=gcfs_config, expected_type=type_hints["gcfs_config"])
            check_type(argname="argument guest_accelerator", value=guest_accelerator, expected_type=type_hints["guest_accelerator"])
            check_type(argname="argument gvnic", value=gvnic, expected_type=type_hints["gvnic"])
            check_type(argname="argument host_maintenance_policy", value=host_maintenance_policy, expected_type=type_hints["host_maintenance_policy"])
            check_type(argname="argument image_type", value=image_type, expected_type=type_hints["image_type"])
            check_type(argname="argument kubelet_config", value=kubelet_config, expected_type=type_hints["kubelet_config"])
            check_type(argname="argument labels", value=labels, expected_type=type_hints["labels"])
            check_type(argname="argument linux_node_config", value=linux_node_config, expected_type=type_hints["linux_node_config"])
            check_type(argname="argument local_nvme_ssd_block_config", value=local_nvme_ssd_block_config, expected_type=type_hints["local_nvme_ssd_block_config"])
            check_type(argname="argument local_ssd_count", value=local_ssd_count, expected_type=type_hints["local_ssd_count"])
            check_type(argname="argument local_ssd_encryption_mode", value=local_ssd_encryption_mode, expected_type=type_hints["local_ssd_encryption_mode"])
            check_type(argname="argument logging_variant", value=logging_variant, expected_type=type_hints["logging_variant"])
            check_type(argname="argument machine_type", value=machine_type, expected_type=type_hints["machine_type"])
            check_type(argname="argument max_run_duration", value=max_run_duration, expected_type=type_hints["max_run_duration"])
            check_type(argname="argument metadata", value=metadata, expected_type=type_hints["metadata"])
            check_type(argname="argument min_cpu_platform", value=min_cpu_platform, expected_type=type_hints["min_cpu_platform"])
            check_type(argname="argument node_group", value=node_group, expected_type=type_hints["node_group"])
            check_type(argname="argument oauth_scopes", value=oauth_scopes, expected_type=type_hints["oauth_scopes"])
            check_type(argname="argument preemptible", value=preemptible, expected_type=type_hints["preemptible"])
            check_type(argname="argument reservation_affinity", value=reservation_affinity, expected_type=type_hints["reservation_affinity"])
            check_type(argname="argument resource_labels", value=resource_labels, expected_type=type_hints["resource_labels"])
            check_type(argname="argument resource_manager_tags", value=resource_manager_tags, expected_type=type_hints["resource_manager_tags"])
            check_type(argname="argument secondary_boot_disks", value=secondary_boot_disks, expected_type=type_hints["secondary_boot_disks"])
            check_type(argname="argument service_account", value=service_account, expected_type=type_hints["service_account"])
            check_type(argname="argument shielded_instance_config", value=shielded_instance_config, expected_type=type_hints["shielded_instance_config"])
            check_type(argname="argument sole_tenant_config", value=sole_tenant_config, expected_type=type_hints["sole_tenant_config"])
            check_type(argname="argument spot", value=spot, expected_type=type_hints["spot"])
            check_type(argname="argument storage_pools", value=storage_pools, expected_type=type_hints["storage_pools"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument taint", value=taint, expected_type=type_hints["taint"])
            check_type(argname="argument windows_node_config", value=windows_node_config, expected_type=type_hints["windows_node_config"])
            check_type(argname="argument workload_metadata_config", value=workload_metadata_config, expected_type=type_hints["workload_metadata_config"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if advanced_machine_features is not None:
            self._values["advanced_machine_features"] = advanced_machine_features
        if boot_disk is not None:
            self._values["boot_disk"] = boot_disk
        if boot_disk_kms_key is not None:
            self._values["boot_disk_kms_key"] = boot_disk_kms_key
        if confidential_nodes is not None:
            self._values["confidential_nodes"] = confidential_nodes
        if containerd_config is not None:
            self._values["containerd_config"] = containerd_config
        if disk_size_gb is not None:
            self._values["disk_size_gb"] = disk_size_gb
        if disk_type is not None:
            self._values["disk_type"] = disk_type
        if enable_confidential_storage is not None:
            self._values["enable_confidential_storage"] = enable_confidential_storage
        if ephemeral_storage_local_ssd_config is not None:
            self._values["ephemeral_storage_local_ssd_config"] = ephemeral_storage_local_ssd_config
        if fast_socket is not None:
            self._values["fast_socket"] = fast_socket
        if flex_start is not None:
            self._values["flex_start"] = flex_start
        if gcfs_config is not None:
            self._values["gcfs_config"] = gcfs_config
        if guest_accelerator is not None:
            self._values["guest_accelerator"] = guest_accelerator
        if gvnic is not None:
            self._values["gvnic"] = gvnic
        if host_maintenance_policy is not None:
            self._values["host_maintenance_policy"] = host_maintenance_policy
        if image_type is not None:
            self._values["image_type"] = image_type
        if kubelet_config is not None:
            self._values["kubelet_config"] = kubelet_config
        if labels is not None:
            self._values["labels"] = labels
        if linux_node_config is not None:
            self._values["linux_node_config"] = linux_node_config
        if local_nvme_ssd_block_config is not None:
            self._values["local_nvme_ssd_block_config"] = local_nvme_ssd_block_config
        if local_ssd_count is not None:
            self._values["local_ssd_count"] = local_ssd_count
        if local_ssd_encryption_mode is not None:
            self._values["local_ssd_encryption_mode"] = local_ssd_encryption_mode
        if logging_variant is not None:
            self._values["logging_variant"] = logging_variant
        if machine_type is not None:
            self._values["machine_type"] = machine_type
        if max_run_duration is not None:
            self._values["max_run_duration"] = max_run_duration
        if metadata is not None:
            self._values["metadata"] = metadata
        if min_cpu_platform is not None:
            self._values["min_cpu_platform"] = min_cpu_platform
        if node_group is not None:
            self._values["node_group"] = node_group
        if oauth_scopes is not None:
            self._values["oauth_scopes"] = oauth_scopes
        if preemptible is not None:
            self._values["preemptible"] = preemptible
        if reservation_affinity is not None:
            self._values["reservation_affinity"] = reservation_affinity
        if resource_labels is not None:
            self._values["resource_labels"] = resource_labels
        if resource_manager_tags is not None:
            self._values["resource_manager_tags"] = resource_manager_tags
        if secondary_boot_disks is not None:
            self._values["secondary_boot_disks"] = secondary_boot_disks
        if service_account is not None:
            self._values["service_account"] = service_account
        if shielded_instance_config is not None:
            self._values["shielded_instance_config"] = shielded_instance_config
        if sole_tenant_config is not None:
            self._values["sole_tenant_config"] = sole_tenant_config
        if spot is not None:
            self._values["spot"] = spot
        if storage_pools is not None:
            self._values["storage_pools"] = storage_pools
        if tags is not None:
            self._values["tags"] = tags
        if taint is not None:
            self._values["taint"] = taint
        if windows_node_config is not None:
            self._values["windows_node_config"] = windows_node_config
        if workload_metadata_config is not None:
            self._values["workload_metadata_config"] = workload_metadata_config

    @builtins.property
    def advanced_machine_features(
        self,
    ) -> typing.Optional["ContainerClusterNodeConfigAdvancedMachineFeatures"]:
        '''advanced_machine_features block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#advanced_machine_features ContainerCluster#advanced_machine_features}
        '''
        result = self._values.get("advanced_machine_features")
        return typing.cast(typing.Optional["ContainerClusterNodeConfigAdvancedMachineFeatures"], result)

    @builtins.property
    def boot_disk(self) -> typing.Optional["ContainerClusterNodeConfigBootDisk"]:
        '''boot_disk block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#boot_disk ContainerCluster#boot_disk}
        '''
        result = self._values.get("boot_disk")
        return typing.cast(typing.Optional["ContainerClusterNodeConfigBootDisk"], result)

    @builtins.property
    def boot_disk_kms_key(self) -> typing.Optional[builtins.str]:
        '''The Customer Managed Encryption Key used to encrypt the boot disk attached to each node in the node pool.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#boot_disk_kms_key ContainerCluster#boot_disk_kms_key}
        '''
        result = self._values.get("boot_disk_kms_key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def confidential_nodes(
        self,
    ) -> typing.Optional["ContainerClusterNodeConfigConfidentialNodes"]:
        '''confidential_nodes block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#confidential_nodes ContainerCluster#confidential_nodes}
        '''
        result = self._values.get("confidential_nodes")
        return typing.cast(typing.Optional["ContainerClusterNodeConfigConfidentialNodes"], result)

    @builtins.property
    def containerd_config(
        self,
    ) -> typing.Optional["ContainerClusterNodeConfigContainerdConfig"]:
        '''containerd_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#containerd_config ContainerCluster#containerd_config}
        '''
        result = self._values.get("containerd_config")
        return typing.cast(typing.Optional["ContainerClusterNodeConfigContainerdConfig"], result)

    @builtins.property
    def disk_size_gb(self) -> typing.Optional[jsii.Number]:
        '''Size of the disk attached to each node, specified in GB. The smallest allowed disk size is 10GB.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#disk_size_gb ContainerCluster#disk_size_gb}
        '''
        result = self._values.get("disk_size_gb")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def disk_type(self) -> typing.Optional[builtins.str]:
        '''Type of the disk attached to each node. Such as pd-standard, pd-balanced or pd-ssd.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#disk_type ContainerCluster#disk_type}
        '''
        result = self._values.get("disk_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_confidential_storage(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''If enabled boot disks are configured with confidential mode.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_confidential_storage ContainerCluster#enable_confidential_storage}
        '''
        result = self._values.get("enable_confidential_storage")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def ephemeral_storage_local_ssd_config(
        self,
    ) -> typing.Optional["ContainerClusterNodeConfigEphemeralStorageLocalSsdConfig"]:
        '''ephemeral_storage_local_ssd_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#ephemeral_storage_local_ssd_config ContainerCluster#ephemeral_storage_local_ssd_config}
        '''
        result = self._values.get("ephemeral_storage_local_ssd_config")
        return typing.cast(typing.Optional["ContainerClusterNodeConfigEphemeralStorageLocalSsdConfig"], result)

    @builtins.property
    def fast_socket(self) -> typing.Optional["ContainerClusterNodeConfigFastSocket"]:
        '''fast_socket block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#fast_socket ContainerCluster#fast_socket}
        '''
        result = self._values.get("fast_socket")
        return typing.cast(typing.Optional["ContainerClusterNodeConfigFastSocket"], result)

    @builtins.property
    def flex_start(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Enables Flex Start provisioning model for the node pool.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#flex_start ContainerCluster#flex_start}
        '''
        result = self._values.get("flex_start")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def gcfs_config(self) -> typing.Optional["ContainerClusterNodeConfigGcfsConfig"]:
        '''gcfs_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gcfs_config ContainerCluster#gcfs_config}
        '''
        result = self._values.get("gcfs_config")
        return typing.cast(typing.Optional["ContainerClusterNodeConfigGcfsConfig"], result)

    @builtins.property
    def guest_accelerator(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ContainerClusterNodeConfigGuestAccelerator"]]]:
        '''guest_accelerator block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#guest_accelerator ContainerCluster#guest_accelerator}
        '''
        result = self._values.get("guest_accelerator")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ContainerClusterNodeConfigGuestAccelerator"]]], result)

    @builtins.property
    def gvnic(self) -> typing.Optional["ContainerClusterNodeConfigGvnic"]:
        '''gvnic block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gvnic ContainerCluster#gvnic}
        '''
        result = self._values.get("gvnic")
        return typing.cast(typing.Optional["ContainerClusterNodeConfigGvnic"], result)

    @builtins.property
    def host_maintenance_policy(
        self,
    ) -> typing.Optional["ContainerClusterNodeConfigHostMaintenancePolicy"]:
        '''host_maintenance_policy block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#host_maintenance_policy ContainerCluster#host_maintenance_policy}
        '''
        result = self._values.get("host_maintenance_policy")
        return typing.cast(typing.Optional["ContainerClusterNodeConfigHostMaintenancePolicy"], result)

    @builtins.property
    def image_type(self) -> typing.Optional[builtins.str]:
        '''The image type to use for this node.

        Note that for a given image type, the latest version of it will be used.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#image_type ContainerCluster#image_type}
        '''
        result = self._values.get("image_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def kubelet_config(
        self,
    ) -> typing.Optional["ContainerClusterNodeConfigKubeletConfig"]:
        '''kubelet_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#kubelet_config ContainerCluster#kubelet_config}
        '''
        result = self._values.get("kubelet_config")
        return typing.cast(typing.Optional["ContainerClusterNodeConfigKubeletConfig"], result)

    @builtins.property
    def labels(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''The map of Kubernetes labels (key/value pairs) to be applied to each node.

        These will added in addition to any default label(s) that Kubernetes may apply to the node.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#labels ContainerCluster#labels}
        '''
        result = self._values.get("labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def linux_node_config(
        self,
    ) -> typing.Optional["ContainerClusterNodeConfigLinuxNodeConfig"]:
        '''linux_node_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#linux_node_config ContainerCluster#linux_node_config}
        '''
        result = self._values.get("linux_node_config")
        return typing.cast(typing.Optional["ContainerClusterNodeConfigLinuxNodeConfig"], result)

    @builtins.property
    def local_nvme_ssd_block_config(
        self,
    ) -> typing.Optional["ContainerClusterNodeConfigLocalNvmeSsdBlockConfig"]:
        '''local_nvme_ssd_block_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#local_nvme_ssd_block_config ContainerCluster#local_nvme_ssd_block_config}
        '''
        result = self._values.get("local_nvme_ssd_block_config")
        return typing.cast(typing.Optional["ContainerClusterNodeConfigLocalNvmeSsdBlockConfig"], result)

    @builtins.property
    def local_ssd_count(self) -> typing.Optional[jsii.Number]:
        '''The number of local SSD disks to be attached to the node.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#local_ssd_count ContainerCluster#local_ssd_count}
        '''
        result = self._values.get("local_ssd_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def local_ssd_encryption_mode(self) -> typing.Optional[builtins.str]:
        '''LocalSsdEncryptionMode specified the method used for encrypting the local SSDs attached to the node.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#local_ssd_encryption_mode ContainerCluster#local_ssd_encryption_mode}
        '''
        result = self._values.get("local_ssd_encryption_mode")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def logging_variant(self) -> typing.Optional[builtins.str]:
        '''Type of logging agent that is used as the default value for node pools in the cluster.

        Valid values include DEFAULT and MAX_THROUGHPUT.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#logging_variant ContainerCluster#logging_variant}
        '''
        result = self._values.get("logging_variant")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def machine_type(self) -> typing.Optional[builtins.str]:
        '''The name of a Google Compute Engine machine type.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#machine_type ContainerCluster#machine_type}
        '''
        result = self._values.get("machine_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def max_run_duration(self) -> typing.Optional[builtins.str]:
        '''The runtime of each node in the node pool in seconds, terminated by 's'. Example: "3600s".

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#max_run_duration ContainerCluster#max_run_duration}
        '''
        result = self._values.get("max_run_duration")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def metadata(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''The metadata key/value pairs assigned to instances in the cluster.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#metadata ContainerCluster#metadata}
        '''
        result = self._values.get("metadata")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def min_cpu_platform(self) -> typing.Optional[builtins.str]:
        '''Minimum CPU platform to be used by this instance.

        The instance may be scheduled on the specified or newer CPU platform.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#min_cpu_platform ContainerCluster#min_cpu_platform}
        '''
        result = self._values.get("min_cpu_platform")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def node_group(self) -> typing.Optional[builtins.str]:
        '''Setting this field will assign instances of this pool to run on the specified node group.

        This is useful for running workloads on sole tenant nodes.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#node_group ContainerCluster#node_group}
        '''
        result = self._values.get("node_group")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def oauth_scopes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The set of Google API scopes to be made available on all of the node VMs.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#oauth_scopes ContainerCluster#oauth_scopes}
        '''
        result = self._values.get("oauth_scopes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def preemptible(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Whether the nodes are created as preemptible VM instances.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#preemptible ContainerCluster#preemptible}
        '''
        result = self._values.get("preemptible")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def reservation_affinity(
        self,
    ) -> typing.Optional["ContainerClusterNodeConfigReservationAffinity"]:
        '''reservation_affinity block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#reservation_affinity ContainerCluster#reservation_affinity}
        '''
        result = self._values.get("reservation_affinity")
        return typing.cast(typing.Optional["ContainerClusterNodeConfigReservationAffinity"], result)

    @builtins.property
    def resource_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''The GCE resource labels (a map of key/value pairs) to be applied to the node pool.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#resource_labels ContainerCluster#resource_labels}
        '''
        result = self._values.get("resource_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def resource_manager_tags(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''A map of resource manager tags.

        Resource manager tag keys and values have the same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id}, and values are in the format tagValues/456. The field is ignored (both PUT & PATCH) when empty.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#resource_manager_tags ContainerCluster#resource_manager_tags}
        '''
        result = self._values.get("resource_manager_tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def secondary_boot_disks(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ContainerClusterNodeConfigSecondaryBootDisks"]]]:
        '''secondary_boot_disks block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#secondary_boot_disks ContainerCluster#secondary_boot_disks}
        '''
        result = self._values.get("secondary_boot_disks")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ContainerClusterNodeConfigSecondaryBootDisks"]]], result)

    @builtins.property
    def service_account(self) -> typing.Optional[builtins.str]:
        '''The Google Cloud Platform Service Account to be used by the node VMs.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#service_account ContainerCluster#service_account}
        '''
        result = self._values.get("service_account")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def shielded_instance_config(
        self,
    ) -> typing.Optional["ContainerClusterNodeConfigShieldedInstanceConfig"]:
        '''shielded_instance_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#shielded_instance_config ContainerCluster#shielded_instance_config}
        '''
        result = self._values.get("shielded_instance_config")
        return typing.cast(typing.Optional["ContainerClusterNodeConfigShieldedInstanceConfig"], result)

    @builtins.property
    def sole_tenant_config(
        self,
    ) -> typing.Optional["ContainerClusterNodeConfigSoleTenantConfig"]:
        '''sole_tenant_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#sole_tenant_config ContainerCluster#sole_tenant_config}
        '''
        result = self._values.get("sole_tenant_config")
        return typing.cast(typing.Optional["ContainerClusterNodeConfigSoleTenantConfig"], result)

    @builtins.property
    def spot(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Whether the nodes are created as spot VM instances.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#spot ContainerCluster#spot}
        '''
        result = self._values.get("spot")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def storage_pools(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The list of Storage Pools where boot disks are provisioned.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#storage_pools ContainerCluster#storage_pools}
        '''
        result = self._values.get("storage_pools")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The list of instance tags applied to all nodes.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#tags ContainerCluster#tags}
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def taint(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ContainerClusterNodeConfigTaint"]]]:
        '''taint block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#taint ContainerCluster#taint}
        '''
        result = self._values.get("taint")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ContainerClusterNodeConfigTaint"]]], result)

    @builtins.property
    def windows_node_config(
        self,
    ) -> typing.Optional["ContainerClusterNodeConfigWindowsNodeConfig"]:
        '''windows_node_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#windows_node_config ContainerCluster#windows_node_config}
        '''
        result = self._values.get("windows_node_config")
        return typing.cast(typing.Optional["ContainerClusterNodeConfigWindowsNodeConfig"], result)

    @builtins.property
    def workload_metadata_config(
        self,
    ) -> typing.Optional["ContainerClusterNodeConfigWorkloadMetadataConfig"]:
        '''workload_metadata_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#workload_metadata_config ContainerCluster#workload_metadata_config}
        '''
        result = self._values.get("workload_metadata_config")
        return typing.cast(typing.Optional["ContainerClusterNodeConfigWorkloadMetadataConfig"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodeConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigAdvancedMachineFeatures",
    jsii_struct_bases=[],
    name_mapping={
        "threads_per_core": "threadsPerCore",
        "enable_nested_virtualization": "enableNestedVirtualization",
        "performance_monitoring_unit": "performanceMonitoringUnit",
    },
)
class ContainerClusterNodeConfigAdvancedMachineFeatures:
    def __init__(
        self,
        *,
        threads_per_core: jsii.Number,
        enable_nested_virtualization: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        performance_monitoring_unit: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param threads_per_core: The number of threads per physical core. To disable simultaneous multithreading (SMT) set this to 1. If unset, the maximum number of threads supported per core by the underlying processor is assumed. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#threads_per_core ContainerCluster#threads_per_core}
        :param enable_nested_virtualization: Whether the node should have nested virtualization enabled. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_nested_virtualization ContainerCluster#enable_nested_virtualization}
        :param performance_monitoring_unit: Level of Performance Monitoring Unit (PMU) requested. If unset, no access to the PMU is assumed. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#performance_monitoring_unit ContainerCluster#performance_monitoring_unit}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b4b9fab3d583cb2d6859161d5c136253a03433bb75ecb8f1fe4fefd2cacc08e5)
            check_type(argname="argument threads_per_core", value=threads_per_core, expected_type=type_hints["threads_per_core"])
            check_type(argname="argument enable_nested_virtualization", value=enable_nested_virtualization, expected_type=type_hints["enable_nested_virtualization"])
            check_type(argname="argument performance_monitoring_unit", value=performance_monitoring_unit, expected_type=type_hints["performance_monitoring_unit"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "threads_per_core": threads_per_core,
        }
        if enable_nested_virtualization is not None:
            self._values["enable_nested_virtualization"] = enable_nested_virtualization
        if performance_monitoring_unit is not None:
            self._values["performance_monitoring_unit"] = performance_monitoring_unit

    @builtins.property
    def threads_per_core(self) -> jsii.Number:
        '''The number of threads per physical core.

        To disable simultaneous multithreading (SMT) set this to 1. If unset, the maximum number of threads supported per core by the underlying processor is assumed.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#threads_per_core ContainerCluster#threads_per_core}
        '''
        result = self._values.get("threads_per_core")
        assert result is not None, "Required property 'threads_per_core' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def enable_nested_virtualization(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Whether the node should have nested virtualization enabled.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_nested_virtualization ContainerCluster#enable_nested_virtualization}
        '''
        result = self._values.get("enable_nested_virtualization")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def performance_monitoring_unit(self) -> typing.Optional[builtins.str]:
        '''Level of Performance Monitoring Unit (PMU) requested. If unset, no access to the PMU is assumed.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#performance_monitoring_unit ContainerCluster#performance_monitoring_unit}
        '''
        result = self._values.get("performance_monitoring_unit")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodeConfigAdvancedMachineFeatures(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodeConfigAdvancedMachineFeaturesOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigAdvancedMachineFeaturesOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fff8d155dd304176ed92c24e2fa561227e24000d4ba84c3881b91edb10eddb6a)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetEnableNestedVirtualization")
    def reset_enable_nested_virtualization(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnableNestedVirtualization", []))

    @jsii.member(jsii_name="resetPerformanceMonitoringUnit")
    def reset_performance_monitoring_unit(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPerformanceMonitoringUnit", []))

    @builtins.property
    @jsii.member(jsii_name="enableNestedVirtualizationInput")
    def enable_nested_virtualization_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enableNestedVirtualizationInput"))

    @builtins.property
    @jsii.member(jsii_name="performanceMonitoringUnitInput")
    def performance_monitoring_unit_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "performanceMonitoringUnitInput"))

    @builtins.property
    @jsii.member(jsii_name="threadsPerCoreInput")
    def threads_per_core_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "threadsPerCoreInput"))

    @builtins.property
    @jsii.member(jsii_name="enableNestedVirtualization")
    def enable_nested_virtualization(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enableNestedVirtualization"))

    @enable_nested_virtualization.setter
    def enable_nested_virtualization(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4e70060c163923424bed68fda3352249979fc39dc714668da8387a765b73311a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableNestedVirtualization", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="performanceMonitoringUnit")
    def performance_monitoring_unit(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "performanceMonitoringUnit"))

    @performance_monitoring_unit.setter
    def performance_monitoring_unit(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c2ad76ee4c483667bb90fbb1cc062d3b09d439587431bc4cd1ff74779c8c0e76)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "performanceMonitoringUnit", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="threadsPerCore")
    def threads_per_core(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "threadsPerCore"))

    @threads_per_core.setter
    def threads_per_core(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2599dfad4ec6f1af825ff6081ae7d2e07c43d3772f547ff12a692ebcaeaeeb4b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "threadsPerCore", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodeConfigAdvancedMachineFeatures]:
        return typing.cast(typing.Optional[ContainerClusterNodeConfigAdvancedMachineFeatures], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodeConfigAdvancedMachineFeatures],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__559878f1e4afbe5663969887fd00ac4cad5db9862703b3fe9491d97c47bf1840)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigBootDisk",
    jsii_struct_bases=[],
    name_mapping={
        "disk_type": "diskType",
        "provisioned_iops": "provisionedIops",
        "provisioned_throughput": "provisionedThroughput",
        "size_gb": "sizeGb",
    },
)
class ContainerClusterNodeConfigBootDisk:
    def __init__(
        self,
        *,
        disk_type: typing.Optional[builtins.str] = None,
        provisioned_iops: typing.Optional[jsii.Number] = None,
        provisioned_throughput: typing.Optional[jsii.Number] = None,
        size_gb: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param disk_type: Type of the disk attached to each node. Such as pd-standard, pd-balanced or pd-ssd. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#disk_type ContainerCluster#disk_type}
        :param provisioned_iops: Configured IOPs provisioning. Only valid with disk type hyperdisk-balanced. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#provisioned_iops ContainerCluster#provisioned_iops}
        :param provisioned_throughput: Configured throughput provisioning. Only valid with disk type hyperdisk-balanced. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#provisioned_throughput ContainerCluster#provisioned_throughput}
        :param size_gb: Size of the disk attached to each node, specified in GB. The smallest allowed disk size is 10GB. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#size_gb ContainerCluster#size_gb}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7141f77c0c271d0c8cc54f3a0120bd06a06d1ec82cbcd1927a46211ddb4523e9)
            check_type(argname="argument disk_type", value=disk_type, expected_type=type_hints["disk_type"])
            check_type(argname="argument provisioned_iops", value=provisioned_iops, expected_type=type_hints["provisioned_iops"])
            check_type(argname="argument provisioned_throughput", value=provisioned_throughput, expected_type=type_hints["provisioned_throughput"])
            check_type(argname="argument size_gb", value=size_gb, expected_type=type_hints["size_gb"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if disk_type is not None:
            self._values["disk_type"] = disk_type
        if provisioned_iops is not None:
            self._values["provisioned_iops"] = provisioned_iops
        if provisioned_throughput is not None:
            self._values["provisioned_throughput"] = provisioned_throughput
        if size_gb is not None:
            self._values["size_gb"] = size_gb

    @builtins.property
    def disk_type(self) -> typing.Optional[builtins.str]:
        '''Type of the disk attached to each node. Such as pd-standard, pd-balanced or pd-ssd.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#disk_type ContainerCluster#disk_type}
        '''
        result = self._values.get("disk_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def provisioned_iops(self) -> typing.Optional[jsii.Number]:
        '''Configured IOPs provisioning. Only valid with disk type hyperdisk-balanced.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#provisioned_iops ContainerCluster#provisioned_iops}
        '''
        result = self._values.get("provisioned_iops")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def provisioned_throughput(self) -> typing.Optional[jsii.Number]:
        '''Configured throughput provisioning. Only valid with disk type hyperdisk-balanced.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#provisioned_throughput ContainerCluster#provisioned_throughput}
        '''
        result = self._values.get("provisioned_throughput")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def size_gb(self) -> typing.Optional[jsii.Number]:
        '''Size of the disk attached to each node, specified in GB. The smallest allowed disk size is 10GB.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#size_gb ContainerCluster#size_gb}
        '''
        result = self._values.get("size_gb")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodeConfigBootDisk(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodeConfigBootDiskOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigBootDiskOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1f6f884660facf73ca2682e67805c1405707416b9fb417abedba603133ca49ca)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetDiskType")
    def reset_disk_type(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDiskType", []))

    @jsii.member(jsii_name="resetProvisionedIops")
    def reset_provisioned_iops(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetProvisionedIops", []))

    @jsii.member(jsii_name="resetProvisionedThroughput")
    def reset_provisioned_throughput(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetProvisionedThroughput", []))

    @jsii.member(jsii_name="resetSizeGb")
    def reset_size_gb(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSizeGb", []))

    @builtins.property
    @jsii.member(jsii_name="diskTypeInput")
    def disk_type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "diskTypeInput"))

    @builtins.property
    @jsii.member(jsii_name="provisionedIopsInput")
    def provisioned_iops_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "provisionedIopsInput"))

    @builtins.property
    @jsii.member(jsii_name="provisionedThroughputInput")
    def provisioned_throughput_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "provisionedThroughputInput"))

    @builtins.property
    @jsii.member(jsii_name="sizeGbInput")
    def size_gb_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "sizeGbInput"))

    @builtins.property
    @jsii.member(jsii_name="diskType")
    def disk_type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "diskType"))

    @disk_type.setter
    def disk_type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5c09cfe1c3e1c352b6e988246472726d1990852008b43fc011683499930e464e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "diskType", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="provisionedIops")
    def provisioned_iops(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "provisionedIops"))

    @provisioned_iops.setter
    def provisioned_iops(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__086cf95d21544fa5b0180ecadde14df69dc2e73820fe1a10051b0353e5a370c5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "provisionedIops", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="provisionedThroughput")
    def provisioned_throughput(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "provisionedThroughput"))

    @provisioned_throughput.setter
    def provisioned_throughput(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d023a53f339fb99586de0799a1ee55f972111338d95ae22dddcd8eea772aa0de)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "provisionedThroughput", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="sizeGb")
    def size_gb(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "sizeGb"))

    @size_gb.setter
    def size_gb(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e036b5ab0ce0596d7ea8ec15aeca9fb2fe32a17883ffc4935a0542ecc988710b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "sizeGb", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[ContainerClusterNodeConfigBootDisk]:
        return typing.cast(typing.Optional[ContainerClusterNodeConfigBootDisk], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodeConfigBootDisk],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__95935476cd5fd318b0d53790b2be11bad0842a8aefe3113616d7a748ebf8023b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigConfidentialNodes",
    jsii_struct_bases=[],
    name_mapping={
        "enabled": "enabled",
        "confidential_instance_type": "confidentialInstanceType",
    },
)
class ContainerClusterNodeConfigConfidentialNodes:
    def __init__(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
        confidential_instance_type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param enabled: Whether Confidential Nodes feature is enabled for all nodes in this pool. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        :param confidential_instance_type: Defines the type of technology used by the confidential node. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#confidential_instance_type ContainerCluster#confidential_instance_type}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e3f8750c4dfbfe848a890a47f21a187ef1445b89095056b80325479e1a2cc9ab)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
            check_type(argname="argument confidential_instance_type", value=confidential_instance_type, expected_type=type_hints["confidential_instance_type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "enabled": enabled,
        }
        if confidential_instance_type is not None:
            self._values["confidential_instance_type"] = confidential_instance_type

    @builtins.property
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        '''Whether Confidential Nodes feature is enabled for all nodes in this pool.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        '''
        result = self._values.get("enabled")
        assert result is not None, "Required property 'enabled' is missing"
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], result)

    @builtins.property
    def confidential_instance_type(self) -> typing.Optional[builtins.str]:
        '''Defines the type of technology used by the confidential node.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#confidential_instance_type ContainerCluster#confidential_instance_type}
        '''
        result = self._values.get("confidential_instance_type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodeConfigConfidentialNodes(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodeConfigConfidentialNodesOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigConfidentialNodesOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eeac8d0082d3cd690faafbe349af6301d4c714bd4938713bc1fa044eb3c541ee)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetConfidentialInstanceType")
    def reset_confidential_instance_type(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetConfidentialInstanceType", []))

    @builtins.property
    @jsii.member(jsii_name="confidentialInstanceTypeInput")
    def confidential_instance_type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "confidentialInstanceTypeInput"))

    @builtins.property
    @jsii.member(jsii_name="enabledInput")
    def enabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enabledInput"))

    @builtins.property
    @jsii.member(jsii_name="confidentialInstanceType")
    def confidential_instance_type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "confidentialInstanceType"))

    @confidential_instance_type.setter
    def confidential_instance_type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a869db5e1b176d956bc7789899a660838c35dd1239ee47f752d39934f3d801b2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "confidentialInstanceType", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="enabled")
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enabled"))

    @enabled.setter
    def enabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b9ed030c28f9a927782b539ca2403f5672b34e4cf18de245052bd804f394a6ed)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodeConfigConfidentialNodes]:
        return typing.cast(typing.Optional[ContainerClusterNodeConfigConfidentialNodes], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodeConfigConfidentialNodes],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a0b5c998c92e7a28de70fae80597b98cc61198b74ec686f428b27456b225bb9e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigContainerdConfig",
    jsii_struct_bases=[],
    name_mapping={"private_registry_access_config": "privateRegistryAccessConfig"},
)
class ContainerClusterNodeConfigContainerdConfig:
    def __init__(
        self,
        *,
        private_registry_access_config: typing.Optional[typing.Union["ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfig", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param private_registry_access_config: private_registry_access_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#private_registry_access_config ContainerCluster#private_registry_access_config}
        '''
        if isinstance(private_registry_access_config, dict):
            private_registry_access_config = ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfig(**private_registry_access_config)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b5ee928e90d84c3d5b27f82015075351ee74f4aa464e1e2623ae00df808d37ef)
            check_type(argname="argument private_registry_access_config", value=private_registry_access_config, expected_type=type_hints["private_registry_access_config"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if private_registry_access_config is not None:
            self._values["private_registry_access_config"] = private_registry_access_config

    @builtins.property
    def private_registry_access_config(
        self,
    ) -> typing.Optional["ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfig"]:
        '''private_registry_access_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#private_registry_access_config ContainerCluster#private_registry_access_config}
        '''
        result = self._values.get("private_registry_access_config")
        return typing.cast(typing.Optional["ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfig"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodeConfigContainerdConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodeConfigContainerdConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigContainerdConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__24d42bfba1550f89ffcef5b7e31ad15a9d5237847abb1c13bea7771406f6b8ed)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putPrivateRegistryAccessConfig")
    def put_private_registry_access_config(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
        certificate_authority_domain_config: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig", typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''
        :param enabled: Whether or not private registries are configured. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        :param certificate_authority_domain_config: certificate_authority_domain_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#certificate_authority_domain_config ContainerCluster#certificate_authority_domain_config}
        '''
        value = ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfig(
            enabled=enabled,
            certificate_authority_domain_config=certificate_authority_domain_config,
        )

        return typing.cast(None, jsii.invoke(self, "putPrivateRegistryAccessConfig", [value]))

    @jsii.member(jsii_name="resetPrivateRegistryAccessConfig")
    def reset_private_registry_access_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPrivateRegistryAccessConfig", []))

    @builtins.property
    @jsii.member(jsii_name="privateRegistryAccessConfig")
    def private_registry_access_config(
        self,
    ) -> "ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigOutputReference":
        return typing.cast("ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigOutputReference", jsii.get(self, "privateRegistryAccessConfig"))

    @builtins.property
    @jsii.member(jsii_name="privateRegistryAccessConfigInput")
    def private_registry_access_config_input(
        self,
    ) -> typing.Optional["ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfig"]:
        return typing.cast(typing.Optional["ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfig"], jsii.get(self, "privateRegistryAccessConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodeConfigContainerdConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodeConfigContainerdConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodeConfigContainerdConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3bb1224503e91b778fb68d6d33787907edfc06824693a3d7b08a287b4d45cbab)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfig",
    jsii_struct_bases=[],
    name_mapping={
        "enabled": "enabled",
        "certificate_authority_domain_config": "certificateAuthorityDomainConfig",
    },
)
class ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfig:
    def __init__(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
        certificate_authority_domain_config: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig", typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''
        :param enabled: Whether or not private registries are configured. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        :param certificate_authority_domain_config: certificate_authority_domain_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#certificate_authority_domain_config ContainerCluster#certificate_authority_domain_config}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7e20c9f011b832e7e1ad481ec9a61245e259038eeb6760d2aefb67072f58fe84)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
            check_type(argname="argument certificate_authority_domain_config", value=certificate_authority_domain_config, expected_type=type_hints["certificate_authority_domain_config"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "enabled": enabled,
        }
        if certificate_authority_domain_config is not None:
            self._values["certificate_authority_domain_config"] = certificate_authority_domain_config

    @builtins.property
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        '''Whether or not private registries are configured.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        '''
        result = self._values.get("enabled")
        assert result is not None, "Required property 'enabled' is missing"
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], result)

    @builtins.property
    def certificate_authority_domain_config(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig"]]]:
        '''certificate_authority_domain_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#certificate_authority_domain_config ContainerCluster#certificate_authority_domain_config}
        '''
        result = self._values.get("certificate_authority_domain_config")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig"]]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig",
    jsii_struct_bases=[],
    name_mapping={
        "fqdns": "fqdns",
        "gcp_secret_manager_certificate_config": "gcpSecretManagerCertificateConfig",
    },
)
class ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig:
    def __init__(
        self,
        *,
        fqdns: typing.Sequence[builtins.str],
        gcp_secret_manager_certificate_config: typing.Union["ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''
        :param fqdns: List of fully-qualified-domain-names. IPv4s and port specification are supported. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#fqdns ContainerCluster#fqdns}
        :param gcp_secret_manager_certificate_config: gcp_secret_manager_certificate_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gcp_secret_manager_certificate_config ContainerCluster#gcp_secret_manager_certificate_config}
        '''
        if isinstance(gcp_secret_manager_certificate_config, dict):
            gcp_secret_manager_certificate_config = ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig(**gcp_secret_manager_certificate_config)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bccbf6b60b46aaf5a96a53815ab501ab0e095a5b88d5efcf6dfab440182ef720)
            check_type(argname="argument fqdns", value=fqdns, expected_type=type_hints["fqdns"])
            check_type(argname="argument gcp_secret_manager_certificate_config", value=gcp_secret_manager_certificate_config, expected_type=type_hints["gcp_secret_manager_certificate_config"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "fqdns": fqdns,
            "gcp_secret_manager_certificate_config": gcp_secret_manager_certificate_config,
        }

    @builtins.property
    def fqdns(self) -> typing.List[builtins.str]:
        '''List of fully-qualified-domain-names. IPv4s and port specification are supported.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#fqdns ContainerCluster#fqdns}
        '''
        result = self._values.get("fqdns")
        assert result is not None, "Required property 'fqdns' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def gcp_secret_manager_certificate_config(
        self,
    ) -> "ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig":
        '''gcp_secret_manager_certificate_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gcp_secret_manager_certificate_config ContainerCluster#gcp_secret_manager_certificate_config}
        '''
        result = self._values.get("gcp_secret_manager_certificate_config")
        assert result is not None, "Required property 'gcp_secret_manager_certificate_config' is missing"
        return typing.cast("ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig",
    jsii_struct_bases=[],
    name_mapping={"secret_uri": "secretUri"},
)
class ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig:
    def __init__(self, *, secret_uri: builtins.str) -> None:
        '''
        :param secret_uri: URI for the secret that hosts a certificate. Must be in the format 'projects/PROJECT_NUM/secrets/SECRET_NAME/versions/VERSION_OR_LATEST'. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#secret_uri ContainerCluster#secret_uri}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__06c49365d2a6050102c0210ab05c4d760992666502685184eacaa5f29f149fcc)
            check_type(argname="argument secret_uri", value=secret_uri, expected_type=type_hints["secret_uri"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "secret_uri": secret_uri,
        }

    @builtins.property
    def secret_uri(self) -> builtins.str:
        '''URI for the secret that hosts a certificate. Must be in the format 'projects/PROJECT_NUM/secrets/SECRET_NAME/versions/VERSION_OR_LATEST'.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#secret_uri ContainerCluster#secret_uri}
        '''
        result = self._values.get("secret_uri")
        assert result is not None, "Required property 'secret_uri' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0ead7cf6abb82687479e7270a136eabd16f31e89c9ec8a7c797694ff0b1d8179)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="secretUriInput")
    def secret_uri_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "secretUriInput"))

    @builtins.property
    @jsii.member(jsii_name="secretUri")
    def secret_uri(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "secretUri"))

    @secret_uri.setter
    def secret_uri(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8c5e06371ce58e2cedcd726fa052ccdfa07525f37ff93476c88ea2fb37c75759)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "secretUri", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f22cd4efaceb95e24f5de3d47f2c39b90db3cbc2027cb57f483aad698643a21b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__42f1295fda1535cc0a281ce8647441f6c2fe80cc35477eb4301e59acc8eeb48d)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__37f7463ea2f3ecfc9279f866401ac2ad252df5787ca28c530a94b307fe6b85c0)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__af4351325f6e61eb50b54d7dfba463391cb9579777e6726827b95e27e2717010)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c70075fff45e96275f277ae91d687708f732ac4c24c42c1feec12f32abc57d7e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__512c1d8a029795ff02e123954fa662050d79732b6d48146e52389cceff9eefbf)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__66bcc4a504e792b164999bdf23b8f46dc3ef92b7a72705965ace55579ef3f638)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3ca79593c23a6c9da597526c8da600d074f1d182d7f0c13c61d5ad126a244f7d)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putGcpSecretManagerCertificateConfig")
    def put_gcp_secret_manager_certificate_config(
        self,
        *,
        secret_uri: builtins.str,
    ) -> None:
        '''
        :param secret_uri: URI for the secret that hosts a certificate. Must be in the format 'projects/PROJECT_NUM/secrets/SECRET_NAME/versions/VERSION_OR_LATEST'. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#secret_uri ContainerCluster#secret_uri}
        '''
        value = ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig(
            secret_uri=secret_uri
        )

        return typing.cast(None, jsii.invoke(self, "putGcpSecretManagerCertificateConfig", [value]))

    @builtins.property
    @jsii.member(jsii_name="gcpSecretManagerCertificateConfig")
    def gcp_secret_manager_certificate_config(
        self,
    ) -> ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfigOutputReference:
        return typing.cast(ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfigOutputReference, jsii.get(self, "gcpSecretManagerCertificateConfig"))

    @builtins.property
    @jsii.member(jsii_name="fqdnsInput")
    def fqdns_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "fqdnsInput"))

    @builtins.property
    @jsii.member(jsii_name="gcpSecretManagerCertificateConfigInput")
    def gcp_secret_manager_certificate_config_input(
        self,
    ) -> typing.Optional[ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig], jsii.get(self, "gcpSecretManagerCertificateConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="fqdns")
    def fqdns(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "fqdns"))

    @fqdns.setter
    def fqdns(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3257febb26623257e13da5e2552c4840979134e856c89b2b676eb53d057f1d0f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "fqdns", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__73b39f425b582a5de35ad8e8f91d04bf3594249efe50b2e786a3a3dbf7e9935d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fa52a26fede32dc81a8247f97ae3f82cd9f178294d9f06290b6f999cf9a1a70d)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putCertificateAuthorityDomainConfig")
    def put_certificate_authority_domain_config(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3e0e32ad0d8388f6d79c65f9f5593015b48b03c063c0d633c72a07a8efdd71d9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putCertificateAuthorityDomainConfig", [value]))

    @jsii.member(jsii_name="resetCertificateAuthorityDomainConfig")
    def reset_certificate_authority_domain_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCertificateAuthorityDomainConfig", []))

    @builtins.property
    @jsii.member(jsii_name="certificateAuthorityDomainConfig")
    def certificate_authority_domain_config(
        self,
    ) -> ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigList:
        return typing.cast(ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigList, jsii.get(self, "certificateAuthorityDomainConfig"))

    @builtins.property
    @jsii.member(jsii_name="certificateAuthorityDomainConfigInput")
    def certificate_authority_domain_config_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig]]], jsii.get(self, "certificateAuthorityDomainConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="enabledInput")
    def enabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enabledInput"))

    @builtins.property
    @jsii.member(jsii_name="enabled")
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enabled"))

    @enabled.setter
    def enabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c455c3d14b61cf2ec14b12b41d6bcb09abb4b6a9eb5ef73c927b005a23ec8a78)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c3386a8c32a64fb3d7feb4da5db21f7ddf246113959c13b61d7ea319460d24de)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigEffectiveTaints",
    jsii_struct_bases=[],
    name_mapping={},
)
class ContainerClusterNodeConfigEffectiveTaints:
    def __init__(self) -> None:
        self._values: typing.Dict[builtins.str, typing.Any] = {}

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodeConfigEffectiveTaints(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodeConfigEffectiveTaintsList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigEffectiveTaintsList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7ce61be4ea9c8146473d93b22cf340633828ef0a23f9a3420dadef8131471afe)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ContainerClusterNodeConfigEffectiveTaintsOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e3a907e6679801babdc867df7ff63e3b31559fe25af9b0d6d330c63ec0bca409)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ContainerClusterNodeConfigEffectiveTaintsOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c7e664f04690c2311a2f4e7b3e2b40a49ab4a3fdbd523090fec7584644f41119)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d6be0c41283bb87abbcefc3b73688259729ffe1bd5696d5687e208a19b11e05e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a97d46de429c4bae18f9c53243ba1142cdaff75bfe7a4036fa0790a32c251fe0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]


class ContainerClusterNodeConfigEffectiveTaintsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigEffectiveTaintsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__64636821a0f073abbb4a41d3557ea335b79365f56e4c9d35bc97a654092d00b7)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @builtins.property
    @jsii.member(jsii_name="effect")
    def effect(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "effect"))

    @builtins.property
    @jsii.member(jsii_name="key")
    def key(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "key"))

    @builtins.property
    @jsii.member(jsii_name="value")
    def value(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "value"))

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodeConfigEffectiveTaints]:
        return typing.cast(typing.Optional[ContainerClusterNodeConfigEffectiveTaints], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodeConfigEffectiveTaints],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6c8a4d07f071be7731dc5f7db11098247d163bdbb6b835c22a6a5e72bc09cd64)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigEphemeralStorageLocalSsdConfig",
    jsii_struct_bases=[],
    name_mapping={
        "local_ssd_count": "localSsdCount",
        "data_cache_count": "dataCacheCount",
    },
)
class ContainerClusterNodeConfigEphemeralStorageLocalSsdConfig:
    def __init__(
        self,
        *,
        local_ssd_count: jsii.Number,
        data_cache_count: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param local_ssd_count: Number of local SSDs to use to back ephemeral storage. Uses NVMe interfaces. Each local SSD must be 375 or 3000 GB in size, and all local SSDs must share the same size. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#local_ssd_count ContainerCluster#local_ssd_count}
        :param data_cache_count: Number of local SSDs to be utilized for GKE Data Cache. Uses NVMe interfaces. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#data_cache_count ContainerCluster#data_cache_count}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__642653687b84db2df0ec8d8969c9b0838171fe3f4a96b61892fd28ee41800c1e)
            check_type(argname="argument local_ssd_count", value=local_ssd_count, expected_type=type_hints["local_ssd_count"])
            check_type(argname="argument data_cache_count", value=data_cache_count, expected_type=type_hints["data_cache_count"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "local_ssd_count": local_ssd_count,
        }
        if data_cache_count is not None:
            self._values["data_cache_count"] = data_cache_count

    @builtins.property
    def local_ssd_count(self) -> jsii.Number:
        '''Number of local SSDs to use to back ephemeral storage.

        Uses NVMe interfaces. Each local SSD must be 375 or 3000 GB in size, and all local SSDs must share the same size.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#local_ssd_count ContainerCluster#local_ssd_count}
        '''
        result = self._values.get("local_ssd_count")
        assert result is not None, "Required property 'local_ssd_count' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def data_cache_count(self) -> typing.Optional[jsii.Number]:
        '''Number of local SSDs to be utilized for GKE Data Cache. Uses NVMe interfaces.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#data_cache_count ContainerCluster#data_cache_count}
        '''
        result = self._values.get("data_cache_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodeConfigEphemeralStorageLocalSsdConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodeConfigEphemeralStorageLocalSsdConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigEphemeralStorageLocalSsdConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4eb45a7189179a5f7f0801c9d267f820e144871fefc0cbe1819a096a5f347863)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetDataCacheCount")
    def reset_data_cache_count(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDataCacheCount", []))

    @builtins.property
    @jsii.member(jsii_name="dataCacheCountInput")
    def data_cache_count_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "dataCacheCountInput"))

    @builtins.property
    @jsii.member(jsii_name="localSsdCountInput")
    def local_ssd_count_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "localSsdCountInput"))

    @builtins.property
    @jsii.member(jsii_name="dataCacheCount")
    def data_cache_count(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "dataCacheCount"))

    @data_cache_count.setter
    def data_cache_count(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2f73a2f3c706b6062d9e7302856a45da7345027f52c7e8ef430baaad77a34668)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "dataCacheCount", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="localSsdCount")
    def local_ssd_count(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "localSsdCount"))

    @local_ssd_count.setter
    def local_ssd_count(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__26fb57418954f934c2c015697c4f3bd22c9c21d9a26a7a7adf963224dfc2847d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "localSsdCount", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodeConfigEphemeralStorageLocalSsdConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodeConfigEphemeralStorageLocalSsdConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodeConfigEphemeralStorageLocalSsdConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__897aa1c34e6280c649200a31e2d6f57863bce059bed9386dc3b134e320f735e4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigFastSocket",
    jsii_struct_bases=[],
    name_mapping={"enabled": "enabled"},
)
class ContainerClusterNodeConfigFastSocket:
    def __init__(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param enabled: Whether or not NCCL Fast Socket is enabled. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0e16c1035a1dabda9c3758d4e09d8359081a8209f933c4e612022e7cee381fd0)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "enabled": enabled,
        }

    @builtins.property
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        '''Whether or not NCCL Fast Socket is enabled.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        '''
        result = self._values.get("enabled")
        assert result is not None, "Required property 'enabled' is missing"
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodeConfigFastSocket(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodeConfigFastSocketOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigFastSocketOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b1ab85979020fdc0a3d1987f0e8da79f5f60b3745bacd222aef2e5f2f0b38d96)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="enabledInput")
    def enabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enabledInput"))

    @builtins.property
    @jsii.member(jsii_name="enabled")
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enabled"))

    @enabled.setter
    def enabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eb07f8d0c26212336fa8d7039625215b7829d6fe130984ff8177f397ab1eab50)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[ContainerClusterNodeConfigFastSocket]:
        return typing.cast(typing.Optional[ContainerClusterNodeConfigFastSocket], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodeConfigFastSocket],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f68aa227aa87cc69385c805d57428701c0dcef3d5d60aa38b84fee1546e6faa7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigGcfsConfig",
    jsii_struct_bases=[],
    name_mapping={"enabled": "enabled"},
)
class ContainerClusterNodeConfigGcfsConfig:
    def __init__(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param enabled: Whether or not GCFS is enabled. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__82e3b98fab98b795ab54b2cff2d5fe2a7da2f7c206f9aa18991d4991c1abf3d0)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "enabled": enabled,
        }

    @builtins.property
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        '''Whether or not GCFS is enabled.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        '''
        result = self._values.get("enabled")
        assert result is not None, "Required property 'enabled' is missing"
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodeConfigGcfsConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodeConfigGcfsConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigGcfsConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__adbd6f965369f896a0d5fe9b3f404f1613074c0cdd11cdeb8aac972a877c2d7c)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="enabledInput")
    def enabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enabledInput"))

    @builtins.property
    @jsii.member(jsii_name="enabled")
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enabled"))

    @enabled.setter
    def enabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2edc4cadef68c97f8381d4300eaac3a7dcfee943571fc58f21fa98279c72009a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[ContainerClusterNodeConfigGcfsConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodeConfigGcfsConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodeConfigGcfsConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__386090f5e9dc7433bda89b01b20a0df79d3f20d1c9d0d6a1f1d71797e91ff3b8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigGuestAccelerator",
    jsii_struct_bases=[],
    name_mapping={
        "count": "count",
        "type": "type",
        "gpu_driver_installation_config": "gpuDriverInstallationConfig",
        "gpu_partition_size": "gpuPartitionSize",
        "gpu_sharing_config": "gpuSharingConfig",
    },
)
class ContainerClusterNodeConfigGuestAccelerator:
    def __init__(
        self,
        *,
        count: jsii.Number,
        type: builtins.str,
        gpu_driver_installation_config: typing.Optional[typing.Union["ContainerClusterNodeConfigGuestAcceleratorGpuDriverInstallationConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        gpu_partition_size: typing.Optional[builtins.str] = None,
        gpu_sharing_config: typing.Optional[typing.Union["ContainerClusterNodeConfigGuestAcceleratorGpuSharingConfig", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param count: The number of the accelerator cards exposed to an instance. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#count ContainerCluster#count}
        :param type: The accelerator type resource name. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#type ContainerCluster#type}
        :param gpu_driver_installation_config: gpu_driver_installation_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gpu_driver_installation_config ContainerCluster#gpu_driver_installation_config}
        :param gpu_partition_size: Size of partitions to create on the GPU. Valid values are described in the NVIDIA mig user guide (https://docs.nvidia.com/datacenter/tesla/mig-user-guide/#partitioning). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gpu_partition_size ContainerCluster#gpu_partition_size}
        :param gpu_sharing_config: gpu_sharing_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gpu_sharing_config ContainerCluster#gpu_sharing_config}
        '''
        if isinstance(gpu_driver_installation_config, dict):
            gpu_driver_installation_config = ContainerClusterNodeConfigGuestAcceleratorGpuDriverInstallationConfig(**gpu_driver_installation_config)
        if isinstance(gpu_sharing_config, dict):
            gpu_sharing_config = ContainerClusterNodeConfigGuestAcceleratorGpuSharingConfig(**gpu_sharing_config)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4d74f983a9b48e00efdced93c0393cf39ab6c8022060081b2cf3c47696254a2c)
            check_type(argname="argument count", value=count, expected_type=type_hints["count"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument gpu_driver_installation_config", value=gpu_driver_installation_config, expected_type=type_hints["gpu_driver_installation_config"])
            check_type(argname="argument gpu_partition_size", value=gpu_partition_size, expected_type=type_hints["gpu_partition_size"])
            check_type(argname="argument gpu_sharing_config", value=gpu_sharing_config, expected_type=type_hints["gpu_sharing_config"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "count": count,
            "type": type,
        }
        if gpu_driver_installation_config is not None:
            self._values["gpu_driver_installation_config"] = gpu_driver_installation_config
        if gpu_partition_size is not None:
            self._values["gpu_partition_size"] = gpu_partition_size
        if gpu_sharing_config is not None:
            self._values["gpu_sharing_config"] = gpu_sharing_config

    @builtins.property
    def count(self) -> jsii.Number:
        '''The number of the accelerator cards exposed to an instance.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#count ContainerCluster#count}
        '''
        result = self._values.get("count")
        assert result is not None, "Required property 'count' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def type(self) -> builtins.str:
        '''The accelerator type resource name.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#type ContainerCluster#type}
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def gpu_driver_installation_config(
        self,
    ) -> typing.Optional["ContainerClusterNodeConfigGuestAcceleratorGpuDriverInstallationConfig"]:
        '''gpu_driver_installation_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gpu_driver_installation_config ContainerCluster#gpu_driver_installation_config}
        '''
        result = self._values.get("gpu_driver_installation_config")
        return typing.cast(typing.Optional["ContainerClusterNodeConfigGuestAcceleratorGpuDriverInstallationConfig"], result)

    @builtins.property
    def gpu_partition_size(self) -> typing.Optional[builtins.str]:
        '''Size of partitions to create on the GPU. Valid values are described in the NVIDIA mig user guide (https://docs.nvidia.com/datacenter/tesla/mig-user-guide/#partitioning).

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gpu_partition_size ContainerCluster#gpu_partition_size}
        '''
        result = self._values.get("gpu_partition_size")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def gpu_sharing_config(
        self,
    ) -> typing.Optional["ContainerClusterNodeConfigGuestAcceleratorGpuSharingConfig"]:
        '''gpu_sharing_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gpu_sharing_config ContainerCluster#gpu_sharing_config}
        '''
        result = self._values.get("gpu_sharing_config")
        return typing.cast(typing.Optional["ContainerClusterNodeConfigGuestAcceleratorGpuSharingConfig"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodeConfigGuestAccelerator(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigGuestAcceleratorGpuDriverInstallationConfig",
    jsii_struct_bases=[],
    name_mapping={"gpu_driver_version": "gpuDriverVersion"},
)
class ContainerClusterNodeConfigGuestAcceleratorGpuDriverInstallationConfig:
    def __init__(self, *, gpu_driver_version: builtins.str) -> None:
        '''
        :param gpu_driver_version: Mode for how the GPU driver is installed. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gpu_driver_version ContainerCluster#gpu_driver_version}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2df323d390381c6b6268ab9f2153e8e6ce2849677b6fcabfbc98659b404b1fb2)
            check_type(argname="argument gpu_driver_version", value=gpu_driver_version, expected_type=type_hints["gpu_driver_version"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "gpu_driver_version": gpu_driver_version,
        }

    @builtins.property
    def gpu_driver_version(self) -> builtins.str:
        '''Mode for how the GPU driver is installed.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gpu_driver_version ContainerCluster#gpu_driver_version}
        '''
        result = self._values.get("gpu_driver_version")
        assert result is not None, "Required property 'gpu_driver_version' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodeConfigGuestAcceleratorGpuDriverInstallationConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodeConfigGuestAcceleratorGpuDriverInstallationConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigGuestAcceleratorGpuDriverInstallationConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__78954ede51a1fa83e49afaca8eecf02e13486c62f6d9f664ee32ba9408236d8d)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="gpuDriverVersionInput")
    def gpu_driver_version_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "gpuDriverVersionInput"))

    @builtins.property
    @jsii.member(jsii_name="gpuDriverVersion")
    def gpu_driver_version(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "gpuDriverVersion"))

    @gpu_driver_version.setter
    def gpu_driver_version(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4d264d3f740a8d9587a061685f50820971beab1d6f4075fb04c7b8aad9bca199)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "gpuDriverVersion", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodeConfigGuestAcceleratorGpuDriverInstallationConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodeConfigGuestAcceleratorGpuDriverInstallationConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodeConfigGuestAcceleratorGpuDriverInstallationConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1c4b28a3d392fe97f254e277ac51c7479e311658bfd95c34320b91201cb17cf3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigGuestAcceleratorGpuSharingConfig",
    jsii_struct_bases=[],
    name_mapping={
        "gpu_sharing_strategy": "gpuSharingStrategy",
        "max_shared_clients_per_gpu": "maxSharedClientsPerGpu",
    },
)
class ContainerClusterNodeConfigGuestAcceleratorGpuSharingConfig:
    def __init__(
        self,
        *,
        gpu_sharing_strategy: builtins.str,
        max_shared_clients_per_gpu: jsii.Number,
    ) -> None:
        '''
        :param gpu_sharing_strategy: The type of GPU sharing strategy to enable on the GPU node. Possible values are described in the API package (https://pkg.go.dev/google.golang.org/api/container/v1#GPUSharingConfig) Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gpu_sharing_strategy ContainerCluster#gpu_sharing_strategy}
        :param max_shared_clients_per_gpu: The maximum number of containers that can share a GPU. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#max_shared_clients_per_gpu ContainerCluster#max_shared_clients_per_gpu}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__87cf09e4d1ccb984f1c5455697e19a1d886647d0a683338eb1e14808ce289204)
            check_type(argname="argument gpu_sharing_strategy", value=gpu_sharing_strategy, expected_type=type_hints["gpu_sharing_strategy"])
            check_type(argname="argument max_shared_clients_per_gpu", value=max_shared_clients_per_gpu, expected_type=type_hints["max_shared_clients_per_gpu"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "gpu_sharing_strategy": gpu_sharing_strategy,
            "max_shared_clients_per_gpu": max_shared_clients_per_gpu,
        }

    @builtins.property
    def gpu_sharing_strategy(self) -> builtins.str:
        '''The type of GPU sharing strategy to enable on the GPU node.

        Possible values are described in the API package (https://pkg.go.dev/google.golang.org/api/container/v1#GPUSharingConfig)

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gpu_sharing_strategy ContainerCluster#gpu_sharing_strategy}
        '''
        result = self._values.get("gpu_sharing_strategy")
        assert result is not None, "Required property 'gpu_sharing_strategy' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def max_shared_clients_per_gpu(self) -> jsii.Number:
        '''The maximum number of containers that can share a GPU.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#max_shared_clients_per_gpu ContainerCluster#max_shared_clients_per_gpu}
        '''
        result = self._values.get("max_shared_clients_per_gpu")
        assert result is not None, "Required property 'max_shared_clients_per_gpu' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodeConfigGuestAcceleratorGpuSharingConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodeConfigGuestAcceleratorGpuSharingConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigGuestAcceleratorGpuSharingConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1f8a936dccd31db2ee19977734177a99ce9efaf270f2cbeeb6bd81c2de328e3b)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="gpuSharingStrategyInput")
    def gpu_sharing_strategy_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "gpuSharingStrategyInput"))

    @builtins.property
    @jsii.member(jsii_name="maxSharedClientsPerGpuInput")
    def max_shared_clients_per_gpu_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "maxSharedClientsPerGpuInput"))

    @builtins.property
    @jsii.member(jsii_name="gpuSharingStrategy")
    def gpu_sharing_strategy(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "gpuSharingStrategy"))

    @gpu_sharing_strategy.setter
    def gpu_sharing_strategy(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__14a4f64375f531672fc191f4c72c39ce7cc5d7f78ccc36fb88825a05480ddf30)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "gpuSharingStrategy", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="maxSharedClientsPerGpu")
    def max_shared_clients_per_gpu(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "maxSharedClientsPerGpu"))

    @max_shared_clients_per_gpu.setter
    def max_shared_clients_per_gpu(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d0944c979fd7875197d6620ef0477e09ac1a7dacf334510729ff171410ccf33f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "maxSharedClientsPerGpu", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodeConfigGuestAcceleratorGpuSharingConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodeConfigGuestAcceleratorGpuSharingConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodeConfigGuestAcceleratorGpuSharingConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__89b6788d95869424b78920384e645ce5ef5af4c5ddc16e25f1ce4274088985b2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ContainerClusterNodeConfigGuestAcceleratorList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigGuestAcceleratorList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d46bcd252915de788b4ecb45e3f6fc276b6cf510a7bb220976e6a7d81e480b18)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ContainerClusterNodeConfigGuestAcceleratorOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c450c930867714c6f6d1395a172679fc787f89f476267b927da61f8af5028710)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ContainerClusterNodeConfigGuestAcceleratorOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a289a84d8300cd82c404ae298f07fa9995b7bb722e311cce2cf6f26ca1f3cb04)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__599691efd702ac1970da501a314f22cefa727c6929b48d5ebb67047c34180811)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__51f4148153bdbdf23e75f2f6c0100b327d1f99c027bd81b7fbbeef58b27f6281)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodeConfigGuestAccelerator]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodeConfigGuestAccelerator]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodeConfigGuestAccelerator]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7096b004b371090d792fe7c7c8b85acb50d4c581baf4e2f8bab9aa752fa77043)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ContainerClusterNodeConfigGuestAcceleratorOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigGuestAcceleratorOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f4e063e8d365cefbd3ecdef3edd3ee6ed4b346970ac9241a0acc7793378e85e1)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putGpuDriverInstallationConfig")
    def put_gpu_driver_installation_config(
        self,
        *,
        gpu_driver_version: builtins.str,
    ) -> None:
        '''
        :param gpu_driver_version: Mode for how the GPU driver is installed. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gpu_driver_version ContainerCluster#gpu_driver_version}
        '''
        value = ContainerClusterNodeConfigGuestAcceleratorGpuDriverInstallationConfig(
            gpu_driver_version=gpu_driver_version
        )

        return typing.cast(None, jsii.invoke(self, "putGpuDriverInstallationConfig", [value]))

    @jsii.member(jsii_name="putGpuSharingConfig")
    def put_gpu_sharing_config(
        self,
        *,
        gpu_sharing_strategy: builtins.str,
        max_shared_clients_per_gpu: jsii.Number,
    ) -> None:
        '''
        :param gpu_sharing_strategy: The type of GPU sharing strategy to enable on the GPU node. Possible values are described in the API package (https://pkg.go.dev/google.golang.org/api/container/v1#GPUSharingConfig) Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gpu_sharing_strategy ContainerCluster#gpu_sharing_strategy}
        :param max_shared_clients_per_gpu: The maximum number of containers that can share a GPU. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#max_shared_clients_per_gpu ContainerCluster#max_shared_clients_per_gpu}
        '''
        value = ContainerClusterNodeConfigGuestAcceleratorGpuSharingConfig(
            gpu_sharing_strategy=gpu_sharing_strategy,
            max_shared_clients_per_gpu=max_shared_clients_per_gpu,
        )

        return typing.cast(None, jsii.invoke(self, "putGpuSharingConfig", [value]))

    @jsii.member(jsii_name="resetGpuDriverInstallationConfig")
    def reset_gpu_driver_installation_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGpuDriverInstallationConfig", []))

    @jsii.member(jsii_name="resetGpuPartitionSize")
    def reset_gpu_partition_size(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGpuPartitionSize", []))

    @jsii.member(jsii_name="resetGpuSharingConfig")
    def reset_gpu_sharing_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGpuSharingConfig", []))

    @builtins.property
    @jsii.member(jsii_name="gpuDriverInstallationConfig")
    def gpu_driver_installation_config(
        self,
    ) -> ContainerClusterNodeConfigGuestAcceleratorGpuDriverInstallationConfigOutputReference:
        return typing.cast(ContainerClusterNodeConfigGuestAcceleratorGpuDriverInstallationConfigOutputReference, jsii.get(self, "gpuDriverInstallationConfig"))

    @builtins.property
    @jsii.member(jsii_name="gpuSharingConfig")
    def gpu_sharing_config(
        self,
    ) -> ContainerClusterNodeConfigGuestAcceleratorGpuSharingConfigOutputReference:
        return typing.cast(ContainerClusterNodeConfigGuestAcceleratorGpuSharingConfigOutputReference, jsii.get(self, "gpuSharingConfig"))

    @builtins.property
    @jsii.member(jsii_name="countInput")
    def count_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "countInput"))

    @builtins.property
    @jsii.member(jsii_name="gpuDriverInstallationConfigInput")
    def gpu_driver_installation_config_input(
        self,
    ) -> typing.Optional[ContainerClusterNodeConfigGuestAcceleratorGpuDriverInstallationConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodeConfigGuestAcceleratorGpuDriverInstallationConfig], jsii.get(self, "gpuDriverInstallationConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="gpuPartitionSizeInput")
    def gpu_partition_size_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "gpuPartitionSizeInput"))

    @builtins.property
    @jsii.member(jsii_name="gpuSharingConfigInput")
    def gpu_sharing_config_input(
        self,
    ) -> typing.Optional[ContainerClusterNodeConfigGuestAcceleratorGpuSharingConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodeConfigGuestAcceleratorGpuSharingConfig], jsii.get(self, "gpuSharingConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="typeInput")
    def type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "typeInput"))

    @builtins.property
    @jsii.member(jsii_name="count")
    def count(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "count"))

    @count.setter
    def count(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a8b4521525ac49b57da0d456a4a85798caacf728fed41cfcf13961ea119e48ce)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "count", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="gpuPartitionSize")
    def gpu_partition_size(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "gpuPartitionSize"))

    @gpu_partition_size.setter
    def gpu_partition_size(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__06d64f51ee642e5976a75802b5540fcdc0e499d0a281b87ff9f1c73c25f18334)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "gpuPartitionSize", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="type")
    def type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "type"))

    @type.setter
    def type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2e7eabb2f3efe6c846d092b0d6cf1addfc1379cfc0cdcf324035bc7147658d77)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "type", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterNodeConfigGuestAccelerator]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterNodeConfigGuestAccelerator]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterNodeConfigGuestAccelerator]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__10d6c706587cf7dad2ba53766c06efd0999bd38cd1219e9d7ef40c23ec7ee843)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigGvnic",
    jsii_struct_bases=[],
    name_mapping={"enabled": "enabled"},
)
class ContainerClusterNodeConfigGvnic:
    def __init__(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param enabled: Whether or not gvnic is enabled. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__464e26794c2fdf7db27634920718bdc70d328c14f168ea7fbdcbf758548f94c7)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "enabled": enabled,
        }

    @builtins.property
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        '''Whether or not gvnic is enabled.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        '''
        result = self._values.get("enabled")
        assert result is not None, "Required property 'enabled' is missing"
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodeConfigGvnic(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodeConfigGvnicOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigGvnicOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f0a347c3f0d14d5c7858821ba6d9f37f37d6a322000bee7dc384192d09ab7f37)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="enabledInput")
    def enabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enabledInput"))

    @builtins.property
    @jsii.member(jsii_name="enabled")
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enabled"))

    @enabled.setter
    def enabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c5455f61e7443bfc8b15fbbc222698fe368978f00c50f6a58568f4859af7a3ca)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[ContainerClusterNodeConfigGvnic]:
        return typing.cast(typing.Optional[ContainerClusterNodeConfigGvnic], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodeConfigGvnic],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3bc0f505dff146c71be8b8b445e32be0ab5c98d0387f77447d1816b024a3b3a3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigHostMaintenancePolicy",
    jsii_struct_bases=[],
    name_mapping={"maintenance_interval": "maintenanceInterval"},
)
class ContainerClusterNodeConfigHostMaintenancePolicy:
    def __init__(self, *, maintenance_interval: builtins.str) -> None:
        '''
        :param maintenance_interval: . Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#maintenance_interval ContainerCluster#maintenance_interval}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a153ee3f964117eed4f6b82a731a7cedbfd57a6ac793c4a65e862f07faacfa38)
            check_type(argname="argument maintenance_interval", value=maintenance_interval, expected_type=type_hints["maintenance_interval"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "maintenance_interval": maintenance_interval,
        }

    @builtins.property
    def maintenance_interval(self) -> builtins.str:
        '''.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#maintenance_interval ContainerCluster#maintenance_interval}
        '''
        result = self._values.get("maintenance_interval")
        assert result is not None, "Required property 'maintenance_interval' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodeConfigHostMaintenancePolicy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodeConfigHostMaintenancePolicyOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigHostMaintenancePolicyOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eacf1b9a1cbc681aaa054f3af56af346ab52f44d742d96286ecba6f5e90a9cb1)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="maintenanceIntervalInput")
    def maintenance_interval_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "maintenanceIntervalInput"))

    @builtins.property
    @jsii.member(jsii_name="maintenanceInterval")
    def maintenance_interval(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "maintenanceInterval"))

    @maintenance_interval.setter
    def maintenance_interval(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3a731e849dfb5240546794aa47d574ba867d92480b8acd3add76eb084b2ec1f3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "maintenanceInterval", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodeConfigHostMaintenancePolicy]:
        return typing.cast(typing.Optional[ContainerClusterNodeConfigHostMaintenancePolicy], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodeConfigHostMaintenancePolicy],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__73ff82385ef19c5c0d0f57c2d10a0f0de354bf0de65a1ead4828d9c6d9eed63d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigKubeletConfig",
    jsii_struct_bases=[],
    name_mapping={
        "allowed_unsafe_sysctls": "allowedUnsafeSysctls",
        "container_log_max_files": "containerLogMaxFiles",
        "container_log_max_size": "containerLogMaxSize",
        "cpu_cfs_quota": "cpuCfsQuota",
        "cpu_cfs_quota_period": "cpuCfsQuotaPeriod",
        "cpu_manager_policy": "cpuManagerPolicy",
        "eviction_max_pod_grace_period_seconds": "evictionMaxPodGracePeriodSeconds",
        "eviction_minimum_reclaim": "evictionMinimumReclaim",
        "eviction_soft": "evictionSoft",
        "eviction_soft_grace_period": "evictionSoftGracePeriod",
        "image_gc_high_threshold_percent": "imageGcHighThresholdPercent",
        "image_gc_low_threshold_percent": "imageGcLowThresholdPercent",
        "image_maximum_gc_age": "imageMaximumGcAge",
        "image_minimum_gc_age": "imageMinimumGcAge",
        "insecure_kubelet_readonly_port_enabled": "insecureKubeletReadonlyPortEnabled",
        "max_parallel_image_pulls": "maxParallelImagePulls",
        "pod_pids_limit": "podPidsLimit",
        "single_process_oom_kill": "singleProcessOomKill",
    },
)
class ContainerClusterNodeConfigKubeletConfig:
    def __init__(
        self,
        *,
        allowed_unsafe_sysctls: typing.Optional[typing.Sequence[builtins.str]] = None,
        container_log_max_files: typing.Optional[jsii.Number] = None,
        container_log_max_size: typing.Optional[builtins.str] = None,
        cpu_cfs_quota: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        cpu_cfs_quota_period: typing.Optional[builtins.str] = None,
        cpu_manager_policy: typing.Optional[builtins.str] = None,
        eviction_max_pod_grace_period_seconds: typing.Optional[jsii.Number] = None,
        eviction_minimum_reclaim: typing.Optional[typing.Union["ContainerClusterNodeConfigKubeletConfigEvictionMinimumReclaim", typing.Dict[builtins.str, typing.Any]]] = None,
        eviction_soft: typing.Optional[typing.Union["ContainerClusterNodeConfigKubeletConfigEvictionSoft", typing.Dict[builtins.str, typing.Any]]] = None,
        eviction_soft_grace_period: typing.Optional[typing.Union["ContainerClusterNodeConfigKubeletConfigEvictionSoftGracePeriod", typing.Dict[builtins.str, typing.Any]]] = None,
        image_gc_high_threshold_percent: typing.Optional[jsii.Number] = None,
        image_gc_low_threshold_percent: typing.Optional[jsii.Number] = None,
        image_maximum_gc_age: typing.Optional[builtins.str] = None,
        image_minimum_gc_age: typing.Optional[builtins.str] = None,
        insecure_kubelet_readonly_port_enabled: typing.Optional[builtins.str] = None,
        max_parallel_image_pulls: typing.Optional[jsii.Number] = None,
        pod_pids_limit: typing.Optional[jsii.Number] = None,
        single_process_oom_kill: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    ) -> None:
        '''
        :param allowed_unsafe_sysctls: Defines a comma-separated allowlist of unsafe sysctls or sysctl patterns which can be set on the Pods. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#allowed_unsafe_sysctls ContainerCluster#allowed_unsafe_sysctls}
        :param container_log_max_files: Defines the maximum number of container log files that can be present for a container. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#container_log_max_files ContainerCluster#container_log_max_files}
        :param container_log_max_size: Defines the maximum size of the container log file before it is rotated. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#container_log_max_size ContainerCluster#container_log_max_size}
        :param cpu_cfs_quota: Enable CPU CFS quota enforcement for containers that specify CPU limits. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cpu_cfs_quota ContainerCluster#cpu_cfs_quota}
        :param cpu_cfs_quota_period: Set the CPU CFS quota period value 'cpu.cfs_period_us'. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cpu_cfs_quota_period ContainerCluster#cpu_cfs_quota_period}
        :param cpu_manager_policy: Control the CPU management policy on the node. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cpu_manager_policy ContainerCluster#cpu_manager_policy}
        :param eviction_max_pod_grace_period_seconds: Defines the maximum allowed grace period (in seconds) to use when terminating pods in response to a soft eviction threshold being met. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#eviction_max_pod_grace_period_seconds ContainerCluster#eviction_max_pod_grace_period_seconds}
        :param eviction_minimum_reclaim: eviction_minimum_reclaim block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#eviction_minimum_reclaim ContainerCluster#eviction_minimum_reclaim}
        :param eviction_soft: eviction_soft block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#eviction_soft ContainerCluster#eviction_soft}
        :param eviction_soft_grace_period: eviction_soft_grace_period block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#eviction_soft_grace_period ContainerCluster#eviction_soft_grace_period}
        :param image_gc_high_threshold_percent: Defines the percent of disk usage after which image garbage collection is always run. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#image_gc_high_threshold_percent ContainerCluster#image_gc_high_threshold_percent}
        :param image_gc_low_threshold_percent: Defines the percent of disk usage before which image garbage collection is never run. Lowest disk usage to garbage collect to. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#image_gc_low_threshold_percent ContainerCluster#image_gc_low_threshold_percent}
        :param image_maximum_gc_age: Defines the maximum age an image can be unused before it is garbage collected. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#image_maximum_gc_age ContainerCluster#image_maximum_gc_age}
        :param image_minimum_gc_age: Defines the minimum age for an unused image before it is garbage collected. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#image_minimum_gc_age ContainerCluster#image_minimum_gc_age}
        :param insecure_kubelet_readonly_port_enabled: Controls whether the kubelet read-only port is enabled. It is strongly recommended to set this to ``FALSE``. Possible values: ``TRUE``, ``FALSE``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#insecure_kubelet_readonly_port_enabled ContainerCluster#insecure_kubelet_readonly_port_enabled}
        :param max_parallel_image_pulls: Set the maximum number of image pulls in parallel. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#max_parallel_image_pulls ContainerCluster#max_parallel_image_pulls}
        :param pod_pids_limit: Controls the maximum number of processes allowed to run in a pod. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#pod_pids_limit ContainerCluster#pod_pids_limit}
        :param single_process_oom_kill: Defines whether to enable single process OOM killer. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#single_process_oom_kill ContainerCluster#single_process_oom_kill}
        '''
        if isinstance(eviction_minimum_reclaim, dict):
            eviction_minimum_reclaim = ContainerClusterNodeConfigKubeletConfigEvictionMinimumReclaim(**eviction_minimum_reclaim)
        if isinstance(eviction_soft, dict):
            eviction_soft = ContainerClusterNodeConfigKubeletConfigEvictionSoft(**eviction_soft)
        if isinstance(eviction_soft_grace_period, dict):
            eviction_soft_grace_period = ContainerClusterNodeConfigKubeletConfigEvictionSoftGracePeriod(**eviction_soft_grace_period)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__625b0c1d1df47f851a31e29b959b6754d9d8ce0c66a19020772a658913cb425d)
            check_type(argname="argument allowed_unsafe_sysctls", value=allowed_unsafe_sysctls, expected_type=type_hints["allowed_unsafe_sysctls"])
            check_type(argname="argument container_log_max_files", value=container_log_max_files, expected_type=type_hints["container_log_max_files"])
            check_type(argname="argument container_log_max_size", value=container_log_max_size, expected_type=type_hints["container_log_max_size"])
            check_type(argname="argument cpu_cfs_quota", value=cpu_cfs_quota, expected_type=type_hints["cpu_cfs_quota"])
            check_type(argname="argument cpu_cfs_quota_period", value=cpu_cfs_quota_period, expected_type=type_hints["cpu_cfs_quota_period"])
            check_type(argname="argument cpu_manager_policy", value=cpu_manager_policy, expected_type=type_hints["cpu_manager_policy"])
            check_type(argname="argument eviction_max_pod_grace_period_seconds", value=eviction_max_pod_grace_period_seconds, expected_type=type_hints["eviction_max_pod_grace_period_seconds"])
            check_type(argname="argument eviction_minimum_reclaim", value=eviction_minimum_reclaim, expected_type=type_hints["eviction_minimum_reclaim"])
            check_type(argname="argument eviction_soft", value=eviction_soft, expected_type=type_hints["eviction_soft"])
            check_type(argname="argument eviction_soft_grace_period", value=eviction_soft_grace_period, expected_type=type_hints["eviction_soft_grace_period"])
            check_type(argname="argument image_gc_high_threshold_percent", value=image_gc_high_threshold_percent, expected_type=type_hints["image_gc_high_threshold_percent"])
            check_type(argname="argument image_gc_low_threshold_percent", value=image_gc_low_threshold_percent, expected_type=type_hints["image_gc_low_threshold_percent"])
            check_type(argname="argument image_maximum_gc_age", value=image_maximum_gc_age, expected_type=type_hints["image_maximum_gc_age"])
            check_type(argname="argument image_minimum_gc_age", value=image_minimum_gc_age, expected_type=type_hints["image_minimum_gc_age"])
            check_type(argname="argument insecure_kubelet_readonly_port_enabled", value=insecure_kubelet_readonly_port_enabled, expected_type=type_hints["insecure_kubelet_readonly_port_enabled"])
            check_type(argname="argument max_parallel_image_pulls", value=max_parallel_image_pulls, expected_type=type_hints["max_parallel_image_pulls"])
            check_type(argname="argument pod_pids_limit", value=pod_pids_limit, expected_type=type_hints["pod_pids_limit"])
            check_type(argname="argument single_process_oom_kill", value=single_process_oom_kill, expected_type=type_hints["single_process_oom_kill"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if allowed_unsafe_sysctls is not None:
            self._values["allowed_unsafe_sysctls"] = allowed_unsafe_sysctls
        if container_log_max_files is not None:
            self._values["container_log_max_files"] = container_log_max_files
        if container_log_max_size is not None:
            self._values["container_log_max_size"] = container_log_max_size
        if cpu_cfs_quota is not None:
            self._values["cpu_cfs_quota"] = cpu_cfs_quota
        if cpu_cfs_quota_period is not None:
            self._values["cpu_cfs_quota_period"] = cpu_cfs_quota_period
        if cpu_manager_policy is not None:
            self._values["cpu_manager_policy"] = cpu_manager_policy
        if eviction_max_pod_grace_period_seconds is not None:
            self._values["eviction_max_pod_grace_period_seconds"] = eviction_max_pod_grace_period_seconds
        if eviction_minimum_reclaim is not None:
            self._values["eviction_minimum_reclaim"] = eviction_minimum_reclaim
        if eviction_soft is not None:
            self._values["eviction_soft"] = eviction_soft
        if eviction_soft_grace_period is not None:
            self._values["eviction_soft_grace_period"] = eviction_soft_grace_period
        if image_gc_high_threshold_percent is not None:
            self._values["image_gc_high_threshold_percent"] = image_gc_high_threshold_percent
        if image_gc_low_threshold_percent is not None:
            self._values["image_gc_low_threshold_percent"] = image_gc_low_threshold_percent
        if image_maximum_gc_age is not None:
            self._values["image_maximum_gc_age"] = image_maximum_gc_age
        if image_minimum_gc_age is not None:
            self._values["image_minimum_gc_age"] = image_minimum_gc_age
        if insecure_kubelet_readonly_port_enabled is not None:
            self._values["insecure_kubelet_readonly_port_enabled"] = insecure_kubelet_readonly_port_enabled
        if max_parallel_image_pulls is not None:
            self._values["max_parallel_image_pulls"] = max_parallel_image_pulls
        if pod_pids_limit is not None:
            self._values["pod_pids_limit"] = pod_pids_limit
        if single_process_oom_kill is not None:
            self._values["single_process_oom_kill"] = single_process_oom_kill

    @builtins.property
    def allowed_unsafe_sysctls(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Defines a comma-separated allowlist of unsafe sysctls or sysctl patterns which can be set on the Pods.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#allowed_unsafe_sysctls ContainerCluster#allowed_unsafe_sysctls}
        '''
        result = self._values.get("allowed_unsafe_sysctls")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def container_log_max_files(self) -> typing.Optional[jsii.Number]:
        '''Defines the maximum number of container log files that can be present for a container.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#container_log_max_files ContainerCluster#container_log_max_files}
        '''
        result = self._values.get("container_log_max_files")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def container_log_max_size(self) -> typing.Optional[builtins.str]:
        '''Defines the maximum size of the container log file before it is rotated.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#container_log_max_size ContainerCluster#container_log_max_size}
        '''
        result = self._values.get("container_log_max_size")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def cpu_cfs_quota(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Enable CPU CFS quota enforcement for containers that specify CPU limits.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cpu_cfs_quota ContainerCluster#cpu_cfs_quota}
        '''
        result = self._values.get("cpu_cfs_quota")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def cpu_cfs_quota_period(self) -> typing.Optional[builtins.str]:
        '''Set the CPU CFS quota period value 'cpu.cfs_period_us'.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cpu_cfs_quota_period ContainerCluster#cpu_cfs_quota_period}
        '''
        result = self._values.get("cpu_cfs_quota_period")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def cpu_manager_policy(self) -> typing.Optional[builtins.str]:
        '''Control the CPU management policy on the node.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cpu_manager_policy ContainerCluster#cpu_manager_policy}
        '''
        result = self._values.get("cpu_manager_policy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def eviction_max_pod_grace_period_seconds(self) -> typing.Optional[jsii.Number]:
        '''Defines the maximum allowed grace period (in seconds) to use when terminating pods in response to a soft eviction threshold being met.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#eviction_max_pod_grace_period_seconds ContainerCluster#eviction_max_pod_grace_period_seconds}
        '''
        result = self._values.get("eviction_max_pod_grace_period_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def eviction_minimum_reclaim(
        self,
    ) -> typing.Optional["ContainerClusterNodeConfigKubeletConfigEvictionMinimumReclaim"]:
        '''eviction_minimum_reclaim block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#eviction_minimum_reclaim ContainerCluster#eviction_minimum_reclaim}
        '''
        result = self._values.get("eviction_minimum_reclaim")
        return typing.cast(typing.Optional["ContainerClusterNodeConfigKubeletConfigEvictionMinimumReclaim"], result)

    @builtins.property
    def eviction_soft(
        self,
    ) -> typing.Optional["ContainerClusterNodeConfigKubeletConfigEvictionSoft"]:
        '''eviction_soft block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#eviction_soft ContainerCluster#eviction_soft}
        '''
        result = self._values.get("eviction_soft")
        return typing.cast(typing.Optional["ContainerClusterNodeConfigKubeletConfigEvictionSoft"], result)

    @builtins.property
    def eviction_soft_grace_period(
        self,
    ) -> typing.Optional["ContainerClusterNodeConfigKubeletConfigEvictionSoftGracePeriod"]:
        '''eviction_soft_grace_period block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#eviction_soft_grace_period ContainerCluster#eviction_soft_grace_period}
        '''
        result = self._values.get("eviction_soft_grace_period")
        return typing.cast(typing.Optional["ContainerClusterNodeConfigKubeletConfigEvictionSoftGracePeriod"], result)

    @builtins.property
    def image_gc_high_threshold_percent(self) -> typing.Optional[jsii.Number]:
        '''Defines the percent of disk usage after which image garbage collection is always run.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#image_gc_high_threshold_percent ContainerCluster#image_gc_high_threshold_percent}
        '''
        result = self._values.get("image_gc_high_threshold_percent")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def image_gc_low_threshold_percent(self) -> typing.Optional[jsii.Number]:
        '''Defines the percent of disk usage before which image garbage collection is never run.

        Lowest disk usage to garbage collect to.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#image_gc_low_threshold_percent ContainerCluster#image_gc_low_threshold_percent}
        '''
        result = self._values.get("image_gc_low_threshold_percent")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def image_maximum_gc_age(self) -> typing.Optional[builtins.str]:
        '''Defines the maximum age an image can be unused before it is garbage collected.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#image_maximum_gc_age ContainerCluster#image_maximum_gc_age}
        '''
        result = self._values.get("image_maximum_gc_age")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def image_minimum_gc_age(self) -> typing.Optional[builtins.str]:
        '''Defines the minimum age for an unused image before it is garbage collected.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#image_minimum_gc_age ContainerCluster#image_minimum_gc_age}
        '''
        result = self._values.get("image_minimum_gc_age")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def insecure_kubelet_readonly_port_enabled(self) -> typing.Optional[builtins.str]:
        '''Controls whether the kubelet read-only port is enabled.

        It is strongly recommended to set this to ``FALSE``. Possible values: ``TRUE``, ``FALSE``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#insecure_kubelet_readonly_port_enabled ContainerCluster#insecure_kubelet_readonly_port_enabled}
        '''
        result = self._values.get("insecure_kubelet_readonly_port_enabled")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def max_parallel_image_pulls(self) -> typing.Optional[jsii.Number]:
        '''Set the maximum number of image pulls in parallel.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#max_parallel_image_pulls ContainerCluster#max_parallel_image_pulls}
        '''
        result = self._values.get("max_parallel_image_pulls")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def pod_pids_limit(self) -> typing.Optional[jsii.Number]:
        '''Controls the maximum number of processes allowed to run in a pod.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#pod_pids_limit ContainerCluster#pod_pids_limit}
        '''
        result = self._values.get("pod_pids_limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def single_process_oom_kill(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Defines whether to enable single process OOM killer.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#single_process_oom_kill ContainerCluster#single_process_oom_kill}
        '''
        result = self._values.get("single_process_oom_kill")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodeConfigKubeletConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigKubeletConfigEvictionMinimumReclaim",
    jsii_struct_bases=[],
    name_mapping={
        "imagefs_available": "imagefsAvailable",
        "imagefs_inodes_free": "imagefsInodesFree",
        "memory_available": "memoryAvailable",
        "nodefs_available": "nodefsAvailable",
        "nodefs_inodes_free": "nodefsInodesFree",
        "pid_available": "pidAvailable",
    },
)
class ContainerClusterNodeConfigKubeletConfigEvictionMinimumReclaim:
    def __init__(
        self,
        *,
        imagefs_available: typing.Optional[builtins.str] = None,
        imagefs_inodes_free: typing.Optional[builtins.str] = None,
        memory_available: typing.Optional[builtins.str] = None,
        nodefs_available: typing.Optional[builtins.str] = None,
        nodefs_inodes_free: typing.Optional[builtins.str] = None,
        pid_available: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param imagefs_available: Defines percentage of minimum reclaim for imagefs.available. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#imagefs_available ContainerCluster#imagefs_available}
        :param imagefs_inodes_free: Defines percentage of minimum reclaim for imagefs.inodesFree. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#imagefs_inodes_free ContainerCluster#imagefs_inodes_free}
        :param memory_available: Defines percentage of minimum reclaim for memory.available. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#memory_available ContainerCluster#memory_available}
        :param nodefs_available: Defines percentage of minimum reclaim for nodefs.available. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#nodefs_available ContainerCluster#nodefs_available}
        :param nodefs_inodes_free: Defines percentage of minimum reclaim for nodefs.inodesFree. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#nodefs_inodes_free ContainerCluster#nodefs_inodes_free}
        :param pid_available: Defines percentage of minimum reclaim for pid.available. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#pid_available ContainerCluster#pid_available}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c73bad66a39b4cb7a5c359d34713f07bdf549da7c7c3b5d6bb639f55f445930d)
            check_type(argname="argument imagefs_available", value=imagefs_available, expected_type=type_hints["imagefs_available"])
            check_type(argname="argument imagefs_inodes_free", value=imagefs_inodes_free, expected_type=type_hints["imagefs_inodes_free"])
            check_type(argname="argument memory_available", value=memory_available, expected_type=type_hints["memory_available"])
            check_type(argname="argument nodefs_available", value=nodefs_available, expected_type=type_hints["nodefs_available"])
            check_type(argname="argument nodefs_inodes_free", value=nodefs_inodes_free, expected_type=type_hints["nodefs_inodes_free"])
            check_type(argname="argument pid_available", value=pid_available, expected_type=type_hints["pid_available"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if imagefs_available is not None:
            self._values["imagefs_available"] = imagefs_available
        if imagefs_inodes_free is not None:
            self._values["imagefs_inodes_free"] = imagefs_inodes_free
        if memory_available is not None:
            self._values["memory_available"] = memory_available
        if nodefs_available is not None:
            self._values["nodefs_available"] = nodefs_available
        if nodefs_inodes_free is not None:
            self._values["nodefs_inodes_free"] = nodefs_inodes_free
        if pid_available is not None:
            self._values["pid_available"] = pid_available

    @builtins.property
    def imagefs_available(self) -> typing.Optional[builtins.str]:
        '''Defines percentage of minimum reclaim for imagefs.available.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#imagefs_available ContainerCluster#imagefs_available}
        '''
        result = self._values.get("imagefs_available")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def imagefs_inodes_free(self) -> typing.Optional[builtins.str]:
        '''Defines percentage of minimum reclaim for imagefs.inodesFree.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#imagefs_inodes_free ContainerCluster#imagefs_inodes_free}
        '''
        result = self._values.get("imagefs_inodes_free")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def memory_available(self) -> typing.Optional[builtins.str]:
        '''Defines percentage of minimum reclaim for memory.available.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#memory_available ContainerCluster#memory_available}
        '''
        result = self._values.get("memory_available")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def nodefs_available(self) -> typing.Optional[builtins.str]:
        '''Defines percentage of minimum reclaim for nodefs.available.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#nodefs_available ContainerCluster#nodefs_available}
        '''
        result = self._values.get("nodefs_available")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def nodefs_inodes_free(self) -> typing.Optional[builtins.str]:
        '''Defines percentage of minimum reclaim for nodefs.inodesFree.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#nodefs_inodes_free ContainerCluster#nodefs_inodes_free}
        '''
        result = self._values.get("nodefs_inodes_free")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def pid_available(self) -> typing.Optional[builtins.str]:
        '''Defines percentage of minimum reclaim for pid.available.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#pid_available ContainerCluster#pid_available}
        '''
        result = self._values.get("pid_available")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodeConfigKubeletConfigEvictionMinimumReclaim(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodeConfigKubeletConfigEvictionMinimumReclaimOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigKubeletConfigEvictionMinimumReclaimOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cf264ca1910c7e7589ddc8aaacbf0371f98c5d68a49e8dd56c6569d96e9b16a7)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetImagefsAvailable")
    def reset_imagefs_available(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetImagefsAvailable", []))

    @jsii.member(jsii_name="resetImagefsInodesFree")
    def reset_imagefs_inodes_free(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetImagefsInodesFree", []))

    @jsii.member(jsii_name="resetMemoryAvailable")
    def reset_memory_available(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMemoryAvailable", []))

    @jsii.member(jsii_name="resetNodefsAvailable")
    def reset_nodefs_available(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNodefsAvailable", []))

    @jsii.member(jsii_name="resetNodefsInodesFree")
    def reset_nodefs_inodes_free(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNodefsInodesFree", []))

    @jsii.member(jsii_name="resetPidAvailable")
    def reset_pid_available(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPidAvailable", []))

    @builtins.property
    @jsii.member(jsii_name="imagefsAvailableInput")
    def imagefs_available_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "imagefsAvailableInput"))

    @builtins.property
    @jsii.member(jsii_name="imagefsInodesFreeInput")
    def imagefs_inodes_free_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "imagefsInodesFreeInput"))

    @builtins.property
    @jsii.member(jsii_name="memoryAvailableInput")
    def memory_available_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "memoryAvailableInput"))

    @builtins.property
    @jsii.member(jsii_name="nodefsAvailableInput")
    def nodefs_available_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nodefsAvailableInput"))

    @builtins.property
    @jsii.member(jsii_name="nodefsInodesFreeInput")
    def nodefs_inodes_free_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nodefsInodesFreeInput"))

    @builtins.property
    @jsii.member(jsii_name="pidAvailableInput")
    def pid_available_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "pidAvailableInput"))

    @builtins.property
    @jsii.member(jsii_name="imagefsAvailable")
    def imagefs_available(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "imagefsAvailable"))

    @imagefs_available.setter
    def imagefs_available(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f53e19e8922be6d502c87fc10dc61199e7f002730e93dd22e05610f1557ae185)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "imagefsAvailable", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="imagefsInodesFree")
    def imagefs_inodes_free(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "imagefsInodesFree"))

    @imagefs_inodes_free.setter
    def imagefs_inodes_free(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__809dc2098ce506ca1d5cbf766b67cbea304d56328c428a87e2fbecaa17310331)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "imagefsInodesFree", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="memoryAvailable")
    def memory_available(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "memoryAvailable"))

    @memory_available.setter
    def memory_available(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1fb47be92be3331f1ab4075d563b6135121f19a97b9a6ebf1fbaf00ec04b07b8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "memoryAvailable", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="nodefsAvailable")
    def nodefs_available(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "nodefsAvailable"))

    @nodefs_available.setter
    def nodefs_available(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bd7553bafd581eaf204d4f4042df8b94ba5ae2da63905459dca0db9f82f4e39c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "nodefsAvailable", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="nodefsInodesFree")
    def nodefs_inodes_free(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "nodefsInodesFree"))

    @nodefs_inodes_free.setter
    def nodefs_inodes_free(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f457a525b79e805d8aeb6b47775e669b0903557fc634c7bafad7004628b03174)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "nodefsInodesFree", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="pidAvailable")
    def pid_available(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "pidAvailable"))

    @pid_available.setter
    def pid_available(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b574672b807a9f2d0efe3b19b3a29f29bf8397990ab2283461aa37dc275a3c06)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "pidAvailable", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodeConfigKubeletConfigEvictionMinimumReclaim]:
        return typing.cast(typing.Optional[ContainerClusterNodeConfigKubeletConfigEvictionMinimumReclaim], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodeConfigKubeletConfigEvictionMinimumReclaim],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__14ec39835952c81639992a0a8488587f14aa1d73ed2f43c9c797e1a9c834d1cd)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigKubeletConfigEvictionSoft",
    jsii_struct_bases=[],
    name_mapping={
        "imagefs_available": "imagefsAvailable",
        "imagefs_inodes_free": "imagefsInodesFree",
        "memory_available": "memoryAvailable",
        "nodefs_available": "nodefsAvailable",
        "nodefs_inodes_free": "nodefsInodesFree",
        "pid_available": "pidAvailable",
    },
)
class ContainerClusterNodeConfigKubeletConfigEvictionSoft:
    def __init__(
        self,
        *,
        imagefs_available: typing.Optional[builtins.str] = None,
        imagefs_inodes_free: typing.Optional[builtins.str] = None,
        memory_available: typing.Optional[builtins.str] = None,
        nodefs_available: typing.Optional[builtins.str] = None,
        nodefs_inodes_free: typing.Optional[builtins.str] = None,
        pid_available: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param imagefs_available: Defines percentage of soft eviction threshold for imagefs.available. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#imagefs_available ContainerCluster#imagefs_available}
        :param imagefs_inodes_free: Defines percentage of soft eviction threshold for imagefs.inodesFree. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#imagefs_inodes_free ContainerCluster#imagefs_inodes_free}
        :param memory_available: Defines quantity of soft eviction threshold for memory.available. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#memory_available ContainerCluster#memory_available}
        :param nodefs_available: Defines percentage of soft eviction threshold for nodefs.available. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#nodefs_available ContainerCluster#nodefs_available}
        :param nodefs_inodes_free: Defines percentage of soft eviction threshold for nodefs.inodesFree. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#nodefs_inodes_free ContainerCluster#nodefs_inodes_free}
        :param pid_available: Defines percentage of soft eviction threshold for pid.available. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#pid_available ContainerCluster#pid_available}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1bfcb35216cd72e322de0d2d71a5c72acfc82832a8b8fc82e9e07c243711d116)
            check_type(argname="argument imagefs_available", value=imagefs_available, expected_type=type_hints["imagefs_available"])
            check_type(argname="argument imagefs_inodes_free", value=imagefs_inodes_free, expected_type=type_hints["imagefs_inodes_free"])
            check_type(argname="argument memory_available", value=memory_available, expected_type=type_hints["memory_available"])
            check_type(argname="argument nodefs_available", value=nodefs_available, expected_type=type_hints["nodefs_available"])
            check_type(argname="argument nodefs_inodes_free", value=nodefs_inodes_free, expected_type=type_hints["nodefs_inodes_free"])
            check_type(argname="argument pid_available", value=pid_available, expected_type=type_hints["pid_available"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if imagefs_available is not None:
            self._values["imagefs_available"] = imagefs_available
        if imagefs_inodes_free is not None:
            self._values["imagefs_inodes_free"] = imagefs_inodes_free
        if memory_available is not None:
            self._values["memory_available"] = memory_available
        if nodefs_available is not None:
            self._values["nodefs_available"] = nodefs_available
        if nodefs_inodes_free is not None:
            self._values["nodefs_inodes_free"] = nodefs_inodes_free
        if pid_available is not None:
            self._values["pid_available"] = pid_available

    @builtins.property
    def imagefs_available(self) -> typing.Optional[builtins.str]:
        '''Defines percentage of soft eviction threshold for imagefs.available.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#imagefs_available ContainerCluster#imagefs_available}
        '''
        result = self._values.get("imagefs_available")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def imagefs_inodes_free(self) -> typing.Optional[builtins.str]:
        '''Defines percentage of soft eviction threshold for imagefs.inodesFree.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#imagefs_inodes_free ContainerCluster#imagefs_inodes_free}
        '''
        result = self._values.get("imagefs_inodes_free")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def memory_available(self) -> typing.Optional[builtins.str]:
        '''Defines quantity of soft eviction threshold for memory.available.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#memory_available ContainerCluster#memory_available}
        '''
        result = self._values.get("memory_available")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def nodefs_available(self) -> typing.Optional[builtins.str]:
        '''Defines percentage of soft eviction threshold for nodefs.available.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#nodefs_available ContainerCluster#nodefs_available}
        '''
        result = self._values.get("nodefs_available")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def nodefs_inodes_free(self) -> typing.Optional[builtins.str]:
        '''Defines percentage of soft eviction threshold for nodefs.inodesFree.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#nodefs_inodes_free ContainerCluster#nodefs_inodes_free}
        '''
        result = self._values.get("nodefs_inodes_free")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def pid_available(self) -> typing.Optional[builtins.str]:
        '''Defines percentage of soft eviction threshold for pid.available.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#pid_available ContainerCluster#pid_available}
        '''
        result = self._values.get("pid_available")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodeConfigKubeletConfigEvictionSoft(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigKubeletConfigEvictionSoftGracePeriod",
    jsii_struct_bases=[],
    name_mapping={
        "imagefs_available": "imagefsAvailable",
        "imagefs_inodes_free": "imagefsInodesFree",
        "memory_available": "memoryAvailable",
        "nodefs_available": "nodefsAvailable",
        "nodefs_inodes_free": "nodefsInodesFree",
        "pid_available": "pidAvailable",
    },
)
class ContainerClusterNodeConfigKubeletConfigEvictionSoftGracePeriod:
    def __init__(
        self,
        *,
        imagefs_available: typing.Optional[builtins.str] = None,
        imagefs_inodes_free: typing.Optional[builtins.str] = None,
        memory_available: typing.Optional[builtins.str] = None,
        nodefs_available: typing.Optional[builtins.str] = None,
        nodefs_inodes_free: typing.Optional[builtins.str] = None,
        pid_available: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param imagefs_available: Defines grace period for the imagefs.available soft eviction threshold. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#imagefs_available ContainerCluster#imagefs_available}
        :param imagefs_inodes_free: Defines grace period for the imagefs.inodesFree soft eviction threshold. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#imagefs_inodes_free ContainerCluster#imagefs_inodes_free}
        :param memory_available: Defines grace period for the memory.available soft eviction threshold. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#memory_available ContainerCluster#memory_available}
        :param nodefs_available: Defines grace period for the nodefs.available soft eviction threshold. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#nodefs_available ContainerCluster#nodefs_available}
        :param nodefs_inodes_free: Defines grace period for the nodefs.inodesFree soft eviction threshold. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#nodefs_inodes_free ContainerCluster#nodefs_inodes_free}
        :param pid_available: Defines grace period for the pid.available soft eviction threshold. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#pid_available ContainerCluster#pid_available}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__030e126bb6a8b727606f7a22ae08ae48b42bac28512c47cbc888f538fb74bbd0)
            check_type(argname="argument imagefs_available", value=imagefs_available, expected_type=type_hints["imagefs_available"])
            check_type(argname="argument imagefs_inodes_free", value=imagefs_inodes_free, expected_type=type_hints["imagefs_inodes_free"])
            check_type(argname="argument memory_available", value=memory_available, expected_type=type_hints["memory_available"])
            check_type(argname="argument nodefs_available", value=nodefs_available, expected_type=type_hints["nodefs_available"])
            check_type(argname="argument nodefs_inodes_free", value=nodefs_inodes_free, expected_type=type_hints["nodefs_inodes_free"])
            check_type(argname="argument pid_available", value=pid_available, expected_type=type_hints["pid_available"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if imagefs_available is not None:
            self._values["imagefs_available"] = imagefs_available
        if imagefs_inodes_free is not None:
            self._values["imagefs_inodes_free"] = imagefs_inodes_free
        if memory_available is not None:
            self._values["memory_available"] = memory_available
        if nodefs_available is not None:
            self._values["nodefs_available"] = nodefs_available
        if nodefs_inodes_free is not None:
            self._values["nodefs_inodes_free"] = nodefs_inodes_free
        if pid_available is not None:
            self._values["pid_available"] = pid_available

    @builtins.property
    def imagefs_available(self) -> typing.Optional[builtins.str]:
        '''Defines grace period for the imagefs.available soft eviction threshold.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#imagefs_available ContainerCluster#imagefs_available}
        '''
        result = self._values.get("imagefs_available")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def imagefs_inodes_free(self) -> typing.Optional[builtins.str]:
        '''Defines grace period for the imagefs.inodesFree soft eviction threshold.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#imagefs_inodes_free ContainerCluster#imagefs_inodes_free}
        '''
        result = self._values.get("imagefs_inodes_free")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def memory_available(self) -> typing.Optional[builtins.str]:
        '''Defines grace period for the memory.available soft eviction threshold.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#memory_available ContainerCluster#memory_available}
        '''
        result = self._values.get("memory_available")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def nodefs_available(self) -> typing.Optional[builtins.str]:
        '''Defines grace period for the nodefs.available soft eviction threshold.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#nodefs_available ContainerCluster#nodefs_available}
        '''
        result = self._values.get("nodefs_available")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def nodefs_inodes_free(self) -> typing.Optional[builtins.str]:
        '''Defines grace period for the nodefs.inodesFree soft eviction threshold.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#nodefs_inodes_free ContainerCluster#nodefs_inodes_free}
        '''
        result = self._values.get("nodefs_inodes_free")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def pid_available(self) -> typing.Optional[builtins.str]:
        '''Defines grace period for the pid.available soft eviction threshold.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#pid_available ContainerCluster#pid_available}
        '''
        result = self._values.get("pid_available")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodeConfigKubeletConfigEvictionSoftGracePeriod(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodeConfigKubeletConfigEvictionSoftGracePeriodOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigKubeletConfigEvictionSoftGracePeriodOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b381415903e8aed0fed95be522c3118a90b03f1eee93a214ffa2e95aebb91528)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetImagefsAvailable")
    def reset_imagefs_available(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetImagefsAvailable", []))

    @jsii.member(jsii_name="resetImagefsInodesFree")
    def reset_imagefs_inodes_free(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetImagefsInodesFree", []))

    @jsii.member(jsii_name="resetMemoryAvailable")
    def reset_memory_available(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMemoryAvailable", []))

    @jsii.member(jsii_name="resetNodefsAvailable")
    def reset_nodefs_available(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNodefsAvailable", []))

    @jsii.member(jsii_name="resetNodefsInodesFree")
    def reset_nodefs_inodes_free(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNodefsInodesFree", []))

    @jsii.member(jsii_name="resetPidAvailable")
    def reset_pid_available(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPidAvailable", []))

    @builtins.property
    @jsii.member(jsii_name="imagefsAvailableInput")
    def imagefs_available_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "imagefsAvailableInput"))

    @builtins.property
    @jsii.member(jsii_name="imagefsInodesFreeInput")
    def imagefs_inodes_free_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "imagefsInodesFreeInput"))

    @builtins.property
    @jsii.member(jsii_name="memoryAvailableInput")
    def memory_available_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "memoryAvailableInput"))

    @builtins.property
    @jsii.member(jsii_name="nodefsAvailableInput")
    def nodefs_available_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nodefsAvailableInput"))

    @builtins.property
    @jsii.member(jsii_name="nodefsInodesFreeInput")
    def nodefs_inodes_free_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nodefsInodesFreeInput"))

    @builtins.property
    @jsii.member(jsii_name="pidAvailableInput")
    def pid_available_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "pidAvailableInput"))

    @builtins.property
    @jsii.member(jsii_name="imagefsAvailable")
    def imagefs_available(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "imagefsAvailable"))

    @imagefs_available.setter
    def imagefs_available(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__551f1922a30ad2fb0b8edbeca0276296171d4c6bc87deccf9dba222023f3fb27)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "imagefsAvailable", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="imagefsInodesFree")
    def imagefs_inodes_free(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "imagefsInodesFree"))

    @imagefs_inodes_free.setter
    def imagefs_inodes_free(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__aad375cfb885fe4120a36041f7db62bbc7b2d4eceb91fcc38de6966511f502af)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "imagefsInodesFree", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="memoryAvailable")
    def memory_available(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "memoryAvailable"))

    @memory_available.setter
    def memory_available(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e05d1c99ccb8e130a31527bcc5c9a3c8328cd2b0945d25fedd3b9c73c5a22744)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "memoryAvailable", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="nodefsAvailable")
    def nodefs_available(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "nodefsAvailable"))

    @nodefs_available.setter
    def nodefs_available(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b39c0a46fa7d18b91cca69de5ced39e90c98167bcc4909f09b0794915777d445)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "nodefsAvailable", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="nodefsInodesFree")
    def nodefs_inodes_free(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "nodefsInodesFree"))

    @nodefs_inodes_free.setter
    def nodefs_inodes_free(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bf4aa701cd2972fbd0284f688cdd03cc2479b5583276444d04a829e918ee0688)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "nodefsInodesFree", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="pidAvailable")
    def pid_available(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "pidAvailable"))

    @pid_available.setter
    def pid_available(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1e83bf840646f5c55f8d179226f4156b4ca089354cb0f68ea29ce5bc2ac928cc)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "pidAvailable", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodeConfigKubeletConfigEvictionSoftGracePeriod]:
        return typing.cast(typing.Optional[ContainerClusterNodeConfigKubeletConfigEvictionSoftGracePeriod], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodeConfigKubeletConfigEvictionSoftGracePeriod],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__428dd79079927869c58a39526b67639dc48df81e7a035d1902ef0d6f38248c72)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ContainerClusterNodeConfigKubeletConfigEvictionSoftOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigKubeletConfigEvictionSoftOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8f8d01cfc653296c3bdd853424679914abb8a6a60ad1332ba3e884a1c2985461)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetImagefsAvailable")
    def reset_imagefs_available(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetImagefsAvailable", []))

    @jsii.member(jsii_name="resetImagefsInodesFree")
    def reset_imagefs_inodes_free(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetImagefsInodesFree", []))

    @jsii.member(jsii_name="resetMemoryAvailable")
    def reset_memory_available(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMemoryAvailable", []))

    @jsii.member(jsii_name="resetNodefsAvailable")
    def reset_nodefs_available(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNodefsAvailable", []))

    @jsii.member(jsii_name="resetNodefsInodesFree")
    def reset_nodefs_inodes_free(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNodefsInodesFree", []))

    @jsii.member(jsii_name="resetPidAvailable")
    def reset_pid_available(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPidAvailable", []))

    @builtins.property
    @jsii.member(jsii_name="imagefsAvailableInput")
    def imagefs_available_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "imagefsAvailableInput"))

    @builtins.property
    @jsii.member(jsii_name="imagefsInodesFreeInput")
    def imagefs_inodes_free_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "imagefsInodesFreeInput"))

    @builtins.property
    @jsii.member(jsii_name="memoryAvailableInput")
    def memory_available_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "memoryAvailableInput"))

    @builtins.property
    @jsii.member(jsii_name="nodefsAvailableInput")
    def nodefs_available_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nodefsAvailableInput"))

    @builtins.property
    @jsii.member(jsii_name="nodefsInodesFreeInput")
    def nodefs_inodes_free_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nodefsInodesFreeInput"))

    @builtins.property
    @jsii.member(jsii_name="pidAvailableInput")
    def pid_available_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "pidAvailableInput"))

    @builtins.property
    @jsii.member(jsii_name="imagefsAvailable")
    def imagefs_available(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "imagefsAvailable"))

    @imagefs_available.setter
    def imagefs_available(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9f2ee4ae9fda05d326d8ff0d52713855540203019ed803e81ba0af5eb2c7e471)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "imagefsAvailable", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="imagefsInodesFree")
    def imagefs_inodes_free(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "imagefsInodesFree"))

    @imagefs_inodes_free.setter
    def imagefs_inodes_free(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c7088fb2b7229694486ea25871c4ee121a4694444bb73739ffc87fc03059ce99)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "imagefsInodesFree", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="memoryAvailable")
    def memory_available(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "memoryAvailable"))

    @memory_available.setter
    def memory_available(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ba3d9c3b5ec07eca6754dca9ec89f71819381c0c09472504a63db5a667846226)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "memoryAvailable", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="nodefsAvailable")
    def nodefs_available(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "nodefsAvailable"))

    @nodefs_available.setter
    def nodefs_available(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1c0c0641ca30ca2e9b6cece132635bfbcc18892cfe23d7bbb72aad512b73e388)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "nodefsAvailable", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="nodefsInodesFree")
    def nodefs_inodes_free(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "nodefsInodesFree"))

    @nodefs_inodes_free.setter
    def nodefs_inodes_free(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4b62554c895e318bb0b3e02a79d84d418d8aa46d90e8ac6e7dbfcf4edeecc48c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "nodefsInodesFree", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="pidAvailable")
    def pid_available(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "pidAvailable"))

    @pid_available.setter
    def pid_available(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8f36f4a370c15f64bb88b9dab06c3846191dbbba436f80a25adb09e9b47cb25a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "pidAvailable", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodeConfigKubeletConfigEvictionSoft]:
        return typing.cast(typing.Optional[ContainerClusterNodeConfigKubeletConfigEvictionSoft], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodeConfigKubeletConfigEvictionSoft],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__31c04b4ea9d62a81a8b371f102556e9f8fbf583efec88ff9a81eb06360721bd3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ContainerClusterNodeConfigKubeletConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigKubeletConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c577999341f4102ca553014b2adc85c8acbbfdb7a92248d87bcf04d85672dc8d)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putEvictionMinimumReclaim")
    def put_eviction_minimum_reclaim(
        self,
        *,
        imagefs_available: typing.Optional[builtins.str] = None,
        imagefs_inodes_free: typing.Optional[builtins.str] = None,
        memory_available: typing.Optional[builtins.str] = None,
        nodefs_available: typing.Optional[builtins.str] = None,
        nodefs_inodes_free: typing.Optional[builtins.str] = None,
        pid_available: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param imagefs_available: Defines percentage of minimum reclaim for imagefs.available. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#imagefs_available ContainerCluster#imagefs_available}
        :param imagefs_inodes_free: Defines percentage of minimum reclaim for imagefs.inodesFree. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#imagefs_inodes_free ContainerCluster#imagefs_inodes_free}
        :param memory_available: Defines percentage of minimum reclaim for memory.available. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#memory_available ContainerCluster#memory_available}
        :param nodefs_available: Defines percentage of minimum reclaim for nodefs.available. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#nodefs_available ContainerCluster#nodefs_available}
        :param nodefs_inodes_free: Defines percentage of minimum reclaim for nodefs.inodesFree. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#nodefs_inodes_free ContainerCluster#nodefs_inodes_free}
        :param pid_available: Defines percentage of minimum reclaim for pid.available. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#pid_available ContainerCluster#pid_available}
        '''
        value = ContainerClusterNodeConfigKubeletConfigEvictionMinimumReclaim(
            imagefs_available=imagefs_available,
            imagefs_inodes_free=imagefs_inodes_free,
            memory_available=memory_available,
            nodefs_available=nodefs_available,
            nodefs_inodes_free=nodefs_inodes_free,
            pid_available=pid_available,
        )

        return typing.cast(None, jsii.invoke(self, "putEvictionMinimumReclaim", [value]))

    @jsii.member(jsii_name="putEvictionSoft")
    def put_eviction_soft(
        self,
        *,
        imagefs_available: typing.Optional[builtins.str] = None,
        imagefs_inodes_free: typing.Optional[builtins.str] = None,
        memory_available: typing.Optional[builtins.str] = None,
        nodefs_available: typing.Optional[builtins.str] = None,
        nodefs_inodes_free: typing.Optional[builtins.str] = None,
        pid_available: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param imagefs_available: Defines percentage of soft eviction threshold for imagefs.available. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#imagefs_available ContainerCluster#imagefs_available}
        :param imagefs_inodes_free: Defines percentage of soft eviction threshold for imagefs.inodesFree. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#imagefs_inodes_free ContainerCluster#imagefs_inodes_free}
        :param memory_available: Defines quantity of soft eviction threshold for memory.available. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#memory_available ContainerCluster#memory_available}
        :param nodefs_available: Defines percentage of soft eviction threshold for nodefs.available. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#nodefs_available ContainerCluster#nodefs_available}
        :param nodefs_inodes_free: Defines percentage of soft eviction threshold for nodefs.inodesFree. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#nodefs_inodes_free ContainerCluster#nodefs_inodes_free}
        :param pid_available: Defines percentage of soft eviction threshold for pid.available. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#pid_available ContainerCluster#pid_available}
        '''
        value = ContainerClusterNodeConfigKubeletConfigEvictionSoft(
            imagefs_available=imagefs_available,
            imagefs_inodes_free=imagefs_inodes_free,
            memory_available=memory_available,
            nodefs_available=nodefs_available,
            nodefs_inodes_free=nodefs_inodes_free,
            pid_available=pid_available,
        )

        return typing.cast(None, jsii.invoke(self, "putEvictionSoft", [value]))

    @jsii.member(jsii_name="putEvictionSoftGracePeriod")
    def put_eviction_soft_grace_period(
        self,
        *,
        imagefs_available: typing.Optional[builtins.str] = None,
        imagefs_inodes_free: typing.Optional[builtins.str] = None,
        memory_available: typing.Optional[builtins.str] = None,
        nodefs_available: typing.Optional[builtins.str] = None,
        nodefs_inodes_free: typing.Optional[builtins.str] = None,
        pid_available: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param imagefs_available: Defines grace period for the imagefs.available soft eviction threshold. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#imagefs_available ContainerCluster#imagefs_available}
        :param imagefs_inodes_free: Defines grace period for the imagefs.inodesFree soft eviction threshold. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#imagefs_inodes_free ContainerCluster#imagefs_inodes_free}
        :param memory_available: Defines grace period for the memory.available soft eviction threshold. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#memory_available ContainerCluster#memory_available}
        :param nodefs_available: Defines grace period for the nodefs.available soft eviction threshold. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#nodefs_available ContainerCluster#nodefs_available}
        :param nodefs_inodes_free: Defines grace period for the nodefs.inodesFree soft eviction threshold. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#nodefs_inodes_free ContainerCluster#nodefs_inodes_free}
        :param pid_available: Defines grace period for the pid.available soft eviction threshold. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#pid_available ContainerCluster#pid_available}
        '''
        value = ContainerClusterNodeConfigKubeletConfigEvictionSoftGracePeriod(
            imagefs_available=imagefs_available,
            imagefs_inodes_free=imagefs_inodes_free,
            memory_available=memory_available,
            nodefs_available=nodefs_available,
            nodefs_inodes_free=nodefs_inodes_free,
            pid_available=pid_available,
        )

        return typing.cast(None, jsii.invoke(self, "putEvictionSoftGracePeriod", [value]))

    @jsii.member(jsii_name="resetAllowedUnsafeSysctls")
    def reset_allowed_unsafe_sysctls(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAllowedUnsafeSysctls", []))

    @jsii.member(jsii_name="resetContainerLogMaxFiles")
    def reset_container_log_max_files(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetContainerLogMaxFiles", []))

    @jsii.member(jsii_name="resetContainerLogMaxSize")
    def reset_container_log_max_size(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetContainerLogMaxSize", []))

    @jsii.member(jsii_name="resetCpuCfsQuota")
    def reset_cpu_cfs_quota(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCpuCfsQuota", []))

    @jsii.member(jsii_name="resetCpuCfsQuotaPeriod")
    def reset_cpu_cfs_quota_period(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCpuCfsQuotaPeriod", []))

    @jsii.member(jsii_name="resetCpuManagerPolicy")
    def reset_cpu_manager_policy(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCpuManagerPolicy", []))

    @jsii.member(jsii_name="resetEvictionMaxPodGracePeriodSeconds")
    def reset_eviction_max_pod_grace_period_seconds(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEvictionMaxPodGracePeriodSeconds", []))

    @jsii.member(jsii_name="resetEvictionMinimumReclaim")
    def reset_eviction_minimum_reclaim(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEvictionMinimumReclaim", []))

    @jsii.member(jsii_name="resetEvictionSoft")
    def reset_eviction_soft(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEvictionSoft", []))

    @jsii.member(jsii_name="resetEvictionSoftGracePeriod")
    def reset_eviction_soft_grace_period(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEvictionSoftGracePeriod", []))

    @jsii.member(jsii_name="resetImageGcHighThresholdPercent")
    def reset_image_gc_high_threshold_percent(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetImageGcHighThresholdPercent", []))

    @jsii.member(jsii_name="resetImageGcLowThresholdPercent")
    def reset_image_gc_low_threshold_percent(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetImageGcLowThresholdPercent", []))

    @jsii.member(jsii_name="resetImageMaximumGcAge")
    def reset_image_maximum_gc_age(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetImageMaximumGcAge", []))

    @jsii.member(jsii_name="resetImageMinimumGcAge")
    def reset_image_minimum_gc_age(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetImageMinimumGcAge", []))

    @jsii.member(jsii_name="resetInsecureKubeletReadonlyPortEnabled")
    def reset_insecure_kubelet_readonly_port_enabled(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetInsecureKubeletReadonlyPortEnabled", []))

    @jsii.member(jsii_name="resetMaxParallelImagePulls")
    def reset_max_parallel_image_pulls(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMaxParallelImagePulls", []))

    @jsii.member(jsii_name="resetPodPidsLimit")
    def reset_pod_pids_limit(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPodPidsLimit", []))

    @jsii.member(jsii_name="resetSingleProcessOomKill")
    def reset_single_process_oom_kill(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSingleProcessOomKill", []))

    @builtins.property
    @jsii.member(jsii_name="evictionMinimumReclaim")
    def eviction_minimum_reclaim(
        self,
    ) -> ContainerClusterNodeConfigKubeletConfigEvictionMinimumReclaimOutputReference:
        return typing.cast(ContainerClusterNodeConfigKubeletConfigEvictionMinimumReclaimOutputReference, jsii.get(self, "evictionMinimumReclaim"))

    @builtins.property
    @jsii.member(jsii_name="evictionSoft")
    def eviction_soft(
        self,
    ) -> ContainerClusterNodeConfigKubeletConfigEvictionSoftOutputReference:
        return typing.cast(ContainerClusterNodeConfigKubeletConfigEvictionSoftOutputReference, jsii.get(self, "evictionSoft"))

    @builtins.property
    @jsii.member(jsii_name="evictionSoftGracePeriod")
    def eviction_soft_grace_period(
        self,
    ) -> ContainerClusterNodeConfigKubeletConfigEvictionSoftGracePeriodOutputReference:
        return typing.cast(ContainerClusterNodeConfigKubeletConfigEvictionSoftGracePeriodOutputReference, jsii.get(self, "evictionSoftGracePeriod"))

    @builtins.property
    @jsii.member(jsii_name="allowedUnsafeSysctlsInput")
    def allowed_unsafe_sysctls_input(
        self,
    ) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "allowedUnsafeSysctlsInput"))

    @builtins.property
    @jsii.member(jsii_name="containerLogMaxFilesInput")
    def container_log_max_files_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "containerLogMaxFilesInput"))

    @builtins.property
    @jsii.member(jsii_name="containerLogMaxSizeInput")
    def container_log_max_size_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "containerLogMaxSizeInput"))

    @builtins.property
    @jsii.member(jsii_name="cpuCfsQuotaInput")
    def cpu_cfs_quota_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "cpuCfsQuotaInput"))

    @builtins.property
    @jsii.member(jsii_name="cpuCfsQuotaPeriodInput")
    def cpu_cfs_quota_period_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "cpuCfsQuotaPeriodInput"))

    @builtins.property
    @jsii.member(jsii_name="cpuManagerPolicyInput")
    def cpu_manager_policy_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "cpuManagerPolicyInput"))

    @builtins.property
    @jsii.member(jsii_name="evictionMaxPodGracePeriodSecondsInput")
    def eviction_max_pod_grace_period_seconds_input(
        self,
    ) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "evictionMaxPodGracePeriodSecondsInput"))

    @builtins.property
    @jsii.member(jsii_name="evictionMinimumReclaimInput")
    def eviction_minimum_reclaim_input(
        self,
    ) -> typing.Optional[ContainerClusterNodeConfigKubeletConfigEvictionMinimumReclaim]:
        return typing.cast(typing.Optional[ContainerClusterNodeConfigKubeletConfigEvictionMinimumReclaim], jsii.get(self, "evictionMinimumReclaimInput"))

    @builtins.property
    @jsii.member(jsii_name="evictionSoftGracePeriodInput")
    def eviction_soft_grace_period_input(
        self,
    ) -> typing.Optional[ContainerClusterNodeConfigKubeletConfigEvictionSoftGracePeriod]:
        return typing.cast(typing.Optional[ContainerClusterNodeConfigKubeletConfigEvictionSoftGracePeriod], jsii.get(self, "evictionSoftGracePeriodInput"))

    @builtins.property
    @jsii.member(jsii_name="evictionSoftInput")
    def eviction_soft_input(
        self,
    ) -> typing.Optional[ContainerClusterNodeConfigKubeletConfigEvictionSoft]:
        return typing.cast(typing.Optional[ContainerClusterNodeConfigKubeletConfigEvictionSoft], jsii.get(self, "evictionSoftInput"))

    @builtins.property
    @jsii.member(jsii_name="imageGcHighThresholdPercentInput")
    def image_gc_high_threshold_percent_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "imageGcHighThresholdPercentInput"))

    @builtins.property
    @jsii.member(jsii_name="imageGcLowThresholdPercentInput")
    def image_gc_low_threshold_percent_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "imageGcLowThresholdPercentInput"))

    @builtins.property
    @jsii.member(jsii_name="imageMaximumGcAgeInput")
    def image_maximum_gc_age_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "imageMaximumGcAgeInput"))

    @builtins.property
    @jsii.member(jsii_name="imageMinimumGcAgeInput")
    def image_minimum_gc_age_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "imageMinimumGcAgeInput"))

    @builtins.property
    @jsii.member(jsii_name="insecureKubeletReadonlyPortEnabledInput")
    def insecure_kubelet_readonly_port_enabled_input(
        self,
    ) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "insecureKubeletReadonlyPortEnabledInput"))

    @builtins.property
    @jsii.member(jsii_name="maxParallelImagePullsInput")
    def max_parallel_image_pulls_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "maxParallelImagePullsInput"))

    @builtins.property
    @jsii.member(jsii_name="podPidsLimitInput")
    def pod_pids_limit_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "podPidsLimitInput"))

    @builtins.property
    @jsii.member(jsii_name="singleProcessOomKillInput")
    def single_process_oom_kill_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "singleProcessOomKillInput"))

    @builtins.property
    @jsii.member(jsii_name="allowedUnsafeSysctls")
    def allowed_unsafe_sysctls(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "allowedUnsafeSysctls"))

    @allowed_unsafe_sysctls.setter
    def allowed_unsafe_sysctls(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__56d17e0fbf9299224aad19af67c2fb227762a92c673cb3f470508db363a431eb)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "allowedUnsafeSysctls", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="containerLogMaxFiles")
    def container_log_max_files(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "containerLogMaxFiles"))

    @container_log_max_files.setter
    def container_log_max_files(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__04c7c4cd7e253eec2b93767920006f955d77ff9de7c63e29a4de7c25c0a36d75)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "containerLogMaxFiles", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="containerLogMaxSize")
    def container_log_max_size(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "containerLogMaxSize"))

    @container_log_max_size.setter
    def container_log_max_size(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__120f354152198caf726f10c779f18b0cd59188206840075a6a5dfe9046e1bc0b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "containerLogMaxSize", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="cpuCfsQuota")
    def cpu_cfs_quota(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "cpuCfsQuota"))

    @cpu_cfs_quota.setter
    def cpu_cfs_quota(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1c20bde77f030d4af9282b53ab42a20a06654698f204d2a4b3dced71d1f2a8b2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "cpuCfsQuota", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="cpuCfsQuotaPeriod")
    def cpu_cfs_quota_period(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "cpuCfsQuotaPeriod"))

    @cpu_cfs_quota_period.setter
    def cpu_cfs_quota_period(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0e9e1a26c2467648706d35292d5464e74c73866f5c012d5f1f7f5f7ad051da5f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "cpuCfsQuotaPeriod", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="cpuManagerPolicy")
    def cpu_manager_policy(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "cpuManagerPolicy"))

    @cpu_manager_policy.setter
    def cpu_manager_policy(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2e384d698ce3ccc0faec262f20df56b6d11d670df2a160ed6fefb03668aca7b5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "cpuManagerPolicy", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="evictionMaxPodGracePeriodSeconds")
    def eviction_max_pod_grace_period_seconds(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "evictionMaxPodGracePeriodSeconds"))

    @eviction_max_pod_grace_period_seconds.setter
    def eviction_max_pod_grace_period_seconds(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7a277a871af2618e0492b5efd490247007e188df92fa32002f37953bb1f805dc)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "evictionMaxPodGracePeriodSeconds", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="imageGcHighThresholdPercent")
    def image_gc_high_threshold_percent(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "imageGcHighThresholdPercent"))

    @image_gc_high_threshold_percent.setter
    def image_gc_high_threshold_percent(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dd4d2def7d7aafbf275a4402d6914dfca8c7bc8942b89f07ab9b5d0b118c4eec)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "imageGcHighThresholdPercent", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="imageGcLowThresholdPercent")
    def image_gc_low_threshold_percent(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "imageGcLowThresholdPercent"))

    @image_gc_low_threshold_percent.setter
    def image_gc_low_threshold_percent(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3b958724edeab4d5c9ee6121f0279ea631581468ab500893707b06cd51e3d4e3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "imageGcLowThresholdPercent", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="imageMaximumGcAge")
    def image_maximum_gc_age(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "imageMaximumGcAge"))

    @image_maximum_gc_age.setter
    def image_maximum_gc_age(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bb1ca122bc6030895804f07902e156a8644f3c64a944457ae9366e3c1dc3eeb9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "imageMaximumGcAge", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="imageMinimumGcAge")
    def image_minimum_gc_age(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "imageMinimumGcAge"))

    @image_minimum_gc_age.setter
    def image_minimum_gc_age(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ca9765dc5fe46066f56ef2dcd972869c7ae113ac15460fedf6682af83cf9711d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "imageMinimumGcAge", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="insecureKubeletReadonlyPortEnabled")
    def insecure_kubelet_readonly_port_enabled(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "insecureKubeletReadonlyPortEnabled"))

    @insecure_kubelet_readonly_port_enabled.setter
    def insecure_kubelet_readonly_port_enabled(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cc0f620dcd3ee56a9683e207b6b27ee66b04abd55ae173ae773daa535091eace)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "insecureKubeletReadonlyPortEnabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="maxParallelImagePulls")
    def max_parallel_image_pulls(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "maxParallelImagePulls"))

    @max_parallel_image_pulls.setter
    def max_parallel_image_pulls(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8c03aed89ee35179c62e022f11ed197c39b2a3656ef8cadb4be31b7a844e4b8c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "maxParallelImagePulls", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="podPidsLimit")
    def pod_pids_limit(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "podPidsLimit"))

    @pod_pids_limit.setter
    def pod_pids_limit(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bc06092394a13b232d6de044022412b151b6dd260cc85194d84799d034253c5d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "podPidsLimit", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="singleProcessOomKill")
    def single_process_oom_kill(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "singleProcessOomKill"))

    @single_process_oom_kill.setter
    def single_process_oom_kill(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a8423057fe52abf644d9cd6072a513c1159d0df86b19202824e6f6105dab6766)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "singleProcessOomKill", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodeConfigKubeletConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodeConfigKubeletConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodeConfigKubeletConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cdbca4b36a12086580d30b5da0314b12b3021ca6e9402b9a975d6ede0d31a092)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigLinuxNodeConfig",
    jsii_struct_bases=[],
    name_mapping={
        "cgroup_mode": "cgroupMode",
        "hugepages_config": "hugepagesConfig",
        "sysctls": "sysctls",
        "transparent_hugepage_defrag": "transparentHugepageDefrag",
        "transparent_hugepage_enabled": "transparentHugepageEnabled",
    },
)
class ContainerClusterNodeConfigLinuxNodeConfig:
    def __init__(
        self,
        *,
        cgroup_mode: typing.Optional[builtins.str] = None,
        hugepages_config: typing.Optional[typing.Union["ContainerClusterNodeConfigLinuxNodeConfigHugepagesConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        sysctls: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        transparent_hugepage_defrag: typing.Optional[builtins.str] = None,
        transparent_hugepage_enabled: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param cgroup_mode: cgroupMode specifies the cgroup mode to be used on the node. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cgroup_mode ContainerCluster#cgroup_mode}
        :param hugepages_config: hugepages_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#hugepages_config ContainerCluster#hugepages_config}
        :param sysctls: The Linux kernel parameters to be applied to the nodes and all pods running on the nodes. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#sysctls ContainerCluster#sysctls}
        :param transparent_hugepage_defrag: The Linux kernel transparent hugepage defrag setting. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#transparent_hugepage_defrag ContainerCluster#transparent_hugepage_defrag}
        :param transparent_hugepage_enabled: The Linux kernel transparent hugepage setting. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#transparent_hugepage_enabled ContainerCluster#transparent_hugepage_enabled}
        '''
        if isinstance(hugepages_config, dict):
            hugepages_config = ContainerClusterNodeConfigLinuxNodeConfigHugepagesConfig(**hugepages_config)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7531f4ed33feb764dd52c8c2bff8672f6117ed9f35387b95fc69f77f6bc716e6)
            check_type(argname="argument cgroup_mode", value=cgroup_mode, expected_type=type_hints["cgroup_mode"])
            check_type(argname="argument hugepages_config", value=hugepages_config, expected_type=type_hints["hugepages_config"])
            check_type(argname="argument sysctls", value=sysctls, expected_type=type_hints["sysctls"])
            check_type(argname="argument transparent_hugepage_defrag", value=transparent_hugepage_defrag, expected_type=type_hints["transparent_hugepage_defrag"])
            check_type(argname="argument transparent_hugepage_enabled", value=transparent_hugepage_enabled, expected_type=type_hints["transparent_hugepage_enabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if cgroup_mode is not None:
            self._values["cgroup_mode"] = cgroup_mode
        if hugepages_config is not None:
            self._values["hugepages_config"] = hugepages_config
        if sysctls is not None:
            self._values["sysctls"] = sysctls
        if transparent_hugepage_defrag is not None:
            self._values["transparent_hugepage_defrag"] = transparent_hugepage_defrag
        if transparent_hugepage_enabled is not None:
            self._values["transparent_hugepage_enabled"] = transparent_hugepage_enabled

    @builtins.property
    def cgroup_mode(self) -> typing.Optional[builtins.str]:
        '''cgroupMode specifies the cgroup mode to be used on the node.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cgroup_mode ContainerCluster#cgroup_mode}
        '''
        result = self._values.get("cgroup_mode")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def hugepages_config(
        self,
    ) -> typing.Optional["ContainerClusterNodeConfigLinuxNodeConfigHugepagesConfig"]:
        '''hugepages_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#hugepages_config ContainerCluster#hugepages_config}
        '''
        result = self._values.get("hugepages_config")
        return typing.cast(typing.Optional["ContainerClusterNodeConfigLinuxNodeConfigHugepagesConfig"], result)

    @builtins.property
    def sysctls(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''The Linux kernel parameters to be applied to the nodes and all pods running on the nodes.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#sysctls ContainerCluster#sysctls}
        '''
        result = self._values.get("sysctls")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def transparent_hugepage_defrag(self) -> typing.Optional[builtins.str]:
        '''The Linux kernel transparent hugepage defrag setting.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#transparent_hugepage_defrag ContainerCluster#transparent_hugepage_defrag}
        '''
        result = self._values.get("transparent_hugepage_defrag")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def transparent_hugepage_enabled(self) -> typing.Optional[builtins.str]:
        '''The Linux kernel transparent hugepage setting.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#transparent_hugepage_enabled ContainerCluster#transparent_hugepage_enabled}
        '''
        result = self._values.get("transparent_hugepage_enabled")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodeConfigLinuxNodeConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigLinuxNodeConfigHugepagesConfig",
    jsii_struct_bases=[],
    name_mapping={
        "hugepage_size1_g": "hugepageSize1G",
        "hugepage_size2_m": "hugepageSize2M",
    },
)
class ContainerClusterNodeConfigLinuxNodeConfigHugepagesConfig:
    def __init__(
        self,
        *,
        hugepage_size1_g: typing.Optional[jsii.Number] = None,
        hugepage_size2_m: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param hugepage_size1_g: Amount of 1G hugepages. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#hugepage_size_1g ContainerCluster#hugepage_size_1g}
        :param hugepage_size2_m: Amount of 2M hugepages. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#hugepage_size_2m ContainerCluster#hugepage_size_2m}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cf6052ff0ddab3720dc422a178af64e70a0317665ec2f83fc97d21f80c3eadaf)
            check_type(argname="argument hugepage_size1_g", value=hugepage_size1_g, expected_type=type_hints["hugepage_size1_g"])
            check_type(argname="argument hugepage_size2_m", value=hugepage_size2_m, expected_type=type_hints["hugepage_size2_m"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if hugepage_size1_g is not None:
            self._values["hugepage_size1_g"] = hugepage_size1_g
        if hugepage_size2_m is not None:
            self._values["hugepage_size2_m"] = hugepage_size2_m

    @builtins.property
    def hugepage_size1_g(self) -> typing.Optional[jsii.Number]:
        '''Amount of 1G hugepages.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#hugepage_size_1g ContainerCluster#hugepage_size_1g}
        '''
        result = self._values.get("hugepage_size1_g")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def hugepage_size2_m(self) -> typing.Optional[jsii.Number]:
        '''Amount of 2M hugepages.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#hugepage_size_2m ContainerCluster#hugepage_size_2m}
        '''
        result = self._values.get("hugepage_size2_m")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodeConfigLinuxNodeConfigHugepagesConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodeConfigLinuxNodeConfigHugepagesConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigLinuxNodeConfigHugepagesConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6f588651ce9dfbaa19c145543b06f8265e82a9f33e1fbdc10df0495faf5d56d4)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetHugepageSize1G")
    def reset_hugepage_size1_g(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHugepageSize1G", []))

    @jsii.member(jsii_name="resetHugepageSize2M")
    def reset_hugepage_size2_m(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHugepageSize2M", []))

    @builtins.property
    @jsii.member(jsii_name="hugepageSize1GInput")
    def hugepage_size1_g_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "hugepageSize1GInput"))

    @builtins.property
    @jsii.member(jsii_name="hugepageSize2MInput")
    def hugepage_size2_m_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "hugepageSize2MInput"))

    @builtins.property
    @jsii.member(jsii_name="hugepageSize1G")
    def hugepage_size1_g(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "hugepageSize1G"))

    @hugepage_size1_g.setter
    def hugepage_size1_g(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b23a1d2f6f4c5518b54dc502ae0457ba2c4bc13311e31ec2e413d4fc2280b4f0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "hugepageSize1G", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="hugepageSize2M")
    def hugepage_size2_m(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "hugepageSize2M"))

    @hugepage_size2_m.setter
    def hugepage_size2_m(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e62b1a4a16db1dd9492ac5f0e6da33c14ff09b7733b3ef96c0638cb1daf6e3d7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "hugepageSize2M", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodeConfigLinuxNodeConfigHugepagesConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodeConfigLinuxNodeConfigHugepagesConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodeConfigLinuxNodeConfigHugepagesConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5833360597da091c5b75f29e93ae2319dc022a18b85d3a6e7dcf361bf6d465fa)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ContainerClusterNodeConfigLinuxNodeConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigLinuxNodeConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8bc5e812915c00ea7dff61ace7daf546fa1ddd0a5bc5e114de835d1ef2b6bcd8)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putHugepagesConfig")
    def put_hugepages_config(
        self,
        *,
        hugepage_size1_g: typing.Optional[jsii.Number] = None,
        hugepage_size2_m: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param hugepage_size1_g: Amount of 1G hugepages. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#hugepage_size_1g ContainerCluster#hugepage_size_1g}
        :param hugepage_size2_m: Amount of 2M hugepages. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#hugepage_size_2m ContainerCluster#hugepage_size_2m}
        '''
        value = ContainerClusterNodeConfigLinuxNodeConfigHugepagesConfig(
            hugepage_size1_g=hugepage_size1_g, hugepage_size2_m=hugepage_size2_m
        )

        return typing.cast(None, jsii.invoke(self, "putHugepagesConfig", [value]))

    @jsii.member(jsii_name="resetCgroupMode")
    def reset_cgroup_mode(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCgroupMode", []))

    @jsii.member(jsii_name="resetHugepagesConfig")
    def reset_hugepages_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHugepagesConfig", []))

    @jsii.member(jsii_name="resetSysctls")
    def reset_sysctls(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSysctls", []))

    @jsii.member(jsii_name="resetTransparentHugepageDefrag")
    def reset_transparent_hugepage_defrag(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTransparentHugepageDefrag", []))

    @jsii.member(jsii_name="resetTransparentHugepageEnabled")
    def reset_transparent_hugepage_enabled(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTransparentHugepageEnabled", []))

    @builtins.property
    @jsii.member(jsii_name="hugepagesConfig")
    def hugepages_config(
        self,
    ) -> ContainerClusterNodeConfigLinuxNodeConfigHugepagesConfigOutputReference:
        return typing.cast(ContainerClusterNodeConfigLinuxNodeConfigHugepagesConfigOutputReference, jsii.get(self, "hugepagesConfig"))

    @builtins.property
    @jsii.member(jsii_name="cgroupModeInput")
    def cgroup_mode_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "cgroupModeInput"))

    @builtins.property
    @jsii.member(jsii_name="hugepagesConfigInput")
    def hugepages_config_input(
        self,
    ) -> typing.Optional[ContainerClusterNodeConfigLinuxNodeConfigHugepagesConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodeConfigLinuxNodeConfigHugepagesConfig], jsii.get(self, "hugepagesConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="sysctlsInput")
    def sysctls_input(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], jsii.get(self, "sysctlsInput"))

    @builtins.property
    @jsii.member(jsii_name="transparentHugepageDefragInput")
    def transparent_hugepage_defrag_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "transparentHugepageDefragInput"))

    @builtins.property
    @jsii.member(jsii_name="transparentHugepageEnabledInput")
    def transparent_hugepage_enabled_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "transparentHugepageEnabledInput"))

    @builtins.property
    @jsii.member(jsii_name="cgroupMode")
    def cgroup_mode(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "cgroupMode"))

    @cgroup_mode.setter
    def cgroup_mode(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7f2c260107460b2bd5996d575d13b65b3a7af8710eb5c42659baa6075700fea2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "cgroupMode", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="sysctls")
    def sysctls(self) -> typing.Mapping[builtins.str, builtins.str]:
        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.get(self, "sysctls"))

    @sysctls.setter
    def sysctls(self, value: typing.Mapping[builtins.str, builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c1fc897ee88b66f4acfde811e413dbaa380e52fe38bda4472e7449f54d22f719)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "sysctls", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="transparentHugepageDefrag")
    def transparent_hugepage_defrag(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "transparentHugepageDefrag"))

    @transparent_hugepage_defrag.setter
    def transparent_hugepage_defrag(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__997f761644d5b527e5feb043443ae42984a61a5c3a939baa60e848d05997ae51)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "transparentHugepageDefrag", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="transparentHugepageEnabled")
    def transparent_hugepage_enabled(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "transparentHugepageEnabled"))

    @transparent_hugepage_enabled.setter
    def transparent_hugepage_enabled(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2597a37a56d639610a5e256b25ba5aef45d84ab31cf0ad0a5110f274ed0bd8b2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "transparentHugepageEnabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodeConfigLinuxNodeConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodeConfigLinuxNodeConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodeConfigLinuxNodeConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__509c25824318351a2e9b168d6bdda9056dcfebdf1ea308945db7dee5b96b3c09)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigLocalNvmeSsdBlockConfig",
    jsii_struct_bases=[],
    name_mapping={"local_ssd_count": "localSsdCount"},
)
class ContainerClusterNodeConfigLocalNvmeSsdBlockConfig:
    def __init__(self, *, local_ssd_count: jsii.Number) -> None:
        '''
        :param local_ssd_count: Number of raw-block local NVMe SSD disks to be attached to the node. Each local SSD is 375 GB in size. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#local_ssd_count ContainerCluster#local_ssd_count}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ab03526e0d5c9c90af4813520aa351057d3edd21bd7c09a4dc33cc035455cba8)
            check_type(argname="argument local_ssd_count", value=local_ssd_count, expected_type=type_hints["local_ssd_count"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "local_ssd_count": local_ssd_count,
        }

    @builtins.property
    def local_ssd_count(self) -> jsii.Number:
        '''Number of raw-block local NVMe SSD disks to be attached to the node.

        Each local SSD is 375 GB in size.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#local_ssd_count ContainerCluster#local_ssd_count}
        '''
        result = self._values.get("local_ssd_count")
        assert result is not None, "Required property 'local_ssd_count' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodeConfigLocalNvmeSsdBlockConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodeConfigLocalNvmeSsdBlockConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigLocalNvmeSsdBlockConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0f348db9ce559b17adad46d2836730781d01741161e25f1d4f54b294bfa6e198)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="localSsdCountInput")
    def local_ssd_count_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "localSsdCountInput"))

    @builtins.property
    @jsii.member(jsii_name="localSsdCount")
    def local_ssd_count(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "localSsdCount"))

    @local_ssd_count.setter
    def local_ssd_count(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__091af90821921e1113006b6b4d6af161b17405c3f6564a9c40a18cc135d8c766)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "localSsdCount", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodeConfigLocalNvmeSsdBlockConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodeConfigLocalNvmeSsdBlockConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodeConfigLocalNvmeSsdBlockConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__978de684bdfcc6de9bcf9ed92fbba73b4e2da66f1b06a1139b0c9948e9289923)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ContainerClusterNodeConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__aed119682c2c6721dd6cba0d1f00874749c3adcdd9defdafeb691cbce36aa8b3)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putAdvancedMachineFeatures")
    def put_advanced_machine_features(
        self,
        *,
        threads_per_core: jsii.Number,
        enable_nested_virtualization: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        performance_monitoring_unit: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param threads_per_core: The number of threads per physical core. To disable simultaneous multithreading (SMT) set this to 1. If unset, the maximum number of threads supported per core by the underlying processor is assumed. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#threads_per_core ContainerCluster#threads_per_core}
        :param enable_nested_virtualization: Whether the node should have nested virtualization enabled. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_nested_virtualization ContainerCluster#enable_nested_virtualization}
        :param performance_monitoring_unit: Level of Performance Monitoring Unit (PMU) requested. If unset, no access to the PMU is assumed. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#performance_monitoring_unit ContainerCluster#performance_monitoring_unit}
        '''
        value = ContainerClusterNodeConfigAdvancedMachineFeatures(
            threads_per_core=threads_per_core,
            enable_nested_virtualization=enable_nested_virtualization,
            performance_monitoring_unit=performance_monitoring_unit,
        )

        return typing.cast(None, jsii.invoke(self, "putAdvancedMachineFeatures", [value]))

    @jsii.member(jsii_name="putBootDisk")
    def put_boot_disk(
        self,
        *,
        disk_type: typing.Optional[builtins.str] = None,
        provisioned_iops: typing.Optional[jsii.Number] = None,
        provisioned_throughput: typing.Optional[jsii.Number] = None,
        size_gb: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param disk_type: Type of the disk attached to each node. Such as pd-standard, pd-balanced or pd-ssd. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#disk_type ContainerCluster#disk_type}
        :param provisioned_iops: Configured IOPs provisioning. Only valid with disk type hyperdisk-balanced. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#provisioned_iops ContainerCluster#provisioned_iops}
        :param provisioned_throughput: Configured throughput provisioning. Only valid with disk type hyperdisk-balanced. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#provisioned_throughput ContainerCluster#provisioned_throughput}
        :param size_gb: Size of the disk attached to each node, specified in GB. The smallest allowed disk size is 10GB. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#size_gb ContainerCluster#size_gb}
        '''
        value = ContainerClusterNodeConfigBootDisk(
            disk_type=disk_type,
            provisioned_iops=provisioned_iops,
            provisioned_throughput=provisioned_throughput,
            size_gb=size_gb,
        )

        return typing.cast(None, jsii.invoke(self, "putBootDisk", [value]))

    @jsii.member(jsii_name="putConfidentialNodes")
    def put_confidential_nodes(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
        confidential_instance_type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param enabled: Whether Confidential Nodes feature is enabled for all nodes in this pool. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        :param confidential_instance_type: Defines the type of technology used by the confidential node. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#confidential_instance_type ContainerCluster#confidential_instance_type}
        '''
        value = ContainerClusterNodeConfigConfidentialNodes(
            enabled=enabled, confidential_instance_type=confidential_instance_type
        )

        return typing.cast(None, jsii.invoke(self, "putConfidentialNodes", [value]))

    @jsii.member(jsii_name="putContainerdConfig")
    def put_containerd_config(
        self,
        *,
        private_registry_access_config: typing.Optional[typing.Union[ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param private_registry_access_config: private_registry_access_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#private_registry_access_config ContainerCluster#private_registry_access_config}
        '''
        value = ContainerClusterNodeConfigContainerdConfig(
            private_registry_access_config=private_registry_access_config
        )

        return typing.cast(None, jsii.invoke(self, "putContainerdConfig", [value]))

    @jsii.member(jsii_name="putEphemeralStorageLocalSsdConfig")
    def put_ephemeral_storage_local_ssd_config(
        self,
        *,
        local_ssd_count: jsii.Number,
        data_cache_count: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param local_ssd_count: Number of local SSDs to use to back ephemeral storage. Uses NVMe interfaces. Each local SSD must be 375 or 3000 GB in size, and all local SSDs must share the same size. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#local_ssd_count ContainerCluster#local_ssd_count}
        :param data_cache_count: Number of local SSDs to be utilized for GKE Data Cache. Uses NVMe interfaces. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#data_cache_count ContainerCluster#data_cache_count}
        '''
        value = ContainerClusterNodeConfigEphemeralStorageLocalSsdConfig(
            local_ssd_count=local_ssd_count, data_cache_count=data_cache_count
        )

        return typing.cast(None, jsii.invoke(self, "putEphemeralStorageLocalSsdConfig", [value]))

    @jsii.member(jsii_name="putFastSocket")
    def put_fast_socket(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param enabled: Whether or not NCCL Fast Socket is enabled. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        '''
        value = ContainerClusterNodeConfigFastSocket(enabled=enabled)

        return typing.cast(None, jsii.invoke(self, "putFastSocket", [value]))

    @jsii.member(jsii_name="putGcfsConfig")
    def put_gcfs_config(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param enabled: Whether or not GCFS is enabled. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        '''
        value = ContainerClusterNodeConfigGcfsConfig(enabled=enabled)

        return typing.cast(None, jsii.invoke(self, "putGcfsConfig", [value]))

    @jsii.member(jsii_name="putGuestAccelerator")
    def put_guest_accelerator(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ContainerClusterNodeConfigGuestAccelerator, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a569e4de6fb926f17fc931735d77034f840e5cf13cce43d1ee352f8fc6ad2c9e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putGuestAccelerator", [value]))

    @jsii.member(jsii_name="putGvnic")
    def put_gvnic(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param enabled: Whether or not gvnic is enabled. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        '''
        value = ContainerClusterNodeConfigGvnic(enabled=enabled)

        return typing.cast(None, jsii.invoke(self, "putGvnic", [value]))

    @jsii.member(jsii_name="putHostMaintenancePolicy")
    def put_host_maintenance_policy(
        self,
        *,
        maintenance_interval: builtins.str,
    ) -> None:
        '''
        :param maintenance_interval: . Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#maintenance_interval ContainerCluster#maintenance_interval}
        '''
        value = ContainerClusterNodeConfigHostMaintenancePolicy(
            maintenance_interval=maintenance_interval
        )

        return typing.cast(None, jsii.invoke(self, "putHostMaintenancePolicy", [value]))

    @jsii.member(jsii_name="putKubeletConfig")
    def put_kubelet_config(
        self,
        *,
        allowed_unsafe_sysctls: typing.Optional[typing.Sequence[builtins.str]] = None,
        container_log_max_files: typing.Optional[jsii.Number] = None,
        container_log_max_size: typing.Optional[builtins.str] = None,
        cpu_cfs_quota: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        cpu_cfs_quota_period: typing.Optional[builtins.str] = None,
        cpu_manager_policy: typing.Optional[builtins.str] = None,
        eviction_max_pod_grace_period_seconds: typing.Optional[jsii.Number] = None,
        eviction_minimum_reclaim: typing.Optional[typing.Union[ContainerClusterNodeConfigKubeletConfigEvictionMinimumReclaim, typing.Dict[builtins.str, typing.Any]]] = None,
        eviction_soft: typing.Optional[typing.Union[ContainerClusterNodeConfigKubeletConfigEvictionSoft, typing.Dict[builtins.str, typing.Any]]] = None,
        eviction_soft_grace_period: typing.Optional[typing.Union[ContainerClusterNodeConfigKubeletConfigEvictionSoftGracePeriod, typing.Dict[builtins.str, typing.Any]]] = None,
        image_gc_high_threshold_percent: typing.Optional[jsii.Number] = None,
        image_gc_low_threshold_percent: typing.Optional[jsii.Number] = None,
        image_maximum_gc_age: typing.Optional[builtins.str] = None,
        image_minimum_gc_age: typing.Optional[builtins.str] = None,
        insecure_kubelet_readonly_port_enabled: typing.Optional[builtins.str] = None,
        max_parallel_image_pulls: typing.Optional[jsii.Number] = None,
        pod_pids_limit: typing.Optional[jsii.Number] = None,
        single_process_oom_kill: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    ) -> None:
        '''
        :param allowed_unsafe_sysctls: Defines a comma-separated allowlist of unsafe sysctls or sysctl patterns which can be set on the Pods. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#allowed_unsafe_sysctls ContainerCluster#allowed_unsafe_sysctls}
        :param container_log_max_files: Defines the maximum number of container log files that can be present for a container. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#container_log_max_files ContainerCluster#container_log_max_files}
        :param container_log_max_size: Defines the maximum size of the container log file before it is rotated. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#container_log_max_size ContainerCluster#container_log_max_size}
        :param cpu_cfs_quota: Enable CPU CFS quota enforcement for containers that specify CPU limits. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cpu_cfs_quota ContainerCluster#cpu_cfs_quota}
        :param cpu_cfs_quota_period: Set the CPU CFS quota period value 'cpu.cfs_period_us'. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cpu_cfs_quota_period ContainerCluster#cpu_cfs_quota_period}
        :param cpu_manager_policy: Control the CPU management policy on the node. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cpu_manager_policy ContainerCluster#cpu_manager_policy}
        :param eviction_max_pod_grace_period_seconds: Defines the maximum allowed grace period (in seconds) to use when terminating pods in response to a soft eviction threshold being met. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#eviction_max_pod_grace_period_seconds ContainerCluster#eviction_max_pod_grace_period_seconds}
        :param eviction_minimum_reclaim: eviction_minimum_reclaim block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#eviction_minimum_reclaim ContainerCluster#eviction_minimum_reclaim}
        :param eviction_soft: eviction_soft block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#eviction_soft ContainerCluster#eviction_soft}
        :param eviction_soft_grace_period: eviction_soft_grace_period block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#eviction_soft_grace_period ContainerCluster#eviction_soft_grace_period}
        :param image_gc_high_threshold_percent: Defines the percent of disk usage after which image garbage collection is always run. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#image_gc_high_threshold_percent ContainerCluster#image_gc_high_threshold_percent}
        :param image_gc_low_threshold_percent: Defines the percent of disk usage before which image garbage collection is never run. Lowest disk usage to garbage collect to. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#image_gc_low_threshold_percent ContainerCluster#image_gc_low_threshold_percent}
        :param image_maximum_gc_age: Defines the maximum age an image can be unused before it is garbage collected. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#image_maximum_gc_age ContainerCluster#image_maximum_gc_age}
        :param image_minimum_gc_age: Defines the minimum age for an unused image before it is garbage collected. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#image_minimum_gc_age ContainerCluster#image_minimum_gc_age}
        :param insecure_kubelet_readonly_port_enabled: Controls whether the kubelet read-only port is enabled. It is strongly recommended to set this to ``FALSE``. Possible values: ``TRUE``, ``FALSE``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#insecure_kubelet_readonly_port_enabled ContainerCluster#insecure_kubelet_readonly_port_enabled}
        :param max_parallel_image_pulls: Set the maximum number of image pulls in parallel. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#max_parallel_image_pulls ContainerCluster#max_parallel_image_pulls}
        :param pod_pids_limit: Controls the maximum number of processes allowed to run in a pod. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#pod_pids_limit ContainerCluster#pod_pids_limit}
        :param single_process_oom_kill: Defines whether to enable single process OOM killer. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#single_process_oom_kill ContainerCluster#single_process_oom_kill}
        '''
        value = ContainerClusterNodeConfigKubeletConfig(
            allowed_unsafe_sysctls=allowed_unsafe_sysctls,
            container_log_max_files=container_log_max_files,
            container_log_max_size=container_log_max_size,
            cpu_cfs_quota=cpu_cfs_quota,
            cpu_cfs_quota_period=cpu_cfs_quota_period,
            cpu_manager_policy=cpu_manager_policy,
            eviction_max_pod_grace_period_seconds=eviction_max_pod_grace_period_seconds,
            eviction_minimum_reclaim=eviction_minimum_reclaim,
            eviction_soft=eviction_soft,
            eviction_soft_grace_period=eviction_soft_grace_period,
            image_gc_high_threshold_percent=image_gc_high_threshold_percent,
            image_gc_low_threshold_percent=image_gc_low_threshold_percent,
            image_maximum_gc_age=image_maximum_gc_age,
            image_minimum_gc_age=image_minimum_gc_age,
            insecure_kubelet_readonly_port_enabled=insecure_kubelet_readonly_port_enabled,
            max_parallel_image_pulls=max_parallel_image_pulls,
            pod_pids_limit=pod_pids_limit,
            single_process_oom_kill=single_process_oom_kill,
        )

        return typing.cast(None, jsii.invoke(self, "putKubeletConfig", [value]))

    @jsii.member(jsii_name="putLinuxNodeConfig")
    def put_linux_node_config(
        self,
        *,
        cgroup_mode: typing.Optional[builtins.str] = None,
        hugepages_config: typing.Optional[typing.Union[ContainerClusterNodeConfigLinuxNodeConfigHugepagesConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        sysctls: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        transparent_hugepage_defrag: typing.Optional[builtins.str] = None,
        transparent_hugepage_enabled: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param cgroup_mode: cgroupMode specifies the cgroup mode to be used on the node. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cgroup_mode ContainerCluster#cgroup_mode}
        :param hugepages_config: hugepages_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#hugepages_config ContainerCluster#hugepages_config}
        :param sysctls: The Linux kernel parameters to be applied to the nodes and all pods running on the nodes. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#sysctls ContainerCluster#sysctls}
        :param transparent_hugepage_defrag: The Linux kernel transparent hugepage defrag setting. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#transparent_hugepage_defrag ContainerCluster#transparent_hugepage_defrag}
        :param transparent_hugepage_enabled: The Linux kernel transparent hugepage setting. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#transparent_hugepage_enabled ContainerCluster#transparent_hugepage_enabled}
        '''
        value = ContainerClusterNodeConfigLinuxNodeConfig(
            cgroup_mode=cgroup_mode,
            hugepages_config=hugepages_config,
            sysctls=sysctls,
            transparent_hugepage_defrag=transparent_hugepage_defrag,
            transparent_hugepage_enabled=transparent_hugepage_enabled,
        )

        return typing.cast(None, jsii.invoke(self, "putLinuxNodeConfig", [value]))

    @jsii.member(jsii_name="putLocalNvmeSsdBlockConfig")
    def put_local_nvme_ssd_block_config(self, *, local_ssd_count: jsii.Number) -> None:
        '''
        :param local_ssd_count: Number of raw-block local NVMe SSD disks to be attached to the node. Each local SSD is 375 GB in size. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#local_ssd_count ContainerCluster#local_ssd_count}
        '''
        value = ContainerClusterNodeConfigLocalNvmeSsdBlockConfig(
            local_ssd_count=local_ssd_count
        )

        return typing.cast(None, jsii.invoke(self, "putLocalNvmeSsdBlockConfig", [value]))

    @jsii.member(jsii_name="putReservationAffinity")
    def put_reservation_affinity(
        self,
        *,
        consume_reservation_type: builtins.str,
        key: typing.Optional[builtins.str] = None,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param consume_reservation_type: Corresponds to the type of reservation consumption. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#consume_reservation_type ContainerCluster#consume_reservation_type}
        :param key: The label key of a reservation resource. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#key ContainerCluster#key}
        :param values: The label values of the reservation resource. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#values ContainerCluster#values}
        '''
        value = ContainerClusterNodeConfigReservationAffinity(
            consume_reservation_type=consume_reservation_type, key=key, values=values
        )

        return typing.cast(None, jsii.invoke(self, "putReservationAffinity", [value]))

    @jsii.member(jsii_name="putSecondaryBootDisks")
    def put_secondary_boot_disks(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ContainerClusterNodeConfigSecondaryBootDisks", typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0a1f64505b9e4d775ec3fef35f6988a357b31c0dd4ad4627fae22854cd6ca117)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putSecondaryBootDisks", [value]))

    @jsii.member(jsii_name="putShieldedInstanceConfig")
    def put_shielded_instance_config(
        self,
        *,
        enable_integrity_monitoring: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        enable_secure_boot: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    ) -> None:
        '''
        :param enable_integrity_monitoring: Defines whether the instance has integrity monitoring enabled. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_integrity_monitoring ContainerCluster#enable_integrity_monitoring}
        :param enable_secure_boot: Defines whether the instance has Secure Boot enabled. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_secure_boot ContainerCluster#enable_secure_boot}
        '''
        value = ContainerClusterNodeConfigShieldedInstanceConfig(
            enable_integrity_monitoring=enable_integrity_monitoring,
            enable_secure_boot=enable_secure_boot,
        )

        return typing.cast(None, jsii.invoke(self, "putShieldedInstanceConfig", [value]))

    @jsii.member(jsii_name="putSoleTenantConfig")
    def put_sole_tenant_config(
        self,
        *,
        node_affinity: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ContainerClusterNodeConfigSoleTenantConfigNodeAffinity", typing.Dict[builtins.str, typing.Any]]]],
        min_node_cpus: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param node_affinity: node_affinity block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#node_affinity ContainerCluster#node_affinity}
        :param min_node_cpus: Specifies the minimum number of vCPUs that each sole tenant node must have to use CPU overcommit. If not specified, the CPU overcommit feature is disabled. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#min_node_cpus ContainerCluster#min_node_cpus}
        '''
        value = ContainerClusterNodeConfigSoleTenantConfig(
            node_affinity=node_affinity, min_node_cpus=min_node_cpus
        )

        return typing.cast(None, jsii.invoke(self, "putSoleTenantConfig", [value]))

    @jsii.member(jsii_name="putTaint")
    def put_taint(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ContainerClusterNodeConfigTaint", typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3af481c7002ae14a5fb9cd46bca70bdd00e64139605db4c6458c10194b5620cd)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putTaint", [value]))

    @jsii.member(jsii_name="putWindowsNodeConfig")
    def put_windows_node_config(
        self,
        *,
        osversion: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param osversion: The OS Version of the windows nodepool.Values are OS_VERSION_UNSPECIFIED,OS_VERSION_LTSC2019 and OS_VERSION_LTSC2022. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#osversion ContainerCluster#osversion}
        '''
        value = ContainerClusterNodeConfigWindowsNodeConfig(osversion=osversion)

        return typing.cast(None, jsii.invoke(self, "putWindowsNodeConfig", [value]))

    @jsii.member(jsii_name="putWorkloadMetadataConfig")
    def put_workload_metadata_config(self, *, mode: builtins.str) -> None:
        '''
        :param mode: Mode is the configuration for how to expose metadata to workloads running on the node. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#mode ContainerCluster#mode}
        '''
        value = ContainerClusterNodeConfigWorkloadMetadataConfig(mode=mode)

        return typing.cast(None, jsii.invoke(self, "putWorkloadMetadataConfig", [value]))

    @jsii.member(jsii_name="resetAdvancedMachineFeatures")
    def reset_advanced_machine_features(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAdvancedMachineFeatures", []))

    @jsii.member(jsii_name="resetBootDisk")
    def reset_boot_disk(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBootDisk", []))

    @jsii.member(jsii_name="resetBootDiskKmsKey")
    def reset_boot_disk_kms_key(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBootDiskKmsKey", []))

    @jsii.member(jsii_name="resetConfidentialNodes")
    def reset_confidential_nodes(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetConfidentialNodes", []))

    @jsii.member(jsii_name="resetContainerdConfig")
    def reset_containerd_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetContainerdConfig", []))

    @jsii.member(jsii_name="resetDiskSizeGb")
    def reset_disk_size_gb(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDiskSizeGb", []))

    @jsii.member(jsii_name="resetDiskType")
    def reset_disk_type(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDiskType", []))

    @jsii.member(jsii_name="resetEnableConfidentialStorage")
    def reset_enable_confidential_storage(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnableConfidentialStorage", []))

    @jsii.member(jsii_name="resetEphemeralStorageLocalSsdConfig")
    def reset_ephemeral_storage_local_ssd_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEphemeralStorageLocalSsdConfig", []))

    @jsii.member(jsii_name="resetFastSocket")
    def reset_fast_socket(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetFastSocket", []))

    @jsii.member(jsii_name="resetFlexStart")
    def reset_flex_start(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetFlexStart", []))

    @jsii.member(jsii_name="resetGcfsConfig")
    def reset_gcfs_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGcfsConfig", []))

    @jsii.member(jsii_name="resetGuestAccelerator")
    def reset_guest_accelerator(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGuestAccelerator", []))

    @jsii.member(jsii_name="resetGvnic")
    def reset_gvnic(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGvnic", []))

    @jsii.member(jsii_name="resetHostMaintenancePolicy")
    def reset_host_maintenance_policy(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHostMaintenancePolicy", []))

    @jsii.member(jsii_name="resetImageType")
    def reset_image_type(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetImageType", []))

    @jsii.member(jsii_name="resetKubeletConfig")
    def reset_kubelet_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKubeletConfig", []))

    @jsii.member(jsii_name="resetLabels")
    def reset_labels(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLabels", []))

    @jsii.member(jsii_name="resetLinuxNodeConfig")
    def reset_linux_node_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLinuxNodeConfig", []))

    @jsii.member(jsii_name="resetLocalNvmeSsdBlockConfig")
    def reset_local_nvme_ssd_block_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLocalNvmeSsdBlockConfig", []))

    @jsii.member(jsii_name="resetLocalSsdCount")
    def reset_local_ssd_count(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLocalSsdCount", []))

    @jsii.member(jsii_name="resetLocalSsdEncryptionMode")
    def reset_local_ssd_encryption_mode(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLocalSsdEncryptionMode", []))

    @jsii.member(jsii_name="resetLoggingVariant")
    def reset_logging_variant(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLoggingVariant", []))

    @jsii.member(jsii_name="resetMachineType")
    def reset_machine_type(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMachineType", []))

    @jsii.member(jsii_name="resetMaxRunDuration")
    def reset_max_run_duration(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMaxRunDuration", []))

    @jsii.member(jsii_name="resetMetadata")
    def reset_metadata(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMetadata", []))

    @jsii.member(jsii_name="resetMinCpuPlatform")
    def reset_min_cpu_platform(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMinCpuPlatform", []))

    @jsii.member(jsii_name="resetNodeGroup")
    def reset_node_group(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNodeGroup", []))

    @jsii.member(jsii_name="resetOauthScopes")
    def reset_oauth_scopes(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetOauthScopes", []))

    @jsii.member(jsii_name="resetPreemptible")
    def reset_preemptible(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPreemptible", []))

    @jsii.member(jsii_name="resetReservationAffinity")
    def reset_reservation_affinity(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetReservationAffinity", []))

    @jsii.member(jsii_name="resetResourceLabels")
    def reset_resource_labels(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetResourceLabels", []))

    @jsii.member(jsii_name="resetResourceManagerTags")
    def reset_resource_manager_tags(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetResourceManagerTags", []))

    @jsii.member(jsii_name="resetSecondaryBootDisks")
    def reset_secondary_boot_disks(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSecondaryBootDisks", []))

    @jsii.member(jsii_name="resetServiceAccount")
    def reset_service_account(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetServiceAccount", []))

    @jsii.member(jsii_name="resetShieldedInstanceConfig")
    def reset_shielded_instance_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetShieldedInstanceConfig", []))

    @jsii.member(jsii_name="resetSoleTenantConfig")
    def reset_sole_tenant_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSoleTenantConfig", []))

    @jsii.member(jsii_name="resetSpot")
    def reset_spot(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSpot", []))

    @jsii.member(jsii_name="resetStoragePools")
    def reset_storage_pools(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetStoragePools", []))

    @jsii.member(jsii_name="resetTags")
    def reset_tags(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTags", []))

    @jsii.member(jsii_name="resetTaint")
    def reset_taint(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTaint", []))

    @jsii.member(jsii_name="resetWindowsNodeConfig")
    def reset_windows_node_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetWindowsNodeConfig", []))

    @jsii.member(jsii_name="resetWorkloadMetadataConfig")
    def reset_workload_metadata_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetWorkloadMetadataConfig", []))

    @builtins.property
    @jsii.member(jsii_name="advancedMachineFeatures")
    def advanced_machine_features(
        self,
    ) -> ContainerClusterNodeConfigAdvancedMachineFeaturesOutputReference:
        return typing.cast(ContainerClusterNodeConfigAdvancedMachineFeaturesOutputReference, jsii.get(self, "advancedMachineFeatures"))

    @builtins.property
    @jsii.member(jsii_name="bootDisk")
    def boot_disk(self) -> ContainerClusterNodeConfigBootDiskOutputReference:
        return typing.cast(ContainerClusterNodeConfigBootDiskOutputReference, jsii.get(self, "bootDisk"))

    @builtins.property
    @jsii.member(jsii_name="confidentialNodes")
    def confidential_nodes(
        self,
    ) -> ContainerClusterNodeConfigConfidentialNodesOutputReference:
        return typing.cast(ContainerClusterNodeConfigConfidentialNodesOutputReference, jsii.get(self, "confidentialNodes"))

    @builtins.property
    @jsii.member(jsii_name="containerdConfig")
    def containerd_config(
        self,
    ) -> ContainerClusterNodeConfigContainerdConfigOutputReference:
        return typing.cast(ContainerClusterNodeConfigContainerdConfigOutputReference, jsii.get(self, "containerdConfig"))

    @builtins.property
    @jsii.member(jsii_name="effectiveTaints")
    def effective_taints(self) -> ContainerClusterNodeConfigEffectiveTaintsList:
        return typing.cast(ContainerClusterNodeConfigEffectiveTaintsList, jsii.get(self, "effectiveTaints"))

    @builtins.property
    @jsii.member(jsii_name="ephemeralStorageLocalSsdConfig")
    def ephemeral_storage_local_ssd_config(
        self,
    ) -> ContainerClusterNodeConfigEphemeralStorageLocalSsdConfigOutputReference:
        return typing.cast(ContainerClusterNodeConfigEphemeralStorageLocalSsdConfigOutputReference, jsii.get(self, "ephemeralStorageLocalSsdConfig"))

    @builtins.property
    @jsii.member(jsii_name="fastSocket")
    def fast_socket(self) -> ContainerClusterNodeConfigFastSocketOutputReference:
        return typing.cast(ContainerClusterNodeConfigFastSocketOutputReference, jsii.get(self, "fastSocket"))

    @builtins.property
    @jsii.member(jsii_name="gcfsConfig")
    def gcfs_config(self) -> ContainerClusterNodeConfigGcfsConfigOutputReference:
        return typing.cast(ContainerClusterNodeConfigGcfsConfigOutputReference, jsii.get(self, "gcfsConfig"))

    @builtins.property
    @jsii.member(jsii_name="guestAccelerator")
    def guest_accelerator(self) -> ContainerClusterNodeConfigGuestAcceleratorList:
        return typing.cast(ContainerClusterNodeConfigGuestAcceleratorList, jsii.get(self, "guestAccelerator"))

    @builtins.property
    @jsii.member(jsii_name="gvnic")
    def gvnic(self) -> ContainerClusterNodeConfigGvnicOutputReference:
        return typing.cast(ContainerClusterNodeConfigGvnicOutputReference, jsii.get(self, "gvnic"))

    @builtins.property
    @jsii.member(jsii_name="hostMaintenancePolicy")
    def host_maintenance_policy(
        self,
    ) -> ContainerClusterNodeConfigHostMaintenancePolicyOutputReference:
        return typing.cast(ContainerClusterNodeConfigHostMaintenancePolicyOutputReference, jsii.get(self, "hostMaintenancePolicy"))

    @builtins.property
    @jsii.member(jsii_name="kubeletConfig")
    def kubelet_config(self) -> ContainerClusterNodeConfigKubeletConfigOutputReference:
        return typing.cast(ContainerClusterNodeConfigKubeletConfigOutputReference, jsii.get(self, "kubeletConfig"))

    @builtins.property
    @jsii.member(jsii_name="linuxNodeConfig")
    def linux_node_config(
        self,
    ) -> ContainerClusterNodeConfigLinuxNodeConfigOutputReference:
        return typing.cast(ContainerClusterNodeConfigLinuxNodeConfigOutputReference, jsii.get(self, "linuxNodeConfig"))

    @builtins.property
    @jsii.member(jsii_name="localNvmeSsdBlockConfig")
    def local_nvme_ssd_block_config(
        self,
    ) -> ContainerClusterNodeConfigLocalNvmeSsdBlockConfigOutputReference:
        return typing.cast(ContainerClusterNodeConfigLocalNvmeSsdBlockConfigOutputReference, jsii.get(self, "localNvmeSsdBlockConfig"))

    @builtins.property
    @jsii.member(jsii_name="reservationAffinity")
    def reservation_affinity(
        self,
    ) -> "ContainerClusterNodeConfigReservationAffinityOutputReference":
        return typing.cast("ContainerClusterNodeConfigReservationAffinityOutputReference", jsii.get(self, "reservationAffinity"))

    @builtins.property
    @jsii.member(jsii_name="secondaryBootDisks")
    def secondary_boot_disks(
        self,
    ) -> "ContainerClusterNodeConfigSecondaryBootDisksList":
        return typing.cast("ContainerClusterNodeConfigSecondaryBootDisksList", jsii.get(self, "secondaryBootDisks"))

    @builtins.property
    @jsii.member(jsii_name="shieldedInstanceConfig")
    def shielded_instance_config(
        self,
    ) -> "ContainerClusterNodeConfigShieldedInstanceConfigOutputReference":
        return typing.cast("ContainerClusterNodeConfigShieldedInstanceConfigOutputReference", jsii.get(self, "shieldedInstanceConfig"))

    @builtins.property
    @jsii.member(jsii_name="soleTenantConfig")
    def sole_tenant_config(
        self,
    ) -> "ContainerClusterNodeConfigSoleTenantConfigOutputReference":
        return typing.cast("ContainerClusterNodeConfigSoleTenantConfigOutputReference", jsii.get(self, "soleTenantConfig"))

    @builtins.property
    @jsii.member(jsii_name="taint")
    def taint(self) -> "ContainerClusterNodeConfigTaintList":
        return typing.cast("ContainerClusterNodeConfigTaintList", jsii.get(self, "taint"))

    @builtins.property
    @jsii.member(jsii_name="windowsNodeConfig")
    def windows_node_config(
        self,
    ) -> "ContainerClusterNodeConfigWindowsNodeConfigOutputReference":
        return typing.cast("ContainerClusterNodeConfigWindowsNodeConfigOutputReference", jsii.get(self, "windowsNodeConfig"))

    @builtins.property
    @jsii.member(jsii_name="workloadMetadataConfig")
    def workload_metadata_config(
        self,
    ) -> "ContainerClusterNodeConfigWorkloadMetadataConfigOutputReference":
        return typing.cast("ContainerClusterNodeConfigWorkloadMetadataConfigOutputReference", jsii.get(self, "workloadMetadataConfig"))

    @builtins.property
    @jsii.member(jsii_name="advancedMachineFeaturesInput")
    def advanced_machine_features_input(
        self,
    ) -> typing.Optional[ContainerClusterNodeConfigAdvancedMachineFeatures]:
        return typing.cast(typing.Optional[ContainerClusterNodeConfigAdvancedMachineFeatures], jsii.get(self, "advancedMachineFeaturesInput"))

    @builtins.property
    @jsii.member(jsii_name="bootDiskInput")
    def boot_disk_input(self) -> typing.Optional[ContainerClusterNodeConfigBootDisk]:
        return typing.cast(typing.Optional[ContainerClusterNodeConfigBootDisk], jsii.get(self, "bootDiskInput"))

    @builtins.property
    @jsii.member(jsii_name="bootDiskKmsKeyInput")
    def boot_disk_kms_key_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "bootDiskKmsKeyInput"))

    @builtins.property
    @jsii.member(jsii_name="confidentialNodesInput")
    def confidential_nodes_input(
        self,
    ) -> typing.Optional[ContainerClusterNodeConfigConfidentialNodes]:
        return typing.cast(typing.Optional[ContainerClusterNodeConfigConfidentialNodes], jsii.get(self, "confidentialNodesInput"))

    @builtins.property
    @jsii.member(jsii_name="containerdConfigInput")
    def containerd_config_input(
        self,
    ) -> typing.Optional[ContainerClusterNodeConfigContainerdConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodeConfigContainerdConfig], jsii.get(self, "containerdConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="diskSizeGbInput")
    def disk_size_gb_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "diskSizeGbInput"))

    @builtins.property
    @jsii.member(jsii_name="diskTypeInput")
    def disk_type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "diskTypeInput"))

    @builtins.property
    @jsii.member(jsii_name="enableConfidentialStorageInput")
    def enable_confidential_storage_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enableConfidentialStorageInput"))

    @builtins.property
    @jsii.member(jsii_name="ephemeralStorageLocalSsdConfigInput")
    def ephemeral_storage_local_ssd_config_input(
        self,
    ) -> typing.Optional[ContainerClusterNodeConfigEphemeralStorageLocalSsdConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodeConfigEphemeralStorageLocalSsdConfig], jsii.get(self, "ephemeralStorageLocalSsdConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="fastSocketInput")
    def fast_socket_input(
        self,
    ) -> typing.Optional[ContainerClusterNodeConfigFastSocket]:
        return typing.cast(typing.Optional[ContainerClusterNodeConfigFastSocket], jsii.get(self, "fastSocketInput"))

    @builtins.property
    @jsii.member(jsii_name="flexStartInput")
    def flex_start_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "flexStartInput"))

    @builtins.property
    @jsii.member(jsii_name="gcfsConfigInput")
    def gcfs_config_input(
        self,
    ) -> typing.Optional[ContainerClusterNodeConfigGcfsConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodeConfigGcfsConfig], jsii.get(self, "gcfsConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="guestAcceleratorInput")
    def guest_accelerator_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodeConfigGuestAccelerator]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodeConfigGuestAccelerator]]], jsii.get(self, "guestAcceleratorInput"))

    @builtins.property
    @jsii.member(jsii_name="gvnicInput")
    def gvnic_input(self) -> typing.Optional[ContainerClusterNodeConfigGvnic]:
        return typing.cast(typing.Optional[ContainerClusterNodeConfigGvnic], jsii.get(self, "gvnicInput"))

    @builtins.property
    @jsii.member(jsii_name="hostMaintenancePolicyInput")
    def host_maintenance_policy_input(
        self,
    ) -> typing.Optional[ContainerClusterNodeConfigHostMaintenancePolicy]:
        return typing.cast(typing.Optional[ContainerClusterNodeConfigHostMaintenancePolicy], jsii.get(self, "hostMaintenancePolicyInput"))

    @builtins.property
    @jsii.member(jsii_name="imageTypeInput")
    def image_type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "imageTypeInput"))

    @builtins.property
    @jsii.member(jsii_name="kubeletConfigInput")
    def kubelet_config_input(
        self,
    ) -> typing.Optional[ContainerClusterNodeConfigKubeletConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodeConfigKubeletConfig], jsii.get(self, "kubeletConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="labelsInput")
    def labels_input(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], jsii.get(self, "labelsInput"))

    @builtins.property
    @jsii.member(jsii_name="linuxNodeConfigInput")
    def linux_node_config_input(
        self,
    ) -> typing.Optional[ContainerClusterNodeConfigLinuxNodeConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodeConfigLinuxNodeConfig], jsii.get(self, "linuxNodeConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="localNvmeSsdBlockConfigInput")
    def local_nvme_ssd_block_config_input(
        self,
    ) -> typing.Optional[ContainerClusterNodeConfigLocalNvmeSsdBlockConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodeConfigLocalNvmeSsdBlockConfig], jsii.get(self, "localNvmeSsdBlockConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="localSsdCountInput")
    def local_ssd_count_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "localSsdCountInput"))

    @builtins.property
    @jsii.member(jsii_name="localSsdEncryptionModeInput")
    def local_ssd_encryption_mode_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "localSsdEncryptionModeInput"))

    @builtins.property
    @jsii.member(jsii_name="loggingVariantInput")
    def logging_variant_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "loggingVariantInput"))

    @builtins.property
    @jsii.member(jsii_name="machineTypeInput")
    def machine_type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "machineTypeInput"))

    @builtins.property
    @jsii.member(jsii_name="maxRunDurationInput")
    def max_run_duration_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "maxRunDurationInput"))

    @builtins.property
    @jsii.member(jsii_name="metadataInput")
    def metadata_input(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], jsii.get(self, "metadataInput"))

    @builtins.property
    @jsii.member(jsii_name="minCpuPlatformInput")
    def min_cpu_platform_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "minCpuPlatformInput"))

    @builtins.property
    @jsii.member(jsii_name="nodeGroupInput")
    def node_group_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nodeGroupInput"))

    @builtins.property
    @jsii.member(jsii_name="oauthScopesInput")
    def oauth_scopes_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "oauthScopesInput"))

    @builtins.property
    @jsii.member(jsii_name="preemptibleInput")
    def preemptible_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "preemptibleInput"))

    @builtins.property
    @jsii.member(jsii_name="reservationAffinityInput")
    def reservation_affinity_input(
        self,
    ) -> typing.Optional["ContainerClusterNodeConfigReservationAffinity"]:
        return typing.cast(typing.Optional["ContainerClusterNodeConfigReservationAffinity"], jsii.get(self, "reservationAffinityInput"))

    @builtins.property
    @jsii.member(jsii_name="resourceLabelsInput")
    def resource_labels_input(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], jsii.get(self, "resourceLabelsInput"))

    @builtins.property
    @jsii.member(jsii_name="resourceManagerTagsInput")
    def resource_manager_tags_input(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], jsii.get(self, "resourceManagerTagsInput"))

    @builtins.property
    @jsii.member(jsii_name="secondaryBootDisksInput")
    def secondary_boot_disks_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ContainerClusterNodeConfigSecondaryBootDisks"]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ContainerClusterNodeConfigSecondaryBootDisks"]]], jsii.get(self, "secondaryBootDisksInput"))

    @builtins.property
    @jsii.member(jsii_name="serviceAccountInput")
    def service_account_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "serviceAccountInput"))

    @builtins.property
    @jsii.member(jsii_name="shieldedInstanceConfigInput")
    def shielded_instance_config_input(
        self,
    ) -> typing.Optional["ContainerClusterNodeConfigShieldedInstanceConfig"]:
        return typing.cast(typing.Optional["ContainerClusterNodeConfigShieldedInstanceConfig"], jsii.get(self, "shieldedInstanceConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="soleTenantConfigInput")
    def sole_tenant_config_input(
        self,
    ) -> typing.Optional["ContainerClusterNodeConfigSoleTenantConfig"]:
        return typing.cast(typing.Optional["ContainerClusterNodeConfigSoleTenantConfig"], jsii.get(self, "soleTenantConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="spotInput")
    def spot_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "spotInput"))

    @builtins.property
    @jsii.member(jsii_name="storagePoolsInput")
    def storage_pools_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "storagePoolsInput"))

    @builtins.property
    @jsii.member(jsii_name="tagsInput")
    def tags_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "tagsInput"))

    @builtins.property
    @jsii.member(jsii_name="taintInput")
    def taint_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ContainerClusterNodeConfigTaint"]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ContainerClusterNodeConfigTaint"]]], jsii.get(self, "taintInput"))

    @builtins.property
    @jsii.member(jsii_name="windowsNodeConfigInput")
    def windows_node_config_input(
        self,
    ) -> typing.Optional["ContainerClusterNodeConfigWindowsNodeConfig"]:
        return typing.cast(typing.Optional["ContainerClusterNodeConfigWindowsNodeConfig"], jsii.get(self, "windowsNodeConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="workloadMetadataConfigInput")
    def workload_metadata_config_input(
        self,
    ) -> typing.Optional["ContainerClusterNodeConfigWorkloadMetadataConfig"]:
        return typing.cast(typing.Optional["ContainerClusterNodeConfigWorkloadMetadataConfig"], jsii.get(self, "workloadMetadataConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="bootDiskKmsKey")
    def boot_disk_kms_key(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "bootDiskKmsKey"))

    @boot_disk_kms_key.setter
    def boot_disk_kms_key(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7aadcbd0e1eae74284144863afa22ddd01bbb4ae849f667e084d378ecbca6287)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "bootDiskKmsKey", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="diskSizeGb")
    def disk_size_gb(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "diskSizeGb"))

    @disk_size_gb.setter
    def disk_size_gb(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__902b89b0ba307eb1ae13313ae034505380bdfcae406bd97b71d8ef76fe5a2fdc)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "diskSizeGb", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="diskType")
    def disk_type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "diskType"))

    @disk_type.setter
    def disk_type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b91aa25f4cc5133f88f9a6dd89b1e7e69fa7d6e897f53ef2249353bbb9ce807b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "diskType", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="enableConfidentialStorage")
    def enable_confidential_storage(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enableConfidentialStorage"))

    @enable_confidential_storage.setter
    def enable_confidential_storage(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f770e77b42ffd94433f13c9ca3bc08a6da0e74ba18e011d0c1e7c3b016848007)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableConfidentialStorage", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="flexStart")
    def flex_start(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "flexStart"))

    @flex_start.setter
    def flex_start(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4172ebe562c55dc973d275faf3368c35af5ee9ca21ca5983ce1e1ea8857a0faa)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "flexStart", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="imageType")
    def image_type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "imageType"))

    @image_type.setter
    def image_type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5473d4fcc0144b62c7905cb542919b103d166f386a585abd86d31ab08eb44672)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "imageType", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="labels")
    def labels(self) -> typing.Mapping[builtins.str, builtins.str]:
        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.get(self, "labels"))

    @labels.setter
    def labels(self, value: typing.Mapping[builtins.str, builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bbbe1075adcffa367f536c02e75d8313de3898bfeb81db09df6c37497cd72714)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "labels", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="localSsdCount")
    def local_ssd_count(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "localSsdCount"))

    @local_ssd_count.setter
    def local_ssd_count(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c11d2b83c2df2d5c21db17ed28050741b50633644ba70a6b543742a03e06f655)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "localSsdCount", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="localSsdEncryptionMode")
    def local_ssd_encryption_mode(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "localSsdEncryptionMode"))

    @local_ssd_encryption_mode.setter
    def local_ssd_encryption_mode(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fafc84ed7ce3566d4d418b6bc28af5f802ef6480a11249d9541552d0cb49ff57)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "localSsdEncryptionMode", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="loggingVariant")
    def logging_variant(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "loggingVariant"))

    @logging_variant.setter
    def logging_variant(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__49935e656ddf1abffa71f3b38ca7dca5cd0a1b10c2ba12abacaba42596e603a2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "loggingVariant", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="machineType")
    def machine_type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "machineType"))

    @machine_type.setter
    def machine_type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8e528d4670f62f2b98f05a3890a10f1ed9cde20a72bbce442cf9796e0800c112)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "machineType", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="maxRunDuration")
    def max_run_duration(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "maxRunDuration"))

    @max_run_duration.setter
    def max_run_duration(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fee9813a0bc25c2422ab1f856759fcfafcb9115150cfb32d3754881fda81bbde)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "maxRunDuration", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="metadata")
    def metadata(self) -> typing.Mapping[builtins.str, builtins.str]:
        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.get(self, "metadata"))

    @metadata.setter
    def metadata(self, value: typing.Mapping[builtins.str, builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__238fb38036f61ab19ad7f0c24360b163d466fa4fb27f176e1830ca477e429be5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "metadata", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="minCpuPlatform")
    def min_cpu_platform(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "minCpuPlatform"))

    @min_cpu_platform.setter
    def min_cpu_platform(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__053f91a4d1139f7763eeadecec17c3e5c96796a64bcf9d7016de66a2a43d61bd)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "minCpuPlatform", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="nodeGroup")
    def node_group(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "nodeGroup"))

    @node_group.setter
    def node_group(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b054514b429441430ebece8ba25f50cc16732b730e00b69dcdbf74c8a83d4198)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "nodeGroup", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="oauthScopes")
    def oauth_scopes(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "oauthScopes"))

    @oauth_scopes.setter
    def oauth_scopes(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b3a5f9936ca7493bc8f0d81cd642ce28074d9005e8427f31b520ab17381c9198)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "oauthScopes", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="preemptible")
    def preemptible(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "preemptible"))

    @preemptible.setter
    def preemptible(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9ab3c75f93a1cc0b8bff629c33dc555bfa274b424684c1725bea73bd9029604f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "preemptible", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="resourceLabels")
    def resource_labels(self) -> typing.Mapping[builtins.str, builtins.str]:
        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.get(self, "resourceLabels"))

    @resource_labels.setter
    def resource_labels(
        self,
        value: typing.Mapping[builtins.str, builtins.str],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__23c4d340767c1f9049c758967a691bbeed23cff88d33e200d5f7b0a50c283d16)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "resourceLabels", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="resourceManagerTags")
    def resource_manager_tags(self) -> typing.Mapping[builtins.str, builtins.str]:
        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.get(self, "resourceManagerTags"))

    @resource_manager_tags.setter
    def resource_manager_tags(
        self,
        value: typing.Mapping[builtins.str, builtins.str],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a292848329377f17e7ef4a46918da7bbf0c71784db1c24d93e4aa9f764acd0af)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "resourceManagerTags", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="serviceAccount")
    def service_account(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "serviceAccount"))

    @service_account.setter
    def service_account(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6464401e4091b304b9b1edbbd95f9ea083bc84a6f80866911723871ce1d8c343)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "serviceAccount", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="spot")
    def spot(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "spot"))

    @spot.setter
    def spot(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3ee2ff4cea3fb33bc3fd97dc25b3ef795020747413f15750d3c874b745c640dc)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "spot", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="storagePools")
    def storage_pools(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "storagePools"))

    @storage_pools.setter
    def storage_pools(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__19a9fd589bbe4cb6b3aea246bf4e96e838e3fd0a9a93ff0546d7bd95320973e4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "storagePools", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="tags")
    def tags(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "tags"))

    @tags.setter
    def tags(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c9dd150b1ef477d41820dc47a6a8d3ddc0773271ab436a315daac45f6e60242e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "tags", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[ContainerClusterNodeConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodeConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodeConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1b1ab86b937be40f548f40501a7fe5a1702d9dc67db3b100aaeca08f74c61441)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigReservationAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "consume_reservation_type": "consumeReservationType",
        "key": "key",
        "values": "values",
    },
)
class ContainerClusterNodeConfigReservationAffinity:
    def __init__(
        self,
        *,
        consume_reservation_type: builtins.str,
        key: typing.Optional[builtins.str] = None,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param consume_reservation_type: Corresponds to the type of reservation consumption. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#consume_reservation_type ContainerCluster#consume_reservation_type}
        :param key: The label key of a reservation resource. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#key ContainerCluster#key}
        :param values: The label values of the reservation resource. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#values ContainerCluster#values}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2b159929b6a46ec40a6772744b1a05be469844fb554a37470af4f2f100839b25)
            check_type(argname="argument consume_reservation_type", value=consume_reservation_type, expected_type=type_hints["consume_reservation_type"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "consume_reservation_type": consume_reservation_type,
        }
        if key is not None:
            self._values["key"] = key
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def consume_reservation_type(self) -> builtins.str:
        '''Corresponds to the type of reservation consumption.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#consume_reservation_type ContainerCluster#consume_reservation_type}
        '''
        result = self._values.get("consume_reservation_type")
        assert result is not None, "Required property 'consume_reservation_type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The label key of a reservation resource.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#key ContainerCluster#key}
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The label values of the reservation resource.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#values ContainerCluster#values}
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodeConfigReservationAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodeConfigReservationAffinityOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigReservationAffinityOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8dcd82b50f84a89303c398a3bd770f38e0ecf1c460b930e1963d5a8c0dda7048)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetKey")
    def reset_key(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKey", []))

    @jsii.member(jsii_name="resetValues")
    def reset_values(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetValues", []))

    @builtins.property
    @jsii.member(jsii_name="consumeReservationTypeInput")
    def consume_reservation_type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "consumeReservationTypeInput"))

    @builtins.property
    @jsii.member(jsii_name="keyInput")
    def key_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyInput"))

    @builtins.property
    @jsii.member(jsii_name="valuesInput")
    def values_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "valuesInput"))

    @builtins.property
    @jsii.member(jsii_name="consumeReservationType")
    def consume_reservation_type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "consumeReservationType"))

    @consume_reservation_type.setter
    def consume_reservation_type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__552ce2a78e4bd785c4835ac58078dd969540a8b0edb6531e30fd1a34e41536f6)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "consumeReservationType", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="key")
    def key(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "key"))

    @key.setter
    def key(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cfee46f05db71983ce3a25855dfc004efef21e93f2af795784a561d0637ca7a3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "key", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="values")
    def values(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "values"))

    @values.setter
    def values(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6285b7629db787bf89e5b2cb668a82bfa42c2a68a14f1ffd6daa83ef148edc36)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "values", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodeConfigReservationAffinity]:
        return typing.cast(typing.Optional[ContainerClusterNodeConfigReservationAffinity], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodeConfigReservationAffinity],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3f9c7793852a4c95ffc2424da3891803905c3e08cec871360d412780b572c168)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigSecondaryBootDisks",
    jsii_struct_bases=[],
    name_mapping={"disk_image": "diskImage", "mode": "mode"},
)
class ContainerClusterNodeConfigSecondaryBootDisks:
    def __init__(
        self,
        *,
        disk_image: builtins.str,
        mode: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param disk_image: Disk image to create the secondary boot disk from. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#disk_image ContainerCluster#disk_image}
        :param mode: Mode for how the secondary boot disk is used. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#mode ContainerCluster#mode}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eeb65a098b9939ce77cad2b6a9f3e814ab57dc2ad2a3f4c0a28e47af0233d99f)
            check_type(argname="argument disk_image", value=disk_image, expected_type=type_hints["disk_image"])
            check_type(argname="argument mode", value=mode, expected_type=type_hints["mode"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "disk_image": disk_image,
        }
        if mode is not None:
            self._values["mode"] = mode

    @builtins.property
    def disk_image(self) -> builtins.str:
        '''Disk image to create the secondary boot disk from.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#disk_image ContainerCluster#disk_image}
        '''
        result = self._values.get("disk_image")
        assert result is not None, "Required property 'disk_image' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def mode(self) -> typing.Optional[builtins.str]:
        '''Mode for how the secondary boot disk is used.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#mode ContainerCluster#mode}
        '''
        result = self._values.get("mode")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodeConfigSecondaryBootDisks(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodeConfigSecondaryBootDisksList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigSecondaryBootDisksList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d246edf8d450fc2ccd163072aa85b22fa8694194c87b66b404fd4c188ab4d6ca)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ContainerClusterNodeConfigSecondaryBootDisksOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f7eeb58c4d09585d0dacdfbd60c5d91d5ba0b74275f40cf34047071ffb08a719)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ContainerClusterNodeConfigSecondaryBootDisksOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__08984c164ac1a1fe60bd2b3c8166f1f69c8b4c73a0ae3924abf657019cea7e7c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__07600f8878201d3afe820caa7490e08d31d1a45d2a9c2d188094441f4e0eaf66)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3831df75970018ca3fff8899d3d2b5237a8acba3931b2ba195a83dd65f45d1cc)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodeConfigSecondaryBootDisks]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodeConfigSecondaryBootDisks]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodeConfigSecondaryBootDisks]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d19fce76459ae4049e2c4526b899e2cfa0fd636a3e9f545437afc3be0601ee35)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ContainerClusterNodeConfigSecondaryBootDisksOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigSecondaryBootDisksOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__adb93e0bf60c711428c496f43f4de7de80a4224f286dc5652b081679e35ba9a6)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="resetMode")
    def reset_mode(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMode", []))

    @builtins.property
    @jsii.member(jsii_name="diskImageInput")
    def disk_image_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "diskImageInput"))

    @builtins.property
    @jsii.member(jsii_name="modeInput")
    def mode_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "modeInput"))

    @builtins.property
    @jsii.member(jsii_name="diskImage")
    def disk_image(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "diskImage"))

    @disk_image.setter
    def disk_image(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d2e1e56c5c6166f31f7baa31b09707da8bb96c9d192cc1a6131a7b6a4afbc028)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "diskImage", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="mode")
    def mode(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "mode"))

    @mode.setter
    def mode(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c7327be35de166e65138394f3b87a7abf9bc159b7de4084265ace15641129315)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "mode", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterNodeConfigSecondaryBootDisks]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterNodeConfigSecondaryBootDisks]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterNodeConfigSecondaryBootDisks]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__40becdc4e8ad52883bb68cf348e3e91add57f9288019471ded6fcd4518b4fd88)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigShieldedInstanceConfig",
    jsii_struct_bases=[],
    name_mapping={
        "enable_integrity_monitoring": "enableIntegrityMonitoring",
        "enable_secure_boot": "enableSecureBoot",
    },
)
class ContainerClusterNodeConfigShieldedInstanceConfig:
    def __init__(
        self,
        *,
        enable_integrity_monitoring: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        enable_secure_boot: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    ) -> None:
        '''
        :param enable_integrity_monitoring: Defines whether the instance has integrity monitoring enabled. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_integrity_monitoring ContainerCluster#enable_integrity_monitoring}
        :param enable_secure_boot: Defines whether the instance has Secure Boot enabled. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_secure_boot ContainerCluster#enable_secure_boot}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1939af5159de8ec74ec2f7bcf4dd4a3ca860811444a44881a1a2a00942c426a0)
            check_type(argname="argument enable_integrity_monitoring", value=enable_integrity_monitoring, expected_type=type_hints["enable_integrity_monitoring"])
            check_type(argname="argument enable_secure_boot", value=enable_secure_boot, expected_type=type_hints["enable_secure_boot"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if enable_integrity_monitoring is not None:
            self._values["enable_integrity_monitoring"] = enable_integrity_monitoring
        if enable_secure_boot is not None:
            self._values["enable_secure_boot"] = enable_secure_boot

    @builtins.property
    def enable_integrity_monitoring(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Defines whether the instance has integrity monitoring enabled.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_integrity_monitoring ContainerCluster#enable_integrity_monitoring}
        '''
        result = self._values.get("enable_integrity_monitoring")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def enable_secure_boot(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Defines whether the instance has Secure Boot enabled.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_secure_boot ContainerCluster#enable_secure_boot}
        '''
        result = self._values.get("enable_secure_boot")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodeConfigShieldedInstanceConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodeConfigShieldedInstanceConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigShieldedInstanceConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5b7e5f88c08fde5d8472c3ad77ac45902fba225f2cad9e533ef7620eb7bbc9fd)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetEnableIntegrityMonitoring")
    def reset_enable_integrity_monitoring(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnableIntegrityMonitoring", []))

    @jsii.member(jsii_name="resetEnableSecureBoot")
    def reset_enable_secure_boot(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnableSecureBoot", []))

    @builtins.property
    @jsii.member(jsii_name="enableIntegrityMonitoringInput")
    def enable_integrity_monitoring_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enableIntegrityMonitoringInput"))

    @builtins.property
    @jsii.member(jsii_name="enableSecureBootInput")
    def enable_secure_boot_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enableSecureBootInput"))

    @builtins.property
    @jsii.member(jsii_name="enableIntegrityMonitoring")
    def enable_integrity_monitoring(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enableIntegrityMonitoring"))

    @enable_integrity_monitoring.setter
    def enable_integrity_monitoring(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f79fa257f06df23c93aac74e319a6ab08a62999b0ea2802ed7591d774b4bd76c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableIntegrityMonitoring", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="enableSecureBoot")
    def enable_secure_boot(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enableSecureBoot"))

    @enable_secure_boot.setter
    def enable_secure_boot(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6ab8086056a1584d7f9740fcf602e5037d9daaaffbb06cfb9017f9ddfbcbb847)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableSecureBoot", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodeConfigShieldedInstanceConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodeConfigShieldedInstanceConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodeConfigShieldedInstanceConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ac7609ebc33cc70392605c449d63b40d2e611489733bc08473c25cad76594bb3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigSoleTenantConfig",
    jsii_struct_bases=[],
    name_mapping={"node_affinity": "nodeAffinity", "min_node_cpus": "minNodeCpus"},
)
class ContainerClusterNodeConfigSoleTenantConfig:
    def __init__(
        self,
        *,
        node_affinity: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ContainerClusterNodeConfigSoleTenantConfigNodeAffinity", typing.Dict[builtins.str, typing.Any]]]],
        min_node_cpus: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param node_affinity: node_affinity block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#node_affinity ContainerCluster#node_affinity}
        :param min_node_cpus: Specifies the minimum number of vCPUs that each sole tenant node must have to use CPU overcommit. If not specified, the CPU overcommit feature is disabled. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#min_node_cpus ContainerCluster#min_node_cpus}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9d46f04489e657674b299b88cccffacba5b587a25bc013ac2a28423bedff0543)
            check_type(argname="argument node_affinity", value=node_affinity, expected_type=type_hints["node_affinity"])
            check_type(argname="argument min_node_cpus", value=min_node_cpus, expected_type=type_hints["min_node_cpus"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "node_affinity": node_affinity,
        }
        if min_node_cpus is not None:
            self._values["min_node_cpus"] = min_node_cpus

    @builtins.property
    def node_affinity(
        self,
    ) -> typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ContainerClusterNodeConfigSoleTenantConfigNodeAffinity"]]:
        '''node_affinity block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#node_affinity ContainerCluster#node_affinity}
        '''
        result = self._values.get("node_affinity")
        assert result is not None, "Required property 'node_affinity' is missing"
        return typing.cast(typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ContainerClusterNodeConfigSoleTenantConfigNodeAffinity"]], result)

    @builtins.property
    def min_node_cpus(self) -> typing.Optional[jsii.Number]:
        '''Specifies the minimum number of vCPUs that each sole tenant node must have to use CPU overcommit.

        If not specified, the CPU overcommit feature is disabled.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#min_node_cpus ContainerCluster#min_node_cpus}
        '''
        result = self._values.get("min_node_cpus")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodeConfigSoleTenantConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigSoleTenantConfigNodeAffinity",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class ContainerClusterNodeConfigSoleTenantConfigNodeAffinity:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Sequence[builtins.str],
    ) -> None:
        '''
        :param key: . Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#key ContainerCluster#key}
        :param operator: . Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#operator ContainerCluster#operator}
        :param values: . Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#values ContainerCluster#values}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eb39204df1f0b38fff5d868a80b803c58b35b60b9a8e401b2e3bebe0b246652f)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "operator": operator,
            "values": values,
        }

    @builtins.property
    def key(self) -> builtins.str:
        '''.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#key ContainerCluster#key}
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#operator ContainerCluster#operator}
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.List[builtins.str]:
        '''.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#values ContainerCluster#values}
        '''
        result = self._values.get("values")
        assert result is not None, "Required property 'values' is missing"
        return typing.cast(typing.List[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodeConfigSoleTenantConfigNodeAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodeConfigSoleTenantConfigNodeAffinityList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigSoleTenantConfigNodeAffinityList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__88793ee8772bb13ddf9ba9d3cde0b8d9e45d36048092ffea2b9012b00cec85ad)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ContainerClusterNodeConfigSoleTenantConfigNodeAffinityOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__998f989ccfb63ee01ed009f811818a3d25e7e506892e6fa4ce69286c4e4e20b2)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ContainerClusterNodeConfigSoleTenantConfigNodeAffinityOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b13008489349c17c651aeb60a7e1a2993adfa1fc7f2e940518047965ba980721)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ec9ed8718fc32e6bc5a24dabe30a60b62d1283213e5d69a0a8fcb38fd56c3c4e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c83d17e9b737c16e78388d28111c687dace79d7f965aa372e17ed0c1d3e2e8b7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodeConfigSoleTenantConfigNodeAffinity]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodeConfigSoleTenantConfigNodeAffinity]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodeConfigSoleTenantConfigNodeAffinity]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2f7f93a8e2be839686d6b78abb0263289980780078232941dd93cda019304c76)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ContainerClusterNodeConfigSoleTenantConfigNodeAffinityOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigSoleTenantConfigNodeAffinityOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c59d1be2ef86d19cee75decae60d524fd779f9ee5145e05aa8e6587cc66bf6ee)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @builtins.property
    @jsii.member(jsii_name="keyInput")
    def key_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyInput"))

    @builtins.property
    @jsii.member(jsii_name="operatorInput")
    def operator_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "operatorInput"))

    @builtins.property
    @jsii.member(jsii_name="valuesInput")
    def values_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "valuesInput"))

    @builtins.property
    @jsii.member(jsii_name="key")
    def key(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "key"))

    @key.setter
    def key(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e47955c5f141cc8b1e8067f8939280c2088e0a7b1fa21c236037d9b54f954444)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "key", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="operator")
    def operator(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "operator"))

    @operator.setter
    def operator(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7bda5bbb5c24b256f24f8b757e84e4cc0138cf65d3cf9578020c6b8610276381)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "operator", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="values")
    def values(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "values"))

    @values.setter
    def values(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c39fdf46653306b5935b6eaaf75b5a1fb9a22e70f950dad0681bdadb18e77652)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "values", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterNodeConfigSoleTenantConfigNodeAffinity]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterNodeConfigSoleTenantConfigNodeAffinity]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterNodeConfigSoleTenantConfigNodeAffinity]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7d18a1c37cd60cad69fbc6f9d3c795564f6add823180d0b06029812afa7c24b6)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ContainerClusterNodeConfigSoleTenantConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigSoleTenantConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e4471675c4b11e0f5eb9d0a2185b17e7bfb0cebdeda845e50c95a81e2d85485f)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putNodeAffinity")
    def put_node_affinity(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ContainerClusterNodeConfigSoleTenantConfigNodeAffinity, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fbd827427e0fd657833f7cc0158552406355f146f2a418caf867bf9623e10082)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putNodeAffinity", [value]))

    @jsii.member(jsii_name="resetMinNodeCpus")
    def reset_min_node_cpus(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMinNodeCpus", []))

    @builtins.property
    @jsii.member(jsii_name="nodeAffinity")
    def node_affinity(
        self,
    ) -> ContainerClusterNodeConfigSoleTenantConfigNodeAffinityList:
        return typing.cast(ContainerClusterNodeConfigSoleTenantConfigNodeAffinityList, jsii.get(self, "nodeAffinity"))

    @builtins.property
    @jsii.member(jsii_name="minNodeCpusInput")
    def min_node_cpus_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "minNodeCpusInput"))

    @builtins.property
    @jsii.member(jsii_name="nodeAffinityInput")
    def node_affinity_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodeConfigSoleTenantConfigNodeAffinity]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodeConfigSoleTenantConfigNodeAffinity]]], jsii.get(self, "nodeAffinityInput"))

    @builtins.property
    @jsii.member(jsii_name="minNodeCpus")
    def min_node_cpus(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "minNodeCpus"))

    @min_node_cpus.setter
    def min_node_cpus(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bad92ad455935e346fbac3c01120f4022792f3e8c6e6ac0c16cbb71b70c555cc)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "minNodeCpus", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodeConfigSoleTenantConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodeConfigSoleTenantConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodeConfigSoleTenantConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__70d932fb54de98b6ac4eee0ec9ec92235900a66433c7832b3fc9650cca12388c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigTaint",
    jsii_struct_bases=[],
    name_mapping={"effect": "effect", "key": "key", "value": "value"},
)
class ContainerClusterNodeConfigTaint:
    def __init__(
        self,
        *,
        effect: builtins.str,
        key: builtins.str,
        value: builtins.str,
    ) -> None:
        '''
        :param effect: Effect for taint. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#effect ContainerCluster#effect}
        :param key: Key for taint. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#key ContainerCluster#key}
        :param value: Value for taint. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#value ContainerCluster#value}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1502a0e3f6b7944d2d306818e5acd3872bd53685ed5cc1f16ce88d53cd22e22a)
            check_type(argname="argument effect", value=effect, expected_type=type_hints["effect"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "effect": effect,
            "key": key,
            "value": value,
        }

    @builtins.property
    def effect(self) -> builtins.str:
        '''Effect for taint.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#effect ContainerCluster#effect}
        '''
        result = self._values.get("effect")
        assert result is not None, "Required property 'effect' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def key(self) -> builtins.str:
        '''Key for taint.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#key ContainerCluster#key}
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> builtins.str:
        '''Value for taint.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#value ContainerCluster#value}
        '''
        result = self._values.get("value")
        assert result is not None, "Required property 'value' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodeConfigTaint(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodeConfigTaintList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigTaintList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e99f3f5a27f018687d76f03a8c538540c866d93c3bd30c0219156ae0e96f7547)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ContainerClusterNodeConfigTaintOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c8825da9a476761a1f02c47f6bef1d56ac7bb760d24b468a021a2cc6d332a68a)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ContainerClusterNodeConfigTaintOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9cefee5938f456863ed4b650449352c7f02e3c02d70bfd55811b8f1c5f6fa95d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__36d2bd31d11d257c28f83ccd11ad0d557189ed49c3ae16452c338ab62b57c9a4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__08358079eb6cecfd12b5b0d21745e3f680cc842d90401ffcb973f19ed01781e3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodeConfigTaint]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodeConfigTaint]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodeConfigTaint]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__014560ff434c1000a8b54315b378327b0ec58abec23edb46117f9c32cc2733df)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ContainerClusterNodeConfigTaintOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigTaintOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3fbce8286c49cc63e4cc56b43d60820241aef8b7f5039975d3497a607e1b0b8c)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @builtins.property
    @jsii.member(jsii_name="effectInput")
    def effect_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "effectInput"))

    @builtins.property
    @jsii.member(jsii_name="keyInput")
    def key_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyInput"))

    @builtins.property
    @jsii.member(jsii_name="valueInput")
    def value_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "valueInput"))

    @builtins.property
    @jsii.member(jsii_name="effect")
    def effect(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "effect"))

    @effect.setter
    def effect(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__714ff64aee441978553f481e535360824fa8770d94536219445d767f8b2234de)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "effect", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="key")
    def key(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "key"))

    @key.setter
    def key(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1a7b4b110122027fd35cdcbdfeef492c9fe1fac8471e28cd276f0064e17111e1)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "key", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="value")
    def value(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "value"))

    @value.setter
    def value(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__62da9da7243510893849be8f2311beaa87d2676148d2a41f501747238e681603)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "value", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterNodeConfigTaint]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterNodeConfigTaint]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterNodeConfigTaint]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ff200b0dffce35c1d4cef18bf8b343e388d1eb8211370b67da77ed298e1ae160)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigWindowsNodeConfig",
    jsii_struct_bases=[],
    name_mapping={"osversion": "osversion"},
)
class ContainerClusterNodeConfigWindowsNodeConfig:
    def __init__(self, *, osversion: typing.Optional[builtins.str] = None) -> None:
        '''
        :param osversion: The OS Version of the windows nodepool.Values are OS_VERSION_UNSPECIFIED,OS_VERSION_LTSC2019 and OS_VERSION_LTSC2022. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#osversion ContainerCluster#osversion}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__49f0256a1e5ea7870d61eed8e8ba06146f38b7b42161212f1ba4944bd7cb7938)
            check_type(argname="argument osversion", value=osversion, expected_type=type_hints["osversion"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if osversion is not None:
            self._values["osversion"] = osversion

    @builtins.property
    def osversion(self) -> typing.Optional[builtins.str]:
        '''The OS Version of the windows nodepool.Values are OS_VERSION_UNSPECIFIED,OS_VERSION_LTSC2019 and OS_VERSION_LTSC2022.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#osversion ContainerCluster#osversion}
        '''
        result = self._values.get("osversion")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodeConfigWindowsNodeConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodeConfigWindowsNodeConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigWindowsNodeConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cce9a81b9e017ff4d67515629c76dbe01007ee2f2fdf7e76251c252fec9b4042)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetOsversion")
    def reset_osversion(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetOsversion", []))

    @builtins.property
    @jsii.member(jsii_name="osversionInput")
    def osversion_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "osversionInput"))

    @builtins.property
    @jsii.member(jsii_name="osversion")
    def osversion(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "osversion"))

    @osversion.setter
    def osversion(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__464fda9f6805221bff22d4d8c9e1199976dc033d23b21ada7112f114fbd120b0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "osversion", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodeConfigWindowsNodeConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodeConfigWindowsNodeConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodeConfigWindowsNodeConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3878bea5fffb612d0269c88eec29920651dd03823e2e10302b9d68b651640137)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigWorkloadMetadataConfig",
    jsii_struct_bases=[],
    name_mapping={"mode": "mode"},
)
class ContainerClusterNodeConfigWorkloadMetadataConfig:
    def __init__(self, *, mode: builtins.str) -> None:
        '''
        :param mode: Mode is the configuration for how to expose metadata to workloads running on the node. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#mode ContainerCluster#mode}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c8530768049758423cb79adabf875a9de8ca2948255cbf1713937501768fae48)
            check_type(argname="argument mode", value=mode, expected_type=type_hints["mode"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "mode": mode,
        }

    @builtins.property
    def mode(self) -> builtins.str:
        '''Mode is the configuration for how to expose metadata to workloads running on the node.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#mode ContainerCluster#mode}
        '''
        result = self._values.get("mode")
        assert result is not None, "Required property 'mode' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodeConfigWorkloadMetadataConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodeConfigWorkloadMetadataConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodeConfigWorkloadMetadataConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0fc265104e4173e5e86df159e0a4c402d5f4200bb4ff1e86154497e24a0bd674)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="modeInput")
    def mode_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "modeInput"))

    @builtins.property
    @jsii.member(jsii_name="mode")
    def mode(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "mode"))

    @mode.setter
    def mode(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0ce1a446de20b6793901cb424644c3de656a1a35b41d1a1eaac393dd7e7939c8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "mode", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodeConfigWorkloadMetadataConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodeConfigWorkloadMetadataConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodeConfigWorkloadMetadataConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__32104ad2e354610e9096164ee05f6a4b4bb1436d46134247b3f595cdf52175ae)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePool",
    jsii_struct_bases=[],
    name_mapping={
        "autoscaling": "autoscaling",
        "initial_node_count": "initialNodeCount",
        "management": "management",
        "max_pods_per_node": "maxPodsPerNode",
        "name": "name",
        "name_prefix": "namePrefix",
        "network_config": "networkConfig",
        "node_config": "nodeConfig",
        "node_count": "nodeCount",
        "node_locations": "nodeLocations",
        "placement_policy": "placementPolicy",
        "queued_provisioning": "queuedProvisioning",
        "upgrade_settings": "upgradeSettings",
        "version": "version",
    },
)
class ContainerClusterNodePool:
    def __init__(
        self,
        *,
        autoscaling: typing.Optional[typing.Union["ContainerClusterNodePoolAutoscaling", typing.Dict[builtins.str, typing.Any]]] = None,
        initial_node_count: typing.Optional[jsii.Number] = None,
        management: typing.Optional[typing.Union["ContainerClusterNodePoolManagement", typing.Dict[builtins.str, typing.Any]]] = None,
        max_pods_per_node: typing.Optional[jsii.Number] = None,
        name: typing.Optional[builtins.str] = None,
        name_prefix: typing.Optional[builtins.str] = None,
        network_config: typing.Optional[typing.Union["ContainerClusterNodePoolNetworkConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        node_config: typing.Optional[typing.Union["ContainerClusterNodePoolNodeConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        node_count: typing.Optional[jsii.Number] = None,
        node_locations: typing.Optional[typing.Sequence[builtins.str]] = None,
        placement_policy: typing.Optional[typing.Union["ContainerClusterNodePoolPlacementPolicy", typing.Dict[builtins.str, typing.Any]]] = None,
        queued_provisioning: typing.Optional[typing.Union["ContainerClusterNodePoolQueuedProvisioning", typing.Dict[builtins.str, typing.Any]]] = None,
        upgrade_settings: typing.Optional[typing.Union["ContainerClusterNodePoolUpgradeSettings", typing.Dict[builtins.str, typing.Any]]] = None,
        version: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param autoscaling: autoscaling block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#autoscaling ContainerCluster#autoscaling}
        :param initial_node_count: The initial number of nodes for the pool. In regional or multi-zonal clusters, this is the number of nodes per zone. Changing this will force recreation of the resource. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#initial_node_count ContainerCluster#initial_node_count}
        :param management: management block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#management ContainerCluster#management}
        :param max_pods_per_node: The maximum number of pods per node in this node pool. Note that this does not work on node pools which are "route-based" - that is, node pools belonging to clusters that do not have IP Aliasing enabled. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#max_pods_per_node ContainerCluster#max_pods_per_node}
        :param name: The name of the node pool. If left blank, Terraform will auto-generate a unique name. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#name ContainerCluster#name}
        :param name_prefix: Creates a unique name for the node pool beginning with the specified prefix. Conflicts with name. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#name_prefix ContainerCluster#name_prefix}
        :param network_config: network_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#network_config ContainerCluster#network_config}
        :param node_config: node_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#node_config ContainerCluster#node_config}
        :param node_count: The number of nodes per instance group. This field can be used to update the number of nodes per instance group but should not be used alongside autoscaling. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#node_count ContainerCluster#node_count}
        :param node_locations: The list of zones in which the node pool's nodes should be located. Nodes must be in the region of their regional cluster or in the same region as their cluster's zone for zonal clusters. If unspecified, the cluster-level node_locations will be used. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#node_locations ContainerCluster#node_locations}
        :param placement_policy: placement_policy block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#placement_policy ContainerCluster#placement_policy}
        :param queued_provisioning: queued_provisioning block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#queued_provisioning ContainerCluster#queued_provisioning}
        :param upgrade_settings: upgrade_settings block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#upgrade_settings ContainerCluster#upgrade_settings}
        :param version: The Kubernetes version for the nodes in this pool. Note that if this field and auto_upgrade are both specified, they will fight each other for what the node version should be, so setting both is highly discouraged. While a fuzzy version can be specified, it's recommended that you specify explicit versions as Terraform will see spurious diffs when fuzzy versions are used. See the google_container_engine_versions data source's version_prefix field to approximate fuzzy versions in a Terraform-compatible way. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#version ContainerCluster#version}
        '''
        if isinstance(autoscaling, dict):
            autoscaling = ContainerClusterNodePoolAutoscaling(**autoscaling)
        if isinstance(management, dict):
            management = ContainerClusterNodePoolManagement(**management)
        if isinstance(network_config, dict):
            network_config = ContainerClusterNodePoolNetworkConfig(**network_config)
        if isinstance(node_config, dict):
            node_config = ContainerClusterNodePoolNodeConfig(**node_config)
        if isinstance(placement_policy, dict):
            placement_policy = ContainerClusterNodePoolPlacementPolicy(**placement_policy)
        if isinstance(queued_provisioning, dict):
            queued_provisioning = ContainerClusterNodePoolQueuedProvisioning(**queued_provisioning)
        if isinstance(upgrade_settings, dict):
            upgrade_settings = ContainerClusterNodePoolUpgradeSettings(**upgrade_settings)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ac0abc9503d9dd4de16d9e29878b6835e86cdd611755f67114409b71d11c3a29)
            check_type(argname="argument autoscaling", value=autoscaling, expected_type=type_hints["autoscaling"])
            check_type(argname="argument initial_node_count", value=initial_node_count, expected_type=type_hints["initial_node_count"])
            check_type(argname="argument management", value=management, expected_type=type_hints["management"])
            check_type(argname="argument max_pods_per_node", value=max_pods_per_node, expected_type=type_hints["max_pods_per_node"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument name_prefix", value=name_prefix, expected_type=type_hints["name_prefix"])
            check_type(argname="argument network_config", value=network_config, expected_type=type_hints["network_config"])
            check_type(argname="argument node_config", value=node_config, expected_type=type_hints["node_config"])
            check_type(argname="argument node_count", value=node_count, expected_type=type_hints["node_count"])
            check_type(argname="argument node_locations", value=node_locations, expected_type=type_hints["node_locations"])
            check_type(argname="argument placement_policy", value=placement_policy, expected_type=type_hints["placement_policy"])
            check_type(argname="argument queued_provisioning", value=queued_provisioning, expected_type=type_hints["queued_provisioning"])
            check_type(argname="argument upgrade_settings", value=upgrade_settings, expected_type=type_hints["upgrade_settings"])
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if autoscaling is not None:
            self._values["autoscaling"] = autoscaling
        if initial_node_count is not None:
            self._values["initial_node_count"] = initial_node_count
        if management is not None:
            self._values["management"] = management
        if max_pods_per_node is not None:
            self._values["max_pods_per_node"] = max_pods_per_node
        if name is not None:
            self._values["name"] = name
        if name_prefix is not None:
            self._values["name_prefix"] = name_prefix
        if network_config is not None:
            self._values["network_config"] = network_config
        if node_config is not None:
            self._values["node_config"] = node_config
        if node_count is not None:
            self._values["node_count"] = node_count
        if node_locations is not None:
            self._values["node_locations"] = node_locations
        if placement_policy is not None:
            self._values["placement_policy"] = placement_policy
        if queued_provisioning is not None:
            self._values["queued_provisioning"] = queued_provisioning
        if upgrade_settings is not None:
            self._values["upgrade_settings"] = upgrade_settings
        if version is not None:
            self._values["version"] = version

    @builtins.property
    def autoscaling(self) -> typing.Optional["ContainerClusterNodePoolAutoscaling"]:
        '''autoscaling block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#autoscaling ContainerCluster#autoscaling}
        '''
        result = self._values.get("autoscaling")
        return typing.cast(typing.Optional["ContainerClusterNodePoolAutoscaling"], result)

    @builtins.property
    def initial_node_count(self) -> typing.Optional[jsii.Number]:
        '''The initial number of nodes for the pool.

        In regional or multi-zonal clusters, this is the number of nodes per zone. Changing this will force recreation of the resource.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#initial_node_count ContainerCluster#initial_node_count}
        '''
        result = self._values.get("initial_node_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def management(self) -> typing.Optional["ContainerClusterNodePoolManagement"]:
        '''management block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#management ContainerCluster#management}
        '''
        result = self._values.get("management")
        return typing.cast(typing.Optional["ContainerClusterNodePoolManagement"], result)

    @builtins.property
    def max_pods_per_node(self) -> typing.Optional[jsii.Number]:
        '''The maximum number of pods per node in this node pool.

        Note that this does not work on node pools which are "route-based" - that is, node pools belonging to clusters that do not have IP Aliasing enabled.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#max_pods_per_node ContainerCluster#max_pods_per_node}
        '''
        result = self._values.get("max_pods_per_node")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the node pool. If left blank, Terraform will auto-generate a unique name.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#name ContainerCluster#name}
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name_prefix(self) -> typing.Optional[builtins.str]:
        '''Creates a unique name for the node pool beginning with the specified prefix. Conflicts with name.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#name_prefix ContainerCluster#name_prefix}
        '''
        result = self._values.get("name_prefix")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def network_config(
        self,
    ) -> typing.Optional["ContainerClusterNodePoolNetworkConfig"]:
        '''network_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#network_config ContainerCluster#network_config}
        '''
        result = self._values.get("network_config")
        return typing.cast(typing.Optional["ContainerClusterNodePoolNetworkConfig"], result)

    @builtins.property
    def node_config(self) -> typing.Optional["ContainerClusterNodePoolNodeConfig"]:
        '''node_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#node_config ContainerCluster#node_config}
        '''
        result = self._values.get("node_config")
        return typing.cast(typing.Optional["ContainerClusterNodePoolNodeConfig"], result)

    @builtins.property
    def node_count(self) -> typing.Optional[jsii.Number]:
        '''The number of nodes per instance group.

        This field can be used to update the number of nodes per instance group but should not be used alongside autoscaling.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#node_count ContainerCluster#node_count}
        '''
        result = self._values.get("node_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def node_locations(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The list of zones in which the node pool's nodes should be located.

        Nodes must be in the region of their regional cluster or in the same region as their cluster's zone for zonal clusters. If unspecified, the cluster-level node_locations will be used.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#node_locations ContainerCluster#node_locations}
        '''
        result = self._values.get("node_locations")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def placement_policy(
        self,
    ) -> typing.Optional["ContainerClusterNodePoolPlacementPolicy"]:
        '''placement_policy block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#placement_policy ContainerCluster#placement_policy}
        '''
        result = self._values.get("placement_policy")
        return typing.cast(typing.Optional["ContainerClusterNodePoolPlacementPolicy"], result)

    @builtins.property
    def queued_provisioning(
        self,
    ) -> typing.Optional["ContainerClusterNodePoolQueuedProvisioning"]:
        '''queued_provisioning block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#queued_provisioning ContainerCluster#queued_provisioning}
        '''
        result = self._values.get("queued_provisioning")
        return typing.cast(typing.Optional["ContainerClusterNodePoolQueuedProvisioning"], result)

    @builtins.property
    def upgrade_settings(
        self,
    ) -> typing.Optional["ContainerClusterNodePoolUpgradeSettings"]:
        '''upgrade_settings block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#upgrade_settings ContainerCluster#upgrade_settings}
        '''
        result = self._values.get("upgrade_settings")
        return typing.cast(typing.Optional["ContainerClusterNodePoolUpgradeSettings"], result)

    @builtins.property
    def version(self) -> typing.Optional[builtins.str]:
        '''The Kubernetes version for the nodes in this pool.

        Note that if this field and auto_upgrade are both specified, they will fight each other for what the node version should be, so setting both is highly discouraged. While a fuzzy version can be specified, it's recommended that you specify explicit versions as Terraform will see spurious diffs when fuzzy versions are used. See the google_container_engine_versions data source's version_prefix field to approximate fuzzy versions in a Terraform-compatible way.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#version ContainerCluster#version}
        '''
        result = self._values.get("version")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodePool(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolAutoConfig",
    jsii_struct_bases=[],
    name_mapping={
        "linux_node_config": "linuxNodeConfig",
        "network_tags": "networkTags",
        "node_kubelet_config": "nodeKubeletConfig",
        "resource_manager_tags": "resourceManagerTags",
    },
)
class ContainerClusterNodePoolAutoConfig:
    def __init__(
        self,
        *,
        linux_node_config: typing.Optional[typing.Union["ContainerClusterNodePoolAutoConfigLinuxNodeConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        network_tags: typing.Optional[typing.Union["ContainerClusterNodePoolAutoConfigNetworkTags", typing.Dict[builtins.str, typing.Any]]] = None,
        node_kubelet_config: typing.Optional[typing.Union["ContainerClusterNodePoolAutoConfigNodeKubeletConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        resource_manager_tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param linux_node_config: linux_node_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#linux_node_config ContainerCluster#linux_node_config}
        :param network_tags: network_tags block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#network_tags ContainerCluster#network_tags}
        :param node_kubelet_config: node_kubelet_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#node_kubelet_config ContainerCluster#node_kubelet_config}
        :param resource_manager_tags: A map of resource manager tags. Resource manager tag keys and values have the same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id}, and values are in the format tagValues/456. The field is ignored (both PUT & PATCH) when empty. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#resource_manager_tags ContainerCluster#resource_manager_tags}
        '''
        if isinstance(linux_node_config, dict):
            linux_node_config = ContainerClusterNodePoolAutoConfigLinuxNodeConfig(**linux_node_config)
        if isinstance(network_tags, dict):
            network_tags = ContainerClusterNodePoolAutoConfigNetworkTags(**network_tags)
        if isinstance(node_kubelet_config, dict):
            node_kubelet_config = ContainerClusterNodePoolAutoConfigNodeKubeletConfig(**node_kubelet_config)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ed97fff1dc5c2a9cd7ab4f45c50c6e1f30f655150f9c626a370141c0dd644457)
            check_type(argname="argument linux_node_config", value=linux_node_config, expected_type=type_hints["linux_node_config"])
            check_type(argname="argument network_tags", value=network_tags, expected_type=type_hints["network_tags"])
            check_type(argname="argument node_kubelet_config", value=node_kubelet_config, expected_type=type_hints["node_kubelet_config"])
            check_type(argname="argument resource_manager_tags", value=resource_manager_tags, expected_type=type_hints["resource_manager_tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if linux_node_config is not None:
            self._values["linux_node_config"] = linux_node_config
        if network_tags is not None:
            self._values["network_tags"] = network_tags
        if node_kubelet_config is not None:
            self._values["node_kubelet_config"] = node_kubelet_config
        if resource_manager_tags is not None:
            self._values["resource_manager_tags"] = resource_manager_tags

    @builtins.property
    def linux_node_config(
        self,
    ) -> typing.Optional["ContainerClusterNodePoolAutoConfigLinuxNodeConfig"]:
        '''linux_node_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#linux_node_config ContainerCluster#linux_node_config}
        '''
        result = self._values.get("linux_node_config")
        return typing.cast(typing.Optional["ContainerClusterNodePoolAutoConfigLinuxNodeConfig"], result)

    @builtins.property
    def network_tags(
        self,
    ) -> typing.Optional["ContainerClusterNodePoolAutoConfigNetworkTags"]:
        '''network_tags block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#network_tags ContainerCluster#network_tags}
        '''
        result = self._values.get("network_tags")
        return typing.cast(typing.Optional["ContainerClusterNodePoolAutoConfigNetworkTags"], result)

    @builtins.property
    def node_kubelet_config(
        self,
    ) -> typing.Optional["ContainerClusterNodePoolAutoConfigNodeKubeletConfig"]:
        '''node_kubelet_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#node_kubelet_config ContainerCluster#node_kubelet_config}
        '''
        result = self._values.get("node_kubelet_config")
        return typing.cast(typing.Optional["ContainerClusterNodePoolAutoConfigNodeKubeletConfig"], result)

    @builtins.property
    def resource_manager_tags(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''A map of resource manager tags.

        Resource manager tag keys and values have the same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id}, and values are in the format tagValues/456. The field is ignored (both PUT & PATCH) when empty.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#resource_manager_tags ContainerCluster#resource_manager_tags}
        '''
        result = self._values.get("resource_manager_tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodePoolAutoConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolAutoConfigLinuxNodeConfig",
    jsii_struct_bases=[],
    name_mapping={"cgroup_mode": "cgroupMode"},
)
class ContainerClusterNodePoolAutoConfigLinuxNodeConfig:
    def __init__(self, *, cgroup_mode: typing.Optional[builtins.str] = None) -> None:
        '''
        :param cgroup_mode: cgroupMode specifies the cgroup mode to be used on the node. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cgroup_mode ContainerCluster#cgroup_mode}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c2019df13f292afeac713d4e0f7cc1b20db4c51a041bba85fb155a8ca12e1ba0)
            check_type(argname="argument cgroup_mode", value=cgroup_mode, expected_type=type_hints["cgroup_mode"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if cgroup_mode is not None:
            self._values["cgroup_mode"] = cgroup_mode

    @builtins.property
    def cgroup_mode(self) -> typing.Optional[builtins.str]:
        '''cgroupMode specifies the cgroup mode to be used on the node.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cgroup_mode ContainerCluster#cgroup_mode}
        '''
        result = self._values.get("cgroup_mode")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodePoolAutoConfigLinuxNodeConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodePoolAutoConfigLinuxNodeConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolAutoConfigLinuxNodeConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__10b507380b603e9efa6f025deb781442591ef0ac4fa13d8f77523e08d5efdd6c)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetCgroupMode")
    def reset_cgroup_mode(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCgroupMode", []))

    @builtins.property
    @jsii.member(jsii_name="cgroupModeInput")
    def cgroup_mode_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "cgroupModeInput"))

    @builtins.property
    @jsii.member(jsii_name="cgroupMode")
    def cgroup_mode(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "cgroupMode"))

    @cgroup_mode.setter
    def cgroup_mode(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0d55989bdef4957158cde7e6b4fd5da160e2e9654bc760d5bc5f1c5faba21dce)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "cgroupMode", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolAutoConfigLinuxNodeConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolAutoConfigLinuxNodeConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodePoolAutoConfigLinuxNodeConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__37c4226072b4ff5fa83a52e674ec2d52f0b969f4df700328c82583da05518ae2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolAutoConfigNetworkTags",
    jsii_struct_bases=[],
    name_mapping={"tags": "tags"},
)
class ContainerClusterNodePoolAutoConfigNetworkTags:
    def __init__(
        self,
        *,
        tags: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param tags: List of network tags applied to auto-provisioned node pools. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#tags ContainerCluster#tags}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1f91e39fecaccabbac30da81a7751b53a982d736ed9e8f543a9a3ae0b5d9fe30)
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''List of network tags applied to auto-provisioned node pools.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#tags ContainerCluster#tags}
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodePoolAutoConfigNetworkTags(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodePoolAutoConfigNetworkTagsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolAutoConfigNetworkTagsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4f9a5d966d5888a9e8f52129c163ae981d3e2e8b9755e33d3ab92967c0855487)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetTags")
    def reset_tags(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTags", []))

    @builtins.property
    @jsii.member(jsii_name="tagsInput")
    def tags_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "tagsInput"))

    @builtins.property
    @jsii.member(jsii_name="tags")
    def tags(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "tags"))

    @tags.setter
    def tags(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c990b4c44658b9bc69a79fff249b7e44709dc4835b8c3638040f50b22c124a77)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "tags", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolAutoConfigNetworkTags]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolAutoConfigNetworkTags], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodePoolAutoConfigNetworkTags],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8e8d420710dc6dbb5b9163dfc6a3c214c0fea74f34be51a5cafb5159795d1239)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolAutoConfigNodeKubeletConfig",
    jsii_struct_bases=[],
    name_mapping={
        "insecure_kubelet_readonly_port_enabled": "insecureKubeletReadonlyPortEnabled",
    },
)
class ContainerClusterNodePoolAutoConfigNodeKubeletConfig:
    def __init__(
        self,
        *,
        insecure_kubelet_readonly_port_enabled: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param insecure_kubelet_readonly_port_enabled: Controls whether the kubelet read-only port is enabled. It is strongly recommended to set this to ``FALSE``. Possible values: ``TRUE``, ``FALSE``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#insecure_kubelet_readonly_port_enabled ContainerCluster#insecure_kubelet_readonly_port_enabled}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__049ed898d76843ef0656eb81b6070ab23633ec3906eb48c8455a851f79d47706)
            check_type(argname="argument insecure_kubelet_readonly_port_enabled", value=insecure_kubelet_readonly_port_enabled, expected_type=type_hints["insecure_kubelet_readonly_port_enabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if insecure_kubelet_readonly_port_enabled is not None:
            self._values["insecure_kubelet_readonly_port_enabled"] = insecure_kubelet_readonly_port_enabled

    @builtins.property
    def insecure_kubelet_readonly_port_enabled(self) -> typing.Optional[builtins.str]:
        '''Controls whether the kubelet read-only port is enabled.

        It is strongly recommended to set this to ``FALSE``. Possible values: ``TRUE``, ``FALSE``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#insecure_kubelet_readonly_port_enabled ContainerCluster#insecure_kubelet_readonly_port_enabled}
        '''
        result = self._values.get("insecure_kubelet_readonly_port_enabled")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodePoolAutoConfigNodeKubeletConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodePoolAutoConfigNodeKubeletConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolAutoConfigNodeKubeletConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ce829216439ae0147fe4085e1c06d8b30b1605ac8a324ee1421b1f9b27354fef)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetInsecureKubeletReadonlyPortEnabled")
    def reset_insecure_kubelet_readonly_port_enabled(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetInsecureKubeletReadonlyPortEnabled", []))

    @builtins.property
    @jsii.member(jsii_name="insecureKubeletReadonlyPortEnabledInput")
    def insecure_kubelet_readonly_port_enabled_input(
        self,
    ) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "insecureKubeletReadonlyPortEnabledInput"))

    @builtins.property
    @jsii.member(jsii_name="insecureKubeletReadonlyPortEnabled")
    def insecure_kubelet_readonly_port_enabled(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "insecureKubeletReadonlyPortEnabled"))

    @insecure_kubelet_readonly_port_enabled.setter
    def insecure_kubelet_readonly_port_enabled(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bb531503f3dc8c4dd5ca8719f1b2b9df92e0b53a76d4fba81b48a7b7637f773a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "insecureKubeletReadonlyPortEnabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolAutoConfigNodeKubeletConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolAutoConfigNodeKubeletConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodePoolAutoConfigNodeKubeletConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f622ed1fa4cdf706fb21261c99b892e2e7d8199f41249d28bd97086b233dc83f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ContainerClusterNodePoolAutoConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolAutoConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__081c6d11867fe647a5b4a67f98f7aa4708873abd8c5eee49801f7afcde017b0f)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putLinuxNodeConfig")
    def put_linux_node_config(
        self,
        *,
        cgroup_mode: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param cgroup_mode: cgroupMode specifies the cgroup mode to be used on the node. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cgroup_mode ContainerCluster#cgroup_mode}
        '''
        value = ContainerClusterNodePoolAutoConfigLinuxNodeConfig(
            cgroup_mode=cgroup_mode
        )

        return typing.cast(None, jsii.invoke(self, "putLinuxNodeConfig", [value]))

    @jsii.member(jsii_name="putNetworkTags")
    def put_network_tags(
        self,
        *,
        tags: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param tags: List of network tags applied to auto-provisioned node pools. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#tags ContainerCluster#tags}
        '''
        value = ContainerClusterNodePoolAutoConfigNetworkTags(tags=tags)

        return typing.cast(None, jsii.invoke(self, "putNetworkTags", [value]))

    @jsii.member(jsii_name="putNodeKubeletConfig")
    def put_node_kubelet_config(
        self,
        *,
        insecure_kubelet_readonly_port_enabled: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param insecure_kubelet_readonly_port_enabled: Controls whether the kubelet read-only port is enabled. It is strongly recommended to set this to ``FALSE``. Possible values: ``TRUE``, ``FALSE``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#insecure_kubelet_readonly_port_enabled ContainerCluster#insecure_kubelet_readonly_port_enabled}
        '''
        value = ContainerClusterNodePoolAutoConfigNodeKubeletConfig(
            insecure_kubelet_readonly_port_enabled=insecure_kubelet_readonly_port_enabled,
        )

        return typing.cast(None, jsii.invoke(self, "putNodeKubeletConfig", [value]))

    @jsii.member(jsii_name="resetLinuxNodeConfig")
    def reset_linux_node_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLinuxNodeConfig", []))

    @jsii.member(jsii_name="resetNetworkTags")
    def reset_network_tags(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNetworkTags", []))

    @jsii.member(jsii_name="resetNodeKubeletConfig")
    def reset_node_kubelet_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNodeKubeletConfig", []))

    @jsii.member(jsii_name="resetResourceManagerTags")
    def reset_resource_manager_tags(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetResourceManagerTags", []))

    @builtins.property
    @jsii.member(jsii_name="linuxNodeConfig")
    def linux_node_config(
        self,
    ) -> ContainerClusterNodePoolAutoConfigLinuxNodeConfigOutputReference:
        return typing.cast(ContainerClusterNodePoolAutoConfigLinuxNodeConfigOutputReference, jsii.get(self, "linuxNodeConfig"))

    @builtins.property
    @jsii.member(jsii_name="networkTags")
    def network_tags(
        self,
    ) -> ContainerClusterNodePoolAutoConfigNetworkTagsOutputReference:
        return typing.cast(ContainerClusterNodePoolAutoConfigNetworkTagsOutputReference, jsii.get(self, "networkTags"))

    @builtins.property
    @jsii.member(jsii_name="nodeKubeletConfig")
    def node_kubelet_config(
        self,
    ) -> ContainerClusterNodePoolAutoConfigNodeKubeletConfigOutputReference:
        return typing.cast(ContainerClusterNodePoolAutoConfigNodeKubeletConfigOutputReference, jsii.get(self, "nodeKubeletConfig"))

    @builtins.property
    @jsii.member(jsii_name="linuxNodeConfigInput")
    def linux_node_config_input(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolAutoConfigLinuxNodeConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolAutoConfigLinuxNodeConfig], jsii.get(self, "linuxNodeConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="networkTagsInput")
    def network_tags_input(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolAutoConfigNetworkTags]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolAutoConfigNetworkTags], jsii.get(self, "networkTagsInput"))

    @builtins.property
    @jsii.member(jsii_name="nodeKubeletConfigInput")
    def node_kubelet_config_input(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolAutoConfigNodeKubeletConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolAutoConfigNodeKubeletConfig], jsii.get(self, "nodeKubeletConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="resourceManagerTagsInput")
    def resource_manager_tags_input(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], jsii.get(self, "resourceManagerTagsInput"))

    @builtins.property
    @jsii.member(jsii_name="resourceManagerTags")
    def resource_manager_tags(self) -> typing.Mapping[builtins.str, builtins.str]:
        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.get(self, "resourceManagerTags"))

    @resource_manager_tags.setter
    def resource_manager_tags(
        self,
        value: typing.Mapping[builtins.str, builtins.str],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__333cefb4115d05689c2cf708ab2c55d92f46412237ac28dc843f36690430f5f5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "resourceManagerTags", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[ContainerClusterNodePoolAutoConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolAutoConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodePoolAutoConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__149f3c7b3c8d7fd7d16667d9153aa0f34d42864379310e2fd6b7a1091a50368b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolAutoscaling",
    jsii_struct_bases=[],
    name_mapping={
        "location_policy": "locationPolicy",
        "max_node_count": "maxNodeCount",
        "min_node_count": "minNodeCount",
        "total_max_node_count": "totalMaxNodeCount",
        "total_min_node_count": "totalMinNodeCount",
    },
)
class ContainerClusterNodePoolAutoscaling:
    def __init__(
        self,
        *,
        location_policy: typing.Optional[builtins.str] = None,
        max_node_count: typing.Optional[jsii.Number] = None,
        min_node_count: typing.Optional[jsii.Number] = None,
        total_max_node_count: typing.Optional[jsii.Number] = None,
        total_min_node_count: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param location_policy: Location policy specifies the algorithm used when scaling-up the node pool. "BALANCED" - Is a best effort policy that aims to balance the sizes of available zones. "ANY" - Instructs the cluster autoscaler to prioritize utilization of unused reservations, and reduces preemption risk for Spot VMs. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#location_policy ContainerCluster#location_policy}
        :param max_node_count: Maximum number of nodes per zone in the node pool. Must be >= min_node_count. Cannot be used with total limits. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#max_node_count ContainerCluster#max_node_count}
        :param min_node_count: Minimum number of nodes per zone in the node pool. Must be >=0 and <= max_node_count. Cannot be used with total limits. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#min_node_count ContainerCluster#min_node_count}
        :param total_max_node_count: Maximum number of all nodes in the node pool. Must be >= total_min_node_count. Cannot be used with per zone limits. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#total_max_node_count ContainerCluster#total_max_node_count}
        :param total_min_node_count: Minimum number of all nodes in the node pool. Must be >=0 and <= total_max_node_count. Cannot be used with per zone limits. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#total_min_node_count ContainerCluster#total_min_node_count}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f37e6afeb20e35ed90359571195810a7457d804ab67055e18827e76ffcb9531a)
            check_type(argname="argument location_policy", value=location_policy, expected_type=type_hints["location_policy"])
            check_type(argname="argument max_node_count", value=max_node_count, expected_type=type_hints["max_node_count"])
            check_type(argname="argument min_node_count", value=min_node_count, expected_type=type_hints["min_node_count"])
            check_type(argname="argument total_max_node_count", value=total_max_node_count, expected_type=type_hints["total_max_node_count"])
            check_type(argname="argument total_min_node_count", value=total_min_node_count, expected_type=type_hints["total_min_node_count"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if location_policy is not None:
            self._values["location_policy"] = location_policy
        if max_node_count is not None:
            self._values["max_node_count"] = max_node_count
        if min_node_count is not None:
            self._values["min_node_count"] = min_node_count
        if total_max_node_count is not None:
            self._values["total_max_node_count"] = total_max_node_count
        if total_min_node_count is not None:
            self._values["total_min_node_count"] = total_min_node_count

    @builtins.property
    def location_policy(self) -> typing.Optional[builtins.str]:
        '''Location policy specifies the algorithm used when scaling-up the node pool.

        "BALANCED" - Is a best effort policy that aims to balance the sizes of available zones. "ANY" - Instructs the cluster autoscaler to prioritize utilization of unused reservations, and reduces preemption risk for Spot VMs.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#location_policy ContainerCluster#location_policy}
        '''
        result = self._values.get("location_policy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def max_node_count(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of nodes per zone in the node pool.

        Must be >= min_node_count. Cannot be used with total limits.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#max_node_count ContainerCluster#max_node_count}
        '''
        result = self._values.get("max_node_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def min_node_count(self) -> typing.Optional[jsii.Number]:
        '''Minimum number of nodes per zone in the node pool.

        Must be >=0 and <= max_node_count. Cannot be used with total limits.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#min_node_count ContainerCluster#min_node_count}
        '''
        result = self._values.get("min_node_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def total_max_node_count(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of all nodes in the node pool.

        Must be >= total_min_node_count. Cannot be used with per zone limits.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#total_max_node_count ContainerCluster#total_max_node_count}
        '''
        result = self._values.get("total_max_node_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def total_min_node_count(self) -> typing.Optional[jsii.Number]:
        '''Minimum number of all nodes in the node pool.

        Must be >=0 and <= total_max_node_count. Cannot be used with per zone limits.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#total_min_node_count ContainerCluster#total_min_node_count}
        '''
        result = self._values.get("total_min_node_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodePoolAutoscaling(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodePoolAutoscalingOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolAutoscalingOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__43b54b0a5864c7a4d43781465a0d61ffe6614e577636517ad1a08acf3c9b0db2)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetLocationPolicy")
    def reset_location_policy(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLocationPolicy", []))

    @jsii.member(jsii_name="resetMaxNodeCount")
    def reset_max_node_count(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMaxNodeCount", []))

    @jsii.member(jsii_name="resetMinNodeCount")
    def reset_min_node_count(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMinNodeCount", []))

    @jsii.member(jsii_name="resetTotalMaxNodeCount")
    def reset_total_max_node_count(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTotalMaxNodeCount", []))

    @jsii.member(jsii_name="resetTotalMinNodeCount")
    def reset_total_min_node_count(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTotalMinNodeCount", []))

    @builtins.property
    @jsii.member(jsii_name="locationPolicyInput")
    def location_policy_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "locationPolicyInput"))

    @builtins.property
    @jsii.member(jsii_name="maxNodeCountInput")
    def max_node_count_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "maxNodeCountInput"))

    @builtins.property
    @jsii.member(jsii_name="minNodeCountInput")
    def min_node_count_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "minNodeCountInput"))

    @builtins.property
    @jsii.member(jsii_name="totalMaxNodeCountInput")
    def total_max_node_count_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "totalMaxNodeCountInput"))

    @builtins.property
    @jsii.member(jsii_name="totalMinNodeCountInput")
    def total_min_node_count_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "totalMinNodeCountInput"))

    @builtins.property
    @jsii.member(jsii_name="locationPolicy")
    def location_policy(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "locationPolicy"))

    @location_policy.setter
    def location_policy(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cb90c3496cf19b2f4130a6854f3e9d1d9b87f8e5fb13a96c40082d4949797605)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "locationPolicy", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="maxNodeCount")
    def max_node_count(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "maxNodeCount"))

    @max_node_count.setter
    def max_node_count(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4e759f3aebbe36d5de18f11d16b19bb947f3f7dcad9354f3d146da1302d5805b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "maxNodeCount", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="minNodeCount")
    def min_node_count(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "minNodeCount"))

    @min_node_count.setter
    def min_node_count(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e4eef3a0241b3a030c335197d11ca760626150c67a070231401d27c90af8662d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "minNodeCount", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="totalMaxNodeCount")
    def total_max_node_count(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "totalMaxNodeCount"))

    @total_max_node_count.setter
    def total_max_node_count(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c10a9181e0350c8f5871ddf3b85b47b63e567914b4ef5e5327b0189440f10041)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "totalMaxNodeCount", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="totalMinNodeCount")
    def total_min_node_count(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "totalMinNodeCount"))

    @total_min_node_count.setter
    def total_min_node_count(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6ecc419e04e5f07c79228f9cd5f26b84461fb5a5f5ef9752c31209c6dab668f5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "totalMinNodeCount", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[ContainerClusterNodePoolAutoscaling]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolAutoscaling], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodePoolAutoscaling],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ff6c7c4dec5523a1a5fb740282bc2294ee560c4ad20f7c969f9cc7e69f61dcb0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolDefaults",
    jsii_struct_bases=[],
    name_mapping={"node_config_defaults": "nodeConfigDefaults"},
)
class ContainerClusterNodePoolDefaults:
    def __init__(
        self,
        *,
        node_config_defaults: typing.Optional[typing.Union["ContainerClusterNodePoolDefaultsNodeConfigDefaults", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param node_config_defaults: node_config_defaults block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#node_config_defaults ContainerCluster#node_config_defaults}
        '''
        if isinstance(node_config_defaults, dict):
            node_config_defaults = ContainerClusterNodePoolDefaultsNodeConfigDefaults(**node_config_defaults)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d290ee536ba1a19948d2d50116bb6629465ed34f3a96ed675f4327abdcce9784)
            check_type(argname="argument node_config_defaults", value=node_config_defaults, expected_type=type_hints["node_config_defaults"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if node_config_defaults is not None:
            self._values["node_config_defaults"] = node_config_defaults

    @builtins.property
    def node_config_defaults(
        self,
    ) -> typing.Optional["ContainerClusterNodePoolDefaultsNodeConfigDefaults"]:
        '''node_config_defaults block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#node_config_defaults ContainerCluster#node_config_defaults}
        '''
        result = self._values.get("node_config_defaults")
        return typing.cast(typing.Optional["ContainerClusterNodePoolDefaultsNodeConfigDefaults"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodePoolDefaults(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolDefaultsNodeConfigDefaults",
    jsii_struct_bases=[],
    name_mapping={
        "containerd_config": "containerdConfig",
        "gcfs_config": "gcfsConfig",
        "insecure_kubelet_readonly_port_enabled": "insecureKubeletReadonlyPortEnabled",
        "logging_variant": "loggingVariant",
    },
)
class ContainerClusterNodePoolDefaultsNodeConfigDefaults:
    def __init__(
        self,
        *,
        containerd_config: typing.Optional[typing.Union["ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        gcfs_config: typing.Optional[typing.Union["ContainerClusterNodePoolDefaultsNodeConfigDefaultsGcfsConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        insecure_kubelet_readonly_port_enabled: typing.Optional[builtins.str] = None,
        logging_variant: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param containerd_config: containerd_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#containerd_config ContainerCluster#containerd_config}
        :param gcfs_config: gcfs_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gcfs_config ContainerCluster#gcfs_config}
        :param insecure_kubelet_readonly_port_enabled: Controls whether the kubelet read-only port is enabled. It is strongly recommended to set this to ``FALSE``. Possible values: ``TRUE``, ``FALSE``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#insecure_kubelet_readonly_port_enabled ContainerCluster#insecure_kubelet_readonly_port_enabled}
        :param logging_variant: Type of logging agent that is used as the default value for node pools in the cluster. Valid values include DEFAULT and MAX_THROUGHPUT. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#logging_variant ContainerCluster#logging_variant}
        '''
        if isinstance(containerd_config, dict):
            containerd_config = ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfig(**containerd_config)
        if isinstance(gcfs_config, dict):
            gcfs_config = ContainerClusterNodePoolDefaultsNodeConfigDefaultsGcfsConfig(**gcfs_config)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d58e2c7bbd3d3cfcca11f1b397643a730777de7884845c92a128c97ddfb60ce5)
            check_type(argname="argument containerd_config", value=containerd_config, expected_type=type_hints["containerd_config"])
            check_type(argname="argument gcfs_config", value=gcfs_config, expected_type=type_hints["gcfs_config"])
            check_type(argname="argument insecure_kubelet_readonly_port_enabled", value=insecure_kubelet_readonly_port_enabled, expected_type=type_hints["insecure_kubelet_readonly_port_enabled"])
            check_type(argname="argument logging_variant", value=logging_variant, expected_type=type_hints["logging_variant"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if containerd_config is not None:
            self._values["containerd_config"] = containerd_config
        if gcfs_config is not None:
            self._values["gcfs_config"] = gcfs_config
        if insecure_kubelet_readonly_port_enabled is not None:
            self._values["insecure_kubelet_readonly_port_enabled"] = insecure_kubelet_readonly_port_enabled
        if logging_variant is not None:
            self._values["logging_variant"] = logging_variant

    @builtins.property
    def containerd_config(
        self,
    ) -> typing.Optional["ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfig"]:
        '''containerd_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#containerd_config ContainerCluster#containerd_config}
        '''
        result = self._values.get("containerd_config")
        return typing.cast(typing.Optional["ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfig"], result)

    @builtins.property
    def gcfs_config(
        self,
    ) -> typing.Optional["ContainerClusterNodePoolDefaultsNodeConfigDefaultsGcfsConfig"]:
        '''gcfs_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gcfs_config ContainerCluster#gcfs_config}
        '''
        result = self._values.get("gcfs_config")
        return typing.cast(typing.Optional["ContainerClusterNodePoolDefaultsNodeConfigDefaultsGcfsConfig"], result)

    @builtins.property
    def insecure_kubelet_readonly_port_enabled(self) -> typing.Optional[builtins.str]:
        '''Controls whether the kubelet read-only port is enabled.

        It is strongly recommended to set this to ``FALSE``. Possible values: ``TRUE``, ``FALSE``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#insecure_kubelet_readonly_port_enabled ContainerCluster#insecure_kubelet_readonly_port_enabled}
        '''
        result = self._values.get("insecure_kubelet_readonly_port_enabled")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def logging_variant(self) -> typing.Optional[builtins.str]:
        '''Type of logging agent that is used as the default value for node pools in the cluster.

        Valid values include DEFAULT and MAX_THROUGHPUT.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#logging_variant ContainerCluster#logging_variant}
        '''
        result = self._values.get("logging_variant")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodePoolDefaultsNodeConfigDefaults(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfig",
    jsii_struct_bases=[],
    name_mapping={"private_registry_access_config": "privateRegistryAccessConfig"},
)
class ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfig:
    def __init__(
        self,
        *,
        private_registry_access_config: typing.Optional[typing.Union["ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param private_registry_access_config: private_registry_access_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#private_registry_access_config ContainerCluster#private_registry_access_config}
        '''
        if isinstance(private_registry_access_config, dict):
            private_registry_access_config = ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig(**private_registry_access_config)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b989e3891af65bae8ad9453a554ac52b6e785c7bec0cbbfff4bba57abce8cc4e)
            check_type(argname="argument private_registry_access_config", value=private_registry_access_config, expected_type=type_hints["private_registry_access_config"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if private_registry_access_config is not None:
            self._values["private_registry_access_config"] = private_registry_access_config

    @builtins.property
    def private_registry_access_config(
        self,
    ) -> typing.Optional["ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig"]:
        '''private_registry_access_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#private_registry_access_config ContainerCluster#private_registry_access_config}
        '''
        result = self._values.get("private_registry_access_config")
        return typing.cast(typing.Optional["ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3cb924ff2dcf327b370c72919c11f9b6be994ba124f3ba68f6dec8620b347017)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putPrivateRegistryAccessConfig")
    def put_private_registry_access_config(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
        certificate_authority_domain_config: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig", typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''
        :param enabled: Whether or not private registries are configured. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        :param certificate_authority_domain_config: certificate_authority_domain_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#certificate_authority_domain_config ContainerCluster#certificate_authority_domain_config}
        '''
        value = ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig(
            enabled=enabled,
            certificate_authority_domain_config=certificate_authority_domain_config,
        )

        return typing.cast(None, jsii.invoke(self, "putPrivateRegistryAccessConfig", [value]))

    @jsii.member(jsii_name="resetPrivateRegistryAccessConfig")
    def reset_private_registry_access_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPrivateRegistryAccessConfig", []))

    @builtins.property
    @jsii.member(jsii_name="privateRegistryAccessConfig")
    def private_registry_access_config(
        self,
    ) -> "ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigOutputReference":
        return typing.cast("ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigOutputReference", jsii.get(self, "privateRegistryAccessConfig"))

    @builtins.property
    @jsii.member(jsii_name="privateRegistryAccessConfigInput")
    def private_registry_access_config_input(
        self,
    ) -> typing.Optional["ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig"]:
        return typing.cast(typing.Optional["ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig"], jsii.get(self, "privateRegistryAccessConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1dcd3ba82b2f3ecf12d4620e55c05ac7a24219e66c803acb44cb936562823bf7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig",
    jsii_struct_bases=[],
    name_mapping={
        "enabled": "enabled",
        "certificate_authority_domain_config": "certificateAuthorityDomainConfig",
    },
)
class ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig:
    def __init__(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
        certificate_authority_domain_config: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig", typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''
        :param enabled: Whether or not private registries are configured. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        :param certificate_authority_domain_config: certificate_authority_domain_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#certificate_authority_domain_config ContainerCluster#certificate_authority_domain_config}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d6321c2be34b42b86ec19ab683b893ed05c454011bbf82e400e4a54f1e9a910f)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
            check_type(argname="argument certificate_authority_domain_config", value=certificate_authority_domain_config, expected_type=type_hints["certificate_authority_domain_config"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "enabled": enabled,
        }
        if certificate_authority_domain_config is not None:
            self._values["certificate_authority_domain_config"] = certificate_authority_domain_config

    @builtins.property
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        '''Whether or not private registries are configured.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        '''
        result = self._values.get("enabled")
        assert result is not None, "Required property 'enabled' is missing"
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], result)

    @builtins.property
    def certificate_authority_domain_config(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig"]]]:
        '''certificate_authority_domain_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#certificate_authority_domain_config ContainerCluster#certificate_authority_domain_config}
        '''
        result = self._values.get("certificate_authority_domain_config")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig"]]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig",
    jsii_struct_bases=[],
    name_mapping={
        "fqdns": "fqdns",
        "gcp_secret_manager_certificate_config": "gcpSecretManagerCertificateConfig",
    },
)
class ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig:
    def __init__(
        self,
        *,
        fqdns: typing.Sequence[builtins.str],
        gcp_secret_manager_certificate_config: typing.Union["ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''
        :param fqdns: List of fully-qualified-domain-names. IPv4s and port specification are supported. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#fqdns ContainerCluster#fqdns}
        :param gcp_secret_manager_certificate_config: gcp_secret_manager_certificate_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gcp_secret_manager_certificate_config ContainerCluster#gcp_secret_manager_certificate_config}
        '''
        if isinstance(gcp_secret_manager_certificate_config, dict):
            gcp_secret_manager_certificate_config = ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig(**gcp_secret_manager_certificate_config)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d13af45f5a7d0b0c7e7603efec819600693120b0de961e7787f21ad656701977)
            check_type(argname="argument fqdns", value=fqdns, expected_type=type_hints["fqdns"])
            check_type(argname="argument gcp_secret_manager_certificate_config", value=gcp_secret_manager_certificate_config, expected_type=type_hints["gcp_secret_manager_certificate_config"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "fqdns": fqdns,
            "gcp_secret_manager_certificate_config": gcp_secret_manager_certificate_config,
        }

    @builtins.property
    def fqdns(self) -> typing.List[builtins.str]:
        '''List of fully-qualified-domain-names. IPv4s and port specification are supported.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#fqdns ContainerCluster#fqdns}
        '''
        result = self._values.get("fqdns")
        assert result is not None, "Required property 'fqdns' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def gcp_secret_manager_certificate_config(
        self,
    ) -> "ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig":
        '''gcp_secret_manager_certificate_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gcp_secret_manager_certificate_config ContainerCluster#gcp_secret_manager_certificate_config}
        '''
        result = self._values.get("gcp_secret_manager_certificate_config")
        assert result is not None, "Required property 'gcp_secret_manager_certificate_config' is missing"
        return typing.cast("ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig",
    jsii_struct_bases=[],
    name_mapping={"secret_uri": "secretUri"},
)
class ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig:
    def __init__(self, *, secret_uri: builtins.str) -> None:
        '''
        :param secret_uri: URI for the secret that hosts a certificate. Must be in the format 'projects/PROJECT_NUM/secrets/SECRET_NAME/versions/VERSION_OR_LATEST'. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#secret_uri ContainerCluster#secret_uri}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4cd790fbcdec4b31a75644d57773de15d21fa2adaf143bcddc8873836224ed98)
            check_type(argname="argument secret_uri", value=secret_uri, expected_type=type_hints["secret_uri"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "secret_uri": secret_uri,
        }

    @builtins.property
    def secret_uri(self) -> builtins.str:
        '''URI for the secret that hosts a certificate. Must be in the format 'projects/PROJECT_NUM/secrets/SECRET_NAME/versions/VERSION_OR_LATEST'.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#secret_uri ContainerCluster#secret_uri}
        '''
        result = self._values.get("secret_uri")
        assert result is not None, "Required property 'secret_uri' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4d36e9b0d95ba519df827eb853736505443d87fbfc7937e71cf1d7806676a0f9)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="secretUriInput")
    def secret_uri_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "secretUriInput"))

    @builtins.property
    @jsii.member(jsii_name="secretUri")
    def secret_uri(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "secretUri"))

    @secret_uri.setter
    def secret_uri(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__91ebef9f13e5e588e5c7957fee7dcbd5e73a8278dc65625100ca0f359f16d249)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "secretUri", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__69ca128b9e40a37f82ecac5ecc4f50631527de32abada1e6579dd81105027c7d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8d477408ff2cf424705ba535cfea7ea693446ee866ccff887194b5d24390fead)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__99cfe49e8f7301c6ebd7e6552f705036b037f2f8877d1791011a853434ee4434)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__097f14ddf58da021d2f2c8d292230cf8e4b8ad3529f9c805146c85a856db660e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__064c93bbc4307092c3a9a2814038a115119bb5fccefd5ae4316b751cda62b567)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1eb5c4475bdb470a796c8fde539b21dc3da9099c632c3de5920176fa77d68000)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9acad653bb4be3cb23b6091153ccd689ac022b6958c9b4f030383dbead0de3c5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ff4774d57b4c7c09ebea7d1c36104a11156de852a3ca70b110acc4ee4b60902a)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putGcpSecretManagerCertificateConfig")
    def put_gcp_secret_manager_certificate_config(
        self,
        *,
        secret_uri: builtins.str,
    ) -> None:
        '''
        :param secret_uri: URI for the secret that hosts a certificate. Must be in the format 'projects/PROJECT_NUM/secrets/SECRET_NAME/versions/VERSION_OR_LATEST'. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#secret_uri ContainerCluster#secret_uri}
        '''
        value = ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig(
            secret_uri=secret_uri
        )

        return typing.cast(None, jsii.invoke(self, "putGcpSecretManagerCertificateConfig", [value]))

    @builtins.property
    @jsii.member(jsii_name="gcpSecretManagerCertificateConfig")
    def gcp_secret_manager_certificate_config(
        self,
    ) -> ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfigOutputReference:
        return typing.cast(ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfigOutputReference, jsii.get(self, "gcpSecretManagerCertificateConfig"))

    @builtins.property
    @jsii.member(jsii_name="fqdnsInput")
    def fqdns_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "fqdnsInput"))

    @builtins.property
    @jsii.member(jsii_name="gcpSecretManagerCertificateConfigInput")
    def gcp_secret_manager_certificate_config_input(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig], jsii.get(self, "gcpSecretManagerCertificateConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="fqdns")
    def fqdns(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "fqdns"))

    @fqdns.setter
    def fqdns(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ea545da6d4e37564557204446dc57231d4cf2b103a7fa1dcc119c62aa08bf3ee)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "fqdns", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__536674119c31732d4f1f563048656ff508bf7b8ac8e7d51770fd9aca7e3c0b1c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3115df67b02ac5081ecfe44b6b1ed05ff6a89f0519959155655df2703f8aba13)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putCertificateAuthorityDomainConfig")
    def put_certificate_authority_domain_config(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ac86bd951e738bf283d14c9a6ad649246e87e6913f5fd693d11271d8bfbde454)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putCertificateAuthorityDomainConfig", [value]))

    @jsii.member(jsii_name="resetCertificateAuthorityDomainConfig")
    def reset_certificate_authority_domain_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCertificateAuthorityDomainConfig", []))

    @builtins.property
    @jsii.member(jsii_name="certificateAuthorityDomainConfig")
    def certificate_authority_domain_config(
        self,
    ) -> ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigList:
        return typing.cast(ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigList, jsii.get(self, "certificateAuthorityDomainConfig"))

    @builtins.property
    @jsii.member(jsii_name="certificateAuthorityDomainConfigInput")
    def certificate_authority_domain_config_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig]]], jsii.get(self, "certificateAuthorityDomainConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="enabledInput")
    def enabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enabledInput"))

    @builtins.property
    @jsii.member(jsii_name="enabled")
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enabled"))

    @enabled.setter
    def enabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bc13bef8cbf97aa033e9326d554c397a18b5efa73f0c4a4396685618105a0ab5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__aafdf67ef89d660e52bebc63601e46f312701627d5d8501e426d4ee33a0349d7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolDefaultsNodeConfigDefaultsGcfsConfig",
    jsii_struct_bases=[],
    name_mapping={"enabled": "enabled"},
)
class ContainerClusterNodePoolDefaultsNodeConfigDefaultsGcfsConfig:
    def __init__(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param enabled: Whether or not GCFS is enabled. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ab1bb5c11879af027445e40afc406158813fca3bbf93c537e2a624c43a64ab98)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "enabled": enabled,
        }

    @builtins.property
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        '''Whether or not GCFS is enabled.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        '''
        result = self._values.get("enabled")
        assert result is not None, "Required property 'enabled' is missing"
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodePoolDefaultsNodeConfigDefaultsGcfsConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodePoolDefaultsNodeConfigDefaultsGcfsConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolDefaultsNodeConfigDefaultsGcfsConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__87842d9a22f82f97923702b36a69165f5b4481611b0683d68f44178f35dda1d9)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="enabledInput")
    def enabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enabledInput"))

    @builtins.property
    @jsii.member(jsii_name="enabled")
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enabled"))

    @enabled.setter
    def enabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__82a37d764dfed7807565002948c0e9baa0d261a34c5f201b2272e73fd1cd0072)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolDefaultsNodeConfigDefaultsGcfsConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolDefaultsNodeConfigDefaultsGcfsConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodePoolDefaultsNodeConfigDefaultsGcfsConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b14d570e69b1235b6bb0be3c2c5cde218419c7ca7da1e06c93b67e4a03bf9312)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ContainerClusterNodePoolDefaultsNodeConfigDefaultsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolDefaultsNodeConfigDefaultsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d03d924502e31c0eed1cddad4efa9a56e9c5ae67415d3b5c6996ecf24b7b82f4)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putContainerdConfig")
    def put_containerd_config(
        self,
        *,
        private_registry_access_config: typing.Optional[typing.Union[ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param private_registry_access_config: private_registry_access_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#private_registry_access_config ContainerCluster#private_registry_access_config}
        '''
        value = ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfig(
            private_registry_access_config=private_registry_access_config
        )

        return typing.cast(None, jsii.invoke(self, "putContainerdConfig", [value]))

    @jsii.member(jsii_name="putGcfsConfig")
    def put_gcfs_config(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param enabled: Whether or not GCFS is enabled. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        '''
        value = ContainerClusterNodePoolDefaultsNodeConfigDefaultsGcfsConfig(
            enabled=enabled
        )

        return typing.cast(None, jsii.invoke(self, "putGcfsConfig", [value]))

    @jsii.member(jsii_name="resetContainerdConfig")
    def reset_containerd_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetContainerdConfig", []))

    @jsii.member(jsii_name="resetGcfsConfig")
    def reset_gcfs_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGcfsConfig", []))

    @jsii.member(jsii_name="resetInsecureKubeletReadonlyPortEnabled")
    def reset_insecure_kubelet_readonly_port_enabled(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetInsecureKubeletReadonlyPortEnabled", []))

    @jsii.member(jsii_name="resetLoggingVariant")
    def reset_logging_variant(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLoggingVariant", []))

    @builtins.property
    @jsii.member(jsii_name="containerdConfig")
    def containerd_config(
        self,
    ) -> ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigOutputReference:
        return typing.cast(ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigOutputReference, jsii.get(self, "containerdConfig"))

    @builtins.property
    @jsii.member(jsii_name="gcfsConfig")
    def gcfs_config(
        self,
    ) -> ContainerClusterNodePoolDefaultsNodeConfigDefaultsGcfsConfigOutputReference:
        return typing.cast(ContainerClusterNodePoolDefaultsNodeConfigDefaultsGcfsConfigOutputReference, jsii.get(self, "gcfsConfig"))

    @builtins.property
    @jsii.member(jsii_name="containerdConfigInput")
    def containerd_config_input(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfig], jsii.get(self, "containerdConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="gcfsConfigInput")
    def gcfs_config_input(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolDefaultsNodeConfigDefaultsGcfsConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolDefaultsNodeConfigDefaultsGcfsConfig], jsii.get(self, "gcfsConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="insecureKubeletReadonlyPortEnabledInput")
    def insecure_kubelet_readonly_port_enabled_input(
        self,
    ) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "insecureKubeletReadonlyPortEnabledInput"))

    @builtins.property
    @jsii.member(jsii_name="loggingVariantInput")
    def logging_variant_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "loggingVariantInput"))

    @builtins.property
    @jsii.member(jsii_name="insecureKubeletReadonlyPortEnabled")
    def insecure_kubelet_readonly_port_enabled(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "insecureKubeletReadonlyPortEnabled"))

    @insecure_kubelet_readonly_port_enabled.setter
    def insecure_kubelet_readonly_port_enabled(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b46cf63eb75aab98ecd7a3a900530fa03f703e0eff7abda2af6c84f41e554503)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "insecureKubeletReadonlyPortEnabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="loggingVariant")
    def logging_variant(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "loggingVariant"))

    @logging_variant.setter
    def logging_variant(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__13848a47360611359e6427dae3a499e245dbce3073920716160d3169933e3dca)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "loggingVariant", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolDefaultsNodeConfigDefaults]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolDefaultsNodeConfigDefaults], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodePoolDefaultsNodeConfigDefaults],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__54613196202259694905bcf8379245aeabdbe98165dac257f94b91e659fe5f84)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ContainerClusterNodePoolDefaultsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolDefaultsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__20ccf7ebea6606a82f40a613ac80caf61fd44d211e618721abe728bc44f44105)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putNodeConfigDefaults")
    def put_node_config_defaults(
        self,
        *,
        containerd_config: typing.Optional[typing.Union[ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        gcfs_config: typing.Optional[typing.Union[ContainerClusterNodePoolDefaultsNodeConfigDefaultsGcfsConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        insecure_kubelet_readonly_port_enabled: typing.Optional[builtins.str] = None,
        logging_variant: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param containerd_config: containerd_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#containerd_config ContainerCluster#containerd_config}
        :param gcfs_config: gcfs_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gcfs_config ContainerCluster#gcfs_config}
        :param insecure_kubelet_readonly_port_enabled: Controls whether the kubelet read-only port is enabled. It is strongly recommended to set this to ``FALSE``. Possible values: ``TRUE``, ``FALSE``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#insecure_kubelet_readonly_port_enabled ContainerCluster#insecure_kubelet_readonly_port_enabled}
        :param logging_variant: Type of logging agent that is used as the default value for node pools in the cluster. Valid values include DEFAULT and MAX_THROUGHPUT. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#logging_variant ContainerCluster#logging_variant}
        '''
        value = ContainerClusterNodePoolDefaultsNodeConfigDefaults(
            containerd_config=containerd_config,
            gcfs_config=gcfs_config,
            insecure_kubelet_readonly_port_enabled=insecure_kubelet_readonly_port_enabled,
            logging_variant=logging_variant,
        )

        return typing.cast(None, jsii.invoke(self, "putNodeConfigDefaults", [value]))

    @jsii.member(jsii_name="resetNodeConfigDefaults")
    def reset_node_config_defaults(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNodeConfigDefaults", []))

    @builtins.property
    @jsii.member(jsii_name="nodeConfigDefaults")
    def node_config_defaults(
        self,
    ) -> ContainerClusterNodePoolDefaultsNodeConfigDefaultsOutputReference:
        return typing.cast(ContainerClusterNodePoolDefaultsNodeConfigDefaultsOutputReference, jsii.get(self, "nodeConfigDefaults"))

    @builtins.property
    @jsii.member(jsii_name="nodeConfigDefaultsInput")
    def node_config_defaults_input(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolDefaultsNodeConfigDefaults]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolDefaultsNodeConfigDefaults], jsii.get(self, "nodeConfigDefaultsInput"))

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[ContainerClusterNodePoolDefaults]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolDefaults], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodePoolDefaults],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3b7d04e62fe56713e712488a769fb8c7e8ff15d1ecf43ca8e5969778a573cb88)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ContainerClusterNodePoolList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__501b372a997596371ef0e3bac9325d8dab9728d4012087d6759c4912456b67a3)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(self, index: jsii.Number) -> "ContainerClusterNodePoolOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ea7dcdc843610e113a16ef44a5b2acab98cd160d89f30b057ea7407d08b1b8a4)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ContainerClusterNodePoolOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0b8c5ad32ec57de8744212f4f69018d344844d2e89f67f79aec02489b9e1a3f5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3842025773b3e45fa99e72a84d0bec2e7d2753c6b77793731c35a7053e94121f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__59ad4b59a226878dbe302647f430007134c3d5c0b851e38b6448c4cde6fe4571)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodePool]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodePool]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodePool]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0eaa4fdd9b5e4e5b7697f9f55e7f6a97840cddf975372a3809b70b3139c73398)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolManagement",
    jsii_struct_bases=[],
    name_mapping={"auto_repair": "autoRepair", "auto_upgrade": "autoUpgrade"},
)
class ContainerClusterNodePoolManagement:
    def __init__(
        self,
        *,
        auto_repair: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        auto_upgrade: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    ) -> None:
        '''
        :param auto_repair: Whether the nodes will be automatically repaired. Enabled by default. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#auto_repair ContainerCluster#auto_repair}
        :param auto_upgrade: Whether the nodes will be automatically upgraded. Enabled by default. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#auto_upgrade ContainerCluster#auto_upgrade}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d5b08e7f6ab990f91bb03c1087044a27abc2a423828ba1d6a362ca69b7382ccd)
            check_type(argname="argument auto_repair", value=auto_repair, expected_type=type_hints["auto_repair"])
            check_type(argname="argument auto_upgrade", value=auto_upgrade, expected_type=type_hints["auto_upgrade"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if auto_repair is not None:
            self._values["auto_repair"] = auto_repair
        if auto_upgrade is not None:
            self._values["auto_upgrade"] = auto_upgrade

    @builtins.property
    def auto_repair(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Whether the nodes will be automatically repaired. Enabled by default.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#auto_repair ContainerCluster#auto_repair}
        '''
        result = self._values.get("auto_repair")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def auto_upgrade(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Whether the nodes will be automatically upgraded. Enabled by default.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#auto_upgrade ContainerCluster#auto_upgrade}
        '''
        result = self._values.get("auto_upgrade")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodePoolManagement(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodePoolManagementOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolManagementOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0a120e363b46d8504ec517f6172c790032c6057dad7f3c112ceb0332592f2cfe)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetAutoRepair")
    def reset_auto_repair(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAutoRepair", []))

    @jsii.member(jsii_name="resetAutoUpgrade")
    def reset_auto_upgrade(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAutoUpgrade", []))

    @builtins.property
    @jsii.member(jsii_name="autoRepairInput")
    def auto_repair_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "autoRepairInput"))

    @builtins.property
    @jsii.member(jsii_name="autoUpgradeInput")
    def auto_upgrade_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "autoUpgradeInput"))

    @builtins.property
    @jsii.member(jsii_name="autoRepair")
    def auto_repair(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "autoRepair"))

    @auto_repair.setter
    def auto_repair(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__10391539e42dd2fac09214ef204d039fe0c2ae13fc06e0be6a2c6129da3cece0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "autoRepair", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="autoUpgrade")
    def auto_upgrade(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "autoUpgrade"))

    @auto_upgrade.setter
    def auto_upgrade(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__84e091cf562e096616ed155c508accb45a8aca5e15a73d5e35b56745cd888e77)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "autoUpgrade", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[ContainerClusterNodePoolManagement]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolManagement], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodePoolManagement],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d5ffd902a805a308ea02ab8e867160a92e2fb5ab2484cd192a23325f005305e9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNetworkConfig",
    jsii_struct_bases=[],
    name_mapping={
        "additional_node_network_configs": "additionalNodeNetworkConfigs",
        "additional_pod_network_configs": "additionalPodNetworkConfigs",
        "create_pod_range": "createPodRange",
        "enable_private_nodes": "enablePrivateNodes",
        "network_performance_config": "networkPerformanceConfig",
        "pod_cidr_overprovision_config": "podCidrOverprovisionConfig",
        "pod_ipv4_cidr_block": "podIpv4CidrBlock",
        "pod_range": "podRange",
    },
)
class ContainerClusterNodePoolNetworkConfig:
    def __init__(
        self,
        *,
        additional_node_network_configs: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ContainerClusterNodePoolNetworkConfigAdditionalNodeNetworkConfigs", typing.Dict[builtins.str, typing.Any]]]]] = None,
        additional_pod_network_configs: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ContainerClusterNodePoolNetworkConfigAdditionalPodNetworkConfigs", typing.Dict[builtins.str, typing.Any]]]]] = None,
        create_pod_range: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        enable_private_nodes: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        network_performance_config: typing.Optional[typing.Union["ContainerClusterNodePoolNetworkConfigNetworkPerformanceConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        pod_cidr_overprovision_config: typing.Optional[typing.Union["ContainerClusterNodePoolNetworkConfigPodCidrOverprovisionConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        pod_ipv4_cidr_block: typing.Optional[builtins.str] = None,
        pod_range: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param additional_node_network_configs: additional_node_network_configs block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#additional_node_network_configs ContainerCluster#additional_node_network_configs}
        :param additional_pod_network_configs: additional_pod_network_configs block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#additional_pod_network_configs ContainerCluster#additional_pod_network_configs}
        :param create_pod_range: Whether to create a new range for pod IPs in this node pool. Defaults are provided for pod_range and pod_ipv4_cidr_block if they are not specified. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#create_pod_range ContainerCluster#create_pod_range}
        :param enable_private_nodes: Whether nodes have internal IP addresses only. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_private_nodes ContainerCluster#enable_private_nodes}
        :param network_performance_config: network_performance_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#network_performance_config ContainerCluster#network_performance_config}
        :param pod_cidr_overprovision_config: pod_cidr_overprovision_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#pod_cidr_overprovision_config ContainerCluster#pod_cidr_overprovision_config}
        :param pod_ipv4_cidr_block: The IP address range for pod IPs in this node pool. Only applicable if create_pod_range is true. Set to blank to have a range chosen with the default size. Set to /netmask (e.g. /14) to have a range chosen with a specific netmask. Set to a CIDR notation (e.g. 10.96.0.0/14) to pick a specific range to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#pod_ipv4_cidr_block ContainerCluster#pod_ipv4_cidr_block}
        :param pod_range: The ID of the secondary range for pod IPs. If create_pod_range is true, this ID is used for the new range. If create_pod_range is false, uses an existing secondary range with this ID. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#pod_range ContainerCluster#pod_range}
        '''
        if isinstance(network_performance_config, dict):
            network_performance_config = ContainerClusterNodePoolNetworkConfigNetworkPerformanceConfig(**network_performance_config)
        if isinstance(pod_cidr_overprovision_config, dict):
            pod_cidr_overprovision_config = ContainerClusterNodePoolNetworkConfigPodCidrOverprovisionConfig(**pod_cidr_overprovision_config)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bcaa1d5fff84b3273f9f810f80f62e9a2ee78fda7ce195bcb03c5ae7fcb0a925)
            check_type(argname="argument additional_node_network_configs", value=additional_node_network_configs, expected_type=type_hints["additional_node_network_configs"])
            check_type(argname="argument additional_pod_network_configs", value=additional_pod_network_configs, expected_type=type_hints["additional_pod_network_configs"])
            check_type(argname="argument create_pod_range", value=create_pod_range, expected_type=type_hints["create_pod_range"])
            check_type(argname="argument enable_private_nodes", value=enable_private_nodes, expected_type=type_hints["enable_private_nodes"])
            check_type(argname="argument network_performance_config", value=network_performance_config, expected_type=type_hints["network_performance_config"])
            check_type(argname="argument pod_cidr_overprovision_config", value=pod_cidr_overprovision_config, expected_type=type_hints["pod_cidr_overprovision_config"])
            check_type(argname="argument pod_ipv4_cidr_block", value=pod_ipv4_cidr_block, expected_type=type_hints["pod_ipv4_cidr_block"])
            check_type(argname="argument pod_range", value=pod_range, expected_type=type_hints["pod_range"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if additional_node_network_configs is not None:
            self._values["additional_node_network_configs"] = additional_node_network_configs
        if additional_pod_network_configs is not None:
            self._values["additional_pod_network_configs"] = additional_pod_network_configs
        if create_pod_range is not None:
            self._values["create_pod_range"] = create_pod_range
        if enable_private_nodes is not None:
            self._values["enable_private_nodes"] = enable_private_nodes
        if network_performance_config is not None:
            self._values["network_performance_config"] = network_performance_config
        if pod_cidr_overprovision_config is not None:
            self._values["pod_cidr_overprovision_config"] = pod_cidr_overprovision_config
        if pod_ipv4_cidr_block is not None:
            self._values["pod_ipv4_cidr_block"] = pod_ipv4_cidr_block
        if pod_range is not None:
            self._values["pod_range"] = pod_range

    @builtins.property
    def additional_node_network_configs(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ContainerClusterNodePoolNetworkConfigAdditionalNodeNetworkConfigs"]]]:
        '''additional_node_network_configs block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#additional_node_network_configs ContainerCluster#additional_node_network_configs}
        '''
        result = self._values.get("additional_node_network_configs")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ContainerClusterNodePoolNetworkConfigAdditionalNodeNetworkConfigs"]]], result)

    @builtins.property
    def additional_pod_network_configs(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ContainerClusterNodePoolNetworkConfigAdditionalPodNetworkConfigs"]]]:
        '''additional_pod_network_configs block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#additional_pod_network_configs ContainerCluster#additional_pod_network_configs}
        '''
        result = self._values.get("additional_pod_network_configs")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ContainerClusterNodePoolNetworkConfigAdditionalPodNetworkConfigs"]]], result)

    @builtins.property
    def create_pod_range(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Whether to create a new range for pod IPs in this node pool.

        Defaults are provided for pod_range and pod_ipv4_cidr_block if they are not specified.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#create_pod_range ContainerCluster#create_pod_range}
        '''
        result = self._values.get("create_pod_range")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def enable_private_nodes(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Whether nodes have internal IP addresses only.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_private_nodes ContainerCluster#enable_private_nodes}
        '''
        result = self._values.get("enable_private_nodes")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def network_performance_config(
        self,
    ) -> typing.Optional["ContainerClusterNodePoolNetworkConfigNetworkPerformanceConfig"]:
        '''network_performance_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#network_performance_config ContainerCluster#network_performance_config}
        '''
        result = self._values.get("network_performance_config")
        return typing.cast(typing.Optional["ContainerClusterNodePoolNetworkConfigNetworkPerformanceConfig"], result)

    @builtins.property
    def pod_cidr_overprovision_config(
        self,
    ) -> typing.Optional["ContainerClusterNodePoolNetworkConfigPodCidrOverprovisionConfig"]:
        '''pod_cidr_overprovision_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#pod_cidr_overprovision_config ContainerCluster#pod_cidr_overprovision_config}
        '''
        result = self._values.get("pod_cidr_overprovision_config")
        return typing.cast(typing.Optional["ContainerClusterNodePoolNetworkConfigPodCidrOverprovisionConfig"], result)

    @builtins.property
    def pod_ipv4_cidr_block(self) -> typing.Optional[builtins.str]:
        '''The IP address range for pod IPs in this node pool.

        Only applicable if create_pod_range is true. Set to blank to have a range chosen with the default size. Set to /netmask (e.g. /14) to have a range chosen with a specific netmask. Set to a CIDR notation (e.g. 10.96.0.0/14) to pick a specific range to use.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#pod_ipv4_cidr_block ContainerCluster#pod_ipv4_cidr_block}
        '''
        result = self._values.get("pod_ipv4_cidr_block")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def pod_range(self) -> typing.Optional[builtins.str]:
        '''The ID of the secondary range for pod IPs.

        If create_pod_range is true, this ID is used for the new range. If create_pod_range is false, uses an existing secondary range with this ID.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#pod_range ContainerCluster#pod_range}
        '''
        result = self._values.get("pod_range")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodePoolNetworkConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNetworkConfigAdditionalNodeNetworkConfigs",
    jsii_struct_bases=[],
    name_mapping={"network": "network", "subnetwork": "subnetwork"},
)
class ContainerClusterNodePoolNetworkConfigAdditionalNodeNetworkConfigs:
    def __init__(
        self,
        *,
        network: typing.Optional[builtins.str] = None,
        subnetwork: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param network: Name of the VPC where the additional interface belongs. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#network ContainerCluster#network}
        :param subnetwork: Name of the subnetwork where the additional interface belongs. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#subnetwork ContainerCluster#subnetwork}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__59488a84313fd413b54ca252888ee68fc264b40ff8b991e689b6528b7378ea83)
            check_type(argname="argument network", value=network, expected_type=type_hints["network"])
            check_type(argname="argument subnetwork", value=subnetwork, expected_type=type_hints["subnetwork"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if network is not None:
            self._values["network"] = network
        if subnetwork is not None:
            self._values["subnetwork"] = subnetwork

    @builtins.property
    def network(self) -> typing.Optional[builtins.str]:
        '''Name of the VPC where the additional interface belongs.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#network ContainerCluster#network}
        '''
        result = self._values.get("network")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def subnetwork(self) -> typing.Optional[builtins.str]:
        '''Name of the subnetwork where the additional interface belongs.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#subnetwork ContainerCluster#subnetwork}
        '''
        result = self._values.get("subnetwork")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodePoolNetworkConfigAdditionalNodeNetworkConfigs(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodePoolNetworkConfigAdditionalNodeNetworkConfigsList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNetworkConfigAdditionalNodeNetworkConfigsList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bd8da296f2905b228fe3c0544656838069a64f3b29c52e33dad8f60ff8b3a98b)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ContainerClusterNodePoolNetworkConfigAdditionalNodeNetworkConfigsOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8f8d3cc4bc9293ba3f163d505b74e8210514ca9ac64fdcf9cf048c014459c749)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ContainerClusterNodePoolNetworkConfigAdditionalNodeNetworkConfigsOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6a32457def4778e0a60928e44c78a0ef631e512d056fcc9fb90f8d9386c06e66)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f5be276c92322c8a89ec439e0df1268f88c3c6e6ffdf1fd60788eeee86f632b8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1029555ccc4d5be306a96ff7f2544583c6a078b95092f08e5c8f9f018e83b2d4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodePoolNetworkConfigAdditionalNodeNetworkConfigs]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodePoolNetworkConfigAdditionalNodeNetworkConfigs]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodePoolNetworkConfigAdditionalNodeNetworkConfigs]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d0603d9647b9e5fd9173c73ec2c7cf77c26dc1be179deb72ba50e24862057c36)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ContainerClusterNodePoolNetworkConfigAdditionalNodeNetworkConfigsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNetworkConfigAdditionalNodeNetworkConfigsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__efa3264fec53199009465355f2ec0a6cb1b3ca6419c56643764113e9b8658faa)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="resetNetwork")
    def reset_network(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNetwork", []))

    @jsii.member(jsii_name="resetSubnetwork")
    def reset_subnetwork(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSubnetwork", []))

    @builtins.property
    @jsii.member(jsii_name="networkInput")
    def network_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "networkInput"))

    @builtins.property
    @jsii.member(jsii_name="subnetworkInput")
    def subnetwork_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "subnetworkInput"))

    @builtins.property
    @jsii.member(jsii_name="network")
    def network(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "network"))

    @network.setter
    def network(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__766d4bc36a240c5cba869e89cd8097355ca16d5fe967f62673b0d83d47f9ba3b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "network", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="subnetwork")
    def subnetwork(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "subnetwork"))

    @subnetwork.setter
    def subnetwork(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cebe04aea55fceb737af294c85ac903755bd39c4036d4c1a4274cca7b105804b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "subnetwork", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterNodePoolNetworkConfigAdditionalNodeNetworkConfigs]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterNodePoolNetworkConfigAdditionalNodeNetworkConfigs]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterNodePoolNetworkConfigAdditionalNodeNetworkConfigs]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__df46d9088e6e7c95228873e22680b89be581f58099c9e09a9aab72225181fc6e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNetworkConfigAdditionalPodNetworkConfigs",
    jsii_struct_bases=[],
    name_mapping={
        "max_pods_per_node": "maxPodsPerNode",
        "secondary_pod_range": "secondaryPodRange",
        "subnetwork": "subnetwork",
    },
)
class ContainerClusterNodePoolNetworkConfigAdditionalPodNetworkConfigs:
    def __init__(
        self,
        *,
        max_pods_per_node: typing.Optional[jsii.Number] = None,
        secondary_pod_range: typing.Optional[builtins.str] = None,
        subnetwork: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param max_pods_per_node: The maximum number of pods per node which use this pod network. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#max_pods_per_node ContainerCluster#max_pods_per_node}
        :param secondary_pod_range: The name of the secondary range on the subnet which provides IP address for this pod range. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#secondary_pod_range ContainerCluster#secondary_pod_range}
        :param subnetwork: Name of the subnetwork where the additional pod network belongs. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#subnetwork ContainerCluster#subnetwork}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__55823b066e4f9d6f1e886bf1f2d7d892c73080ee27078ddd0d8a4023d014ff23)
            check_type(argname="argument max_pods_per_node", value=max_pods_per_node, expected_type=type_hints["max_pods_per_node"])
            check_type(argname="argument secondary_pod_range", value=secondary_pod_range, expected_type=type_hints["secondary_pod_range"])
            check_type(argname="argument subnetwork", value=subnetwork, expected_type=type_hints["subnetwork"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if max_pods_per_node is not None:
            self._values["max_pods_per_node"] = max_pods_per_node
        if secondary_pod_range is not None:
            self._values["secondary_pod_range"] = secondary_pod_range
        if subnetwork is not None:
            self._values["subnetwork"] = subnetwork

    @builtins.property
    def max_pods_per_node(self) -> typing.Optional[jsii.Number]:
        '''The maximum number of pods per node which use this pod network.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#max_pods_per_node ContainerCluster#max_pods_per_node}
        '''
        result = self._values.get("max_pods_per_node")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def secondary_pod_range(self) -> typing.Optional[builtins.str]:
        '''The name of the secondary range on the subnet which provides IP address for this pod range.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#secondary_pod_range ContainerCluster#secondary_pod_range}
        '''
        result = self._values.get("secondary_pod_range")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def subnetwork(self) -> typing.Optional[builtins.str]:
        '''Name of the subnetwork where the additional pod network belongs.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#subnetwork ContainerCluster#subnetwork}
        '''
        result = self._values.get("subnetwork")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodePoolNetworkConfigAdditionalPodNetworkConfigs(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodePoolNetworkConfigAdditionalPodNetworkConfigsList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNetworkConfigAdditionalPodNetworkConfigsList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c47cbe6696c2ee27df9d030f9cc1e58862b2adfb73044ada5a0bea8900d109fc)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ContainerClusterNodePoolNetworkConfigAdditionalPodNetworkConfigsOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__61bdfd58fd44e36bff55c12bac760216845375f9460f751f70e51b8deba30351)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ContainerClusterNodePoolNetworkConfigAdditionalPodNetworkConfigsOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__671308bb0b775442c2313e42b5028623be0a4148c6d093cf534e66c9e67abde9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e29ebd100f03e38170b24be3652c851fedc485e20589e71043b772f175d8282f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b45ea2a224c63aa1ff23b3b5a2c0de1fd3fed60795cad88e5e62181eda6578d1)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodePoolNetworkConfigAdditionalPodNetworkConfigs]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodePoolNetworkConfigAdditionalPodNetworkConfigs]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodePoolNetworkConfigAdditionalPodNetworkConfigs]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__37e74b9ec4444f7128d63e9cfb04f86240a9d92e788051488c3e1429872a1a5e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ContainerClusterNodePoolNetworkConfigAdditionalPodNetworkConfigsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNetworkConfigAdditionalPodNetworkConfigsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__050b4aba9f20b3f0167889296896015a6a32c670e93aa64338d3e28c492f71a5)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="resetMaxPodsPerNode")
    def reset_max_pods_per_node(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMaxPodsPerNode", []))

    @jsii.member(jsii_name="resetSecondaryPodRange")
    def reset_secondary_pod_range(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSecondaryPodRange", []))

    @jsii.member(jsii_name="resetSubnetwork")
    def reset_subnetwork(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSubnetwork", []))

    @builtins.property
    @jsii.member(jsii_name="maxPodsPerNodeInput")
    def max_pods_per_node_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "maxPodsPerNodeInput"))

    @builtins.property
    @jsii.member(jsii_name="secondaryPodRangeInput")
    def secondary_pod_range_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "secondaryPodRangeInput"))

    @builtins.property
    @jsii.member(jsii_name="subnetworkInput")
    def subnetwork_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "subnetworkInput"))

    @builtins.property
    @jsii.member(jsii_name="maxPodsPerNode")
    def max_pods_per_node(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "maxPodsPerNode"))

    @max_pods_per_node.setter
    def max_pods_per_node(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f8796b81c3ddf74c6c4baca8c9de7f16dc26677ace3176e4835baafc49fa1f85)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "maxPodsPerNode", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="secondaryPodRange")
    def secondary_pod_range(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "secondaryPodRange"))

    @secondary_pod_range.setter
    def secondary_pod_range(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__25e199eac1c8abaf6f014e84a1a924e42ee8a47c9186e96eb6cd0a6557cb2c76)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "secondaryPodRange", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="subnetwork")
    def subnetwork(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "subnetwork"))

    @subnetwork.setter
    def subnetwork(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e7bca4857339bb3495f7ee06a6d3e72b9277967268e14d1296c0b8fa939aff82)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "subnetwork", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterNodePoolNetworkConfigAdditionalPodNetworkConfigs]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterNodePoolNetworkConfigAdditionalPodNetworkConfigs]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterNodePoolNetworkConfigAdditionalPodNetworkConfigs]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0a48467024086c37237c8a74d16ed5e1dbc2da3b6ca87a05ee7d65b0d0363e21)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNetworkConfigNetworkPerformanceConfig",
    jsii_struct_bases=[],
    name_mapping={"total_egress_bandwidth_tier": "totalEgressBandwidthTier"},
)
class ContainerClusterNodePoolNetworkConfigNetworkPerformanceConfig:
    def __init__(self, *, total_egress_bandwidth_tier: builtins.str) -> None:
        '''
        :param total_egress_bandwidth_tier: Specifies the total network bandwidth tier for the NodePool. `Valid values <https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1/projects.locations.clusters.nodePools#NodePool.Tier>`_ include: "TIER_1" and "TIER_UNSPECIFIED". Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#total_egress_bandwidth_tier ContainerCluster#total_egress_bandwidth_tier}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d67792a8422e7c121612f13f549b1dba48fdff2629d185cc274cb59c9153c1aa)
            check_type(argname="argument total_egress_bandwidth_tier", value=total_egress_bandwidth_tier, expected_type=type_hints["total_egress_bandwidth_tier"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "total_egress_bandwidth_tier": total_egress_bandwidth_tier,
        }

    @builtins.property
    def total_egress_bandwidth_tier(self) -> builtins.str:
        '''Specifies the total network bandwidth tier for the NodePool. `Valid values <https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1/projects.locations.clusters.nodePools#NodePool.Tier>`_ include: "TIER_1" and "TIER_UNSPECIFIED".

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#total_egress_bandwidth_tier ContainerCluster#total_egress_bandwidth_tier}
        '''
        result = self._values.get("total_egress_bandwidth_tier")
        assert result is not None, "Required property 'total_egress_bandwidth_tier' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodePoolNetworkConfigNetworkPerformanceConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodePoolNetworkConfigNetworkPerformanceConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNetworkConfigNetworkPerformanceConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2acc7a3dd513d7ac5b2105926a33b948ed8237f74ea928c5aa15d228c1512efa)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="totalEgressBandwidthTierInput")
    def total_egress_bandwidth_tier_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "totalEgressBandwidthTierInput"))

    @builtins.property
    @jsii.member(jsii_name="totalEgressBandwidthTier")
    def total_egress_bandwidth_tier(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "totalEgressBandwidthTier"))

    @total_egress_bandwidth_tier.setter
    def total_egress_bandwidth_tier(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e85916b6a06f2ec2b84fdb14c67869586b7a10696a1f5d92046f3c1e6fd9f08b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "totalEgressBandwidthTier", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolNetworkConfigNetworkPerformanceConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolNetworkConfigNetworkPerformanceConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodePoolNetworkConfigNetworkPerformanceConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fb37105d674f8bc16813822039ef13f37f412414d043bc69e766d64b2853c819)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ContainerClusterNodePoolNetworkConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNetworkConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3be27225729ff71d2b22e3150820d8078edf8fde7754a743b95494b222d909ba)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putAdditionalNodeNetworkConfigs")
    def put_additional_node_network_configs(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ContainerClusterNodePoolNetworkConfigAdditionalNodeNetworkConfigs, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__29638403988821d5253807d7d4de8451f0a2b22fe871f811a3e85693e12fddee)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putAdditionalNodeNetworkConfigs", [value]))

    @jsii.member(jsii_name="putAdditionalPodNetworkConfigs")
    def put_additional_pod_network_configs(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ContainerClusterNodePoolNetworkConfigAdditionalPodNetworkConfigs, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__24572967e8b8f65e3f03fd4d26e7bb9255d25d0d6cff504bb9a271fbfa59f96d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putAdditionalPodNetworkConfigs", [value]))

    @jsii.member(jsii_name="putNetworkPerformanceConfig")
    def put_network_performance_config(
        self,
        *,
        total_egress_bandwidth_tier: builtins.str,
    ) -> None:
        '''
        :param total_egress_bandwidth_tier: Specifies the total network bandwidth tier for the NodePool. `Valid values <https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1/projects.locations.clusters.nodePools#NodePool.Tier>`_ include: "TIER_1" and "TIER_UNSPECIFIED". Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#total_egress_bandwidth_tier ContainerCluster#total_egress_bandwidth_tier}
        '''
        value = ContainerClusterNodePoolNetworkConfigNetworkPerformanceConfig(
            total_egress_bandwidth_tier=total_egress_bandwidth_tier
        )

        return typing.cast(None, jsii.invoke(self, "putNetworkPerformanceConfig", [value]))

    @jsii.member(jsii_name="putPodCidrOverprovisionConfig")
    def put_pod_cidr_overprovision_config(
        self,
        *,
        disabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param disabled: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#disabled ContainerCluster#disabled}.
        '''
        value = ContainerClusterNodePoolNetworkConfigPodCidrOverprovisionConfig(
            disabled=disabled
        )

        return typing.cast(None, jsii.invoke(self, "putPodCidrOverprovisionConfig", [value]))

    @jsii.member(jsii_name="resetAdditionalNodeNetworkConfigs")
    def reset_additional_node_network_configs(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAdditionalNodeNetworkConfigs", []))

    @jsii.member(jsii_name="resetAdditionalPodNetworkConfigs")
    def reset_additional_pod_network_configs(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAdditionalPodNetworkConfigs", []))

    @jsii.member(jsii_name="resetCreatePodRange")
    def reset_create_pod_range(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCreatePodRange", []))

    @jsii.member(jsii_name="resetEnablePrivateNodes")
    def reset_enable_private_nodes(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnablePrivateNodes", []))

    @jsii.member(jsii_name="resetNetworkPerformanceConfig")
    def reset_network_performance_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNetworkPerformanceConfig", []))

    @jsii.member(jsii_name="resetPodCidrOverprovisionConfig")
    def reset_pod_cidr_overprovision_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPodCidrOverprovisionConfig", []))

    @jsii.member(jsii_name="resetPodIpv4CidrBlock")
    def reset_pod_ipv4_cidr_block(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPodIpv4CidrBlock", []))

    @jsii.member(jsii_name="resetPodRange")
    def reset_pod_range(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPodRange", []))

    @builtins.property
    @jsii.member(jsii_name="additionalNodeNetworkConfigs")
    def additional_node_network_configs(
        self,
    ) -> ContainerClusterNodePoolNetworkConfigAdditionalNodeNetworkConfigsList:
        return typing.cast(ContainerClusterNodePoolNetworkConfigAdditionalNodeNetworkConfigsList, jsii.get(self, "additionalNodeNetworkConfigs"))

    @builtins.property
    @jsii.member(jsii_name="additionalPodNetworkConfigs")
    def additional_pod_network_configs(
        self,
    ) -> ContainerClusterNodePoolNetworkConfigAdditionalPodNetworkConfigsList:
        return typing.cast(ContainerClusterNodePoolNetworkConfigAdditionalPodNetworkConfigsList, jsii.get(self, "additionalPodNetworkConfigs"))

    @builtins.property
    @jsii.member(jsii_name="networkPerformanceConfig")
    def network_performance_config(
        self,
    ) -> ContainerClusterNodePoolNetworkConfigNetworkPerformanceConfigOutputReference:
        return typing.cast(ContainerClusterNodePoolNetworkConfigNetworkPerformanceConfigOutputReference, jsii.get(self, "networkPerformanceConfig"))

    @builtins.property
    @jsii.member(jsii_name="podCidrOverprovisionConfig")
    def pod_cidr_overprovision_config(
        self,
    ) -> "ContainerClusterNodePoolNetworkConfigPodCidrOverprovisionConfigOutputReference":
        return typing.cast("ContainerClusterNodePoolNetworkConfigPodCidrOverprovisionConfigOutputReference", jsii.get(self, "podCidrOverprovisionConfig"))

    @builtins.property
    @jsii.member(jsii_name="subnetwork")
    def subnetwork(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "subnetwork"))

    @builtins.property
    @jsii.member(jsii_name="additionalNodeNetworkConfigsInput")
    def additional_node_network_configs_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodePoolNetworkConfigAdditionalNodeNetworkConfigs]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodePoolNetworkConfigAdditionalNodeNetworkConfigs]]], jsii.get(self, "additionalNodeNetworkConfigsInput"))

    @builtins.property
    @jsii.member(jsii_name="additionalPodNetworkConfigsInput")
    def additional_pod_network_configs_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodePoolNetworkConfigAdditionalPodNetworkConfigs]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodePoolNetworkConfigAdditionalPodNetworkConfigs]]], jsii.get(self, "additionalPodNetworkConfigsInput"))

    @builtins.property
    @jsii.member(jsii_name="createPodRangeInput")
    def create_pod_range_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "createPodRangeInput"))

    @builtins.property
    @jsii.member(jsii_name="enablePrivateNodesInput")
    def enable_private_nodes_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enablePrivateNodesInput"))

    @builtins.property
    @jsii.member(jsii_name="networkPerformanceConfigInput")
    def network_performance_config_input(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolNetworkConfigNetworkPerformanceConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolNetworkConfigNetworkPerformanceConfig], jsii.get(self, "networkPerformanceConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="podCidrOverprovisionConfigInput")
    def pod_cidr_overprovision_config_input(
        self,
    ) -> typing.Optional["ContainerClusterNodePoolNetworkConfigPodCidrOverprovisionConfig"]:
        return typing.cast(typing.Optional["ContainerClusterNodePoolNetworkConfigPodCidrOverprovisionConfig"], jsii.get(self, "podCidrOverprovisionConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="podIpv4CidrBlockInput")
    def pod_ipv4_cidr_block_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "podIpv4CidrBlockInput"))

    @builtins.property
    @jsii.member(jsii_name="podRangeInput")
    def pod_range_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "podRangeInput"))

    @builtins.property
    @jsii.member(jsii_name="createPodRange")
    def create_pod_range(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "createPodRange"))

    @create_pod_range.setter
    def create_pod_range(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__604a9fd6e5e5aa9a95bc9beb632040863e2d75912179dab397a64f7c1ec47529)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "createPodRange", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="enablePrivateNodes")
    def enable_private_nodes(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enablePrivateNodes"))

    @enable_private_nodes.setter
    def enable_private_nodes(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d5996dbc6a93da1649d271dae51d3ef211f417e41f9e82683e8f94f2d704325f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enablePrivateNodes", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="podIpv4CidrBlock")
    def pod_ipv4_cidr_block(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "podIpv4CidrBlock"))

    @pod_ipv4_cidr_block.setter
    def pod_ipv4_cidr_block(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d164ecbbdaad8af840ac9ebfa2ab2bd28451e369defeeca06d4b927b451a9a43)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "podIpv4CidrBlock", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="podRange")
    def pod_range(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "podRange"))

    @pod_range.setter
    def pod_range(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6f3bfa558e423935b09222f1688f3d503d5f4c3d4ee9cbcd88e5b89dca4ac1bc)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "podRange", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[ContainerClusterNodePoolNetworkConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolNetworkConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodePoolNetworkConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4cef7c6b5ee8154c273cba49c7284d8c7f5570685d3027f6546e97fa92eb5e86)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNetworkConfigPodCidrOverprovisionConfig",
    jsii_struct_bases=[],
    name_mapping={"disabled": "disabled"},
)
class ContainerClusterNodePoolNetworkConfigPodCidrOverprovisionConfig:
    def __init__(
        self,
        *,
        disabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param disabled: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#disabled ContainerCluster#disabled}.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b087f24f9fb413cf2edfa067ba48203729af1ce439467b881d19bdcc3ae73a80)
            check_type(argname="argument disabled", value=disabled, expected_type=type_hints["disabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "disabled": disabled,
        }

    @builtins.property
    def disabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#disabled ContainerCluster#disabled}.'''
        result = self._values.get("disabled")
        assert result is not None, "Required property 'disabled' is missing"
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodePoolNetworkConfigPodCidrOverprovisionConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodePoolNetworkConfigPodCidrOverprovisionConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNetworkConfigPodCidrOverprovisionConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__88b1a4da55ade8a871aae9b3dc08225b88c959facc17107cbdcef33ed6f3e413)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="disabledInput")
    def disabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "disabledInput"))

    @builtins.property
    @jsii.member(jsii_name="disabled")
    def disabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "disabled"))

    @disabled.setter
    def disabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fb5955b00d872cbf3a93409fb1163f39f66ba0eb465cbc73b1cf619b276b0658)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "disabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolNetworkConfigPodCidrOverprovisionConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolNetworkConfigPodCidrOverprovisionConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodePoolNetworkConfigPodCidrOverprovisionConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cdda960c79a276b91951c543d9364d4f356a31f01de629ba0eeabd7b2c405ce8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfig",
    jsii_struct_bases=[],
    name_mapping={
        "advanced_machine_features": "advancedMachineFeatures",
        "boot_disk": "bootDisk",
        "boot_disk_kms_key": "bootDiskKmsKey",
        "confidential_nodes": "confidentialNodes",
        "containerd_config": "containerdConfig",
        "disk_size_gb": "diskSizeGb",
        "disk_type": "diskType",
        "enable_confidential_storage": "enableConfidentialStorage",
        "ephemeral_storage_local_ssd_config": "ephemeralStorageLocalSsdConfig",
        "fast_socket": "fastSocket",
        "flex_start": "flexStart",
        "gcfs_config": "gcfsConfig",
        "guest_accelerator": "guestAccelerator",
        "gvnic": "gvnic",
        "host_maintenance_policy": "hostMaintenancePolicy",
        "image_type": "imageType",
        "kubelet_config": "kubeletConfig",
        "labels": "labels",
        "linux_node_config": "linuxNodeConfig",
        "local_nvme_ssd_block_config": "localNvmeSsdBlockConfig",
        "local_ssd_count": "localSsdCount",
        "local_ssd_encryption_mode": "localSsdEncryptionMode",
        "logging_variant": "loggingVariant",
        "machine_type": "machineType",
        "max_run_duration": "maxRunDuration",
        "metadata": "metadata",
        "min_cpu_platform": "minCpuPlatform",
        "node_group": "nodeGroup",
        "oauth_scopes": "oauthScopes",
        "preemptible": "preemptible",
        "reservation_affinity": "reservationAffinity",
        "resource_labels": "resourceLabels",
        "resource_manager_tags": "resourceManagerTags",
        "secondary_boot_disks": "secondaryBootDisks",
        "service_account": "serviceAccount",
        "shielded_instance_config": "shieldedInstanceConfig",
        "sole_tenant_config": "soleTenantConfig",
        "spot": "spot",
        "storage_pools": "storagePools",
        "tags": "tags",
        "taint": "taint",
        "windows_node_config": "windowsNodeConfig",
        "workload_metadata_config": "workloadMetadataConfig",
    },
)
class ContainerClusterNodePoolNodeConfig:
    def __init__(
        self,
        *,
        advanced_machine_features: typing.Optional[typing.Union["ContainerClusterNodePoolNodeConfigAdvancedMachineFeatures", typing.Dict[builtins.str, typing.Any]]] = None,
        boot_disk: typing.Optional[typing.Union["ContainerClusterNodePoolNodeConfigBootDisk", typing.Dict[builtins.str, typing.Any]]] = None,
        boot_disk_kms_key: typing.Optional[builtins.str] = None,
        confidential_nodes: typing.Optional[typing.Union["ContainerClusterNodePoolNodeConfigConfidentialNodes", typing.Dict[builtins.str, typing.Any]]] = None,
        containerd_config: typing.Optional[typing.Union["ContainerClusterNodePoolNodeConfigContainerdConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        disk_size_gb: typing.Optional[jsii.Number] = None,
        disk_type: typing.Optional[builtins.str] = None,
        enable_confidential_storage: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        ephemeral_storage_local_ssd_config: typing.Optional[typing.Union["ContainerClusterNodePoolNodeConfigEphemeralStorageLocalSsdConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        fast_socket: typing.Optional[typing.Union["ContainerClusterNodePoolNodeConfigFastSocket", typing.Dict[builtins.str, typing.Any]]] = None,
        flex_start: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        gcfs_config: typing.Optional[typing.Union["ContainerClusterNodePoolNodeConfigGcfsConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        guest_accelerator: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ContainerClusterNodePoolNodeConfigGuestAccelerator", typing.Dict[builtins.str, typing.Any]]]]] = None,
        gvnic: typing.Optional[typing.Union["ContainerClusterNodePoolNodeConfigGvnic", typing.Dict[builtins.str, typing.Any]]] = None,
        host_maintenance_policy: typing.Optional[typing.Union["ContainerClusterNodePoolNodeConfigHostMaintenancePolicy", typing.Dict[builtins.str, typing.Any]]] = None,
        image_type: typing.Optional[builtins.str] = None,
        kubelet_config: typing.Optional[typing.Union["ContainerClusterNodePoolNodeConfigKubeletConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        linux_node_config: typing.Optional[typing.Union["ContainerClusterNodePoolNodeConfigLinuxNodeConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        local_nvme_ssd_block_config: typing.Optional[typing.Union["ContainerClusterNodePoolNodeConfigLocalNvmeSsdBlockConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        local_ssd_count: typing.Optional[jsii.Number] = None,
        local_ssd_encryption_mode: typing.Optional[builtins.str] = None,
        logging_variant: typing.Optional[builtins.str] = None,
        machine_type: typing.Optional[builtins.str] = None,
        max_run_duration: typing.Optional[builtins.str] = None,
        metadata: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        min_cpu_platform: typing.Optional[builtins.str] = None,
        node_group: typing.Optional[builtins.str] = None,
        oauth_scopes: typing.Optional[typing.Sequence[builtins.str]] = None,
        preemptible: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        reservation_affinity: typing.Optional[typing.Union["ContainerClusterNodePoolNodeConfigReservationAffinity", typing.Dict[builtins.str, typing.Any]]] = None,
        resource_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        resource_manager_tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        secondary_boot_disks: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ContainerClusterNodePoolNodeConfigSecondaryBootDisks", typing.Dict[builtins.str, typing.Any]]]]] = None,
        service_account: typing.Optional[builtins.str] = None,
        shielded_instance_config: typing.Optional[typing.Union["ContainerClusterNodePoolNodeConfigShieldedInstanceConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        sole_tenant_config: typing.Optional[typing.Union["ContainerClusterNodePoolNodeConfigSoleTenantConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        spot: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        storage_pools: typing.Optional[typing.Sequence[builtins.str]] = None,
        tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        taint: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ContainerClusterNodePoolNodeConfigTaint", typing.Dict[builtins.str, typing.Any]]]]] = None,
        windows_node_config: typing.Optional[typing.Union["ContainerClusterNodePoolNodeConfigWindowsNodeConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        workload_metadata_config: typing.Optional[typing.Union["ContainerClusterNodePoolNodeConfigWorkloadMetadataConfig", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param advanced_machine_features: advanced_machine_features block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#advanced_machine_features ContainerCluster#advanced_machine_features}
        :param boot_disk: boot_disk block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#boot_disk ContainerCluster#boot_disk}
        :param boot_disk_kms_key: The Customer Managed Encryption Key used to encrypt the boot disk attached to each node in the node pool. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#boot_disk_kms_key ContainerCluster#boot_disk_kms_key}
        :param confidential_nodes: confidential_nodes block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#confidential_nodes ContainerCluster#confidential_nodes}
        :param containerd_config: containerd_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#containerd_config ContainerCluster#containerd_config}
        :param disk_size_gb: Size of the disk attached to each node, specified in GB. The smallest allowed disk size is 10GB. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#disk_size_gb ContainerCluster#disk_size_gb}
        :param disk_type: Type of the disk attached to each node. Such as pd-standard, pd-balanced or pd-ssd. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#disk_type ContainerCluster#disk_type}
        :param enable_confidential_storage: If enabled boot disks are configured with confidential mode. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_confidential_storage ContainerCluster#enable_confidential_storage}
        :param ephemeral_storage_local_ssd_config: ephemeral_storage_local_ssd_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#ephemeral_storage_local_ssd_config ContainerCluster#ephemeral_storage_local_ssd_config}
        :param fast_socket: fast_socket block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#fast_socket ContainerCluster#fast_socket}
        :param flex_start: Enables Flex Start provisioning model for the node pool. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#flex_start ContainerCluster#flex_start}
        :param gcfs_config: gcfs_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gcfs_config ContainerCluster#gcfs_config}
        :param guest_accelerator: guest_accelerator block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#guest_accelerator ContainerCluster#guest_accelerator}
        :param gvnic: gvnic block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gvnic ContainerCluster#gvnic}
        :param host_maintenance_policy: host_maintenance_policy block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#host_maintenance_policy ContainerCluster#host_maintenance_policy}
        :param image_type: The image type to use for this node. Note that for a given image type, the latest version of it will be used. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#image_type ContainerCluster#image_type}
        :param kubelet_config: kubelet_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#kubelet_config ContainerCluster#kubelet_config}
        :param labels: The map of Kubernetes labels (key/value pairs) to be applied to each node. These will added in addition to any default label(s) that Kubernetes may apply to the node. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#labels ContainerCluster#labels}
        :param linux_node_config: linux_node_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#linux_node_config ContainerCluster#linux_node_config}
        :param local_nvme_ssd_block_config: local_nvme_ssd_block_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#local_nvme_ssd_block_config ContainerCluster#local_nvme_ssd_block_config}
        :param local_ssd_count: The number of local SSD disks to be attached to the node. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#local_ssd_count ContainerCluster#local_ssd_count}
        :param local_ssd_encryption_mode: LocalSsdEncryptionMode specified the method used for encrypting the local SSDs attached to the node. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#local_ssd_encryption_mode ContainerCluster#local_ssd_encryption_mode}
        :param logging_variant: Type of logging agent that is used as the default value for node pools in the cluster. Valid values include DEFAULT and MAX_THROUGHPUT. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#logging_variant ContainerCluster#logging_variant}
        :param machine_type: The name of a Google Compute Engine machine type. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#machine_type ContainerCluster#machine_type}
        :param max_run_duration: The runtime of each node in the node pool in seconds, terminated by 's'. Example: "3600s". Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#max_run_duration ContainerCluster#max_run_duration}
        :param metadata: The metadata key/value pairs assigned to instances in the cluster. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#metadata ContainerCluster#metadata}
        :param min_cpu_platform: Minimum CPU platform to be used by this instance. The instance may be scheduled on the specified or newer CPU platform. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#min_cpu_platform ContainerCluster#min_cpu_platform}
        :param node_group: Setting this field will assign instances of this pool to run on the specified node group. This is useful for running workloads on sole tenant nodes. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#node_group ContainerCluster#node_group}
        :param oauth_scopes: The set of Google API scopes to be made available on all of the node VMs. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#oauth_scopes ContainerCluster#oauth_scopes}
        :param preemptible: Whether the nodes are created as preemptible VM instances. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#preemptible ContainerCluster#preemptible}
        :param reservation_affinity: reservation_affinity block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#reservation_affinity ContainerCluster#reservation_affinity}
        :param resource_labels: The GCE resource labels (a map of key/value pairs) to be applied to the node pool. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#resource_labels ContainerCluster#resource_labels}
        :param resource_manager_tags: A map of resource manager tags. Resource manager tag keys and values have the same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id}, and values are in the format tagValues/456. The field is ignored (both PUT & PATCH) when empty. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#resource_manager_tags ContainerCluster#resource_manager_tags}
        :param secondary_boot_disks: secondary_boot_disks block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#secondary_boot_disks ContainerCluster#secondary_boot_disks}
        :param service_account: The Google Cloud Platform Service Account to be used by the node VMs. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#service_account ContainerCluster#service_account}
        :param shielded_instance_config: shielded_instance_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#shielded_instance_config ContainerCluster#shielded_instance_config}
        :param sole_tenant_config: sole_tenant_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#sole_tenant_config ContainerCluster#sole_tenant_config}
        :param spot: Whether the nodes are created as spot VM instances. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#spot ContainerCluster#spot}
        :param storage_pools: The list of Storage Pools where boot disks are provisioned. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#storage_pools ContainerCluster#storage_pools}
        :param tags: The list of instance tags applied to all nodes. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#tags ContainerCluster#tags}
        :param taint: taint block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#taint ContainerCluster#taint}
        :param windows_node_config: windows_node_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#windows_node_config ContainerCluster#windows_node_config}
        :param workload_metadata_config: workload_metadata_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#workload_metadata_config ContainerCluster#workload_metadata_config}
        '''
        if isinstance(advanced_machine_features, dict):
            advanced_machine_features = ContainerClusterNodePoolNodeConfigAdvancedMachineFeatures(**advanced_machine_features)
        if isinstance(boot_disk, dict):
            boot_disk = ContainerClusterNodePoolNodeConfigBootDisk(**boot_disk)
        if isinstance(confidential_nodes, dict):
            confidential_nodes = ContainerClusterNodePoolNodeConfigConfidentialNodes(**confidential_nodes)
        if isinstance(containerd_config, dict):
            containerd_config = ContainerClusterNodePoolNodeConfigContainerdConfig(**containerd_config)
        if isinstance(ephemeral_storage_local_ssd_config, dict):
            ephemeral_storage_local_ssd_config = ContainerClusterNodePoolNodeConfigEphemeralStorageLocalSsdConfig(**ephemeral_storage_local_ssd_config)
        if isinstance(fast_socket, dict):
            fast_socket = ContainerClusterNodePoolNodeConfigFastSocket(**fast_socket)
        if isinstance(gcfs_config, dict):
            gcfs_config = ContainerClusterNodePoolNodeConfigGcfsConfig(**gcfs_config)
        if isinstance(gvnic, dict):
            gvnic = ContainerClusterNodePoolNodeConfigGvnic(**gvnic)
        if isinstance(host_maintenance_policy, dict):
            host_maintenance_policy = ContainerClusterNodePoolNodeConfigHostMaintenancePolicy(**host_maintenance_policy)
        if isinstance(kubelet_config, dict):
            kubelet_config = ContainerClusterNodePoolNodeConfigKubeletConfig(**kubelet_config)
        if isinstance(linux_node_config, dict):
            linux_node_config = ContainerClusterNodePoolNodeConfigLinuxNodeConfig(**linux_node_config)
        if isinstance(local_nvme_ssd_block_config, dict):
            local_nvme_ssd_block_config = ContainerClusterNodePoolNodeConfigLocalNvmeSsdBlockConfig(**local_nvme_ssd_block_config)
        if isinstance(reservation_affinity, dict):
            reservation_affinity = ContainerClusterNodePoolNodeConfigReservationAffinity(**reservation_affinity)
        if isinstance(shielded_instance_config, dict):
            shielded_instance_config = ContainerClusterNodePoolNodeConfigShieldedInstanceConfig(**shielded_instance_config)
        if isinstance(sole_tenant_config, dict):
            sole_tenant_config = ContainerClusterNodePoolNodeConfigSoleTenantConfig(**sole_tenant_config)
        if isinstance(windows_node_config, dict):
            windows_node_config = ContainerClusterNodePoolNodeConfigWindowsNodeConfig(**windows_node_config)
        if isinstance(workload_metadata_config, dict):
            workload_metadata_config = ContainerClusterNodePoolNodeConfigWorkloadMetadataConfig(**workload_metadata_config)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__be965926d2825b4376a88b0ab45cf8481d4377ad56abd4470e7938b3498b809a)
            check_type(argname="argument advanced_machine_features", value=advanced_machine_features, expected_type=type_hints["advanced_machine_features"])
            check_type(argname="argument boot_disk", value=boot_disk, expected_type=type_hints["boot_disk"])
            check_type(argname="argument boot_disk_kms_key", value=boot_disk_kms_key, expected_type=type_hints["boot_disk_kms_key"])
            check_type(argname="argument confidential_nodes", value=confidential_nodes, expected_type=type_hints["confidential_nodes"])
            check_type(argname="argument containerd_config", value=containerd_config, expected_type=type_hints["containerd_config"])
            check_type(argname="argument disk_size_gb", value=disk_size_gb, expected_type=type_hints["disk_size_gb"])
            check_type(argname="argument disk_type", value=disk_type, expected_type=type_hints["disk_type"])
            check_type(argname="argument enable_confidential_storage", value=enable_confidential_storage, expected_type=type_hints["enable_confidential_storage"])
            check_type(argname="argument ephemeral_storage_local_ssd_config", value=ephemeral_storage_local_ssd_config, expected_type=type_hints["ephemeral_storage_local_ssd_config"])
            check_type(argname="argument fast_socket", value=fast_socket, expected_type=type_hints["fast_socket"])
            check_type(argname="argument flex_start", value=flex_start, expected_type=type_hints["flex_start"])
            check_type(argname="argument gcfs_config", value=gcfs_config, expected_type=type_hints["gcfs_config"])
            check_type(argname="argument guest_accelerator", value=guest_accelerator, expected_type=type_hints["guest_accelerator"])
            check_type(argname="argument gvnic", value=gvnic, expected_type=type_hints["gvnic"])
            check_type(argname="argument host_maintenance_policy", value=host_maintenance_policy, expected_type=type_hints["host_maintenance_policy"])
            check_type(argname="argument image_type", value=image_type, expected_type=type_hints["image_type"])
            check_type(argname="argument kubelet_config", value=kubelet_config, expected_type=type_hints["kubelet_config"])
            check_type(argname="argument labels", value=labels, expected_type=type_hints["labels"])
            check_type(argname="argument linux_node_config", value=linux_node_config, expected_type=type_hints["linux_node_config"])
            check_type(argname="argument local_nvme_ssd_block_config", value=local_nvme_ssd_block_config, expected_type=type_hints["local_nvme_ssd_block_config"])
            check_type(argname="argument local_ssd_count", value=local_ssd_count, expected_type=type_hints["local_ssd_count"])
            check_type(argname="argument local_ssd_encryption_mode", value=local_ssd_encryption_mode, expected_type=type_hints["local_ssd_encryption_mode"])
            check_type(argname="argument logging_variant", value=logging_variant, expected_type=type_hints["logging_variant"])
            check_type(argname="argument machine_type", value=machine_type, expected_type=type_hints["machine_type"])
            check_type(argname="argument max_run_duration", value=max_run_duration, expected_type=type_hints["max_run_duration"])
            check_type(argname="argument metadata", value=metadata, expected_type=type_hints["metadata"])
            check_type(argname="argument min_cpu_platform", value=min_cpu_platform, expected_type=type_hints["min_cpu_platform"])
            check_type(argname="argument node_group", value=node_group, expected_type=type_hints["node_group"])
            check_type(argname="argument oauth_scopes", value=oauth_scopes, expected_type=type_hints["oauth_scopes"])
            check_type(argname="argument preemptible", value=preemptible, expected_type=type_hints["preemptible"])
            check_type(argname="argument reservation_affinity", value=reservation_affinity, expected_type=type_hints["reservation_affinity"])
            check_type(argname="argument resource_labels", value=resource_labels, expected_type=type_hints["resource_labels"])
            check_type(argname="argument resource_manager_tags", value=resource_manager_tags, expected_type=type_hints["resource_manager_tags"])
            check_type(argname="argument secondary_boot_disks", value=secondary_boot_disks, expected_type=type_hints["secondary_boot_disks"])
            check_type(argname="argument service_account", value=service_account, expected_type=type_hints["service_account"])
            check_type(argname="argument shielded_instance_config", value=shielded_instance_config, expected_type=type_hints["shielded_instance_config"])
            check_type(argname="argument sole_tenant_config", value=sole_tenant_config, expected_type=type_hints["sole_tenant_config"])
            check_type(argname="argument spot", value=spot, expected_type=type_hints["spot"])
            check_type(argname="argument storage_pools", value=storage_pools, expected_type=type_hints["storage_pools"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument taint", value=taint, expected_type=type_hints["taint"])
            check_type(argname="argument windows_node_config", value=windows_node_config, expected_type=type_hints["windows_node_config"])
            check_type(argname="argument workload_metadata_config", value=workload_metadata_config, expected_type=type_hints["workload_metadata_config"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if advanced_machine_features is not None:
            self._values["advanced_machine_features"] = advanced_machine_features
        if boot_disk is not None:
            self._values["boot_disk"] = boot_disk
        if boot_disk_kms_key is not None:
            self._values["boot_disk_kms_key"] = boot_disk_kms_key
        if confidential_nodes is not None:
            self._values["confidential_nodes"] = confidential_nodes
        if containerd_config is not None:
            self._values["containerd_config"] = containerd_config
        if disk_size_gb is not None:
            self._values["disk_size_gb"] = disk_size_gb
        if disk_type is not None:
            self._values["disk_type"] = disk_type
        if enable_confidential_storage is not None:
            self._values["enable_confidential_storage"] = enable_confidential_storage
        if ephemeral_storage_local_ssd_config is not None:
            self._values["ephemeral_storage_local_ssd_config"] = ephemeral_storage_local_ssd_config
        if fast_socket is not None:
            self._values["fast_socket"] = fast_socket
        if flex_start is not None:
            self._values["flex_start"] = flex_start
        if gcfs_config is not None:
            self._values["gcfs_config"] = gcfs_config
        if guest_accelerator is not None:
            self._values["guest_accelerator"] = guest_accelerator
        if gvnic is not None:
            self._values["gvnic"] = gvnic
        if host_maintenance_policy is not None:
            self._values["host_maintenance_policy"] = host_maintenance_policy
        if image_type is not None:
            self._values["image_type"] = image_type
        if kubelet_config is not None:
            self._values["kubelet_config"] = kubelet_config
        if labels is not None:
            self._values["labels"] = labels
        if linux_node_config is not None:
            self._values["linux_node_config"] = linux_node_config
        if local_nvme_ssd_block_config is not None:
            self._values["local_nvme_ssd_block_config"] = local_nvme_ssd_block_config
        if local_ssd_count is not None:
            self._values["local_ssd_count"] = local_ssd_count
        if local_ssd_encryption_mode is not None:
            self._values["local_ssd_encryption_mode"] = local_ssd_encryption_mode
        if logging_variant is not None:
            self._values["logging_variant"] = logging_variant
        if machine_type is not None:
            self._values["machine_type"] = machine_type
        if max_run_duration is not None:
            self._values["max_run_duration"] = max_run_duration
        if metadata is not None:
            self._values["metadata"] = metadata
        if min_cpu_platform is not None:
            self._values["min_cpu_platform"] = min_cpu_platform
        if node_group is not None:
            self._values["node_group"] = node_group
        if oauth_scopes is not None:
            self._values["oauth_scopes"] = oauth_scopes
        if preemptible is not None:
            self._values["preemptible"] = preemptible
        if reservation_affinity is not None:
            self._values["reservation_affinity"] = reservation_affinity
        if resource_labels is not None:
            self._values["resource_labels"] = resource_labels
        if resource_manager_tags is not None:
            self._values["resource_manager_tags"] = resource_manager_tags
        if secondary_boot_disks is not None:
            self._values["secondary_boot_disks"] = secondary_boot_disks
        if service_account is not None:
            self._values["service_account"] = service_account
        if shielded_instance_config is not None:
            self._values["shielded_instance_config"] = shielded_instance_config
        if sole_tenant_config is not None:
            self._values["sole_tenant_config"] = sole_tenant_config
        if spot is not None:
            self._values["spot"] = spot
        if storage_pools is not None:
            self._values["storage_pools"] = storage_pools
        if tags is not None:
            self._values["tags"] = tags
        if taint is not None:
            self._values["taint"] = taint
        if windows_node_config is not None:
            self._values["windows_node_config"] = windows_node_config
        if workload_metadata_config is not None:
            self._values["workload_metadata_config"] = workload_metadata_config

    @builtins.property
    def advanced_machine_features(
        self,
    ) -> typing.Optional["ContainerClusterNodePoolNodeConfigAdvancedMachineFeatures"]:
        '''advanced_machine_features block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#advanced_machine_features ContainerCluster#advanced_machine_features}
        '''
        result = self._values.get("advanced_machine_features")
        return typing.cast(typing.Optional["ContainerClusterNodePoolNodeConfigAdvancedMachineFeatures"], result)

    @builtins.property
    def boot_disk(
        self,
    ) -> typing.Optional["ContainerClusterNodePoolNodeConfigBootDisk"]:
        '''boot_disk block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#boot_disk ContainerCluster#boot_disk}
        '''
        result = self._values.get("boot_disk")
        return typing.cast(typing.Optional["ContainerClusterNodePoolNodeConfigBootDisk"], result)

    @builtins.property
    def boot_disk_kms_key(self) -> typing.Optional[builtins.str]:
        '''The Customer Managed Encryption Key used to encrypt the boot disk attached to each node in the node pool.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#boot_disk_kms_key ContainerCluster#boot_disk_kms_key}
        '''
        result = self._values.get("boot_disk_kms_key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def confidential_nodes(
        self,
    ) -> typing.Optional["ContainerClusterNodePoolNodeConfigConfidentialNodes"]:
        '''confidential_nodes block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#confidential_nodes ContainerCluster#confidential_nodes}
        '''
        result = self._values.get("confidential_nodes")
        return typing.cast(typing.Optional["ContainerClusterNodePoolNodeConfigConfidentialNodes"], result)

    @builtins.property
    def containerd_config(
        self,
    ) -> typing.Optional["ContainerClusterNodePoolNodeConfigContainerdConfig"]:
        '''containerd_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#containerd_config ContainerCluster#containerd_config}
        '''
        result = self._values.get("containerd_config")
        return typing.cast(typing.Optional["ContainerClusterNodePoolNodeConfigContainerdConfig"], result)

    @builtins.property
    def disk_size_gb(self) -> typing.Optional[jsii.Number]:
        '''Size of the disk attached to each node, specified in GB. The smallest allowed disk size is 10GB.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#disk_size_gb ContainerCluster#disk_size_gb}
        '''
        result = self._values.get("disk_size_gb")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def disk_type(self) -> typing.Optional[builtins.str]:
        '''Type of the disk attached to each node. Such as pd-standard, pd-balanced or pd-ssd.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#disk_type ContainerCluster#disk_type}
        '''
        result = self._values.get("disk_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_confidential_storage(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''If enabled boot disks are configured with confidential mode.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_confidential_storage ContainerCluster#enable_confidential_storage}
        '''
        result = self._values.get("enable_confidential_storage")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def ephemeral_storage_local_ssd_config(
        self,
    ) -> typing.Optional["ContainerClusterNodePoolNodeConfigEphemeralStorageLocalSsdConfig"]:
        '''ephemeral_storage_local_ssd_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#ephemeral_storage_local_ssd_config ContainerCluster#ephemeral_storage_local_ssd_config}
        '''
        result = self._values.get("ephemeral_storage_local_ssd_config")
        return typing.cast(typing.Optional["ContainerClusterNodePoolNodeConfigEphemeralStorageLocalSsdConfig"], result)

    @builtins.property
    def fast_socket(
        self,
    ) -> typing.Optional["ContainerClusterNodePoolNodeConfigFastSocket"]:
        '''fast_socket block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#fast_socket ContainerCluster#fast_socket}
        '''
        result = self._values.get("fast_socket")
        return typing.cast(typing.Optional["ContainerClusterNodePoolNodeConfigFastSocket"], result)

    @builtins.property
    def flex_start(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Enables Flex Start provisioning model for the node pool.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#flex_start ContainerCluster#flex_start}
        '''
        result = self._values.get("flex_start")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def gcfs_config(
        self,
    ) -> typing.Optional["ContainerClusterNodePoolNodeConfigGcfsConfig"]:
        '''gcfs_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gcfs_config ContainerCluster#gcfs_config}
        '''
        result = self._values.get("gcfs_config")
        return typing.cast(typing.Optional["ContainerClusterNodePoolNodeConfigGcfsConfig"], result)

    @builtins.property
    def guest_accelerator(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ContainerClusterNodePoolNodeConfigGuestAccelerator"]]]:
        '''guest_accelerator block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#guest_accelerator ContainerCluster#guest_accelerator}
        '''
        result = self._values.get("guest_accelerator")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ContainerClusterNodePoolNodeConfigGuestAccelerator"]]], result)

    @builtins.property
    def gvnic(self) -> typing.Optional["ContainerClusterNodePoolNodeConfigGvnic"]:
        '''gvnic block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gvnic ContainerCluster#gvnic}
        '''
        result = self._values.get("gvnic")
        return typing.cast(typing.Optional["ContainerClusterNodePoolNodeConfigGvnic"], result)

    @builtins.property
    def host_maintenance_policy(
        self,
    ) -> typing.Optional["ContainerClusterNodePoolNodeConfigHostMaintenancePolicy"]:
        '''host_maintenance_policy block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#host_maintenance_policy ContainerCluster#host_maintenance_policy}
        '''
        result = self._values.get("host_maintenance_policy")
        return typing.cast(typing.Optional["ContainerClusterNodePoolNodeConfigHostMaintenancePolicy"], result)

    @builtins.property
    def image_type(self) -> typing.Optional[builtins.str]:
        '''The image type to use for this node.

        Note that for a given image type, the latest version of it will be used.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#image_type ContainerCluster#image_type}
        '''
        result = self._values.get("image_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def kubelet_config(
        self,
    ) -> typing.Optional["ContainerClusterNodePoolNodeConfigKubeletConfig"]:
        '''kubelet_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#kubelet_config ContainerCluster#kubelet_config}
        '''
        result = self._values.get("kubelet_config")
        return typing.cast(typing.Optional["ContainerClusterNodePoolNodeConfigKubeletConfig"], result)

    @builtins.property
    def labels(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''The map of Kubernetes labels (key/value pairs) to be applied to each node.

        These will added in addition to any default label(s) that Kubernetes may apply to the node.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#labels ContainerCluster#labels}
        '''
        result = self._values.get("labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def linux_node_config(
        self,
    ) -> typing.Optional["ContainerClusterNodePoolNodeConfigLinuxNodeConfig"]:
        '''linux_node_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#linux_node_config ContainerCluster#linux_node_config}
        '''
        result = self._values.get("linux_node_config")
        return typing.cast(typing.Optional["ContainerClusterNodePoolNodeConfigLinuxNodeConfig"], result)

    @builtins.property
    def local_nvme_ssd_block_config(
        self,
    ) -> typing.Optional["ContainerClusterNodePoolNodeConfigLocalNvmeSsdBlockConfig"]:
        '''local_nvme_ssd_block_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#local_nvme_ssd_block_config ContainerCluster#local_nvme_ssd_block_config}
        '''
        result = self._values.get("local_nvme_ssd_block_config")
        return typing.cast(typing.Optional["ContainerClusterNodePoolNodeConfigLocalNvmeSsdBlockConfig"], result)

    @builtins.property
    def local_ssd_count(self) -> typing.Optional[jsii.Number]:
        '''The number of local SSD disks to be attached to the node.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#local_ssd_count ContainerCluster#local_ssd_count}
        '''
        result = self._values.get("local_ssd_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def local_ssd_encryption_mode(self) -> typing.Optional[builtins.str]:
        '''LocalSsdEncryptionMode specified the method used for encrypting the local SSDs attached to the node.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#local_ssd_encryption_mode ContainerCluster#local_ssd_encryption_mode}
        '''
        result = self._values.get("local_ssd_encryption_mode")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def logging_variant(self) -> typing.Optional[builtins.str]:
        '''Type of logging agent that is used as the default value for node pools in the cluster.

        Valid values include DEFAULT and MAX_THROUGHPUT.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#logging_variant ContainerCluster#logging_variant}
        '''
        result = self._values.get("logging_variant")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def machine_type(self) -> typing.Optional[builtins.str]:
        '''The name of a Google Compute Engine machine type.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#machine_type ContainerCluster#machine_type}
        '''
        result = self._values.get("machine_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def max_run_duration(self) -> typing.Optional[builtins.str]:
        '''The runtime of each node in the node pool in seconds, terminated by 's'. Example: "3600s".

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#max_run_duration ContainerCluster#max_run_duration}
        '''
        result = self._values.get("max_run_duration")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def metadata(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''The metadata key/value pairs assigned to instances in the cluster.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#metadata ContainerCluster#metadata}
        '''
        result = self._values.get("metadata")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def min_cpu_platform(self) -> typing.Optional[builtins.str]:
        '''Minimum CPU platform to be used by this instance.

        The instance may be scheduled on the specified or newer CPU platform.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#min_cpu_platform ContainerCluster#min_cpu_platform}
        '''
        result = self._values.get("min_cpu_platform")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def node_group(self) -> typing.Optional[builtins.str]:
        '''Setting this field will assign instances of this pool to run on the specified node group.

        This is useful for running workloads on sole tenant nodes.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#node_group ContainerCluster#node_group}
        '''
        result = self._values.get("node_group")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def oauth_scopes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The set of Google API scopes to be made available on all of the node VMs.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#oauth_scopes ContainerCluster#oauth_scopes}
        '''
        result = self._values.get("oauth_scopes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def preemptible(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Whether the nodes are created as preemptible VM instances.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#preemptible ContainerCluster#preemptible}
        '''
        result = self._values.get("preemptible")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def reservation_affinity(
        self,
    ) -> typing.Optional["ContainerClusterNodePoolNodeConfigReservationAffinity"]:
        '''reservation_affinity block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#reservation_affinity ContainerCluster#reservation_affinity}
        '''
        result = self._values.get("reservation_affinity")
        return typing.cast(typing.Optional["ContainerClusterNodePoolNodeConfigReservationAffinity"], result)

    @builtins.property
    def resource_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''The GCE resource labels (a map of key/value pairs) to be applied to the node pool.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#resource_labels ContainerCluster#resource_labels}
        '''
        result = self._values.get("resource_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def resource_manager_tags(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''A map of resource manager tags.

        Resource manager tag keys and values have the same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id}, and values are in the format tagValues/456. The field is ignored (both PUT & PATCH) when empty.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#resource_manager_tags ContainerCluster#resource_manager_tags}
        '''
        result = self._values.get("resource_manager_tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def secondary_boot_disks(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ContainerClusterNodePoolNodeConfigSecondaryBootDisks"]]]:
        '''secondary_boot_disks block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#secondary_boot_disks ContainerCluster#secondary_boot_disks}
        '''
        result = self._values.get("secondary_boot_disks")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ContainerClusterNodePoolNodeConfigSecondaryBootDisks"]]], result)

    @builtins.property
    def service_account(self) -> typing.Optional[builtins.str]:
        '''The Google Cloud Platform Service Account to be used by the node VMs.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#service_account ContainerCluster#service_account}
        '''
        result = self._values.get("service_account")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def shielded_instance_config(
        self,
    ) -> typing.Optional["ContainerClusterNodePoolNodeConfigShieldedInstanceConfig"]:
        '''shielded_instance_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#shielded_instance_config ContainerCluster#shielded_instance_config}
        '''
        result = self._values.get("shielded_instance_config")
        return typing.cast(typing.Optional["ContainerClusterNodePoolNodeConfigShieldedInstanceConfig"], result)

    @builtins.property
    def sole_tenant_config(
        self,
    ) -> typing.Optional["ContainerClusterNodePoolNodeConfigSoleTenantConfig"]:
        '''sole_tenant_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#sole_tenant_config ContainerCluster#sole_tenant_config}
        '''
        result = self._values.get("sole_tenant_config")
        return typing.cast(typing.Optional["ContainerClusterNodePoolNodeConfigSoleTenantConfig"], result)

    @builtins.property
    def spot(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Whether the nodes are created as spot VM instances.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#spot ContainerCluster#spot}
        '''
        result = self._values.get("spot")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def storage_pools(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The list of Storage Pools where boot disks are provisioned.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#storage_pools ContainerCluster#storage_pools}
        '''
        result = self._values.get("storage_pools")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The list of instance tags applied to all nodes.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#tags ContainerCluster#tags}
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def taint(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ContainerClusterNodePoolNodeConfigTaint"]]]:
        '''taint block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#taint ContainerCluster#taint}
        '''
        result = self._values.get("taint")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ContainerClusterNodePoolNodeConfigTaint"]]], result)

    @builtins.property
    def windows_node_config(
        self,
    ) -> typing.Optional["ContainerClusterNodePoolNodeConfigWindowsNodeConfig"]:
        '''windows_node_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#windows_node_config ContainerCluster#windows_node_config}
        '''
        result = self._values.get("windows_node_config")
        return typing.cast(typing.Optional["ContainerClusterNodePoolNodeConfigWindowsNodeConfig"], result)

    @builtins.property
    def workload_metadata_config(
        self,
    ) -> typing.Optional["ContainerClusterNodePoolNodeConfigWorkloadMetadataConfig"]:
        '''workload_metadata_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#workload_metadata_config ContainerCluster#workload_metadata_config}
        '''
        result = self._values.get("workload_metadata_config")
        return typing.cast(typing.Optional["ContainerClusterNodePoolNodeConfigWorkloadMetadataConfig"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodePoolNodeConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigAdvancedMachineFeatures",
    jsii_struct_bases=[],
    name_mapping={
        "threads_per_core": "threadsPerCore",
        "enable_nested_virtualization": "enableNestedVirtualization",
        "performance_monitoring_unit": "performanceMonitoringUnit",
    },
)
class ContainerClusterNodePoolNodeConfigAdvancedMachineFeatures:
    def __init__(
        self,
        *,
        threads_per_core: jsii.Number,
        enable_nested_virtualization: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        performance_monitoring_unit: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param threads_per_core: The number of threads per physical core. To disable simultaneous multithreading (SMT) set this to 1. If unset, the maximum number of threads supported per core by the underlying processor is assumed. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#threads_per_core ContainerCluster#threads_per_core}
        :param enable_nested_virtualization: Whether the node should have nested virtualization enabled. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_nested_virtualization ContainerCluster#enable_nested_virtualization}
        :param performance_monitoring_unit: Level of Performance Monitoring Unit (PMU) requested. If unset, no access to the PMU is assumed. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#performance_monitoring_unit ContainerCluster#performance_monitoring_unit}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cf28aacd12be6625c735af9e591e9458fc217c241592ccf3906aa5b83854afde)
            check_type(argname="argument threads_per_core", value=threads_per_core, expected_type=type_hints["threads_per_core"])
            check_type(argname="argument enable_nested_virtualization", value=enable_nested_virtualization, expected_type=type_hints["enable_nested_virtualization"])
            check_type(argname="argument performance_monitoring_unit", value=performance_monitoring_unit, expected_type=type_hints["performance_monitoring_unit"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "threads_per_core": threads_per_core,
        }
        if enable_nested_virtualization is not None:
            self._values["enable_nested_virtualization"] = enable_nested_virtualization
        if performance_monitoring_unit is not None:
            self._values["performance_monitoring_unit"] = performance_monitoring_unit

    @builtins.property
    def threads_per_core(self) -> jsii.Number:
        '''The number of threads per physical core.

        To disable simultaneous multithreading (SMT) set this to 1. If unset, the maximum number of threads supported per core by the underlying processor is assumed.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#threads_per_core ContainerCluster#threads_per_core}
        '''
        result = self._values.get("threads_per_core")
        assert result is not None, "Required property 'threads_per_core' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def enable_nested_virtualization(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Whether the node should have nested virtualization enabled.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_nested_virtualization ContainerCluster#enable_nested_virtualization}
        '''
        result = self._values.get("enable_nested_virtualization")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def performance_monitoring_unit(self) -> typing.Optional[builtins.str]:
        '''Level of Performance Monitoring Unit (PMU) requested. If unset, no access to the PMU is assumed.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#performance_monitoring_unit ContainerCluster#performance_monitoring_unit}
        '''
        result = self._values.get("performance_monitoring_unit")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodePoolNodeConfigAdvancedMachineFeatures(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodePoolNodeConfigAdvancedMachineFeaturesOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigAdvancedMachineFeaturesOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c2794bf04f73271dd4bb6f45de44a9521b3e6ba2d9b6dc107274942437043c13)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetEnableNestedVirtualization")
    def reset_enable_nested_virtualization(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnableNestedVirtualization", []))

    @jsii.member(jsii_name="resetPerformanceMonitoringUnit")
    def reset_performance_monitoring_unit(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPerformanceMonitoringUnit", []))

    @builtins.property
    @jsii.member(jsii_name="enableNestedVirtualizationInput")
    def enable_nested_virtualization_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enableNestedVirtualizationInput"))

    @builtins.property
    @jsii.member(jsii_name="performanceMonitoringUnitInput")
    def performance_monitoring_unit_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "performanceMonitoringUnitInput"))

    @builtins.property
    @jsii.member(jsii_name="threadsPerCoreInput")
    def threads_per_core_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "threadsPerCoreInput"))

    @builtins.property
    @jsii.member(jsii_name="enableNestedVirtualization")
    def enable_nested_virtualization(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enableNestedVirtualization"))

    @enable_nested_virtualization.setter
    def enable_nested_virtualization(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__02abf2705b35df1e0f53b236eff28868762efc9ae912287c2ad2e7732fb23f1c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableNestedVirtualization", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="performanceMonitoringUnit")
    def performance_monitoring_unit(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "performanceMonitoringUnit"))

    @performance_monitoring_unit.setter
    def performance_monitoring_unit(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__88a8c27edde2d695813dd59b348bf0e05af1f34c333dcc360fef69c78c760b36)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "performanceMonitoringUnit", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="threadsPerCore")
    def threads_per_core(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "threadsPerCore"))

    @threads_per_core.setter
    def threads_per_core(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f022d134b97f0a2e1d50065296170f95cecaa17f201e6f13fc3d0b78c67fa134)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "threadsPerCore", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolNodeConfigAdvancedMachineFeatures]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolNodeConfigAdvancedMachineFeatures], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodePoolNodeConfigAdvancedMachineFeatures],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a6741dcae86074693f271cfd64afb741b1fd87ff4c05d50b63dd8f44fd1dfc6f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigBootDisk",
    jsii_struct_bases=[],
    name_mapping={
        "disk_type": "diskType",
        "provisioned_iops": "provisionedIops",
        "provisioned_throughput": "provisionedThroughput",
        "size_gb": "sizeGb",
    },
)
class ContainerClusterNodePoolNodeConfigBootDisk:
    def __init__(
        self,
        *,
        disk_type: typing.Optional[builtins.str] = None,
        provisioned_iops: typing.Optional[jsii.Number] = None,
        provisioned_throughput: typing.Optional[jsii.Number] = None,
        size_gb: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param disk_type: Type of the disk attached to each node. Such as pd-standard, pd-balanced or pd-ssd. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#disk_type ContainerCluster#disk_type}
        :param provisioned_iops: Configured IOPs provisioning. Only valid with disk type hyperdisk-balanced. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#provisioned_iops ContainerCluster#provisioned_iops}
        :param provisioned_throughput: Configured throughput provisioning. Only valid with disk type hyperdisk-balanced. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#provisioned_throughput ContainerCluster#provisioned_throughput}
        :param size_gb: Size of the disk attached to each node, specified in GB. The smallest allowed disk size is 10GB. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#size_gb ContainerCluster#size_gb}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fd3683846a431888441d45bfe7d33dd72bf81cd839b5931abdf3c37be6032c1b)
            check_type(argname="argument disk_type", value=disk_type, expected_type=type_hints["disk_type"])
            check_type(argname="argument provisioned_iops", value=provisioned_iops, expected_type=type_hints["provisioned_iops"])
            check_type(argname="argument provisioned_throughput", value=provisioned_throughput, expected_type=type_hints["provisioned_throughput"])
            check_type(argname="argument size_gb", value=size_gb, expected_type=type_hints["size_gb"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if disk_type is not None:
            self._values["disk_type"] = disk_type
        if provisioned_iops is not None:
            self._values["provisioned_iops"] = provisioned_iops
        if provisioned_throughput is not None:
            self._values["provisioned_throughput"] = provisioned_throughput
        if size_gb is not None:
            self._values["size_gb"] = size_gb

    @builtins.property
    def disk_type(self) -> typing.Optional[builtins.str]:
        '''Type of the disk attached to each node. Such as pd-standard, pd-balanced or pd-ssd.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#disk_type ContainerCluster#disk_type}
        '''
        result = self._values.get("disk_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def provisioned_iops(self) -> typing.Optional[jsii.Number]:
        '''Configured IOPs provisioning. Only valid with disk type hyperdisk-balanced.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#provisioned_iops ContainerCluster#provisioned_iops}
        '''
        result = self._values.get("provisioned_iops")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def provisioned_throughput(self) -> typing.Optional[jsii.Number]:
        '''Configured throughput provisioning. Only valid with disk type hyperdisk-balanced.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#provisioned_throughput ContainerCluster#provisioned_throughput}
        '''
        result = self._values.get("provisioned_throughput")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def size_gb(self) -> typing.Optional[jsii.Number]:
        '''Size of the disk attached to each node, specified in GB. The smallest allowed disk size is 10GB.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#size_gb ContainerCluster#size_gb}
        '''
        result = self._values.get("size_gb")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodePoolNodeConfigBootDisk(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodePoolNodeConfigBootDiskOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigBootDiskOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1eb640ca6b28a7814e677ea00d229fd8ca9dba493aaafd17b506025b23dace13)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetDiskType")
    def reset_disk_type(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDiskType", []))

    @jsii.member(jsii_name="resetProvisionedIops")
    def reset_provisioned_iops(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetProvisionedIops", []))

    @jsii.member(jsii_name="resetProvisionedThroughput")
    def reset_provisioned_throughput(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetProvisionedThroughput", []))

    @jsii.member(jsii_name="resetSizeGb")
    def reset_size_gb(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSizeGb", []))

    @builtins.property
    @jsii.member(jsii_name="diskTypeInput")
    def disk_type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "diskTypeInput"))

    @builtins.property
    @jsii.member(jsii_name="provisionedIopsInput")
    def provisioned_iops_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "provisionedIopsInput"))

    @builtins.property
    @jsii.member(jsii_name="provisionedThroughputInput")
    def provisioned_throughput_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "provisionedThroughputInput"))

    @builtins.property
    @jsii.member(jsii_name="sizeGbInput")
    def size_gb_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "sizeGbInput"))

    @builtins.property
    @jsii.member(jsii_name="diskType")
    def disk_type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "diskType"))

    @disk_type.setter
    def disk_type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b4298bb191503bbdb42e69a251d6f805bbda678d23ab9ec3f95949a79d636ad9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "diskType", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="provisionedIops")
    def provisioned_iops(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "provisionedIops"))

    @provisioned_iops.setter
    def provisioned_iops(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b587f3534367057a9a86377b3e80cf5e3562a9dad3c27c76405e8278e85279d1)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "provisionedIops", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="provisionedThroughput")
    def provisioned_throughput(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "provisionedThroughput"))

    @provisioned_throughput.setter
    def provisioned_throughput(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7b5a196d7635afca3adf7b5cb1bf0c6398a8d083f2eff0eae464cbbfc3569684)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "provisionedThroughput", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="sizeGb")
    def size_gb(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "sizeGb"))

    @size_gb.setter
    def size_gb(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5df3cd3fdcb92509ad45cf0266523feaaba95a69edd859ca4e8c997973ccf7a9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "sizeGb", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolNodeConfigBootDisk]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolNodeConfigBootDisk], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodePoolNodeConfigBootDisk],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__009f9f1f1a30acb16d5f1c52204e69eed061af21f8d142d4f91107e17939f15d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigConfidentialNodes",
    jsii_struct_bases=[],
    name_mapping={
        "enabled": "enabled",
        "confidential_instance_type": "confidentialInstanceType",
    },
)
class ContainerClusterNodePoolNodeConfigConfidentialNodes:
    def __init__(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
        confidential_instance_type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param enabled: Whether Confidential Nodes feature is enabled for all nodes in this pool. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        :param confidential_instance_type: Defines the type of technology used by the confidential node. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#confidential_instance_type ContainerCluster#confidential_instance_type}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e6c395174f0caf88fa0279c2fcde4da58593e6beb008d8841cca254bdd7d4e3c)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
            check_type(argname="argument confidential_instance_type", value=confidential_instance_type, expected_type=type_hints["confidential_instance_type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "enabled": enabled,
        }
        if confidential_instance_type is not None:
            self._values["confidential_instance_type"] = confidential_instance_type

    @builtins.property
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        '''Whether Confidential Nodes feature is enabled for all nodes in this pool.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        '''
        result = self._values.get("enabled")
        assert result is not None, "Required property 'enabled' is missing"
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], result)

    @builtins.property
    def confidential_instance_type(self) -> typing.Optional[builtins.str]:
        '''Defines the type of technology used by the confidential node.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#confidential_instance_type ContainerCluster#confidential_instance_type}
        '''
        result = self._values.get("confidential_instance_type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodePoolNodeConfigConfidentialNodes(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodePoolNodeConfigConfidentialNodesOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigConfidentialNodesOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ae2d765bd48c72b4e57714e927d4986f18fa560bbdd5ff94c5bcfdd12d97381c)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetConfidentialInstanceType")
    def reset_confidential_instance_type(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetConfidentialInstanceType", []))

    @builtins.property
    @jsii.member(jsii_name="confidentialInstanceTypeInput")
    def confidential_instance_type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "confidentialInstanceTypeInput"))

    @builtins.property
    @jsii.member(jsii_name="enabledInput")
    def enabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enabledInput"))

    @builtins.property
    @jsii.member(jsii_name="confidentialInstanceType")
    def confidential_instance_type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "confidentialInstanceType"))

    @confidential_instance_type.setter
    def confidential_instance_type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fd732ada6fa1b517367ae768a33ec6a122e1212e44b52935b9ab29bed3a7ed9e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "confidentialInstanceType", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="enabled")
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enabled"))

    @enabled.setter
    def enabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f59ca7c194740942d8e664b74aa24b5c9b1cb7ae25bbb63007beef24f540bec1)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolNodeConfigConfidentialNodes]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolNodeConfigConfidentialNodes], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodePoolNodeConfigConfidentialNodes],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__85de66673b352f189442871c723cd4c2512d01df54b8a47ebee8ca91e6b2e836)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigContainerdConfig",
    jsii_struct_bases=[],
    name_mapping={"private_registry_access_config": "privateRegistryAccessConfig"},
)
class ContainerClusterNodePoolNodeConfigContainerdConfig:
    def __init__(
        self,
        *,
        private_registry_access_config: typing.Optional[typing.Union["ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfig", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param private_registry_access_config: private_registry_access_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#private_registry_access_config ContainerCluster#private_registry_access_config}
        '''
        if isinstance(private_registry_access_config, dict):
            private_registry_access_config = ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfig(**private_registry_access_config)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1d76227ea7307cd430327f6684c67bd0edab50c2fcdd1676448db65fc71015ee)
            check_type(argname="argument private_registry_access_config", value=private_registry_access_config, expected_type=type_hints["private_registry_access_config"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if private_registry_access_config is not None:
            self._values["private_registry_access_config"] = private_registry_access_config

    @builtins.property
    def private_registry_access_config(
        self,
    ) -> typing.Optional["ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfig"]:
        '''private_registry_access_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#private_registry_access_config ContainerCluster#private_registry_access_config}
        '''
        result = self._values.get("private_registry_access_config")
        return typing.cast(typing.Optional["ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfig"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodePoolNodeConfigContainerdConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodePoolNodeConfigContainerdConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigContainerdConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eea7a5fcd530c986c5e435090734d85f89a654930ed3138cc8feadf0d8698fd7)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putPrivateRegistryAccessConfig")
    def put_private_registry_access_config(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
        certificate_authority_domain_config: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig", typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''
        :param enabled: Whether or not private registries are configured. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        :param certificate_authority_domain_config: certificate_authority_domain_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#certificate_authority_domain_config ContainerCluster#certificate_authority_domain_config}
        '''
        value = ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfig(
            enabled=enabled,
            certificate_authority_domain_config=certificate_authority_domain_config,
        )

        return typing.cast(None, jsii.invoke(self, "putPrivateRegistryAccessConfig", [value]))

    @jsii.member(jsii_name="resetPrivateRegistryAccessConfig")
    def reset_private_registry_access_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPrivateRegistryAccessConfig", []))

    @builtins.property
    @jsii.member(jsii_name="privateRegistryAccessConfig")
    def private_registry_access_config(
        self,
    ) -> "ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigOutputReference":
        return typing.cast("ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigOutputReference", jsii.get(self, "privateRegistryAccessConfig"))

    @builtins.property
    @jsii.member(jsii_name="privateRegistryAccessConfigInput")
    def private_registry_access_config_input(
        self,
    ) -> typing.Optional["ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfig"]:
        return typing.cast(typing.Optional["ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfig"], jsii.get(self, "privateRegistryAccessConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolNodeConfigContainerdConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolNodeConfigContainerdConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodePoolNodeConfigContainerdConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__490fa88eb8531aba5f62066121bf87050ebb0830ebdf414626af1020a94cff63)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfig",
    jsii_struct_bases=[],
    name_mapping={
        "enabled": "enabled",
        "certificate_authority_domain_config": "certificateAuthorityDomainConfig",
    },
)
class ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfig:
    def __init__(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
        certificate_authority_domain_config: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig", typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''
        :param enabled: Whether or not private registries are configured. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        :param certificate_authority_domain_config: certificate_authority_domain_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#certificate_authority_domain_config ContainerCluster#certificate_authority_domain_config}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__20f5729ac786be4bdefb07806f5dc68c27fbf423d1c1a14ee5dabdd8113b04ae)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
            check_type(argname="argument certificate_authority_domain_config", value=certificate_authority_domain_config, expected_type=type_hints["certificate_authority_domain_config"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "enabled": enabled,
        }
        if certificate_authority_domain_config is not None:
            self._values["certificate_authority_domain_config"] = certificate_authority_domain_config

    @builtins.property
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        '''Whether or not private registries are configured.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        '''
        result = self._values.get("enabled")
        assert result is not None, "Required property 'enabled' is missing"
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], result)

    @builtins.property
    def certificate_authority_domain_config(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig"]]]:
        '''certificate_authority_domain_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#certificate_authority_domain_config ContainerCluster#certificate_authority_domain_config}
        '''
        result = self._values.get("certificate_authority_domain_config")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig"]]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig",
    jsii_struct_bases=[],
    name_mapping={
        "fqdns": "fqdns",
        "gcp_secret_manager_certificate_config": "gcpSecretManagerCertificateConfig",
    },
)
class ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig:
    def __init__(
        self,
        *,
        fqdns: typing.Sequence[builtins.str],
        gcp_secret_manager_certificate_config: typing.Union["ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''
        :param fqdns: List of fully-qualified-domain-names. IPv4s and port specification are supported. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#fqdns ContainerCluster#fqdns}
        :param gcp_secret_manager_certificate_config: gcp_secret_manager_certificate_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gcp_secret_manager_certificate_config ContainerCluster#gcp_secret_manager_certificate_config}
        '''
        if isinstance(gcp_secret_manager_certificate_config, dict):
            gcp_secret_manager_certificate_config = ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig(**gcp_secret_manager_certificate_config)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__43cb3584d481618b8cca43134c2e5c2e55dfe880cfe155f2490f25b034a95d46)
            check_type(argname="argument fqdns", value=fqdns, expected_type=type_hints["fqdns"])
            check_type(argname="argument gcp_secret_manager_certificate_config", value=gcp_secret_manager_certificate_config, expected_type=type_hints["gcp_secret_manager_certificate_config"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "fqdns": fqdns,
            "gcp_secret_manager_certificate_config": gcp_secret_manager_certificate_config,
        }

    @builtins.property
    def fqdns(self) -> typing.List[builtins.str]:
        '''List of fully-qualified-domain-names. IPv4s and port specification are supported.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#fqdns ContainerCluster#fqdns}
        '''
        result = self._values.get("fqdns")
        assert result is not None, "Required property 'fqdns' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def gcp_secret_manager_certificate_config(
        self,
    ) -> "ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig":
        '''gcp_secret_manager_certificate_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gcp_secret_manager_certificate_config ContainerCluster#gcp_secret_manager_certificate_config}
        '''
        result = self._values.get("gcp_secret_manager_certificate_config")
        assert result is not None, "Required property 'gcp_secret_manager_certificate_config' is missing"
        return typing.cast("ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig",
    jsii_struct_bases=[],
    name_mapping={"secret_uri": "secretUri"},
)
class ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig:
    def __init__(self, *, secret_uri: builtins.str) -> None:
        '''
        :param secret_uri: URI for the secret that hosts a certificate. Must be in the format 'projects/PROJECT_NUM/secrets/SECRET_NAME/versions/VERSION_OR_LATEST'. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#secret_uri ContainerCluster#secret_uri}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__91b8b57944bb1bd31a2c2ee814a4af7a30eaefb16784d31336c24f86618839be)
            check_type(argname="argument secret_uri", value=secret_uri, expected_type=type_hints["secret_uri"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "secret_uri": secret_uri,
        }

    @builtins.property
    def secret_uri(self) -> builtins.str:
        '''URI for the secret that hosts a certificate. Must be in the format 'projects/PROJECT_NUM/secrets/SECRET_NAME/versions/VERSION_OR_LATEST'.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#secret_uri ContainerCluster#secret_uri}
        '''
        result = self._values.get("secret_uri")
        assert result is not None, "Required property 'secret_uri' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__78b01f7a12cb74deafea09bf15b5b3700d0628a8af5b68a36af2156f10229eec)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="secretUriInput")
    def secret_uri_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "secretUriInput"))

    @builtins.property
    @jsii.member(jsii_name="secretUri")
    def secret_uri(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "secretUri"))

    @secret_uri.setter
    def secret_uri(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__93e2d397cc58c0b950a681c2a90f65b6a6791f602d4dfecfa0d8f823d1159175)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "secretUri", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6255af41f4873a4ecd14121788f7161cd34405f8164788d96acc783dd5acaadc)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6505c286b894bb0656d3d83e889402a4a8e9897dff560d2f834e1c51db1410b5)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bfbf7670fa95faee2a01ee8097218a90ba062a93a01dde4132a4ec9ae1a7eaf5)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4c83951a4e4a583be733d58e9410615a34162ff9f1c1315fd3163c4f53e6ad19)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f098c007a31e9f1028d4b7119cee9358d5bd8b614898dc04c035e7f4df9fba50)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f17711b611f3d67ee67ec8ecfeb44b8c1eee3ae14cd67ffdb96a309a9c952016)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c9525754bda3fe56fbda56d19a6cad0f1e0d05ab424df2c82612f0b11e2a88f4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8f0591c617ae95d4cf82a7bb9d7a05710220dee4e6515dacee9824aba607d192)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putGcpSecretManagerCertificateConfig")
    def put_gcp_secret_manager_certificate_config(
        self,
        *,
        secret_uri: builtins.str,
    ) -> None:
        '''
        :param secret_uri: URI for the secret that hosts a certificate. Must be in the format 'projects/PROJECT_NUM/secrets/SECRET_NAME/versions/VERSION_OR_LATEST'. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#secret_uri ContainerCluster#secret_uri}
        '''
        value = ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig(
            secret_uri=secret_uri
        )

        return typing.cast(None, jsii.invoke(self, "putGcpSecretManagerCertificateConfig", [value]))

    @builtins.property
    @jsii.member(jsii_name="gcpSecretManagerCertificateConfig")
    def gcp_secret_manager_certificate_config(
        self,
    ) -> ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfigOutputReference:
        return typing.cast(ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfigOutputReference, jsii.get(self, "gcpSecretManagerCertificateConfig"))

    @builtins.property
    @jsii.member(jsii_name="fqdnsInput")
    def fqdns_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "fqdnsInput"))

    @builtins.property
    @jsii.member(jsii_name="gcpSecretManagerCertificateConfigInput")
    def gcp_secret_manager_certificate_config_input(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig], jsii.get(self, "gcpSecretManagerCertificateConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="fqdns")
    def fqdns(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "fqdns"))

    @fqdns.setter
    def fqdns(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__855b171fb68f2cdaff60e7ada23f77b544cc00b2e44056cde293c3abd5efd884)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "fqdns", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0b8b60e4f1fbb31185a6df32e3a5a1a0e7d94b9c8e90675bb554e09b8eecdc1d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a97bbf0ed2adcbf94d81d1ca179d862a8f7d10915787ad80cb8e7e1354fac6c1)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putCertificateAuthorityDomainConfig")
    def put_certificate_authority_domain_config(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__da99f0ee7bec8e0295ea923e45c1fcda06267e592de92bf20b6c741b6211405a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putCertificateAuthorityDomainConfig", [value]))

    @jsii.member(jsii_name="resetCertificateAuthorityDomainConfig")
    def reset_certificate_authority_domain_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCertificateAuthorityDomainConfig", []))

    @builtins.property
    @jsii.member(jsii_name="certificateAuthorityDomainConfig")
    def certificate_authority_domain_config(
        self,
    ) -> ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigList:
        return typing.cast(ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigList, jsii.get(self, "certificateAuthorityDomainConfig"))

    @builtins.property
    @jsii.member(jsii_name="certificateAuthorityDomainConfigInput")
    def certificate_authority_domain_config_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig]]], jsii.get(self, "certificateAuthorityDomainConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="enabledInput")
    def enabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enabledInput"))

    @builtins.property
    @jsii.member(jsii_name="enabled")
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enabled"))

    @enabled.setter
    def enabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cab6c3f2f73d2305701072b48c597c98f8a8aaa294e0d15cd229a0a5d8fd0543)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__38b907842288686112fd634a375c81f0e52ba0e61130a57651c6bc29589871c0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigEffectiveTaints",
    jsii_struct_bases=[],
    name_mapping={},
)
class ContainerClusterNodePoolNodeConfigEffectiveTaints:
    def __init__(self) -> None:
        self._values: typing.Dict[builtins.str, typing.Any] = {}

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodePoolNodeConfigEffectiveTaints(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodePoolNodeConfigEffectiveTaintsList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigEffectiveTaintsList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3a3d266cb4028fbcfb89265b8ff8b62188a00d1a178de622a41ae1593e6b329e)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ContainerClusterNodePoolNodeConfigEffectiveTaintsOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3d8bb9d7d4c5c0436909d25909c2f0e24a737fd36648f65a4bd3cb095b4da476)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ContainerClusterNodePoolNodeConfigEffectiveTaintsOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5fbdb999a6567e3e2929d553e026476937eb8f75aa5d10df88bba67c0e2b35e0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__49a29a6fd844b38b95ccb278f147b753dab91b56047eee9515b218c202c6466b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2e97cc201f825eecdd6718396132b343bf9f88334acb77b430b7eb9d2274ebdd)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]


class ContainerClusterNodePoolNodeConfigEffectiveTaintsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigEffectiveTaintsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7d100fb9b589fb71e2d85959c0456c76eac3d5be682f62a4bd27ef02c0d6431e)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @builtins.property
    @jsii.member(jsii_name="effect")
    def effect(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "effect"))

    @builtins.property
    @jsii.member(jsii_name="key")
    def key(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "key"))

    @builtins.property
    @jsii.member(jsii_name="value")
    def value(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "value"))

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolNodeConfigEffectiveTaints]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolNodeConfigEffectiveTaints], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodePoolNodeConfigEffectiveTaints],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__98389dc47cedc60966e6b2e62098c20cbf6030a4cebee32684db424096e6007b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigEphemeralStorageLocalSsdConfig",
    jsii_struct_bases=[],
    name_mapping={
        "local_ssd_count": "localSsdCount",
        "data_cache_count": "dataCacheCount",
    },
)
class ContainerClusterNodePoolNodeConfigEphemeralStorageLocalSsdConfig:
    def __init__(
        self,
        *,
        local_ssd_count: jsii.Number,
        data_cache_count: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param local_ssd_count: Number of local SSDs to use to back ephemeral storage. Uses NVMe interfaces. Each local SSD must be 375 or 3000 GB in size, and all local SSDs must share the same size. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#local_ssd_count ContainerCluster#local_ssd_count}
        :param data_cache_count: Number of local SSDs to be utilized for GKE Data Cache. Uses NVMe interfaces. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#data_cache_count ContainerCluster#data_cache_count}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d7d532bc4036070da93c1bbabde0a3bb4e6fa4e86a5f84816d19abc7b7f55101)
            check_type(argname="argument local_ssd_count", value=local_ssd_count, expected_type=type_hints["local_ssd_count"])
            check_type(argname="argument data_cache_count", value=data_cache_count, expected_type=type_hints["data_cache_count"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "local_ssd_count": local_ssd_count,
        }
        if data_cache_count is not None:
            self._values["data_cache_count"] = data_cache_count

    @builtins.property
    def local_ssd_count(self) -> jsii.Number:
        '''Number of local SSDs to use to back ephemeral storage.

        Uses NVMe interfaces. Each local SSD must be 375 or 3000 GB in size, and all local SSDs must share the same size.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#local_ssd_count ContainerCluster#local_ssd_count}
        '''
        result = self._values.get("local_ssd_count")
        assert result is not None, "Required property 'local_ssd_count' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def data_cache_count(self) -> typing.Optional[jsii.Number]:
        '''Number of local SSDs to be utilized for GKE Data Cache. Uses NVMe interfaces.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#data_cache_count ContainerCluster#data_cache_count}
        '''
        result = self._values.get("data_cache_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodePoolNodeConfigEphemeralStorageLocalSsdConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodePoolNodeConfigEphemeralStorageLocalSsdConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigEphemeralStorageLocalSsdConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e7d9a2b3965781dfceaf15cb0ba4b60b8089b32682217667a6a9511b2ce1f9b4)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetDataCacheCount")
    def reset_data_cache_count(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDataCacheCount", []))

    @builtins.property
    @jsii.member(jsii_name="dataCacheCountInput")
    def data_cache_count_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "dataCacheCountInput"))

    @builtins.property
    @jsii.member(jsii_name="localSsdCountInput")
    def local_ssd_count_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "localSsdCountInput"))

    @builtins.property
    @jsii.member(jsii_name="dataCacheCount")
    def data_cache_count(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "dataCacheCount"))

    @data_cache_count.setter
    def data_cache_count(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e2af8e39cc30f5c9a8826bee88b3b1b7be84640d46d05a2e759f723986d4d782)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "dataCacheCount", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="localSsdCount")
    def local_ssd_count(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "localSsdCount"))

    @local_ssd_count.setter
    def local_ssd_count(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__579d2322078b0ad351720a30bf39c91ef56e5b2cb47c33c3f834f07e8cf94789)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "localSsdCount", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolNodeConfigEphemeralStorageLocalSsdConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolNodeConfigEphemeralStorageLocalSsdConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodePoolNodeConfigEphemeralStorageLocalSsdConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__76a57bbb01a0f2a90af168a4d6ac6fb171b5d597014b4fdf1370e35d700428ca)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigFastSocket",
    jsii_struct_bases=[],
    name_mapping={"enabled": "enabled"},
)
class ContainerClusterNodePoolNodeConfigFastSocket:
    def __init__(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param enabled: Whether or not NCCL Fast Socket is enabled. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eae97e3c9237544ebc5e08135ba32e0194e35d4932f82a8a527c097b0c6d02d3)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "enabled": enabled,
        }

    @builtins.property
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        '''Whether or not NCCL Fast Socket is enabled.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        '''
        result = self._values.get("enabled")
        assert result is not None, "Required property 'enabled' is missing"
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodePoolNodeConfigFastSocket(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodePoolNodeConfigFastSocketOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigFastSocketOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1c7ae44e206be0c66c45e2d386a8038fe338df7b34f762e3bbc54980220cd3e1)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="enabledInput")
    def enabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enabledInput"))

    @builtins.property
    @jsii.member(jsii_name="enabled")
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enabled"))

    @enabled.setter
    def enabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__96488c094be448eb97323164a8e797ded22fbbe59be7d3fdbae70d1864c59a5d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolNodeConfigFastSocket]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolNodeConfigFastSocket], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodePoolNodeConfigFastSocket],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e5f7f5ca73b4dc4f78af9f2854b74ad61b465f12545e79bb399963153788af92)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigGcfsConfig",
    jsii_struct_bases=[],
    name_mapping={"enabled": "enabled"},
)
class ContainerClusterNodePoolNodeConfigGcfsConfig:
    def __init__(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param enabled: Whether or not GCFS is enabled. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__322e77a049aaea739b7970052120f0687c986d787108ee6222795d29c77b8d3b)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "enabled": enabled,
        }

    @builtins.property
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        '''Whether or not GCFS is enabled.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        '''
        result = self._values.get("enabled")
        assert result is not None, "Required property 'enabled' is missing"
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodePoolNodeConfigGcfsConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodePoolNodeConfigGcfsConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigGcfsConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__954746095aba4e54c1c2f931757a6c6a149b034e4ee8e6064dd5fcaedd4554e5)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="enabledInput")
    def enabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enabledInput"))

    @builtins.property
    @jsii.member(jsii_name="enabled")
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enabled"))

    @enabled.setter
    def enabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e4fef4a7b2a7968403bab2586b25c470655ff194d92a2601b6ea5452ffa61d08)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolNodeConfigGcfsConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolNodeConfigGcfsConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodePoolNodeConfigGcfsConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__22c7a50bd30815789274601d1e3ba8d2a571643fa171bb74568f0cbb62e3986e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigGuestAccelerator",
    jsii_struct_bases=[],
    name_mapping={
        "count": "count",
        "type": "type",
        "gpu_driver_installation_config": "gpuDriverInstallationConfig",
        "gpu_partition_size": "gpuPartitionSize",
        "gpu_sharing_config": "gpuSharingConfig",
    },
)
class ContainerClusterNodePoolNodeConfigGuestAccelerator:
    def __init__(
        self,
        *,
        count: jsii.Number,
        type: builtins.str,
        gpu_driver_installation_config: typing.Optional[typing.Union["ContainerClusterNodePoolNodeConfigGuestAcceleratorGpuDriverInstallationConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        gpu_partition_size: typing.Optional[builtins.str] = None,
        gpu_sharing_config: typing.Optional[typing.Union["ContainerClusterNodePoolNodeConfigGuestAcceleratorGpuSharingConfig", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param count: The number of the accelerator cards exposed to an instance. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#count ContainerCluster#count}
        :param type: The accelerator type resource name. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#type ContainerCluster#type}
        :param gpu_driver_installation_config: gpu_driver_installation_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gpu_driver_installation_config ContainerCluster#gpu_driver_installation_config}
        :param gpu_partition_size: Size of partitions to create on the GPU. Valid values are described in the NVIDIA mig user guide (https://docs.nvidia.com/datacenter/tesla/mig-user-guide/#partitioning). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gpu_partition_size ContainerCluster#gpu_partition_size}
        :param gpu_sharing_config: gpu_sharing_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gpu_sharing_config ContainerCluster#gpu_sharing_config}
        '''
        if isinstance(gpu_driver_installation_config, dict):
            gpu_driver_installation_config = ContainerClusterNodePoolNodeConfigGuestAcceleratorGpuDriverInstallationConfig(**gpu_driver_installation_config)
        if isinstance(gpu_sharing_config, dict):
            gpu_sharing_config = ContainerClusterNodePoolNodeConfigGuestAcceleratorGpuSharingConfig(**gpu_sharing_config)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__55b2a152c157398862bae4565126d2ede0b7005999dfdf4b1e088a54ceff0a18)
            check_type(argname="argument count", value=count, expected_type=type_hints["count"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument gpu_driver_installation_config", value=gpu_driver_installation_config, expected_type=type_hints["gpu_driver_installation_config"])
            check_type(argname="argument gpu_partition_size", value=gpu_partition_size, expected_type=type_hints["gpu_partition_size"])
            check_type(argname="argument gpu_sharing_config", value=gpu_sharing_config, expected_type=type_hints["gpu_sharing_config"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "count": count,
            "type": type,
        }
        if gpu_driver_installation_config is not None:
            self._values["gpu_driver_installation_config"] = gpu_driver_installation_config
        if gpu_partition_size is not None:
            self._values["gpu_partition_size"] = gpu_partition_size
        if gpu_sharing_config is not None:
            self._values["gpu_sharing_config"] = gpu_sharing_config

    @builtins.property
    def count(self) -> jsii.Number:
        '''The number of the accelerator cards exposed to an instance.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#count ContainerCluster#count}
        '''
        result = self._values.get("count")
        assert result is not None, "Required property 'count' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def type(self) -> builtins.str:
        '''The accelerator type resource name.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#type ContainerCluster#type}
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def gpu_driver_installation_config(
        self,
    ) -> typing.Optional["ContainerClusterNodePoolNodeConfigGuestAcceleratorGpuDriverInstallationConfig"]:
        '''gpu_driver_installation_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gpu_driver_installation_config ContainerCluster#gpu_driver_installation_config}
        '''
        result = self._values.get("gpu_driver_installation_config")
        return typing.cast(typing.Optional["ContainerClusterNodePoolNodeConfigGuestAcceleratorGpuDriverInstallationConfig"], result)

    @builtins.property
    def gpu_partition_size(self) -> typing.Optional[builtins.str]:
        '''Size of partitions to create on the GPU. Valid values are described in the NVIDIA mig user guide (https://docs.nvidia.com/datacenter/tesla/mig-user-guide/#partitioning).

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gpu_partition_size ContainerCluster#gpu_partition_size}
        '''
        result = self._values.get("gpu_partition_size")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def gpu_sharing_config(
        self,
    ) -> typing.Optional["ContainerClusterNodePoolNodeConfigGuestAcceleratorGpuSharingConfig"]:
        '''gpu_sharing_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gpu_sharing_config ContainerCluster#gpu_sharing_config}
        '''
        result = self._values.get("gpu_sharing_config")
        return typing.cast(typing.Optional["ContainerClusterNodePoolNodeConfigGuestAcceleratorGpuSharingConfig"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodePoolNodeConfigGuestAccelerator(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigGuestAcceleratorGpuDriverInstallationConfig",
    jsii_struct_bases=[],
    name_mapping={"gpu_driver_version": "gpuDriverVersion"},
)
class ContainerClusterNodePoolNodeConfigGuestAcceleratorGpuDriverInstallationConfig:
    def __init__(self, *, gpu_driver_version: builtins.str) -> None:
        '''
        :param gpu_driver_version: Mode for how the GPU driver is installed. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gpu_driver_version ContainerCluster#gpu_driver_version}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__256cea0e78afbc2802b60a186403653c54a7aa483313a822bf3cba147a967dd7)
            check_type(argname="argument gpu_driver_version", value=gpu_driver_version, expected_type=type_hints["gpu_driver_version"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "gpu_driver_version": gpu_driver_version,
        }

    @builtins.property
    def gpu_driver_version(self) -> builtins.str:
        '''Mode for how the GPU driver is installed.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gpu_driver_version ContainerCluster#gpu_driver_version}
        '''
        result = self._values.get("gpu_driver_version")
        assert result is not None, "Required property 'gpu_driver_version' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodePoolNodeConfigGuestAcceleratorGpuDriverInstallationConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodePoolNodeConfigGuestAcceleratorGpuDriverInstallationConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigGuestAcceleratorGpuDriverInstallationConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__60a8600d320238f234b935ae764554a1051a063d7c2a1fceb354dce74d9e7eb5)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="gpuDriverVersionInput")
    def gpu_driver_version_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "gpuDriverVersionInput"))

    @builtins.property
    @jsii.member(jsii_name="gpuDriverVersion")
    def gpu_driver_version(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "gpuDriverVersion"))

    @gpu_driver_version.setter
    def gpu_driver_version(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5cbe6b0e6cc797fee904c5cdefdf81a3526eb0c3482ab94d93633572e84d8f24)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "gpuDriverVersion", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolNodeConfigGuestAcceleratorGpuDriverInstallationConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolNodeConfigGuestAcceleratorGpuDriverInstallationConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodePoolNodeConfigGuestAcceleratorGpuDriverInstallationConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__82771ca21caf29aecce8965227658c10444a8e1f413effdba21c7a03603161ac)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigGuestAcceleratorGpuSharingConfig",
    jsii_struct_bases=[],
    name_mapping={
        "gpu_sharing_strategy": "gpuSharingStrategy",
        "max_shared_clients_per_gpu": "maxSharedClientsPerGpu",
    },
)
class ContainerClusterNodePoolNodeConfigGuestAcceleratorGpuSharingConfig:
    def __init__(
        self,
        *,
        gpu_sharing_strategy: builtins.str,
        max_shared_clients_per_gpu: jsii.Number,
    ) -> None:
        '''
        :param gpu_sharing_strategy: The type of GPU sharing strategy to enable on the GPU node. Possible values are described in the API package (https://pkg.go.dev/google.golang.org/api/container/v1#GPUSharingConfig) Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gpu_sharing_strategy ContainerCluster#gpu_sharing_strategy}
        :param max_shared_clients_per_gpu: The maximum number of containers that can share a GPU. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#max_shared_clients_per_gpu ContainerCluster#max_shared_clients_per_gpu}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2fa12660bf052e16b16af3356986ffdf0e844487d8b75e27c51d6ee0a54ea546)
            check_type(argname="argument gpu_sharing_strategy", value=gpu_sharing_strategy, expected_type=type_hints["gpu_sharing_strategy"])
            check_type(argname="argument max_shared_clients_per_gpu", value=max_shared_clients_per_gpu, expected_type=type_hints["max_shared_clients_per_gpu"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "gpu_sharing_strategy": gpu_sharing_strategy,
            "max_shared_clients_per_gpu": max_shared_clients_per_gpu,
        }

    @builtins.property
    def gpu_sharing_strategy(self) -> builtins.str:
        '''The type of GPU sharing strategy to enable on the GPU node.

        Possible values are described in the API package (https://pkg.go.dev/google.golang.org/api/container/v1#GPUSharingConfig)

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gpu_sharing_strategy ContainerCluster#gpu_sharing_strategy}
        '''
        result = self._values.get("gpu_sharing_strategy")
        assert result is not None, "Required property 'gpu_sharing_strategy' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def max_shared_clients_per_gpu(self) -> jsii.Number:
        '''The maximum number of containers that can share a GPU.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#max_shared_clients_per_gpu ContainerCluster#max_shared_clients_per_gpu}
        '''
        result = self._values.get("max_shared_clients_per_gpu")
        assert result is not None, "Required property 'max_shared_clients_per_gpu' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodePoolNodeConfigGuestAcceleratorGpuSharingConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodePoolNodeConfigGuestAcceleratorGpuSharingConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigGuestAcceleratorGpuSharingConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__50ade9daea746cbd832feecc6d9018b04cff8c6bef292d7838c059d430c05162)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="gpuSharingStrategyInput")
    def gpu_sharing_strategy_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "gpuSharingStrategyInput"))

    @builtins.property
    @jsii.member(jsii_name="maxSharedClientsPerGpuInput")
    def max_shared_clients_per_gpu_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "maxSharedClientsPerGpuInput"))

    @builtins.property
    @jsii.member(jsii_name="gpuSharingStrategy")
    def gpu_sharing_strategy(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "gpuSharingStrategy"))

    @gpu_sharing_strategy.setter
    def gpu_sharing_strategy(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a83e0a21744ff00e11fefc2db0dad71791b9b47763aa9f04a579f2b4f66a5d01)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "gpuSharingStrategy", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="maxSharedClientsPerGpu")
    def max_shared_clients_per_gpu(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "maxSharedClientsPerGpu"))

    @max_shared_clients_per_gpu.setter
    def max_shared_clients_per_gpu(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__697fd0df6f3a46ff06f35730922a85c5ccc1a25d6311a0a16d91c4440366ea79)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "maxSharedClientsPerGpu", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolNodeConfigGuestAcceleratorGpuSharingConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolNodeConfigGuestAcceleratorGpuSharingConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodePoolNodeConfigGuestAcceleratorGpuSharingConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__481793bcf3550cc4e12657ecfa329a493d5757e09d3ec4aaf6d820512975c277)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ContainerClusterNodePoolNodeConfigGuestAcceleratorList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigGuestAcceleratorList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d87917881aaa7ce7aad94f95d60eb17f0355ef3640f928109620e48366b9f730)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ContainerClusterNodePoolNodeConfigGuestAcceleratorOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a349bea151887dab3058a90370c218a4281538820e19c1bd7be55435e3441f81)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ContainerClusterNodePoolNodeConfigGuestAcceleratorOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fdefbda83a1228b519bfbd19d5226d9731a6764b5f847a79473f6717bdfee7ee)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bb4ef658bff467060ee92629c76a78af157bdfc840f22205829bc47762f0c3e3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__95e9d5b45f08197bbdf87b449a8db49b7a796beee2e019996bd7099de008cd1f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodePoolNodeConfigGuestAccelerator]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodePoolNodeConfigGuestAccelerator]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodePoolNodeConfigGuestAccelerator]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__66d16b12985fb0b68e4a3f6f6c99117279335619cd70ab8fd0bdb9400caf8bda)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ContainerClusterNodePoolNodeConfigGuestAcceleratorOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigGuestAcceleratorOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__32d8fd39e1613e65cdbc4dcf59775f7c92780894750bdfb86f048d98afc99b01)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putGpuDriverInstallationConfig")
    def put_gpu_driver_installation_config(
        self,
        *,
        gpu_driver_version: builtins.str,
    ) -> None:
        '''
        :param gpu_driver_version: Mode for how the GPU driver is installed. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gpu_driver_version ContainerCluster#gpu_driver_version}
        '''
        value = ContainerClusterNodePoolNodeConfigGuestAcceleratorGpuDriverInstallationConfig(
            gpu_driver_version=gpu_driver_version
        )

        return typing.cast(None, jsii.invoke(self, "putGpuDriverInstallationConfig", [value]))

    @jsii.member(jsii_name="putGpuSharingConfig")
    def put_gpu_sharing_config(
        self,
        *,
        gpu_sharing_strategy: builtins.str,
        max_shared_clients_per_gpu: jsii.Number,
    ) -> None:
        '''
        :param gpu_sharing_strategy: The type of GPU sharing strategy to enable on the GPU node. Possible values are described in the API package (https://pkg.go.dev/google.golang.org/api/container/v1#GPUSharingConfig) Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gpu_sharing_strategy ContainerCluster#gpu_sharing_strategy}
        :param max_shared_clients_per_gpu: The maximum number of containers that can share a GPU. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#max_shared_clients_per_gpu ContainerCluster#max_shared_clients_per_gpu}
        '''
        value = ContainerClusterNodePoolNodeConfigGuestAcceleratorGpuSharingConfig(
            gpu_sharing_strategy=gpu_sharing_strategy,
            max_shared_clients_per_gpu=max_shared_clients_per_gpu,
        )

        return typing.cast(None, jsii.invoke(self, "putGpuSharingConfig", [value]))

    @jsii.member(jsii_name="resetGpuDriverInstallationConfig")
    def reset_gpu_driver_installation_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGpuDriverInstallationConfig", []))

    @jsii.member(jsii_name="resetGpuPartitionSize")
    def reset_gpu_partition_size(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGpuPartitionSize", []))

    @jsii.member(jsii_name="resetGpuSharingConfig")
    def reset_gpu_sharing_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGpuSharingConfig", []))

    @builtins.property
    @jsii.member(jsii_name="gpuDriverInstallationConfig")
    def gpu_driver_installation_config(
        self,
    ) -> ContainerClusterNodePoolNodeConfigGuestAcceleratorGpuDriverInstallationConfigOutputReference:
        return typing.cast(ContainerClusterNodePoolNodeConfigGuestAcceleratorGpuDriverInstallationConfigOutputReference, jsii.get(self, "gpuDriverInstallationConfig"))

    @builtins.property
    @jsii.member(jsii_name="gpuSharingConfig")
    def gpu_sharing_config(
        self,
    ) -> ContainerClusterNodePoolNodeConfigGuestAcceleratorGpuSharingConfigOutputReference:
        return typing.cast(ContainerClusterNodePoolNodeConfigGuestAcceleratorGpuSharingConfigOutputReference, jsii.get(self, "gpuSharingConfig"))

    @builtins.property
    @jsii.member(jsii_name="countInput")
    def count_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "countInput"))

    @builtins.property
    @jsii.member(jsii_name="gpuDriverInstallationConfigInput")
    def gpu_driver_installation_config_input(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolNodeConfigGuestAcceleratorGpuDriverInstallationConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolNodeConfigGuestAcceleratorGpuDriverInstallationConfig], jsii.get(self, "gpuDriverInstallationConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="gpuPartitionSizeInput")
    def gpu_partition_size_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "gpuPartitionSizeInput"))

    @builtins.property
    @jsii.member(jsii_name="gpuSharingConfigInput")
    def gpu_sharing_config_input(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolNodeConfigGuestAcceleratorGpuSharingConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolNodeConfigGuestAcceleratorGpuSharingConfig], jsii.get(self, "gpuSharingConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="typeInput")
    def type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "typeInput"))

    @builtins.property
    @jsii.member(jsii_name="count")
    def count(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "count"))

    @count.setter
    def count(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4d746ef920a8739f700aa43385c14a4bcbef71d9e38973c9582b2d67181f3d51)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "count", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="gpuPartitionSize")
    def gpu_partition_size(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "gpuPartitionSize"))

    @gpu_partition_size.setter
    def gpu_partition_size(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3bd99ed23be565fab643fff1c3aeea618cf2ffd28174dc6009f46473316a653e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "gpuPartitionSize", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="type")
    def type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "type"))

    @type.setter
    def type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c56247843c96a0cc67e33bc8b25c826f684a5c3d1da534e32772ff74a7d751cb)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "type", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterNodePoolNodeConfigGuestAccelerator]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterNodePoolNodeConfigGuestAccelerator]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterNodePoolNodeConfigGuestAccelerator]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__12f7b2611d488118d9f52d6e55d954b642efa242c365725c006da72c6f36e367)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigGvnic",
    jsii_struct_bases=[],
    name_mapping={"enabled": "enabled"},
)
class ContainerClusterNodePoolNodeConfigGvnic:
    def __init__(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param enabled: Whether or not gvnic is enabled. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e369d40ec7ca8c1d6d432f66ea27ded5a88c450e2eefbc5bba476cbeac3a2eee)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "enabled": enabled,
        }

    @builtins.property
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        '''Whether or not gvnic is enabled.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        '''
        result = self._values.get("enabled")
        assert result is not None, "Required property 'enabled' is missing"
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodePoolNodeConfigGvnic(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodePoolNodeConfigGvnicOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigGvnicOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b739808075c2f295dc109632023c57a288ccc0c00616a553013d647dfe8cdd99)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="enabledInput")
    def enabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enabledInput"))

    @builtins.property
    @jsii.member(jsii_name="enabled")
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enabled"))

    @enabled.setter
    def enabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2cf7c314d12fb90ab87f10e5a23a888e892d97ae2d0f8999fd60e54338a427b0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolNodeConfigGvnic]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolNodeConfigGvnic], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodePoolNodeConfigGvnic],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4dad6c7843e3100675e80deb529df59292c51a2ef4dcbf41f388381a08db7cb4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigHostMaintenancePolicy",
    jsii_struct_bases=[],
    name_mapping={"maintenance_interval": "maintenanceInterval"},
)
class ContainerClusterNodePoolNodeConfigHostMaintenancePolicy:
    def __init__(self, *, maintenance_interval: builtins.str) -> None:
        '''
        :param maintenance_interval: . Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#maintenance_interval ContainerCluster#maintenance_interval}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a16d48176d430934793339dad2f00425c019623bd618098116fb2c9a2421e1bf)
            check_type(argname="argument maintenance_interval", value=maintenance_interval, expected_type=type_hints["maintenance_interval"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "maintenance_interval": maintenance_interval,
        }

    @builtins.property
    def maintenance_interval(self) -> builtins.str:
        '''.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#maintenance_interval ContainerCluster#maintenance_interval}
        '''
        result = self._values.get("maintenance_interval")
        assert result is not None, "Required property 'maintenance_interval' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodePoolNodeConfigHostMaintenancePolicy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodePoolNodeConfigHostMaintenancePolicyOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigHostMaintenancePolicyOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c4be3b677e4ba565a595d78c2ecccb2d4e038aab30b45164477dbad70e5ea2de)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="maintenanceIntervalInput")
    def maintenance_interval_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "maintenanceIntervalInput"))

    @builtins.property
    @jsii.member(jsii_name="maintenanceInterval")
    def maintenance_interval(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "maintenanceInterval"))

    @maintenance_interval.setter
    def maintenance_interval(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__65a45a787681a4dd89f134ea85bf3c66d230a2f8d3171b8aee943d90262f42f9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "maintenanceInterval", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolNodeConfigHostMaintenancePolicy]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolNodeConfigHostMaintenancePolicy], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodePoolNodeConfigHostMaintenancePolicy],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e26a6f7525d2ca8e84d069717b77026c837eb7e3fb45aed7303f9176ee4f4fd2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigKubeletConfig",
    jsii_struct_bases=[],
    name_mapping={
        "allowed_unsafe_sysctls": "allowedUnsafeSysctls",
        "container_log_max_files": "containerLogMaxFiles",
        "container_log_max_size": "containerLogMaxSize",
        "cpu_cfs_quota": "cpuCfsQuota",
        "cpu_cfs_quota_period": "cpuCfsQuotaPeriod",
        "cpu_manager_policy": "cpuManagerPolicy",
        "eviction_max_pod_grace_period_seconds": "evictionMaxPodGracePeriodSeconds",
        "eviction_minimum_reclaim": "evictionMinimumReclaim",
        "eviction_soft": "evictionSoft",
        "eviction_soft_grace_period": "evictionSoftGracePeriod",
        "image_gc_high_threshold_percent": "imageGcHighThresholdPercent",
        "image_gc_low_threshold_percent": "imageGcLowThresholdPercent",
        "image_maximum_gc_age": "imageMaximumGcAge",
        "image_minimum_gc_age": "imageMinimumGcAge",
        "insecure_kubelet_readonly_port_enabled": "insecureKubeletReadonlyPortEnabled",
        "max_parallel_image_pulls": "maxParallelImagePulls",
        "pod_pids_limit": "podPidsLimit",
        "single_process_oom_kill": "singleProcessOomKill",
    },
)
class ContainerClusterNodePoolNodeConfigKubeletConfig:
    def __init__(
        self,
        *,
        allowed_unsafe_sysctls: typing.Optional[typing.Sequence[builtins.str]] = None,
        container_log_max_files: typing.Optional[jsii.Number] = None,
        container_log_max_size: typing.Optional[builtins.str] = None,
        cpu_cfs_quota: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        cpu_cfs_quota_period: typing.Optional[builtins.str] = None,
        cpu_manager_policy: typing.Optional[builtins.str] = None,
        eviction_max_pod_grace_period_seconds: typing.Optional[jsii.Number] = None,
        eviction_minimum_reclaim: typing.Optional[typing.Union["ContainerClusterNodePoolNodeConfigKubeletConfigEvictionMinimumReclaim", typing.Dict[builtins.str, typing.Any]]] = None,
        eviction_soft: typing.Optional[typing.Union["ContainerClusterNodePoolNodeConfigKubeletConfigEvictionSoft", typing.Dict[builtins.str, typing.Any]]] = None,
        eviction_soft_grace_period: typing.Optional[typing.Union["ContainerClusterNodePoolNodeConfigKubeletConfigEvictionSoftGracePeriod", typing.Dict[builtins.str, typing.Any]]] = None,
        image_gc_high_threshold_percent: typing.Optional[jsii.Number] = None,
        image_gc_low_threshold_percent: typing.Optional[jsii.Number] = None,
        image_maximum_gc_age: typing.Optional[builtins.str] = None,
        image_minimum_gc_age: typing.Optional[builtins.str] = None,
        insecure_kubelet_readonly_port_enabled: typing.Optional[builtins.str] = None,
        max_parallel_image_pulls: typing.Optional[jsii.Number] = None,
        pod_pids_limit: typing.Optional[jsii.Number] = None,
        single_process_oom_kill: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    ) -> None:
        '''
        :param allowed_unsafe_sysctls: Defines a comma-separated allowlist of unsafe sysctls or sysctl patterns which can be set on the Pods. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#allowed_unsafe_sysctls ContainerCluster#allowed_unsafe_sysctls}
        :param container_log_max_files: Defines the maximum number of container log files that can be present for a container. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#container_log_max_files ContainerCluster#container_log_max_files}
        :param container_log_max_size: Defines the maximum size of the container log file before it is rotated. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#container_log_max_size ContainerCluster#container_log_max_size}
        :param cpu_cfs_quota: Enable CPU CFS quota enforcement for containers that specify CPU limits. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cpu_cfs_quota ContainerCluster#cpu_cfs_quota}
        :param cpu_cfs_quota_period: Set the CPU CFS quota period value 'cpu.cfs_period_us'. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cpu_cfs_quota_period ContainerCluster#cpu_cfs_quota_period}
        :param cpu_manager_policy: Control the CPU management policy on the node. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cpu_manager_policy ContainerCluster#cpu_manager_policy}
        :param eviction_max_pod_grace_period_seconds: Defines the maximum allowed grace period (in seconds) to use when terminating pods in response to a soft eviction threshold being met. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#eviction_max_pod_grace_period_seconds ContainerCluster#eviction_max_pod_grace_period_seconds}
        :param eviction_minimum_reclaim: eviction_minimum_reclaim block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#eviction_minimum_reclaim ContainerCluster#eviction_minimum_reclaim}
        :param eviction_soft: eviction_soft block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#eviction_soft ContainerCluster#eviction_soft}
        :param eviction_soft_grace_period: eviction_soft_grace_period block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#eviction_soft_grace_period ContainerCluster#eviction_soft_grace_period}
        :param image_gc_high_threshold_percent: Defines the percent of disk usage after which image garbage collection is always run. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#image_gc_high_threshold_percent ContainerCluster#image_gc_high_threshold_percent}
        :param image_gc_low_threshold_percent: Defines the percent of disk usage before which image garbage collection is never run. Lowest disk usage to garbage collect to. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#image_gc_low_threshold_percent ContainerCluster#image_gc_low_threshold_percent}
        :param image_maximum_gc_age: Defines the maximum age an image can be unused before it is garbage collected. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#image_maximum_gc_age ContainerCluster#image_maximum_gc_age}
        :param image_minimum_gc_age: Defines the minimum age for an unused image before it is garbage collected. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#image_minimum_gc_age ContainerCluster#image_minimum_gc_age}
        :param insecure_kubelet_readonly_port_enabled: Controls whether the kubelet read-only port is enabled. It is strongly recommended to set this to ``FALSE``. Possible values: ``TRUE``, ``FALSE``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#insecure_kubelet_readonly_port_enabled ContainerCluster#insecure_kubelet_readonly_port_enabled}
        :param max_parallel_image_pulls: Set the maximum number of image pulls in parallel. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#max_parallel_image_pulls ContainerCluster#max_parallel_image_pulls}
        :param pod_pids_limit: Controls the maximum number of processes allowed to run in a pod. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#pod_pids_limit ContainerCluster#pod_pids_limit}
        :param single_process_oom_kill: Defines whether to enable single process OOM killer. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#single_process_oom_kill ContainerCluster#single_process_oom_kill}
        '''
        if isinstance(eviction_minimum_reclaim, dict):
            eviction_minimum_reclaim = ContainerClusterNodePoolNodeConfigKubeletConfigEvictionMinimumReclaim(**eviction_minimum_reclaim)
        if isinstance(eviction_soft, dict):
            eviction_soft = ContainerClusterNodePoolNodeConfigKubeletConfigEvictionSoft(**eviction_soft)
        if isinstance(eviction_soft_grace_period, dict):
            eviction_soft_grace_period = ContainerClusterNodePoolNodeConfigKubeletConfigEvictionSoftGracePeriod(**eviction_soft_grace_period)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7981cb432c5947da5bb61b86448537df695595b5439d1f2cb8531257784dbddd)
            check_type(argname="argument allowed_unsafe_sysctls", value=allowed_unsafe_sysctls, expected_type=type_hints["allowed_unsafe_sysctls"])
            check_type(argname="argument container_log_max_files", value=container_log_max_files, expected_type=type_hints["container_log_max_files"])
            check_type(argname="argument container_log_max_size", value=container_log_max_size, expected_type=type_hints["container_log_max_size"])
            check_type(argname="argument cpu_cfs_quota", value=cpu_cfs_quota, expected_type=type_hints["cpu_cfs_quota"])
            check_type(argname="argument cpu_cfs_quota_period", value=cpu_cfs_quota_period, expected_type=type_hints["cpu_cfs_quota_period"])
            check_type(argname="argument cpu_manager_policy", value=cpu_manager_policy, expected_type=type_hints["cpu_manager_policy"])
            check_type(argname="argument eviction_max_pod_grace_period_seconds", value=eviction_max_pod_grace_period_seconds, expected_type=type_hints["eviction_max_pod_grace_period_seconds"])
            check_type(argname="argument eviction_minimum_reclaim", value=eviction_minimum_reclaim, expected_type=type_hints["eviction_minimum_reclaim"])
            check_type(argname="argument eviction_soft", value=eviction_soft, expected_type=type_hints["eviction_soft"])
            check_type(argname="argument eviction_soft_grace_period", value=eviction_soft_grace_period, expected_type=type_hints["eviction_soft_grace_period"])
            check_type(argname="argument image_gc_high_threshold_percent", value=image_gc_high_threshold_percent, expected_type=type_hints["image_gc_high_threshold_percent"])
            check_type(argname="argument image_gc_low_threshold_percent", value=image_gc_low_threshold_percent, expected_type=type_hints["image_gc_low_threshold_percent"])
            check_type(argname="argument image_maximum_gc_age", value=image_maximum_gc_age, expected_type=type_hints["image_maximum_gc_age"])
            check_type(argname="argument image_minimum_gc_age", value=image_minimum_gc_age, expected_type=type_hints["image_minimum_gc_age"])
            check_type(argname="argument insecure_kubelet_readonly_port_enabled", value=insecure_kubelet_readonly_port_enabled, expected_type=type_hints["insecure_kubelet_readonly_port_enabled"])
            check_type(argname="argument max_parallel_image_pulls", value=max_parallel_image_pulls, expected_type=type_hints["max_parallel_image_pulls"])
            check_type(argname="argument pod_pids_limit", value=pod_pids_limit, expected_type=type_hints["pod_pids_limit"])
            check_type(argname="argument single_process_oom_kill", value=single_process_oom_kill, expected_type=type_hints["single_process_oom_kill"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if allowed_unsafe_sysctls is not None:
            self._values["allowed_unsafe_sysctls"] = allowed_unsafe_sysctls
        if container_log_max_files is not None:
            self._values["container_log_max_files"] = container_log_max_files
        if container_log_max_size is not None:
            self._values["container_log_max_size"] = container_log_max_size
        if cpu_cfs_quota is not None:
            self._values["cpu_cfs_quota"] = cpu_cfs_quota
        if cpu_cfs_quota_period is not None:
            self._values["cpu_cfs_quota_period"] = cpu_cfs_quota_period
        if cpu_manager_policy is not None:
            self._values["cpu_manager_policy"] = cpu_manager_policy
        if eviction_max_pod_grace_period_seconds is not None:
            self._values["eviction_max_pod_grace_period_seconds"] = eviction_max_pod_grace_period_seconds
        if eviction_minimum_reclaim is not None:
            self._values["eviction_minimum_reclaim"] = eviction_minimum_reclaim
        if eviction_soft is not None:
            self._values["eviction_soft"] = eviction_soft
        if eviction_soft_grace_period is not None:
            self._values["eviction_soft_grace_period"] = eviction_soft_grace_period
        if image_gc_high_threshold_percent is not None:
            self._values["image_gc_high_threshold_percent"] = image_gc_high_threshold_percent
        if image_gc_low_threshold_percent is not None:
            self._values["image_gc_low_threshold_percent"] = image_gc_low_threshold_percent
        if image_maximum_gc_age is not None:
            self._values["image_maximum_gc_age"] = image_maximum_gc_age
        if image_minimum_gc_age is not None:
            self._values["image_minimum_gc_age"] = image_minimum_gc_age
        if insecure_kubelet_readonly_port_enabled is not None:
            self._values["insecure_kubelet_readonly_port_enabled"] = insecure_kubelet_readonly_port_enabled
        if max_parallel_image_pulls is not None:
            self._values["max_parallel_image_pulls"] = max_parallel_image_pulls
        if pod_pids_limit is not None:
            self._values["pod_pids_limit"] = pod_pids_limit
        if single_process_oom_kill is not None:
            self._values["single_process_oom_kill"] = single_process_oom_kill

    @builtins.property
    def allowed_unsafe_sysctls(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Defines a comma-separated allowlist of unsafe sysctls or sysctl patterns which can be set on the Pods.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#allowed_unsafe_sysctls ContainerCluster#allowed_unsafe_sysctls}
        '''
        result = self._values.get("allowed_unsafe_sysctls")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def container_log_max_files(self) -> typing.Optional[jsii.Number]:
        '''Defines the maximum number of container log files that can be present for a container.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#container_log_max_files ContainerCluster#container_log_max_files}
        '''
        result = self._values.get("container_log_max_files")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def container_log_max_size(self) -> typing.Optional[builtins.str]:
        '''Defines the maximum size of the container log file before it is rotated.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#container_log_max_size ContainerCluster#container_log_max_size}
        '''
        result = self._values.get("container_log_max_size")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def cpu_cfs_quota(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Enable CPU CFS quota enforcement for containers that specify CPU limits.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cpu_cfs_quota ContainerCluster#cpu_cfs_quota}
        '''
        result = self._values.get("cpu_cfs_quota")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def cpu_cfs_quota_period(self) -> typing.Optional[builtins.str]:
        '''Set the CPU CFS quota period value 'cpu.cfs_period_us'.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cpu_cfs_quota_period ContainerCluster#cpu_cfs_quota_period}
        '''
        result = self._values.get("cpu_cfs_quota_period")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def cpu_manager_policy(self) -> typing.Optional[builtins.str]:
        '''Control the CPU management policy on the node.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cpu_manager_policy ContainerCluster#cpu_manager_policy}
        '''
        result = self._values.get("cpu_manager_policy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def eviction_max_pod_grace_period_seconds(self) -> typing.Optional[jsii.Number]:
        '''Defines the maximum allowed grace period (in seconds) to use when terminating pods in response to a soft eviction threshold being met.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#eviction_max_pod_grace_period_seconds ContainerCluster#eviction_max_pod_grace_period_seconds}
        '''
        result = self._values.get("eviction_max_pod_grace_period_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def eviction_minimum_reclaim(
        self,
    ) -> typing.Optional["ContainerClusterNodePoolNodeConfigKubeletConfigEvictionMinimumReclaim"]:
        '''eviction_minimum_reclaim block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#eviction_minimum_reclaim ContainerCluster#eviction_minimum_reclaim}
        '''
        result = self._values.get("eviction_minimum_reclaim")
        return typing.cast(typing.Optional["ContainerClusterNodePoolNodeConfigKubeletConfigEvictionMinimumReclaim"], result)

    @builtins.property
    def eviction_soft(
        self,
    ) -> typing.Optional["ContainerClusterNodePoolNodeConfigKubeletConfigEvictionSoft"]:
        '''eviction_soft block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#eviction_soft ContainerCluster#eviction_soft}
        '''
        result = self._values.get("eviction_soft")
        return typing.cast(typing.Optional["ContainerClusterNodePoolNodeConfigKubeletConfigEvictionSoft"], result)

    @builtins.property
    def eviction_soft_grace_period(
        self,
    ) -> typing.Optional["ContainerClusterNodePoolNodeConfigKubeletConfigEvictionSoftGracePeriod"]:
        '''eviction_soft_grace_period block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#eviction_soft_grace_period ContainerCluster#eviction_soft_grace_period}
        '''
        result = self._values.get("eviction_soft_grace_period")
        return typing.cast(typing.Optional["ContainerClusterNodePoolNodeConfigKubeletConfigEvictionSoftGracePeriod"], result)

    @builtins.property
    def image_gc_high_threshold_percent(self) -> typing.Optional[jsii.Number]:
        '''Defines the percent of disk usage after which image garbage collection is always run.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#image_gc_high_threshold_percent ContainerCluster#image_gc_high_threshold_percent}
        '''
        result = self._values.get("image_gc_high_threshold_percent")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def image_gc_low_threshold_percent(self) -> typing.Optional[jsii.Number]:
        '''Defines the percent of disk usage before which image garbage collection is never run.

        Lowest disk usage to garbage collect to.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#image_gc_low_threshold_percent ContainerCluster#image_gc_low_threshold_percent}
        '''
        result = self._values.get("image_gc_low_threshold_percent")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def image_maximum_gc_age(self) -> typing.Optional[builtins.str]:
        '''Defines the maximum age an image can be unused before it is garbage collected.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#image_maximum_gc_age ContainerCluster#image_maximum_gc_age}
        '''
        result = self._values.get("image_maximum_gc_age")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def image_minimum_gc_age(self) -> typing.Optional[builtins.str]:
        '''Defines the minimum age for an unused image before it is garbage collected.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#image_minimum_gc_age ContainerCluster#image_minimum_gc_age}
        '''
        result = self._values.get("image_minimum_gc_age")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def insecure_kubelet_readonly_port_enabled(self) -> typing.Optional[builtins.str]:
        '''Controls whether the kubelet read-only port is enabled.

        It is strongly recommended to set this to ``FALSE``. Possible values: ``TRUE``, ``FALSE``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#insecure_kubelet_readonly_port_enabled ContainerCluster#insecure_kubelet_readonly_port_enabled}
        '''
        result = self._values.get("insecure_kubelet_readonly_port_enabled")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def max_parallel_image_pulls(self) -> typing.Optional[jsii.Number]:
        '''Set the maximum number of image pulls in parallel.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#max_parallel_image_pulls ContainerCluster#max_parallel_image_pulls}
        '''
        result = self._values.get("max_parallel_image_pulls")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def pod_pids_limit(self) -> typing.Optional[jsii.Number]:
        '''Controls the maximum number of processes allowed to run in a pod.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#pod_pids_limit ContainerCluster#pod_pids_limit}
        '''
        result = self._values.get("pod_pids_limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def single_process_oom_kill(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Defines whether to enable single process OOM killer.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#single_process_oom_kill ContainerCluster#single_process_oom_kill}
        '''
        result = self._values.get("single_process_oom_kill")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodePoolNodeConfigKubeletConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigKubeletConfigEvictionMinimumReclaim",
    jsii_struct_bases=[],
    name_mapping={
        "imagefs_available": "imagefsAvailable",
        "imagefs_inodes_free": "imagefsInodesFree",
        "memory_available": "memoryAvailable",
        "nodefs_available": "nodefsAvailable",
        "nodefs_inodes_free": "nodefsInodesFree",
        "pid_available": "pidAvailable",
    },
)
class ContainerClusterNodePoolNodeConfigKubeletConfigEvictionMinimumReclaim:
    def __init__(
        self,
        *,
        imagefs_available: typing.Optional[builtins.str] = None,
        imagefs_inodes_free: typing.Optional[builtins.str] = None,
        memory_available: typing.Optional[builtins.str] = None,
        nodefs_available: typing.Optional[builtins.str] = None,
        nodefs_inodes_free: typing.Optional[builtins.str] = None,
        pid_available: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param imagefs_available: Defines percentage of minimum reclaim for imagefs.available. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#imagefs_available ContainerCluster#imagefs_available}
        :param imagefs_inodes_free: Defines percentage of minimum reclaim for imagefs.inodesFree. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#imagefs_inodes_free ContainerCluster#imagefs_inodes_free}
        :param memory_available: Defines percentage of minimum reclaim for memory.available. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#memory_available ContainerCluster#memory_available}
        :param nodefs_available: Defines percentage of minimum reclaim for nodefs.available. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#nodefs_available ContainerCluster#nodefs_available}
        :param nodefs_inodes_free: Defines percentage of minimum reclaim for nodefs.inodesFree. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#nodefs_inodes_free ContainerCluster#nodefs_inodes_free}
        :param pid_available: Defines percentage of minimum reclaim for pid.available. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#pid_available ContainerCluster#pid_available}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3b6c80a4c03fec2d3536c2631578d4ddfa6b7eb2d4b27cd3c326ba9509ec55e5)
            check_type(argname="argument imagefs_available", value=imagefs_available, expected_type=type_hints["imagefs_available"])
            check_type(argname="argument imagefs_inodes_free", value=imagefs_inodes_free, expected_type=type_hints["imagefs_inodes_free"])
            check_type(argname="argument memory_available", value=memory_available, expected_type=type_hints["memory_available"])
            check_type(argname="argument nodefs_available", value=nodefs_available, expected_type=type_hints["nodefs_available"])
            check_type(argname="argument nodefs_inodes_free", value=nodefs_inodes_free, expected_type=type_hints["nodefs_inodes_free"])
            check_type(argname="argument pid_available", value=pid_available, expected_type=type_hints["pid_available"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if imagefs_available is not None:
            self._values["imagefs_available"] = imagefs_available
        if imagefs_inodes_free is not None:
            self._values["imagefs_inodes_free"] = imagefs_inodes_free
        if memory_available is not None:
            self._values["memory_available"] = memory_available
        if nodefs_available is not None:
            self._values["nodefs_available"] = nodefs_available
        if nodefs_inodes_free is not None:
            self._values["nodefs_inodes_free"] = nodefs_inodes_free
        if pid_available is not None:
            self._values["pid_available"] = pid_available

    @builtins.property
    def imagefs_available(self) -> typing.Optional[builtins.str]:
        '''Defines percentage of minimum reclaim for imagefs.available.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#imagefs_available ContainerCluster#imagefs_available}
        '''
        result = self._values.get("imagefs_available")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def imagefs_inodes_free(self) -> typing.Optional[builtins.str]:
        '''Defines percentage of minimum reclaim for imagefs.inodesFree.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#imagefs_inodes_free ContainerCluster#imagefs_inodes_free}
        '''
        result = self._values.get("imagefs_inodes_free")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def memory_available(self) -> typing.Optional[builtins.str]:
        '''Defines percentage of minimum reclaim for memory.available.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#memory_available ContainerCluster#memory_available}
        '''
        result = self._values.get("memory_available")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def nodefs_available(self) -> typing.Optional[builtins.str]:
        '''Defines percentage of minimum reclaim for nodefs.available.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#nodefs_available ContainerCluster#nodefs_available}
        '''
        result = self._values.get("nodefs_available")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def nodefs_inodes_free(self) -> typing.Optional[builtins.str]:
        '''Defines percentage of minimum reclaim for nodefs.inodesFree.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#nodefs_inodes_free ContainerCluster#nodefs_inodes_free}
        '''
        result = self._values.get("nodefs_inodes_free")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def pid_available(self) -> typing.Optional[builtins.str]:
        '''Defines percentage of minimum reclaim for pid.available.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#pid_available ContainerCluster#pid_available}
        '''
        result = self._values.get("pid_available")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodePoolNodeConfigKubeletConfigEvictionMinimumReclaim(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodePoolNodeConfigKubeletConfigEvictionMinimumReclaimOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigKubeletConfigEvictionMinimumReclaimOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__72420c58d89ddf09a2aeaf3084315ccdaf8b84eb2c85bd13239e3465cc32681e)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetImagefsAvailable")
    def reset_imagefs_available(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetImagefsAvailable", []))

    @jsii.member(jsii_name="resetImagefsInodesFree")
    def reset_imagefs_inodes_free(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetImagefsInodesFree", []))

    @jsii.member(jsii_name="resetMemoryAvailable")
    def reset_memory_available(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMemoryAvailable", []))

    @jsii.member(jsii_name="resetNodefsAvailable")
    def reset_nodefs_available(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNodefsAvailable", []))

    @jsii.member(jsii_name="resetNodefsInodesFree")
    def reset_nodefs_inodes_free(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNodefsInodesFree", []))

    @jsii.member(jsii_name="resetPidAvailable")
    def reset_pid_available(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPidAvailable", []))

    @builtins.property
    @jsii.member(jsii_name="imagefsAvailableInput")
    def imagefs_available_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "imagefsAvailableInput"))

    @builtins.property
    @jsii.member(jsii_name="imagefsInodesFreeInput")
    def imagefs_inodes_free_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "imagefsInodesFreeInput"))

    @builtins.property
    @jsii.member(jsii_name="memoryAvailableInput")
    def memory_available_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "memoryAvailableInput"))

    @builtins.property
    @jsii.member(jsii_name="nodefsAvailableInput")
    def nodefs_available_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nodefsAvailableInput"))

    @builtins.property
    @jsii.member(jsii_name="nodefsInodesFreeInput")
    def nodefs_inodes_free_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nodefsInodesFreeInput"))

    @builtins.property
    @jsii.member(jsii_name="pidAvailableInput")
    def pid_available_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "pidAvailableInput"))

    @builtins.property
    @jsii.member(jsii_name="imagefsAvailable")
    def imagefs_available(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "imagefsAvailable"))

    @imagefs_available.setter
    def imagefs_available(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1d441c78259b523f8922c2faf75188e949af004805d5e09f868b23dc8e312407)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "imagefsAvailable", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="imagefsInodesFree")
    def imagefs_inodes_free(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "imagefsInodesFree"))

    @imagefs_inodes_free.setter
    def imagefs_inodes_free(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__452b92683412e76afc614c977182bcb3cf337b69431906e8b6341e9ca8c7e69a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "imagefsInodesFree", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="memoryAvailable")
    def memory_available(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "memoryAvailable"))

    @memory_available.setter
    def memory_available(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a538d0d4af228bed560a507618e1fe3b559e427defd0b65224eb1290c052beec)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "memoryAvailable", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="nodefsAvailable")
    def nodefs_available(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "nodefsAvailable"))

    @nodefs_available.setter
    def nodefs_available(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f4e85515afefb7e1b5f23249e7df26deb9a24d96c3d76983a48de3b76cdf1862)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "nodefsAvailable", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="nodefsInodesFree")
    def nodefs_inodes_free(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "nodefsInodesFree"))

    @nodefs_inodes_free.setter
    def nodefs_inodes_free(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__24ddfab9726caf01715e0f2b76f92d9632c384e2e80d6384c78e83585b72bbdf)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "nodefsInodesFree", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="pidAvailable")
    def pid_available(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "pidAvailable"))

    @pid_available.setter
    def pid_available(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0083cd1f4058eadc72cf40adffe56b55d355d094e88d80abc8b8e0e6c6b0d727)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "pidAvailable", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolNodeConfigKubeletConfigEvictionMinimumReclaim]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolNodeConfigKubeletConfigEvictionMinimumReclaim], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodePoolNodeConfigKubeletConfigEvictionMinimumReclaim],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7c423061562b5c35b4452ba0049f416b780c5a6effab1ea10f8ab91fefbd290c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigKubeletConfigEvictionSoft",
    jsii_struct_bases=[],
    name_mapping={
        "imagefs_available": "imagefsAvailable",
        "imagefs_inodes_free": "imagefsInodesFree",
        "memory_available": "memoryAvailable",
        "nodefs_available": "nodefsAvailable",
        "nodefs_inodes_free": "nodefsInodesFree",
        "pid_available": "pidAvailable",
    },
)
class ContainerClusterNodePoolNodeConfigKubeletConfigEvictionSoft:
    def __init__(
        self,
        *,
        imagefs_available: typing.Optional[builtins.str] = None,
        imagefs_inodes_free: typing.Optional[builtins.str] = None,
        memory_available: typing.Optional[builtins.str] = None,
        nodefs_available: typing.Optional[builtins.str] = None,
        nodefs_inodes_free: typing.Optional[builtins.str] = None,
        pid_available: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param imagefs_available: Defines percentage of soft eviction threshold for imagefs.available. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#imagefs_available ContainerCluster#imagefs_available}
        :param imagefs_inodes_free: Defines percentage of soft eviction threshold for imagefs.inodesFree. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#imagefs_inodes_free ContainerCluster#imagefs_inodes_free}
        :param memory_available: Defines quantity of soft eviction threshold for memory.available. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#memory_available ContainerCluster#memory_available}
        :param nodefs_available: Defines percentage of soft eviction threshold for nodefs.available. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#nodefs_available ContainerCluster#nodefs_available}
        :param nodefs_inodes_free: Defines percentage of soft eviction threshold for nodefs.inodesFree. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#nodefs_inodes_free ContainerCluster#nodefs_inodes_free}
        :param pid_available: Defines percentage of soft eviction threshold for pid.available. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#pid_available ContainerCluster#pid_available}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4bec9b950c1b35af28e94b186eb2e5b0dd7c75f3cae3f1d993036c591c1533d4)
            check_type(argname="argument imagefs_available", value=imagefs_available, expected_type=type_hints["imagefs_available"])
            check_type(argname="argument imagefs_inodes_free", value=imagefs_inodes_free, expected_type=type_hints["imagefs_inodes_free"])
            check_type(argname="argument memory_available", value=memory_available, expected_type=type_hints["memory_available"])
            check_type(argname="argument nodefs_available", value=nodefs_available, expected_type=type_hints["nodefs_available"])
            check_type(argname="argument nodefs_inodes_free", value=nodefs_inodes_free, expected_type=type_hints["nodefs_inodes_free"])
            check_type(argname="argument pid_available", value=pid_available, expected_type=type_hints["pid_available"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if imagefs_available is not None:
            self._values["imagefs_available"] = imagefs_available
        if imagefs_inodes_free is not None:
            self._values["imagefs_inodes_free"] = imagefs_inodes_free
        if memory_available is not None:
            self._values["memory_available"] = memory_available
        if nodefs_available is not None:
            self._values["nodefs_available"] = nodefs_available
        if nodefs_inodes_free is not None:
            self._values["nodefs_inodes_free"] = nodefs_inodes_free
        if pid_available is not None:
            self._values["pid_available"] = pid_available

    @builtins.property
    def imagefs_available(self) -> typing.Optional[builtins.str]:
        '''Defines percentage of soft eviction threshold for imagefs.available.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#imagefs_available ContainerCluster#imagefs_available}
        '''
        result = self._values.get("imagefs_available")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def imagefs_inodes_free(self) -> typing.Optional[builtins.str]:
        '''Defines percentage of soft eviction threshold for imagefs.inodesFree.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#imagefs_inodes_free ContainerCluster#imagefs_inodes_free}
        '''
        result = self._values.get("imagefs_inodes_free")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def memory_available(self) -> typing.Optional[builtins.str]:
        '''Defines quantity of soft eviction threshold for memory.available.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#memory_available ContainerCluster#memory_available}
        '''
        result = self._values.get("memory_available")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def nodefs_available(self) -> typing.Optional[builtins.str]:
        '''Defines percentage of soft eviction threshold for nodefs.available.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#nodefs_available ContainerCluster#nodefs_available}
        '''
        result = self._values.get("nodefs_available")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def nodefs_inodes_free(self) -> typing.Optional[builtins.str]:
        '''Defines percentage of soft eviction threshold for nodefs.inodesFree.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#nodefs_inodes_free ContainerCluster#nodefs_inodes_free}
        '''
        result = self._values.get("nodefs_inodes_free")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def pid_available(self) -> typing.Optional[builtins.str]:
        '''Defines percentage of soft eviction threshold for pid.available.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#pid_available ContainerCluster#pid_available}
        '''
        result = self._values.get("pid_available")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodePoolNodeConfigKubeletConfigEvictionSoft(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigKubeletConfigEvictionSoftGracePeriod",
    jsii_struct_bases=[],
    name_mapping={
        "imagefs_available": "imagefsAvailable",
        "imagefs_inodes_free": "imagefsInodesFree",
        "memory_available": "memoryAvailable",
        "nodefs_available": "nodefsAvailable",
        "nodefs_inodes_free": "nodefsInodesFree",
        "pid_available": "pidAvailable",
    },
)
class ContainerClusterNodePoolNodeConfigKubeletConfigEvictionSoftGracePeriod:
    def __init__(
        self,
        *,
        imagefs_available: typing.Optional[builtins.str] = None,
        imagefs_inodes_free: typing.Optional[builtins.str] = None,
        memory_available: typing.Optional[builtins.str] = None,
        nodefs_available: typing.Optional[builtins.str] = None,
        nodefs_inodes_free: typing.Optional[builtins.str] = None,
        pid_available: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param imagefs_available: Defines grace period for the imagefs.available soft eviction threshold. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#imagefs_available ContainerCluster#imagefs_available}
        :param imagefs_inodes_free: Defines grace period for the imagefs.inodesFree soft eviction threshold. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#imagefs_inodes_free ContainerCluster#imagefs_inodes_free}
        :param memory_available: Defines grace period for the memory.available soft eviction threshold. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#memory_available ContainerCluster#memory_available}
        :param nodefs_available: Defines grace period for the nodefs.available soft eviction threshold. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#nodefs_available ContainerCluster#nodefs_available}
        :param nodefs_inodes_free: Defines grace period for the nodefs.inodesFree soft eviction threshold. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#nodefs_inodes_free ContainerCluster#nodefs_inodes_free}
        :param pid_available: Defines grace period for the pid.available soft eviction threshold. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#pid_available ContainerCluster#pid_available}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__04f15e3cd119962331bbeed39edaf9c9fb1f2502e2d4f795ad7cff3e6796eca1)
            check_type(argname="argument imagefs_available", value=imagefs_available, expected_type=type_hints["imagefs_available"])
            check_type(argname="argument imagefs_inodes_free", value=imagefs_inodes_free, expected_type=type_hints["imagefs_inodes_free"])
            check_type(argname="argument memory_available", value=memory_available, expected_type=type_hints["memory_available"])
            check_type(argname="argument nodefs_available", value=nodefs_available, expected_type=type_hints["nodefs_available"])
            check_type(argname="argument nodefs_inodes_free", value=nodefs_inodes_free, expected_type=type_hints["nodefs_inodes_free"])
            check_type(argname="argument pid_available", value=pid_available, expected_type=type_hints["pid_available"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if imagefs_available is not None:
            self._values["imagefs_available"] = imagefs_available
        if imagefs_inodes_free is not None:
            self._values["imagefs_inodes_free"] = imagefs_inodes_free
        if memory_available is not None:
            self._values["memory_available"] = memory_available
        if nodefs_available is not None:
            self._values["nodefs_available"] = nodefs_available
        if nodefs_inodes_free is not None:
            self._values["nodefs_inodes_free"] = nodefs_inodes_free
        if pid_available is not None:
            self._values["pid_available"] = pid_available

    @builtins.property
    def imagefs_available(self) -> typing.Optional[builtins.str]:
        '''Defines grace period for the imagefs.available soft eviction threshold.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#imagefs_available ContainerCluster#imagefs_available}
        '''
        result = self._values.get("imagefs_available")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def imagefs_inodes_free(self) -> typing.Optional[builtins.str]:
        '''Defines grace period for the imagefs.inodesFree soft eviction threshold.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#imagefs_inodes_free ContainerCluster#imagefs_inodes_free}
        '''
        result = self._values.get("imagefs_inodes_free")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def memory_available(self) -> typing.Optional[builtins.str]:
        '''Defines grace period for the memory.available soft eviction threshold.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#memory_available ContainerCluster#memory_available}
        '''
        result = self._values.get("memory_available")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def nodefs_available(self) -> typing.Optional[builtins.str]:
        '''Defines grace period for the nodefs.available soft eviction threshold.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#nodefs_available ContainerCluster#nodefs_available}
        '''
        result = self._values.get("nodefs_available")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def nodefs_inodes_free(self) -> typing.Optional[builtins.str]:
        '''Defines grace period for the nodefs.inodesFree soft eviction threshold.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#nodefs_inodes_free ContainerCluster#nodefs_inodes_free}
        '''
        result = self._values.get("nodefs_inodes_free")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def pid_available(self) -> typing.Optional[builtins.str]:
        '''Defines grace period for the pid.available soft eviction threshold.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#pid_available ContainerCluster#pid_available}
        '''
        result = self._values.get("pid_available")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodePoolNodeConfigKubeletConfigEvictionSoftGracePeriod(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodePoolNodeConfigKubeletConfigEvictionSoftGracePeriodOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigKubeletConfigEvictionSoftGracePeriodOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a87d33af639a9d8b7ca39f8476ccb60071ee868d2c32db0263dd71960806a795)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetImagefsAvailable")
    def reset_imagefs_available(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetImagefsAvailable", []))

    @jsii.member(jsii_name="resetImagefsInodesFree")
    def reset_imagefs_inodes_free(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetImagefsInodesFree", []))

    @jsii.member(jsii_name="resetMemoryAvailable")
    def reset_memory_available(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMemoryAvailable", []))

    @jsii.member(jsii_name="resetNodefsAvailable")
    def reset_nodefs_available(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNodefsAvailable", []))

    @jsii.member(jsii_name="resetNodefsInodesFree")
    def reset_nodefs_inodes_free(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNodefsInodesFree", []))

    @jsii.member(jsii_name="resetPidAvailable")
    def reset_pid_available(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPidAvailable", []))

    @builtins.property
    @jsii.member(jsii_name="imagefsAvailableInput")
    def imagefs_available_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "imagefsAvailableInput"))

    @builtins.property
    @jsii.member(jsii_name="imagefsInodesFreeInput")
    def imagefs_inodes_free_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "imagefsInodesFreeInput"))

    @builtins.property
    @jsii.member(jsii_name="memoryAvailableInput")
    def memory_available_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "memoryAvailableInput"))

    @builtins.property
    @jsii.member(jsii_name="nodefsAvailableInput")
    def nodefs_available_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nodefsAvailableInput"))

    @builtins.property
    @jsii.member(jsii_name="nodefsInodesFreeInput")
    def nodefs_inodes_free_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nodefsInodesFreeInput"))

    @builtins.property
    @jsii.member(jsii_name="pidAvailableInput")
    def pid_available_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "pidAvailableInput"))

    @builtins.property
    @jsii.member(jsii_name="imagefsAvailable")
    def imagefs_available(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "imagefsAvailable"))

    @imagefs_available.setter
    def imagefs_available(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__19332fba63d5337f74e87a86918d8c7402d829a14f8728ccd216ea9ceb8db91f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "imagefsAvailable", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="imagefsInodesFree")
    def imagefs_inodes_free(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "imagefsInodesFree"))

    @imagefs_inodes_free.setter
    def imagefs_inodes_free(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b79aa85e67e79f5022e68b1ed05cccfecf2474368a0c38cfd7b9726654b947ce)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "imagefsInodesFree", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="memoryAvailable")
    def memory_available(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "memoryAvailable"))

    @memory_available.setter
    def memory_available(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b65733fade713c99f372ee58679c0d7bdd98926f8958e781d6523deaadd0b6fa)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "memoryAvailable", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="nodefsAvailable")
    def nodefs_available(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "nodefsAvailable"))

    @nodefs_available.setter
    def nodefs_available(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__482048a372f004eb1d48e67ad15a6a9b85d89958b7a49515512d8ee538478a86)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "nodefsAvailable", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="nodefsInodesFree")
    def nodefs_inodes_free(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "nodefsInodesFree"))

    @nodefs_inodes_free.setter
    def nodefs_inodes_free(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__af5b1ca480442d8795e980ac4ce0c4ffa80dd896a83cf55effd5af08689b9823)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "nodefsInodesFree", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="pidAvailable")
    def pid_available(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "pidAvailable"))

    @pid_available.setter
    def pid_available(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e28ef50b18c4b1a5c92d5de4bcf489753ced1cffa9b0de7c69a08019ceeab374)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "pidAvailable", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolNodeConfigKubeletConfigEvictionSoftGracePeriod]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolNodeConfigKubeletConfigEvictionSoftGracePeriod], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodePoolNodeConfigKubeletConfigEvictionSoftGracePeriod],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3a51f521468203ac470aa8735c4a4f5566efe70c08b0b976e161da9dc7489880)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ContainerClusterNodePoolNodeConfigKubeletConfigEvictionSoftOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigKubeletConfigEvictionSoftOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9c4e6b74953672daa624485323ab335358345643bb0bdf32825f503cbb23abaa)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetImagefsAvailable")
    def reset_imagefs_available(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetImagefsAvailable", []))

    @jsii.member(jsii_name="resetImagefsInodesFree")
    def reset_imagefs_inodes_free(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetImagefsInodesFree", []))

    @jsii.member(jsii_name="resetMemoryAvailable")
    def reset_memory_available(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMemoryAvailable", []))

    @jsii.member(jsii_name="resetNodefsAvailable")
    def reset_nodefs_available(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNodefsAvailable", []))

    @jsii.member(jsii_name="resetNodefsInodesFree")
    def reset_nodefs_inodes_free(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNodefsInodesFree", []))

    @jsii.member(jsii_name="resetPidAvailable")
    def reset_pid_available(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPidAvailable", []))

    @builtins.property
    @jsii.member(jsii_name="imagefsAvailableInput")
    def imagefs_available_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "imagefsAvailableInput"))

    @builtins.property
    @jsii.member(jsii_name="imagefsInodesFreeInput")
    def imagefs_inodes_free_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "imagefsInodesFreeInput"))

    @builtins.property
    @jsii.member(jsii_name="memoryAvailableInput")
    def memory_available_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "memoryAvailableInput"))

    @builtins.property
    @jsii.member(jsii_name="nodefsAvailableInput")
    def nodefs_available_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nodefsAvailableInput"))

    @builtins.property
    @jsii.member(jsii_name="nodefsInodesFreeInput")
    def nodefs_inodes_free_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nodefsInodesFreeInput"))

    @builtins.property
    @jsii.member(jsii_name="pidAvailableInput")
    def pid_available_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "pidAvailableInput"))

    @builtins.property
    @jsii.member(jsii_name="imagefsAvailable")
    def imagefs_available(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "imagefsAvailable"))

    @imagefs_available.setter
    def imagefs_available(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fb303b2f2c11f561db71abb2d28d7bb665afda0ecf872a2814edb28ecbe6b680)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "imagefsAvailable", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="imagefsInodesFree")
    def imagefs_inodes_free(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "imagefsInodesFree"))

    @imagefs_inodes_free.setter
    def imagefs_inodes_free(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b7f48becb896fc13082b88891e659cd25df0c9d238493f27c995971ba570e6ab)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "imagefsInodesFree", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="memoryAvailable")
    def memory_available(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "memoryAvailable"))

    @memory_available.setter
    def memory_available(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b17c8df12743a0c981fe6ec967c459e9d0fd5a83c7c9cdc0a9722d7076af7074)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "memoryAvailable", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="nodefsAvailable")
    def nodefs_available(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "nodefsAvailable"))

    @nodefs_available.setter
    def nodefs_available(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bf0254476f448870b9086dd28a69f777e0246f07e8483e9df6d4798ea4645b73)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "nodefsAvailable", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="nodefsInodesFree")
    def nodefs_inodes_free(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "nodefsInodesFree"))

    @nodefs_inodes_free.setter
    def nodefs_inodes_free(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a461f2a00acdc4b2d755d0ff83eb8d08f3e970d54d3cebb0729d1567b4f3b164)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "nodefsInodesFree", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="pidAvailable")
    def pid_available(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "pidAvailable"))

    @pid_available.setter
    def pid_available(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c7227fb61963fe2b7d03890581d4da50ed04ccf7bf9ad23ed6b07050e67c8be3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "pidAvailable", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolNodeConfigKubeletConfigEvictionSoft]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolNodeConfigKubeletConfigEvictionSoft], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodePoolNodeConfigKubeletConfigEvictionSoft],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d8dffdbc5550f7f63dc2bddf8c7035d3aa40e1831630126f3793c2644765f7f4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ContainerClusterNodePoolNodeConfigKubeletConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigKubeletConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d109feba51f4c70d724a5ffb8b4544a37d9f7b459957db51588737139ba200bf)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putEvictionMinimumReclaim")
    def put_eviction_minimum_reclaim(
        self,
        *,
        imagefs_available: typing.Optional[builtins.str] = None,
        imagefs_inodes_free: typing.Optional[builtins.str] = None,
        memory_available: typing.Optional[builtins.str] = None,
        nodefs_available: typing.Optional[builtins.str] = None,
        nodefs_inodes_free: typing.Optional[builtins.str] = None,
        pid_available: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param imagefs_available: Defines percentage of minimum reclaim for imagefs.available. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#imagefs_available ContainerCluster#imagefs_available}
        :param imagefs_inodes_free: Defines percentage of minimum reclaim for imagefs.inodesFree. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#imagefs_inodes_free ContainerCluster#imagefs_inodes_free}
        :param memory_available: Defines percentage of minimum reclaim for memory.available. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#memory_available ContainerCluster#memory_available}
        :param nodefs_available: Defines percentage of minimum reclaim for nodefs.available. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#nodefs_available ContainerCluster#nodefs_available}
        :param nodefs_inodes_free: Defines percentage of minimum reclaim for nodefs.inodesFree. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#nodefs_inodes_free ContainerCluster#nodefs_inodes_free}
        :param pid_available: Defines percentage of minimum reclaim for pid.available. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#pid_available ContainerCluster#pid_available}
        '''
        value = ContainerClusterNodePoolNodeConfigKubeletConfigEvictionMinimumReclaim(
            imagefs_available=imagefs_available,
            imagefs_inodes_free=imagefs_inodes_free,
            memory_available=memory_available,
            nodefs_available=nodefs_available,
            nodefs_inodes_free=nodefs_inodes_free,
            pid_available=pid_available,
        )

        return typing.cast(None, jsii.invoke(self, "putEvictionMinimumReclaim", [value]))

    @jsii.member(jsii_name="putEvictionSoft")
    def put_eviction_soft(
        self,
        *,
        imagefs_available: typing.Optional[builtins.str] = None,
        imagefs_inodes_free: typing.Optional[builtins.str] = None,
        memory_available: typing.Optional[builtins.str] = None,
        nodefs_available: typing.Optional[builtins.str] = None,
        nodefs_inodes_free: typing.Optional[builtins.str] = None,
        pid_available: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param imagefs_available: Defines percentage of soft eviction threshold for imagefs.available. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#imagefs_available ContainerCluster#imagefs_available}
        :param imagefs_inodes_free: Defines percentage of soft eviction threshold for imagefs.inodesFree. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#imagefs_inodes_free ContainerCluster#imagefs_inodes_free}
        :param memory_available: Defines quantity of soft eviction threshold for memory.available. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#memory_available ContainerCluster#memory_available}
        :param nodefs_available: Defines percentage of soft eviction threshold for nodefs.available. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#nodefs_available ContainerCluster#nodefs_available}
        :param nodefs_inodes_free: Defines percentage of soft eviction threshold for nodefs.inodesFree. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#nodefs_inodes_free ContainerCluster#nodefs_inodes_free}
        :param pid_available: Defines percentage of soft eviction threshold for pid.available. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#pid_available ContainerCluster#pid_available}
        '''
        value = ContainerClusterNodePoolNodeConfigKubeletConfigEvictionSoft(
            imagefs_available=imagefs_available,
            imagefs_inodes_free=imagefs_inodes_free,
            memory_available=memory_available,
            nodefs_available=nodefs_available,
            nodefs_inodes_free=nodefs_inodes_free,
            pid_available=pid_available,
        )

        return typing.cast(None, jsii.invoke(self, "putEvictionSoft", [value]))

    @jsii.member(jsii_name="putEvictionSoftGracePeriod")
    def put_eviction_soft_grace_period(
        self,
        *,
        imagefs_available: typing.Optional[builtins.str] = None,
        imagefs_inodes_free: typing.Optional[builtins.str] = None,
        memory_available: typing.Optional[builtins.str] = None,
        nodefs_available: typing.Optional[builtins.str] = None,
        nodefs_inodes_free: typing.Optional[builtins.str] = None,
        pid_available: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param imagefs_available: Defines grace period for the imagefs.available soft eviction threshold. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#imagefs_available ContainerCluster#imagefs_available}
        :param imagefs_inodes_free: Defines grace period for the imagefs.inodesFree soft eviction threshold. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#imagefs_inodes_free ContainerCluster#imagefs_inodes_free}
        :param memory_available: Defines grace period for the memory.available soft eviction threshold. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#memory_available ContainerCluster#memory_available}
        :param nodefs_available: Defines grace period for the nodefs.available soft eviction threshold. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#nodefs_available ContainerCluster#nodefs_available}
        :param nodefs_inodes_free: Defines grace period for the nodefs.inodesFree soft eviction threshold. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#nodefs_inodes_free ContainerCluster#nodefs_inodes_free}
        :param pid_available: Defines grace period for the pid.available soft eviction threshold. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#pid_available ContainerCluster#pid_available}
        '''
        value = ContainerClusterNodePoolNodeConfigKubeletConfigEvictionSoftGracePeriod(
            imagefs_available=imagefs_available,
            imagefs_inodes_free=imagefs_inodes_free,
            memory_available=memory_available,
            nodefs_available=nodefs_available,
            nodefs_inodes_free=nodefs_inodes_free,
            pid_available=pid_available,
        )

        return typing.cast(None, jsii.invoke(self, "putEvictionSoftGracePeriod", [value]))

    @jsii.member(jsii_name="resetAllowedUnsafeSysctls")
    def reset_allowed_unsafe_sysctls(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAllowedUnsafeSysctls", []))

    @jsii.member(jsii_name="resetContainerLogMaxFiles")
    def reset_container_log_max_files(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetContainerLogMaxFiles", []))

    @jsii.member(jsii_name="resetContainerLogMaxSize")
    def reset_container_log_max_size(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetContainerLogMaxSize", []))

    @jsii.member(jsii_name="resetCpuCfsQuota")
    def reset_cpu_cfs_quota(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCpuCfsQuota", []))

    @jsii.member(jsii_name="resetCpuCfsQuotaPeriod")
    def reset_cpu_cfs_quota_period(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCpuCfsQuotaPeriod", []))

    @jsii.member(jsii_name="resetCpuManagerPolicy")
    def reset_cpu_manager_policy(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCpuManagerPolicy", []))

    @jsii.member(jsii_name="resetEvictionMaxPodGracePeriodSeconds")
    def reset_eviction_max_pod_grace_period_seconds(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEvictionMaxPodGracePeriodSeconds", []))

    @jsii.member(jsii_name="resetEvictionMinimumReclaim")
    def reset_eviction_minimum_reclaim(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEvictionMinimumReclaim", []))

    @jsii.member(jsii_name="resetEvictionSoft")
    def reset_eviction_soft(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEvictionSoft", []))

    @jsii.member(jsii_name="resetEvictionSoftGracePeriod")
    def reset_eviction_soft_grace_period(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEvictionSoftGracePeriod", []))

    @jsii.member(jsii_name="resetImageGcHighThresholdPercent")
    def reset_image_gc_high_threshold_percent(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetImageGcHighThresholdPercent", []))

    @jsii.member(jsii_name="resetImageGcLowThresholdPercent")
    def reset_image_gc_low_threshold_percent(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetImageGcLowThresholdPercent", []))

    @jsii.member(jsii_name="resetImageMaximumGcAge")
    def reset_image_maximum_gc_age(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetImageMaximumGcAge", []))

    @jsii.member(jsii_name="resetImageMinimumGcAge")
    def reset_image_minimum_gc_age(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetImageMinimumGcAge", []))

    @jsii.member(jsii_name="resetInsecureKubeletReadonlyPortEnabled")
    def reset_insecure_kubelet_readonly_port_enabled(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetInsecureKubeletReadonlyPortEnabled", []))

    @jsii.member(jsii_name="resetMaxParallelImagePulls")
    def reset_max_parallel_image_pulls(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMaxParallelImagePulls", []))

    @jsii.member(jsii_name="resetPodPidsLimit")
    def reset_pod_pids_limit(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPodPidsLimit", []))

    @jsii.member(jsii_name="resetSingleProcessOomKill")
    def reset_single_process_oom_kill(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSingleProcessOomKill", []))

    @builtins.property
    @jsii.member(jsii_name="evictionMinimumReclaim")
    def eviction_minimum_reclaim(
        self,
    ) -> ContainerClusterNodePoolNodeConfigKubeletConfigEvictionMinimumReclaimOutputReference:
        return typing.cast(ContainerClusterNodePoolNodeConfigKubeletConfigEvictionMinimumReclaimOutputReference, jsii.get(self, "evictionMinimumReclaim"))

    @builtins.property
    @jsii.member(jsii_name="evictionSoft")
    def eviction_soft(
        self,
    ) -> ContainerClusterNodePoolNodeConfigKubeletConfigEvictionSoftOutputReference:
        return typing.cast(ContainerClusterNodePoolNodeConfigKubeletConfigEvictionSoftOutputReference, jsii.get(self, "evictionSoft"))

    @builtins.property
    @jsii.member(jsii_name="evictionSoftGracePeriod")
    def eviction_soft_grace_period(
        self,
    ) -> ContainerClusterNodePoolNodeConfigKubeletConfigEvictionSoftGracePeriodOutputReference:
        return typing.cast(ContainerClusterNodePoolNodeConfigKubeletConfigEvictionSoftGracePeriodOutputReference, jsii.get(self, "evictionSoftGracePeriod"))

    @builtins.property
    @jsii.member(jsii_name="allowedUnsafeSysctlsInput")
    def allowed_unsafe_sysctls_input(
        self,
    ) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "allowedUnsafeSysctlsInput"))

    @builtins.property
    @jsii.member(jsii_name="containerLogMaxFilesInput")
    def container_log_max_files_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "containerLogMaxFilesInput"))

    @builtins.property
    @jsii.member(jsii_name="containerLogMaxSizeInput")
    def container_log_max_size_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "containerLogMaxSizeInput"))

    @builtins.property
    @jsii.member(jsii_name="cpuCfsQuotaInput")
    def cpu_cfs_quota_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "cpuCfsQuotaInput"))

    @builtins.property
    @jsii.member(jsii_name="cpuCfsQuotaPeriodInput")
    def cpu_cfs_quota_period_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "cpuCfsQuotaPeriodInput"))

    @builtins.property
    @jsii.member(jsii_name="cpuManagerPolicyInput")
    def cpu_manager_policy_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "cpuManagerPolicyInput"))

    @builtins.property
    @jsii.member(jsii_name="evictionMaxPodGracePeriodSecondsInput")
    def eviction_max_pod_grace_period_seconds_input(
        self,
    ) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "evictionMaxPodGracePeriodSecondsInput"))

    @builtins.property
    @jsii.member(jsii_name="evictionMinimumReclaimInput")
    def eviction_minimum_reclaim_input(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolNodeConfigKubeletConfigEvictionMinimumReclaim]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolNodeConfigKubeletConfigEvictionMinimumReclaim], jsii.get(self, "evictionMinimumReclaimInput"))

    @builtins.property
    @jsii.member(jsii_name="evictionSoftGracePeriodInput")
    def eviction_soft_grace_period_input(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolNodeConfigKubeletConfigEvictionSoftGracePeriod]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolNodeConfigKubeletConfigEvictionSoftGracePeriod], jsii.get(self, "evictionSoftGracePeriodInput"))

    @builtins.property
    @jsii.member(jsii_name="evictionSoftInput")
    def eviction_soft_input(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolNodeConfigKubeletConfigEvictionSoft]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolNodeConfigKubeletConfigEvictionSoft], jsii.get(self, "evictionSoftInput"))

    @builtins.property
    @jsii.member(jsii_name="imageGcHighThresholdPercentInput")
    def image_gc_high_threshold_percent_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "imageGcHighThresholdPercentInput"))

    @builtins.property
    @jsii.member(jsii_name="imageGcLowThresholdPercentInput")
    def image_gc_low_threshold_percent_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "imageGcLowThresholdPercentInput"))

    @builtins.property
    @jsii.member(jsii_name="imageMaximumGcAgeInput")
    def image_maximum_gc_age_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "imageMaximumGcAgeInput"))

    @builtins.property
    @jsii.member(jsii_name="imageMinimumGcAgeInput")
    def image_minimum_gc_age_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "imageMinimumGcAgeInput"))

    @builtins.property
    @jsii.member(jsii_name="insecureKubeletReadonlyPortEnabledInput")
    def insecure_kubelet_readonly_port_enabled_input(
        self,
    ) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "insecureKubeletReadonlyPortEnabledInput"))

    @builtins.property
    @jsii.member(jsii_name="maxParallelImagePullsInput")
    def max_parallel_image_pulls_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "maxParallelImagePullsInput"))

    @builtins.property
    @jsii.member(jsii_name="podPidsLimitInput")
    def pod_pids_limit_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "podPidsLimitInput"))

    @builtins.property
    @jsii.member(jsii_name="singleProcessOomKillInput")
    def single_process_oom_kill_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "singleProcessOomKillInput"))

    @builtins.property
    @jsii.member(jsii_name="allowedUnsafeSysctls")
    def allowed_unsafe_sysctls(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "allowedUnsafeSysctls"))

    @allowed_unsafe_sysctls.setter
    def allowed_unsafe_sysctls(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__925af7399f34670b29aa4137be9f55e7af1503b677f57172775172a7d6830b9c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "allowedUnsafeSysctls", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="containerLogMaxFiles")
    def container_log_max_files(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "containerLogMaxFiles"))

    @container_log_max_files.setter
    def container_log_max_files(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c02de33cce0a92f2c4214bb0d78163925f56810691423b2fef8813dd80d020a8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "containerLogMaxFiles", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="containerLogMaxSize")
    def container_log_max_size(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "containerLogMaxSize"))

    @container_log_max_size.setter
    def container_log_max_size(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d0ded689ed72b935b7c6c835f9693c065ac02d3cedfa52a6f6e70350cd3ca4fc)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "containerLogMaxSize", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="cpuCfsQuota")
    def cpu_cfs_quota(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "cpuCfsQuota"))

    @cpu_cfs_quota.setter
    def cpu_cfs_quota(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e2ceafaa1e2a312b37ce288ccdcb85c42bdf66834f095634dc510f150e1eca4a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "cpuCfsQuota", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="cpuCfsQuotaPeriod")
    def cpu_cfs_quota_period(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "cpuCfsQuotaPeriod"))

    @cpu_cfs_quota_period.setter
    def cpu_cfs_quota_period(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cfc5b99345d39675314cc585fad9b2816759e4179f9059a02f10e44a2c8cc0e2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "cpuCfsQuotaPeriod", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="cpuManagerPolicy")
    def cpu_manager_policy(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "cpuManagerPolicy"))

    @cpu_manager_policy.setter
    def cpu_manager_policy(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__64feda1719659002731944fa22febc08a371e841221d9d7ecd91f02ba3f3e8c9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "cpuManagerPolicy", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="evictionMaxPodGracePeriodSeconds")
    def eviction_max_pod_grace_period_seconds(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "evictionMaxPodGracePeriodSeconds"))

    @eviction_max_pod_grace_period_seconds.setter
    def eviction_max_pod_grace_period_seconds(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__537e0ac27586fe8a6a584e80ab30304ba931d785bea2ceae588ca63a8b72eae3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "evictionMaxPodGracePeriodSeconds", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="imageGcHighThresholdPercent")
    def image_gc_high_threshold_percent(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "imageGcHighThresholdPercent"))

    @image_gc_high_threshold_percent.setter
    def image_gc_high_threshold_percent(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__37cfb978e4ba03a89223fac561c8634bd8ebf1d149b640c2710576ef4f6055c3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "imageGcHighThresholdPercent", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="imageGcLowThresholdPercent")
    def image_gc_low_threshold_percent(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "imageGcLowThresholdPercent"))

    @image_gc_low_threshold_percent.setter
    def image_gc_low_threshold_percent(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9fcde601c73e28ddc527e394236597acd0135ac4850aa7ad182edffe7836829c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "imageGcLowThresholdPercent", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="imageMaximumGcAge")
    def image_maximum_gc_age(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "imageMaximumGcAge"))

    @image_maximum_gc_age.setter
    def image_maximum_gc_age(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b44aa4154aeb6c3aa69becd892741052d29a2235b03bf2e201cc1644c46827e4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "imageMaximumGcAge", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="imageMinimumGcAge")
    def image_minimum_gc_age(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "imageMinimumGcAge"))

    @image_minimum_gc_age.setter
    def image_minimum_gc_age(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b8238cfc352a6b4a014d3bc024697f46a77c0208a2565d84d8870c42d3255add)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "imageMinimumGcAge", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="insecureKubeletReadonlyPortEnabled")
    def insecure_kubelet_readonly_port_enabled(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "insecureKubeletReadonlyPortEnabled"))

    @insecure_kubelet_readonly_port_enabled.setter
    def insecure_kubelet_readonly_port_enabled(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e370123d0ace95ce23c565c7688e479f5349465a4173a8281ca2b9253abde255)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "insecureKubeletReadonlyPortEnabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="maxParallelImagePulls")
    def max_parallel_image_pulls(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "maxParallelImagePulls"))

    @max_parallel_image_pulls.setter
    def max_parallel_image_pulls(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0c37fcf2b957e282c9eac9227a935249b8bc7c69c815083609eedd6b61354a04)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "maxParallelImagePulls", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="podPidsLimit")
    def pod_pids_limit(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "podPidsLimit"))

    @pod_pids_limit.setter
    def pod_pids_limit(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b7579fec24ebb7b93199c18f2742e1e9b2488ca11b9babfaf459db9b8fb61000)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "podPidsLimit", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="singleProcessOomKill")
    def single_process_oom_kill(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "singleProcessOomKill"))

    @single_process_oom_kill.setter
    def single_process_oom_kill(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b2c670c8572013c32638e394604720436e9b802b847a1a627d259a4bc08cdd49)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "singleProcessOomKill", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolNodeConfigKubeletConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolNodeConfigKubeletConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodePoolNodeConfigKubeletConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0015c7c68c9ee2ac08e755b437f441647a38ea071b69c124f616e2db6de88049)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigLinuxNodeConfig",
    jsii_struct_bases=[],
    name_mapping={
        "cgroup_mode": "cgroupMode",
        "hugepages_config": "hugepagesConfig",
        "sysctls": "sysctls",
        "transparent_hugepage_defrag": "transparentHugepageDefrag",
        "transparent_hugepage_enabled": "transparentHugepageEnabled",
    },
)
class ContainerClusterNodePoolNodeConfigLinuxNodeConfig:
    def __init__(
        self,
        *,
        cgroup_mode: typing.Optional[builtins.str] = None,
        hugepages_config: typing.Optional[typing.Union["ContainerClusterNodePoolNodeConfigLinuxNodeConfigHugepagesConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        sysctls: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        transparent_hugepage_defrag: typing.Optional[builtins.str] = None,
        transparent_hugepage_enabled: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param cgroup_mode: cgroupMode specifies the cgroup mode to be used on the node. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cgroup_mode ContainerCluster#cgroup_mode}
        :param hugepages_config: hugepages_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#hugepages_config ContainerCluster#hugepages_config}
        :param sysctls: The Linux kernel parameters to be applied to the nodes and all pods running on the nodes. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#sysctls ContainerCluster#sysctls}
        :param transparent_hugepage_defrag: The Linux kernel transparent hugepage defrag setting. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#transparent_hugepage_defrag ContainerCluster#transparent_hugepage_defrag}
        :param transparent_hugepage_enabled: The Linux kernel transparent hugepage setting. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#transparent_hugepage_enabled ContainerCluster#transparent_hugepage_enabled}
        '''
        if isinstance(hugepages_config, dict):
            hugepages_config = ContainerClusterNodePoolNodeConfigLinuxNodeConfigHugepagesConfig(**hugepages_config)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6e61ef93528399ecc12e219a25332af83b87c0aac293478edb6d786de5da95fc)
            check_type(argname="argument cgroup_mode", value=cgroup_mode, expected_type=type_hints["cgroup_mode"])
            check_type(argname="argument hugepages_config", value=hugepages_config, expected_type=type_hints["hugepages_config"])
            check_type(argname="argument sysctls", value=sysctls, expected_type=type_hints["sysctls"])
            check_type(argname="argument transparent_hugepage_defrag", value=transparent_hugepage_defrag, expected_type=type_hints["transparent_hugepage_defrag"])
            check_type(argname="argument transparent_hugepage_enabled", value=transparent_hugepage_enabled, expected_type=type_hints["transparent_hugepage_enabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if cgroup_mode is not None:
            self._values["cgroup_mode"] = cgroup_mode
        if hugepages_config is not None:
            self._values["hugepages_config"] = hugepages_config
        if sysctls is not None:
            self._values["sysctls"] = sysctls
        if transparent_hugepage_defrag is not None:
            self._values["transparent_hugepage_defrag"] = transparent_hugepage_defrag
        if transparent_hugepage_enabled is not None:
            self._values["transparent_hugepage_enabled"] = transparent_hugepage_enabled

    @builtins.property
    def cgroup_mode(self) -> typing.Optional[builtins.str]:
        '''cgroupMode specifies the cgroup mode to be used on the node.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cgroup_mode ContainerCluster#cgroup_mode}
        '''
        result = self._values.get("cgroup_mode")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def hugepages_config(
        self,
    ) -> typing.Optional["ContainerClusterNodePoolNodeConfigLinuxNodeConfigHugepagesConfig"]:
        '''hugepages_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#hugepages_config ContainerCluster#hugepages_config}
        '''
        result = self._values.get("hugepages_config")
        return typing.cast(typing.Optional["ContainerClusterNodePoolNodeConfigLinuxNodeConfigHugepagesConfig"], result)

    @builtins.property
    def sysctls(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''The Linux kernel parameters to be applied to the nodes and all pods running on the nodes.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#sysctls ContainerCluster#sysctls}
        '''
        result = self._values.get("sysctls")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def transparent_hugepage_defrag(self) -> typing.Optional[builtins.str]:
        '''The Linux kernel transparent hugepage defrag setting.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#transparent_hugepage_defrag ContainerCluster#transparent_hugepage_defrag}
        '''
        result = self._values.get("transparent_hugepage_defrag")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def transparent_hugepage_enabled(self) -> typing.Optional[builtins.str]:
        '''The Linux kernel transparent hugepage setting.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#transparent_hugepage_enabled ContainerCluster#transparent_hugepage_enabled}
        '''
        result = self._values.get("transparent_hugepage_enabled")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodePoolNodeConfigLinuxNodeConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigLinuxNodeConfigHugepagesConfig",
    jsii_struct_bases=[],
    name_mapping={
        "hugepage_size1_g": "hugepageSize1G",
        "hugepage_size2_m": "hugepageSize2M",
    },
)
class ContainerClusterNodePoolNodeConfigLinuxNodeConfigHugepagesConfig:
    def __init__(
        self,
        *,
        hugepage_size1_g: typing.Optional[jsii.Number] = None,
        hugepage_size2_m: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param hugepage_size1_g: Amount of 1G hugepages. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#hugepage_size_1g ContainerCluster#hugepage_size_1g}
        :param hugepage_size2_m: Amount of 2M hugepages. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#hugepage_size_2m ContainerCluster#hugepage_size_2m}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fd1208040507b6153c45a951f27037c30813df18dfcb4b661e0868ef85638b6f)
            check_type(argname="argument hugepage_size1_g", value=hugepage_size1_g, expected_type=type_hints["hugepage_size1_g"])
            check_type(argname="argument hugepage_size2_m", value=hugepage_size2_m, expected_type=type_hints["hugepage_size2_m"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if hugepage_size1_g is not None:
            self._values["hugepage_size1_g"] = hugepage_size1_g
        if hugepage_size2_m is not None:
            self._values["hugepage_size2_m"] = hugepage_size2_m

    @builtins.property
    def hugepage_size1_g(self) -> typing.Optional[jsii.Number]:
        '''Amount of 1G hugepages.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#hugepage_size_1g ContainerCluster#hugepage_size_1g}
        '''
        result = self._values.get("hugepage_size1_g")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def hugepage_size2_m(self) -> typing.Optional[jsii.Number]:
        '''Amount of 2M hugepages.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#hugepage_size_2m ContainerCluster#hugepage_size_2m}
        '''
        result = self._values.get("hugepage_size2_m")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodePoolNodeConfigLinuxNodeConfigHugepagesConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodePoolNodeConfigLinuxNodeConfigHugepagesConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigLinuxNodeConfigHugepagesConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__94934ecb7cd69032a6503cf225e26d5dbf4001ad9ad4b3d3af3e386c3481fc3c)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetHugepageSize1G")
    def reset_hugepage_size1_g(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHugepageSize1G", []))

    @jsii.member(jsii_name="resetHugepageSize2M")
    def reset_hugepage_size2_m(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHugepageSize2M", []))

    @builtins.property
    @jsii.member(jsii_name="hugepageSize1GInput")
    def hugepage_size1_g_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "hugepageSize1GInput"))

    @builtins.property
    @jsii.member(jsii_name="hugepageSize2MInput")
    def hugepage_size2_m_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "hugepageSize2MInput"))

    @builtins.property
    @jsii.member(jsii_name="hugepageSize1G")
    def hugepage_size1_g(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "hugepageSize1G"))

    @hugepage_size1_g.setter
    def hugepage_size1_g(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__601a64fbc6f9e5daa8d1a83155d3d47f245530d1563948ba3936ea2a3a925916)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "hugepageSize1G", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="hugepageSize2M")
    def hugepage_size2_m(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "hugepageSize2M"))

    @hugepage_size2_m.setter
    def hugepage_size2_m(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9e4267d8ce57146de83620280df5a651ea3af1f2696dc09d745c813b1e76f829)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "hugepageSize2M", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolNodeConfigLinuxNodeConfigHugepagesConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolNodeConfigLinuxNodeConfigHugepagesConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodePoolNodeConfigLinuxNodeConfigHugepagesConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__35a661da13b8fac81cf9497ee624b524f944ebc701a2392aaf837812a290a71c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ContainerClusterNodePoolNodeConfigLinuxNodeConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigLinuxNodeConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bcad1595df79fba622f5fda30036322c24ebb850db912ed22c48c5499bf4c32b)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putHugepagesConfig")
    def put_hugepages_config(
        self,
        *,
        hugepage_size1_g: typing.Optional[jsii.Number] = None,
        hugepage_size2_m: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param hugepage_size1_g: Amount of 1G hugepages. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#hugepage_size_1g ContainerCluster#hugepage_size_1g}
        :param hugepage_size2_m: Amount of 2M hugepages. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#hugepage_size_2m ContainerCluster#hugepage_size_2m}
        '''
        value = ContainerClusterNodePoolNodeConfigLinuxNodeConfigHugepagesConfig(
            hugepage_size1_g=hugepage_size1_g, hugepage_size2_m=hugepage_size2_m
        )

        return typing.cast(None, jsii.invoke(self, "putHugepagesConfig", [value]))

    @jsii.member(jsii_name="resetCgroupMode")
    def reset_cgroup_mode(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCgroupMode", []))

    @jsii.member(jsii_name="resetHugepagesConfig")
    def reset_hugepages_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHugepagesConfig", []))

    @jsii.member(jsii_name="resetSysctls")
    def reset_sysctls(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSysctls", []))

    @jsii.member(jsii_name="resetTransparentHugepageDefrag")
    def reset_transparent_hugepage_defrag(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTransparentHugepageDefrag", []))

    @jsii.member(jsii_name="resetTransparentHugepageEnabled")
    def reset_transparent_hugepage_enabled(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTransparentHugepageEnabled", []))

    @builtins.property
    @jsii.member(jsii_name="hugepagesConfig")
    def hugepages_config(
        self,
    ) -> ContainerClusterNodePoolNodeConfigLinuxNodeConfigHugepagesConfigOutputReference:
        return typing.cast(ContainerClusterNodePoolNodeConfigLinuxNodeConfigHugepagesConfigOutputReference, jsii.get(self, "hugepagesConfig"))

    @builtins.property
    @jsii.member(jsii_name="cgroupModeInput")
    def cgroup_mode_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "cgroupModeInput"))

    @builtins.property
    @jsii.member(jsii_name="hugepagesConfigInput")
    def hugepages_config_input(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolNodeConfigLinuxNodeConfigHugepagesConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolNodeConfigLinuxNodeConfigHugepagesConfig], jsii.get(self, "hugepagesConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="sysctlsInput")
    def sysctls_input(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], jsii.get(self, "sysctlsInput"))

    @builtins.property
    @jsii.member(jsii_name="transparentHugepageDefragInput")
    def transparent_hugepage_defrag_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "transparentHugepageDefragInput"))

    @builtins.property
    @jsii.member(jsii_name="transparentHugepageEnabledInput")
    def transparent_hugepage_enabled_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "transparentHugepageEnabledInput"))

    @builtins.property
    @jsii.member(jsii_name="cgroupMode")
    def cgroup_mode(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "cgroupMode"))

    @cgroup_mode.setter
    def cgroup_mode(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ae9c5dfc8a662949b1c6df0eb0de3b2eada71b310da8c40bb8bba385326f2814)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "cgroupMode", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="sysctls")
    def sysctls(self) -> typing.Mapping[builtins.str, builtins.str]:
        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.get(self, "sysctls"))

    @sysctls.setter
    def sysctls(self, value: typing.Mapping[builtins.str, builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e461ede9f682827922296d0c34e7297bb3f5219c860d220ad42660733a8560fa)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "sysctls", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="transparentHugepageDefrag")
    def transparent_hugepage_defrag(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "transparentHugepageDefrag"))

    @transparent_hugepage_defrag.setter
    def transparent_hugepage_defrag(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1d34e10966144e543fc4afe56b34d186d7992bf51b6815aa48dff35dc2220496)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "transparentHugepageDefrag", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="transparentHugepageEnabled")
    def transparent_hugepage_enabled(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "transparentHugepageEnabled"))

    @transparent_hugepage_enabled.setter
    def transparent_hugepage_enabled(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6e34901439e4d6de96793db63c0cb567cd3b33064b0d1a5f74a7e98bfee9154c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "transparentHugepageEnabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolNodeConfigLinuxNodeConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolNodeConfigLinuxNodeConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodePoolNodeConfigLinuxNodeConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1903c99927304b1af90737ece869dd58b811945f6c21d0c5628c1b8336372e0b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigLocalNvmeSsdBlockConfig",
    jsii_struct_bases=[],
    name_mapping={"local_ssd_count": "localSsdCount"},
)
class ContainerClusterNodePoolNodeConfigLocalNvmeSsdBlockConfig:
    def __init__(self, *, local_ssd_count: jsii.Number) -> None:
        '''
        :param local_ssd_count: Number of raw-block local NVMe SSD disks to be attached to the node. Each local SSD is 375 GB in size. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#local_ssd_count ContainerCluster#local_ssd_count}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3d86581ae32dd1636fc3581095fa297470b8cd9ed4109ee5d960cf16ccb097b7)
            check_type(argname="argument local_ssd_count", value=local_ssd_count, expected_type=type_hints["local_ssd_count"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "local_ssd_count": local_ssd_count,
        }

    @builtins.property
    def local_ssd_count(self) -> jsii.Number:
        '''Number of raw-block local NVMe SSD disks to be attached to the node.

        Each local SSD is 375 GB in size.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#local_ssd_count ContainerCluster#local_ssd_count}
        '''
        result = self._values.get("local_ssd_count")
        assert result is not None, "Required property 'local_ssd_count' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodePoolNodeConfigLocalNvmeSsdBlockConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodePoolNodeConfigLocalNvmeSsdBlockConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigLocalNvmeSsdBlockConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3d2f17c8c35e78bd665014f3ff93fe78ba490329740c5a21baadfb3c523ab652)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="localSsdCountInput")
    def local_ssd_count_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "localSsdCountInput"))

    @builtins.property
    @jsii.member(jsii_name="localSsdCount")
    def local_ssd_count(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "localSsdCount"))

    @local_ssd_count.setter
    def local_ssd_count(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__26654ededbe8f1eb9d77b3b00c6d0266725ad899eb4c535596b52f8fedcd9e76)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "localSsdCount", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolNodeConfigLocalNvmeSsdBlockConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolNodeConfigLocalNvmeSsdBlockConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodePoolNodeConfigLocalNvmeSsdBlockConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__99669bce26a25d375935811c74fbe99b28ff5c32fd19f959d31501f0d181b2d0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ContainerClusterNodePoolNodeConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6f49fc053ac152ed5cec516aec36fb4d3c18f9cc338f660d59fa2ee8bc80ef24)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putAdvancedMachineFeatures")
    def put_advanced_machine_features(
        self,
        *,
        threads_per_core: jsii.Number,
        enable_nested_virtualization: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        performance_monitoring_unit: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param threads_per_core: The number of threads per physical core. To disable simultaneous multithreading (SMT) set this to 1. If unset, the maximum number of threads supported per core by the underlying processor is assumed. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#threads_per_core ContainerCluster#threads_per_core}
        :param enable_nested_virtualization: Whether the node should have nested virtualization enabled. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_nested_virtualization ContainerCluster#enable_nested_virtualization}
        :param performance_monitoring_unit: Level of Performance Monitoring Unit (PMU) requested. If unset, no access to the PMU is assumed. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#performance_monitoring_unit ContainerCluster#performance_monitoring_unit}
        '''
        value = ContainerClusterNodePoolNodeConfigAdvancedMachineFeatures(
            threads_per_core=threads_per_core,
            enable_nested_virtualization=enable_nested_virtualization,
            performance_monitoring_unit=performance_monitoring_unit,
        )

        return typing.cast(None, jsii.invoke(self, "putAdvancedMachineFeatures", [value]))

    @jsii.member(jsii_name="putBootDisk")
    def put_boot_disk(
        self,
        *,
        disk_type: typing.Optional[builtins.str] = None,
        provisioned_iops: typing.Optional[jsii.Number] = None,
        provisioned_throughput: typing.Optional[jsii.Number] = None,
        size_gb: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param disk_type: Type of the disk attached to each node. Such as pd-standard, pd-balanced or pd-ssd. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#disk_type ContainerCluster#disk_type}
        :param provisioned_iops: Configured IOPs provisioning. Only valid with disk type hyperdisk-balanced. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#provisioned_iops ContainerCluster#provisioned_iops}
        :param provisioned_throughput: Configured throughput provisioning. Only valid with disk type hyperdisk-balanced. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#provisioned_throughput ContainerCluster#provisioned_throughput}
        :param size_gb: Size of the disk attached to each node, specified in GB. The smallest allowed disk size is 10GB. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#size_gb ContainerCluster#size_gb}
        '''
        value = ContainerClusterNodePoolNodeConfigBootDisk(
            disk_type=disk_type,
            provisioned_iops=provisioned_iops,
            provisioned_throughput=provisioned_throughput,
            size_gb=size_gb,
        )

        return typing.cast(None, jsii.invoke(self, "putBootDisk", [value]))

    @jsii.member(jsii_name="putConfidentialNodes")
    def put_confidential_nodes(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
        confidential_instance_type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param enabled: Whether Confidential Nodes feature is enabled for all nodes in this pool. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        :param confidential_instance_type: Defines the type of technology used by the confidential node. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#confidential_instance_type ContainerCluster#confidential_instance_type}
        '''
        value = ContainerClusterNodePoolNodeConfigConfidentialNodes(
            enabled=enabled, confidential_instance_type=confidential_instance_type
        )

        return typing.cast(None, jsii.invoke(self, "putConfidentialNodes", [value]))

    @jsii.member(jsii_name="putContainerdConfig")
    def put_containerd_config(
        self,
        *,
        private_registry_access_config: typing.Optional[typing.Union[ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param private_registry_access_config: private_registry_access_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#private_registry_access_config ContainerCluster#private_registry_access_config}
        '''
        value = ContainerClusterNodePoolNodeConfigContainerdConfig(
            private_registry_access_config=private_registry_access_config
        )

        return typing.cast(None, jsii.invoke(self, "putContainerdConfig", [value]))

    @jsii.member(jsii_name="putEphemeralStorageLocalSsdConfig")
    def put_ephemeral_storage_local_ssd_config(
        self,
        *,
        local_ssd_count: jsii.Number,
        data_cache_count: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param local_ssd_count: Number of local SSDs to use to back ephemeral storage. Uses NVMe interfaces. Each local SSD must be 375 or 3000 GB in size, and all local SSDs must share the same size. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#local_ssd_count ContainerCluster#local_ssd_count}
        :param data_cache_count: Number of local SSDs to be utilized for GKE Data Cache. Uses NVMe interfaces. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#data_cache_count ContainerCluster#data_cache_count}
        '''
        value = ContainerClusterNodePoolNodeConfigEphemeralStorageLocalSsdConfig(
            local_ssd_count=local_ssd_count, data_cache_count=data_cache_count
        )

        return typing.cast(None, jsii.invoke(self, "putEphemeralStorageLocalSsdConfig", [value]))

    @jsii.member(jsii_name="putFastSocket")
    def put_fast_socket(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param enabled: Whether or not NCCL Fast Socket is enabled. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        '''
        value = ContainerClusterNodePoolNodeConfigFastSocket(enabled=enabled)

        return typing.cast(None, jsii.invoke(self, "putFastSocket", [value]))

    @jsii.member(jsii_name="putGcfsConfig")
    def put_gcfs_config(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param enabled: Whether or not GCFS is enabled. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        '''
        value = ContainerClusterNodePoolNodeConfigGcfsConfig(enabled=enabled)

        return typing.cast(None, jsii.invoke(self, "putGcfsConfig", [value]))

    @jsii.member(jsii_name="putGuestAccelerator")
    def put_guest_accelerator(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ContainerClusterNodePoolNodeConfigGuestAccelerator, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__78f7608483721a816fc2b7d1d95a12e57b86a2089a225a89a87bc30a70e7ac3c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putGuestAccelerator", [value]))

    @jsii.member(jsii_name="putGvnic")
    def put_gvnic(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param enabled: Whether or not gvnic is enabled. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        '''
        value = ContainerClusterNodePoolNodeConfigGvnic(enabled=enabled)

        return typing.cast(None, jsii.invoke(self, "putGvnic", [value]))

    @jsii.member(jsii_name="putHostMaintenancePolicy")
    def put_host_maintenance_policy(
        self,
        *,
        maintenance_interval: builtins.str,
    ) -> None:
        '''
        :param maintenance_interval: . Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#maintenance_interval ContainerCluster#maintenance_interval}
        '''
        value = ContainerClusterNodePoolNodeConfigHostMaintenancePolicy(
            maintenance_interval=maintenance_interval
        )

        return typing.cast(None, jsii.invoke(self, "putHostMaintenancePolicy", [value]))

    @jsii.member(jsii_name="putKubeletConfig")
    def put_kubelet_config(
        self,
        *,
        allowed_unsafe_sysctls: typing.Optional[typing.Sequence[builtins.str]] = None,
        container_log_max_files: typing.Optional[jsii.Number] = None,
        container_log_max_size: typing.Optional[builtins.str] = None,
        cpu_cfs_quota: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        cpu_cfs_quota_period: typing.Optional[builtins.str] = None,
        cpu_manager_policy: typing.Optional[builtins.str] = None,
        eviction_max_pod_grace_period_seconds: typing.Optional[jsii.Number] = None,
        eviction_minimum_reclaim: typing.Optional[typing.Union[ContainerClusterNodePoolNodeConfigKubeletConfigEvictionMinimumReclaim, typing.Dict[builtins.str, typing.Any]]] = None,
        eviction_soft: typing.Optional[typing.Union[ContainerClusterNodePoolNodeConfigKubeletConfigEvictionSoft, typing.Dict[builtins.str, typing.Any]]] = None,
        eviction_soft_grace_period: typing.Optional[typing.Union[ContainerClusterNodePoolNodeConfigKubeletConfigEvictionSoftGracePeriod, typing.Dict[builtins.str, typing.Any]]] = None,
        image_gc_high_threshold_percent: typing.Optional[jsii.Number] = None,
        image_gc_low_threshold_percent: typing.Optional[jsii.Number] = None,
        image_maximum_gc_age: typing.Optional[builtins.str] = None,
        image_minimum_gc_age: typing.Optional[builtins.str] = None,
        insecure_kubelet_readonly_port_enabled: typing.Optional[builtins.str] = None,
        max_parallel_image_pulls: typing.Optional[jsii.Number] = None,
        pod_pids_limit: typing.Optional[jsii.Number] = None,
        single_process_oom_kill: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    ) -> None:
        '''
        :param allowed_unsafe_sysctls: Defines a comma-separated allowlist of unsafe sysctls or sysctl patterns which can be set on the Pods. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#allowed_unsafe_sysctls ContainerCluster#allowed_unsafe_sysctls}
        :param container_log_max_files: Defines the maximum number of container log files that can be present for a container. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#container_log_max_files ContainerCluster#container_log_max_files}
        :param container_log_max_size: Defines the maximum size of the container log file before it is rotated. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#container_log_max_size ContainerCluster#container_log_max_size}
        :param cpu_cfs_quota: Enable CPU CFS quota enforcement for containers that specify CPU limits. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cpu_cfs_quota ContainerCluster#cpu_cfs_quota}
        :param cpu_cfs_quota_period: Set the CPU CFS quota period value 'cpu.cfs_period_us'. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cpu_cfs_quota_period ContainerCluster#cpu_cfs_quota_period}
        :param cpu_manager_policy: Control the CPU management policy on the node. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cpu_manager_policy ContainerCluster#cpu_manager_policy}
        :param eviction_max_pod_grace_period_seconds: Defines the maximum allowed grace period (in seconds) to use when terminating pods in response to a soft eviction threshold being met. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#eviction_max_pod_grace_period_seconds ContainerCluster#eviction_max_pod_grace_period_seconds}
        :param eviction_minimum_reclaim: eviction_minimum_reclaim block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#eviction_minimum_reclaim ContainerCluster#eviction_minimum_reclaim}
        :param eviction_soft: eviction_soft block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#eviction_soft ContainerCluster#eviction_soft}
        :param eviction_soft_grace_period: eviction_soft_grace_period block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#eviction_soft_grace_period ContainerCluster#eviction_soft_grace_period}
        :param image_gc_high_threshold_percent: Defines the percent of disk usage after which image garbage collection is always run. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#image_gc_high_threshold_percent ContainerCluster#image_gc_high_threshold_percent}
        :param image_gc_low_threshold_percent: Defines the percent of disk usage before which image garbage collection is never run. Lowest disk usage to garbage collect to. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#image_gc_low_threshold_percent ContainerCluster#image_gc_low_threshold_percent}
        :param image_maximum_gc_age: Defines the maximum age an image can be unused before it is garbage collected. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#image_maximum_gc_age ContainerCluster#image_maximum_gc_age}
        :param image_minimum_gc_age: Defines the minimum age for an unused image before it is garbage collected. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#image_minimum_gc_age ContainerCluster#image_minimum_gc_age}
        :param insecure_kubelet_readonly_port_enabled: Controls whether the kubelet read-only port is enabled. It is strongly recommended to set this to ``FALSE``. Possible values: ``TRUE``, ``FALSE``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#insecure_kubelet_readonly_port_enabled ContainerCluster#insecure_kubelet_readonly_port_enabled}
        :param max_parallel_image_pulls: Set the maximum number of image pulls in parallel. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#max_parallel_image_pulls ContainerCluster#max_parallel_image_pulls}
        :param pod_pids_limit: Controls the maximum number of processes allowed to run in a pod. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#pod_pids_limit ContainerCluster#pod_pids_limit}
        :param single_process_oom_kill: Defines whether to enable single process OOM killer. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#single_process_oom_kill ContainerCluster#single_process_oom_kill}
        '''
        value = ContainerClusterNodePoolNodeConfigKubeletConfig(
            allowed_unsafe_sysctls=allowed_unsafe_sysctls,
            container_log_max_files=container_log_max_files,
            container_log_max_size=container_log_max_size,
            cpu_cfs_quota=cpu_cfs_quota,
            cpu_cfs_quota_period=cpu_cfs_quota_period,
            cpu_manager_policy=cpu_manager_policy,
            eviction_max_pod_grace_period_seconds=eviction_max_pod_grace_period_seconds,
            eviction_minimum_reclaim=eviction_minimum_reclaim,
            eviction_soft=eviction_soft,
            eviction_soft_grace_period=eviction_soft_grace_period,
            image_gc_high_threshold_percent=image_gc_high_threshold_percent,
            image_gc_low_threshold_percent=image_gc_low_threshold_percent,
            image_maximum_gc_age=image_maximum_gc_age,
            image_minimum_gc_age=image_minimum_gc_age,
            insecure_kubelet_readonly_port_enabled=insecure_kubelet_readonly_port_enabled,
            max_parallel_image_pulls=max_parallel_image_pulls,
            pod_pids_limit=pod_pids_limit,
            single_process_oom_kill=single_process_oom_kill,
        )

        return typing.cast(None, jsii.invoke(self, "putKubeletConfig", [value]))

    @jsii.member(jsii_name="putLinuxNodeConfig")
    def put_linux_node_config(
        self,
        *,
        cgroup_mode: typing.Optional[builtins.str] = None,
        hugepages_config: typing.Optional[typing.Union[ContainerClusterNodePoolNodeConfigLinuxNodeConfigHugepagesConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        sysctls: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        transparent_hugepage_defrag: typing.Optional[builtins.str] = None,
        transparent_hugepage_enabled: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param cgroup_mode: cgroupMode specifies the cgroup mode to be used on the node. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cgroup_mode ContainerCluster#cgroup_mode}
        :param hugepages_config: hugepages_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#hugepages_config ContainerCluster#hugepages_config}
        :param sysctls: The Linux kernel parameters to be applied to the nodes and all pods running on the nodes. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#sysctls ContainerCluster#sysctls}
        :param transparent_hugepage_defrag: The Linux kernel transparent hugepage defrag setting. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#transparent_hugepage_defrag ContainerCluster#transparent_hugepage_defrag}
        :param transparent_hugepage_enabled: The Linux kernel transparent hugepage setting. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#transparent_hugepage_enabled ContainerCluster#transparent_hugepage_enabled}
        '''
        value = ContainerClusterNodePoolNodeConfigLinuxNodeConfig(
            cgroup_mode=cgroup_mode,
            hugepages_config=hugepages_config,
            sysctls=sysctls,
            transparent_hugepage_defrag=transparent_hugepage_defrag,
            transparent_hugepage_enabled=transparent_hugepage_enabled,
        )

        return typing.cast(None, jsii.invoke(self, "putLinuxNodeConfig", [value]))

    @jsii.member(jsii_name="putLocalNvmeSsdBlockConfig")
    def put_local_nvme_ssd_block_config(self, *, local_ssd_count: jsii.Number) -> None:
        '''
        :param local_ssd_count: Number of raw-block local NVMe SSD disks to be attached to the node. Each local SSD is 375 GB in size. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#local_ssd_count ContainerCluster#local_ssd_count}
        '''
        value = ContainerClusterNodePoolNodeConfigLocalNvmeSsdBlockConfig(
            local_ssd_count=local_ssd_count
        )

        return typing.cast(None, jsii.invoke(self, "putLocalNvmeSsdBlockConfig", [value]))

    @jsii.member(jsii_name="putReservationAffinity")
    def put_reservation_affinity(
        self,
        *,
        consume_reservation_type: builtins.str,
        key: typing.Optional[builtins.str] = None,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param consume_reservation_type: Corresponds to the type of reservation consumption. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#consume_reservation_type ContainerCluster#consume_reservation_type}
        :param key: The label key of a reservation resource. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#key ContainerCluster#key}
        :param values: The label values of the reservation resource. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#values ContainerCluster#values}
        '''
        value = ContainerClusterNodePoolNodeConfigReservationAffinity(
            consume_reservation_type=consume_reservation_type, key=key, values=values
        )

        return typing.cast(None, jsii.invoke(self, "putReservationAffinity", [value]))

    @jsii.member(jsii_name="putSecondaryBootDisks")
    def put_secondary_boot_disks(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ContainerClusterNodePoolNodeConfigSecondaryBootDisks", typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__90e44878380b2bbeda6f96aa2c6313c5e7a797b44872add995d9b4e45bee7283)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putSecondaryBootDisks", [value]))

    @jsii.member(jsii_name="putShieldedInstanceConfig")
    def put_shielded_instance_config(
        self,
        *,
        enable_integrity_monitoring: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        enable_secure_boot: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    ) -> None:
        '''
        :param enable_integrity_monitoring: Defines whether the instance has integrity monitoring enabled. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_integrity_monitoring ContainerCluster#enable_integrity_monitoring}
        :param enable_secure_boot: Defines whether the instance has Secure Boot enabled. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_secure_boot ContainerCluster#enable_secure_boot}
        '''
        value = ContainerClusterNodePoolNodeConfigShieldedInstanceConfig(
            enable_integrity_monitoring=enable_integrity_monitoring,
            enable_secure_boot=enable_secure_boot,
        )

        return typing.cast(None, jsii.invoke(self, "putShieldedInstanceConfig", [value]))

    @jsii.member(jsii_name="putSoleTenantConfig")
    def put_sole_tenant_config(
        self,
        *,
        node_affinity: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ContainerClusterNodePoolNodeConfigSoleTenantConfigNodeAffinity", typing.Dict[builtins.str, typing.Any]]]],
        min_node_cpus: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param node_affinity: node_affinity block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#node_affinity ContainerCluster#node_affinity}
        :param min_node_cpus: Specifies the minimum number of vCPUs that each sole tenant node must have to use CPU overcommit. If not specified, the CPU overcommit feature is disabled. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#min_node_cpus ContainerCluster#min_node_cpus}
        '''
        value = ContainerClusterNodePoolNodeConfigSoleTenantConfig(
            node_affinity=node_affinity, min_node_cpus=min_node_cpus
        )

        return typing.cast(None, jsii.invoke(self, "putSoleTenantConfig", [value]))

    @jsii.member(jsii_name="putTaint")
    def put_taint(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ContainerClusterNodePoolNodeConfigTaint", typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__885cfaadacdf1a19ca65dbe946617174a9ac7c71958b2e72feb93f3bb1318b11)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putTaint", [value]))

    @jsii.member(jsii_name="putWindowsNodeConfig")
    def put_windows_node_config(
        self,
        *,
        osversion: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param osversion: The OS Version of the windows nodepool.Values are OS_VERSION_UNSPECIFIED,OS_VERSION_LTSC2019 and OS_VERSION_LTSC2022. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#osversion ContainerCluster#osversion}
        '''
        value = ContainerClusterNodePoolNodeConfigWindowsNodeConfig(
            osversion=osversion
        )

        return typing.cast(None, jsii.invoke(self, "putWindowsNodeConfig", [value]))

    @jsii.member(jsii_name="putWorkloadMetadataConfig")
    def put_workload_metadata_config(self, *, mode: builtins.str) -> None:
        '''
        :param mode: Mode is the configuration for how to expose metadata to workloads running on the node. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#mode ContainerCluster#mode}
        '''
        value = ContainerClusterNodePoolNodeConfigWorkloadMetadataConfig(mode=mode)

        return typing.cast(None, jsii.invoke(self, "putWorkloadMetadataConfig", [value]))

    @jsii.member(jsii_name="resetAdvancedMachineFeatures")
    def reset_advanced_machine_features(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAdvancedMachineFeatures", []))

    @jsii.member(jsii_name="resetBootDisk")
    def reset_boot_disk(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBootDisk", []))

    @jsii.member(jsii_name="resetBootDiskKmsKey")
    def reset_boot_disk_kms_key(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBootDiskKmsKey", []))

    @jsii.member(jsii_name="resetConfidentialNodes")
    def reset_confidential_nodes(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetConfidentialNodes", []))

    @jsii.member(jsii_name="resetContainerdConfig")
    def reset_containerd_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetContainerdConfig", []))

    @jsii.member(jsii_name="resetDiskSizeGb")
    def reset_disk_size_gb(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDiskSizeGb", []))

    @jsii.member(jsii_name="resetDiskType")
    def reset_disk_type(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDiskType", []))

    @jsii.member(jsii_name="resetEnableConfidentialStorage")
    def reset_enable_confidential_storage(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnableConfidentialStorage", []))

    @jsii.member(jsii_name="resetEphemeralStorageLocalSsdConfig")
    def reset_ephemeral_storage_local_ssd_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEphemeralStorageLocalSsdConfig", []))

    @jsii.member(jsii_name="resetFastSocket")
    def reset_fast_socket(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetFastSocket", []))

    @jsii.member(jsii_name="resetFlexStart")
    def reset_flex_start(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetFlexStart", []))

    @jsii.member(jsii_name="resetGcfsConfig")
    def reset_gcfs_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGcfsConfig", []))

    @jsii.member(jsii_name="resetGuestAccelerator")
    def reset_guest_accelerator(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGuestAccelerator", []))

    @jsii.member(jsii_name="resetGvnic")
    def reset_gvnic(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGvnic", []))

    @jsii.member(jsii_name="resetHostMaintenancePolicy")
    def reset_host_maintenance_policy(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHostMaintenancePolicy", []))

    @jsii.member(jsii_name="resetImageType")
    def reset_image_type(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetImageType", []))

    @jsii.member(jsii_name="resetKubeletConfig")
    def reset_kubelet_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKubeletConfig", []))

    @jsii.member(jsii_name="resetLabels")
    def reset_labels(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLabels", []))

    @jsii.member(jsii_name="resetLinuxNodeConfig")
    def reset_linux_node_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLinuxNodeConfig", []))

    @jsii.member(jsii_name="resetLocalNvmeSsdBlockConfig")
    def reset_local_nvme_ssd_block_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLocalNvmeSsdBlockConfig", []))

    @jsii.member(jsii_name="resetLocalSsdCount")
    def reset_local_ssd_count(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLocalSsdCount", []))

    @jsii.member(jsii_name="resetLocalSsdEncryptionMode")
    def reset_local_ssd_encryption_mode(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLocalSsdEncryptionMode", []))

    @jsii.member(jsii_name="resetLoggingVariant")
    def reset_logging_variant(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLoggingVariant", []))

    @jsii.member(jsii_name="resetMachineType")
    def reset_machine_type(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMachineType", []))

    @jsii.member(jsii_name="resetMaxRunDuration")
    def reset_max_run_duration(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMaxRunDuration", []))

    @jsii.member(jsii_name="resetMetadata")
    def reset_metadata(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMetadata", []))

    @jsii.member(jsii_name="resetMinCpuPlatform")
    def reset_min_cpu_platform(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMinCpuPlatform", []))

    @jsii.member(jsii_name="resetNodeGroup")
    def reset_node_group(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNodeGroup", []))

    @jsii.member(jsii_name="resetOauthScopes")
    def reset_oauth_scopes(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetOauthScopes", []))

    @jsii.member(jsii_name="resetPreemptible")
    def reset_preemptible(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPreemptible", []))

    @jsii.member(jsii_name="resetReservationAffinity")
    def reset_reservation_affinity(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetReservationAffinity", []))

    @jsii.member(jsii_name="resetResourceLabels")
    def reset_resource_labels(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetResourceLabels", []))

    @jsii.member(jsii_name="resetResourceManagerTags")
    def reset_resource_manager_tags(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetResourceManagerTags", []))

    @jsii.member(jsii_name="resetSecondaryBootDisks")
    def reset_secondary_boot_disks(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSecondaryBootDisks", []))

    @jsii.member(jsii_name="resetServiceAccount")
    def reset_service_account(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetServiceAccount", []))

    @jsii.member(jsii_name="resetShieldedInstanceConfig")
    def reset_shielded_instance_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetShieldedInstanceConfig", []))

    @jsii.member(jsii_name="resetSoleTenantConfig")
    def reset_sole_tenant_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSoleTenantConfig", []))

    @jsii.member(jsii_name="resetSpot")
    def reset_spot(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSpot", []))

    @jsii.member(jsii_name="resetStoragePools")
    def reset_storage_pools(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetStoragePools", []))

    @jsii.member(jsii_name="resetTags")
    def reset_tags(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTags", []))

    @jsii.member(jsii_name="resetTaint")
    def reset_taint(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTaint", []))

    @jsii.member(jsii_name="resetWindowsNodeConfig")
    def reset_windows_node_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetWindowsNodeConfig", []))

    @jsii.member(jsii_name="resetWorkloadMetadataConfig")
    def reset_workload_metadata_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetWorkloadMetadataConfig", []))

    @builtins.property
    @jsii.member(jsii_name="advancedMachineFeatures")
    def advanced_machine_features(
        self,
    ) -> ContainerClusterNodePoolNodeConfigAdvancedMachineFeaturesOutputReference:
        return typing.cast(ContainerClusterNodePoolNodeConfigAdvancedMachineFeaturesOutputReference, jsii.get(self, "advancedMachineFeatures"))

    @builtins.property
    @jsii.member(jsii_name="bootDisk")
    def boot_disk(self) -> ContainerClusterNodePoolNodeConfigBootDiskOutputReference:
        return typing.cast(ContainerClusterNodePoolNodeConfigBootDiskOutputReference, jsii.get(self, "bootDisk"))

    @builtins.property
    @jsii.member(jsii_name="confidentialNodes")
    def confidential_nodes(
        self,
    ) -> ContainerClusterNodePoolNodeConfigConfidentialNodesOutputReference:
        return typing.cast(ContainerClusterNodePoolNodeConfigConfidentialNodesOutputReference, jsii.get(self, "confidentialNodes"))

    @builtins.property
    @jsii.member(jsii_name="containerdConfig")
    def containerd_config(
        self,
    ) -> ContainerClusterNodePoolNodeConfigContainerdConfigOutputReference:
        return typing.cast(ContainerClusterNodePoolNodeConfigContainerdConfigOutputReference, jsii.get(self, "containerdConfig"))

    @builtins.property
    @jsii.member(jsii_name="effectiveTaints")
    def effective_taints(self) -> ContainerClusterNodePoolNodeConfigEffectiveTaintsList:
        return typing.cast(ContainerClusterNodePoolNodeConfigEffectiveTaintsList, jsii.get(self, "effectiveTaints"))

    @builtins.property
    @jsii.member(jsii_name="ephemeralStorageLocalSsdConfig")
    def ephemeral_storage_local_ssd_config(
        self,
    ) -> ContainerClusterNodePoolNodeConfigEphemeralStorageLocalSsdConfigOutputReference:
        return typing.cast(ContainerClusterNodePoolNodeConfigEphemeralStorageLocalSsdConfigOutputReference, jsii.get(self, "ephemeralStorageLocalSsdConfig"))

    @builtins.property
    @jsii.member(jsii_name="fastSocket")
    def fast_socket(
        self,
    ) -> ContainerClusterNodePoolNodeConfigFastSocketOutputReference:
        return typing.cast(ContainerClusterNodePoolNodeConfigFastSocketOutputReference, jsii.get(self, "fastSocket"))

    @builtins.property
    @jsii.member(jsii_name="gcfsConfig")
    def gcfs_config(
        self,
    ) -> ContainerClusterNodePoolNodeConfigGcfsConfigOutputReference:
        return typing.cast(ContainerClusterNodePoolNodeConfigGcfsConfigOutputReference, jsii.get(self, "gcfsConfig"))

    @builtins.property
    @jsii.member(jsii_name="guestAccelerator")
    def guest_accelerator(
        self,
    ) -> ContainerClusterNodePoolNodeConfigGuestAcceleratorList:
        return typing.cast(ContainerClusterNodePoolNodeConfigGuestAcceleratorList, jsii.get(self, "guestAccelerator"))

    @builtins.property
    @jsii.member(jsii_name="gvnic")
    def gvnic(self) -> ContainerClusterNodePoolNodeConfigGvnicOutputReference:
        return typing.cast(ContainerClusterNodePoolNodeConfigGvnicOutputReference, jsii.get(self, "gvnic"))

    @builtins.property
    @jsii.member(jsii_name="hostMaintenancePolicy")
    def host_maintenance_policy(
        self,
    ) -> ContainerClusterNodePoolNodeConfigHostMaintenancePolicyOutputReference:
        return typing.cast(ContainerClusterNodePoolNodeConfigHostMaintenancePolicyOutputReference, jsii.get(self, "hostMaintenancePolicy"))

    @builtins.property
    @jsii.member(jsii_name="kubeletConfig")
    def kubelet_config(
        self,
    ) -> ContainerClusterNodePoolNodeConfigKubeletConfigOutputReference:
        return typing.cast(ContainerClusterNodePoolNodeConfigKubeletConfigOutputReference, jsii.get(self, "kubeletConfig"))

    @builtins.property
    @jsii.member(jsii_name="linuxNodeConfig")
    def linux_node_config(
        self,
    ) -> ContainerClusterNodePoolNodeConfigLinuxNodeConfigOutputReference:
        return typing.cast(ContainerClusterNodePoolNodeConfigLinuxNodeConfigOutputReference, jsii.get(self, "linuxNodeConfig"))

    @builtins.property
    @jsii.member(jsii_name="localNvmeSsdBlockConfig")
    def local_nvme_ssd_block_config(
        self,
    ) -> ContainerClusterNodePoolNodeConfigLocalNvmeSsdBlockConfigOutputReference:
        return typing.cast(ContainerClusterNodePoolNodeConfigLocalNvmeSsdBlockConfigOutputReference, jsii.get(self, "localNvmeSsdBlockConfig"))

    @builtins.property
    @jsii.member(jsii_name="reservationAffinity")
    def reservation_affinity(
        self,
    ) -> "ContainerClusterNodePoolNodeConfigReservationAffinityOutputReference":
        return typing.cast("ContainerClusterNodePoolNodeConfigReservationAffinityOutputReference", jsii.get(self, "reservationAffinity"))

    @builtins.property
    @jsii.member(jsii_name="secondaryBootDisks")
    def secondary_boot_disks(
        self,
    ) -> "ContainerClusterNodePoolNodeConfigSecondaryBootDisksList":
        return typing.cast("ContainerClusterNodePoolNodeConfigSecondaryBootDisksList", jsii.get(self, "secondaryBootDisks"))

    @builtins.property
    @jsii.member(jsii_name="shieldedInstanceConfig")
    def shielded_instance_config(
        self,
    ) -> "ContainerClusterNodePoolNodeConfigShieldedInstanceConfigOutputReference":
        return typing.cast("ContainerClusterNodePoolNodeConfigShieldedInstanceConfigOutputReference", jsii.get(self, "shieldedInstanceConfig"))

    @builtins.property
    @jsii.member(jsii_name="soleTenantConfig")
    def sole_tenant_config(
        self,
    ) -> "ContainerClusterNodePoolNodeConfigSoleTenantConfigOutputReference":
        return typing.cast("ContainerClusterNodePoolNodeConfigSoleTenantConfigOutputReference", jsii.get(self, "soleTenantConfig"))

    @builtins.property
    @jsii.member(jsii_name="taint")
    def taint(self) -> "ContainerClusterNodePoolNodeConfigTaintList":
        return typing.cast("ContainerClusterNodePoolNodeConfigTaintList", jsii.get(self, "taint"))

    @builtins.property
    @jsii.member(jsii_name="windowsNodeConfig")
    def windows_node_config(
        self,
    ) -> "ContainerClusterNodePoolNodeConfigWindowsNodeConfigOutputReference":
        return typing.cast("ContainerClusterNodePoolNodeConfigWindowsNodeConfigOutputReference", jsii.get(self, "windowsNodeConfig"))

    @builtins.property
    @jsii.member(jsii_name="workloadMetadataConfig")
    def workload_metadata_config(
        self,
    ) -> "ContainerClusterNodePoolNodeConfigWorkloadMetadataConfigOutputReference":
        return typing.cast("ContainerClusterNodePoolNodeConfigWorkloadMetadataConfigOutputReference", jsii.get(self, "workloadMetadataConfig"))

    @builtins.property
    @jsii.member(jsii_name="advancedMachineFeaturesInput")
    def advanced_machine_features_input(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolNodeConfigAdvancedMachineFeatures]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolNodeConfigAdvancedMachineFeatures], jsii.get(self, "advancedMachineFeaturesInput"))

    @builtins.property
    @jsii.member(jsii_name="bootDiskInput")
    def boot_disk_input(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolNodeConfigBootDisk]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolNodeConfigBootDisk], jsii.get(self, "bootDiskInput"))

    @builtins.property
    @jsii.member(jsii_name="bootDiskKmsKeyInput")
    def boot_disk_kms_key_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "bootDiskKmsKeyInput"))

    @builtins.property
    @jsii.member(jsii_name="confidentialNodesInput")
    def confidential_nodes_input(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolNodeConfigConfidentialNodes]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolNodeConfigConfidentialNodes], jsii.get(self, "confidentialNodesInput"))

    @builtins.property
    @jsii.member(jsii_name="containerdConfigInput")
    def containerd_config_input(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolNodeConfigContainerdConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolNodeConfigContainerdConfig], jsii.get(self, "containerdConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="diskSizeGbInput")
    def disk_size_gb_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "diskSizeGbInput"))

    @builtins.property
    @jsii.member(jsii_name="diskTypeInput")
    def disk_type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "diskTypeInput"))

    @builtins.property
    @jsii.member(jsii_name="enableConfidentialStorageInput")
    def enable_confidential_storage_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enableConfidentialStorageInput"))

    @builtins.property
    @jsii.member(jsii_name="ephemeralStorageLocalSsdConfigInput")
    def ephemeral_storage_local_ssd_config_input(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolNodeConfigEphemeralStorageLocalSsdConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolNodeConfigEphemeralStorageLocalSsdConfig], jsii.get(self, "ephemeralStorageLocalSsdConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="fastSocketInput")
    def fast_socket_input(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolNodeConfigFastSocket]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolNodeConfigFastSocket], jsii.get(self, "fastSocketInput"))

    @builtins.property
    @jsii.member(jsii_name="flexStartInput")
    def flex_start_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "flexStartInput"))

    @builtins.property
    @jsii.member(jsii_name="gcfsConfigInput")
    def gcfs_config_input(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolNodeConfigGcfsConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolNodeConfigGcfsConfig], jsii.get(self, "gcfsConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="guestAcceleratorInput")
    def guest_accelerator_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodePoolNodeConfigGuestAccelerator]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodePoolNodeConfigGuestAccelerator]]], jsii.get(self, "guestAcceleratorInput"))

    @builtins.property
    @jsii.member(jsii_name="gvnicInput")
    def gvnic_input(self) -> typing.Optional[ContainerClusterNodePoolNodeConfigGvnic]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolNodeConfigGvnic], jsii.get(self, "gvnicInput"))

    @builtins.property
    @jsii.member(jsii_name="hostMaintenancePolicyInput")
    def host_maintenance_policy_input(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolNodeConfigHostMaintenancePolicy]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolNodeConfigHostMaintenancePolicy], jsii.get(self, "hostMaintenancePolicyInput"))

    @builtins.property
    @jsii.member(jsii_name="imageTypeInput")
    def image_type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "imageTypeInput"))

    @builtins.property
    @jsii.member(jsii_name="kubeletConfigInput")
    def kubelet_config_input(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolNodeConfigKubeletConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolNodeConfigKubeletConfig], jsii.get(self, "kubeletConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="labelsInput")
    def labels_input(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], jsii.get(self, "labelsInput"))

    @builtins.property
    @jsii.member(jsii_name="linuxNodeConfigInput")
    def linux_node_config_input(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolNodeConfigLinuxNodeConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolNodeConfigLinuxNodeConfig], jsii.get(self, "linuxNodeConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="localNvmeSsdBlockConfigInput")
    def local_nvme_ssd_block_config_input(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolNodeConfigLocalNvmeSsdBlockConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolNodeConfigLocalNvmeSsdBlockConfig], jsii.get(self, "localNvmeSsdBlockConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="localSsdCountInput")
    def local_ssd_count_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "localSsdCountInput"))

    @builtins.property
    @jsii.member(jsii_name="localSsdEncryptionModeInput")
    def local_ssd_encryption_mode_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "localSsdEncryptionModeInput"))

    @builtins.property
    @jsii.member(jsii_name="loggingVariantInput")
    def logging_variant_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "loggingVariantInput"))

    @builtins.property
    @jsii.member(jsii_name="machineTypeInput")
    def machine_type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "machineTypeInput"))

    @builtins.property
    @jsii.member(jsii_name="maxRunDurationInput")
    def max_run_duration_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "maxRunDurationInput"))

    @builtins.property
    @jsii.member(jsii_name="metadataInput")
    def metadata_input(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], jsii.get(self, "metadataInput"))

    @builtins.property
    @jsii.member(jsii_name="minCpuPlatformInput")
    def min_cpu_platform_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "minCpuPlatformInput"))

    @builtins.property
    @jsii.member(jsii_name="nodeGroupInput")
    def node_group_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nodeGroupInput"))

    @builtins.property
    @jsii.member(jsii_name="oauthScopesInput")
    def oauth_scopes_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "oauthScopesInput"))

    @builtins.property
    @jsii.member(jsii_name="preemptibleInput")
    def preemptible_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "preemptibleInput"))

    @builtins.property
    @jsii.member(jsii_name="reservationAffinityInput")
    def reservation_affinity_input(
        self,
    ) -> typing.Optional["ContainerClusterNodePoolNodeConfigReservationAffinity"]:
        return typing.cast(typing.Optional["ContainerClusterNodePoolNodeConfigReservationAffinity"], jsii.get(self, "reservationAffinityInput"))

    @builtins.property
    @jsii.member(jsii_name="resourceLabelsInput")
    def resource_labels_input(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], jsii.get(self, "resourceLabelsInput"))

    @builtins.property
    @jsii.member(jsii_name="resourceManagerTagsInput")
    def resource_manager_tags_input(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], jsii.get(self, "resourceManagerTagsInput"))

    @builtins.property
    @jsii.member(jsii_name="secondaryBootDisksInput")
    def secondary_boot_disks_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ContainerClusterNodePoolNodeConfigSecondaryBootDisks"]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ContainerClusterNodePoolNodeConfigSecondaryBootDisks"]]], jsii.get(self, "secondaryBootDisksInput"))

    @builtins.property
    @jsii.member(jsii_name="serviceAccountInput")
    def service_account_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "serviceAccountInput"))

    @builtins.property
    @jsii.member(jsii_name="shieldedInstanceConfigInput")
    def shielded_instance_config_input(
        self,
    ) -> typing.Optional["ContainerClusterNodePoolNodeConfigShieldedInstanceConfig"]:
        return typing.cast(typing.Optional["ContainerClusterNodePoolNodeConfigShieldedInstanceConfig"], jsii.get(self, "shieldedInstanceConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="soleTenantConfigInput")
    def sole_tenant_config_input(
        self,
    ) -> typing.Optional["ContainerClusterNodePoolNodeConfigSoleTenantConfig"]:
        return typing.cast(typing.Optional["ContainerClusterNodePoolNodeConfigSoleTenantConfig"], jsii.get(self, "soleTenantConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="spotInput")
    def spot_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "spotInput"))

    @builtins.property
    @jsii.member(jsii_name="storagePoolsInput")
    def storage_pools_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "storagePoolsInput"))

    @builtins.property
    @jsii.member(jsii_name="tagsInput")
    def tags_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "tagsInput"))

    @builtins.property
    @jsii.member(jsii_name="taintInput")
    def taint_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ContainerClusterNodePoolNodeConfigTaint"]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ContainerClusterNodePoolNodeConfigTaint"]]], jsii.get(self, "taintInput"))

    @builtins.property
    @jsii.member(jsii_name="windowsNodeConfigInput")
    def windows_node_config_input(
        self,
    ) -> typing.Optional["ContainerClusterNodePoolNodeConfigWindowsNodeConfig"]:
        return typing.cast(typing.Optional["ContainerClusterNodePoolNodeConfigWindowsNodeConfig"], jsii.get(self, "windowsNodeConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="workloadMetadataConfigInput")
    def workload_metadata_config_input(
        self,
    ) -> typing.Optional["ContainerClusterNodePoolNodeConfigWorkloadMetadataConfig"]:
        return typing.cast(typing.Optional["ContainerClusterNodePoolNodeConfigWorkloadMetadataConfig"], jsii.get(self, "workloadMetadataConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="bootDiskKmsKey")
    def boot_disk_kms_key(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "bootDiskKmsKey"))

    @boot_disk_kms_key.setter
    def boot_disk_kms_key(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__45eba2c595e7f25b00f647e4930182165c23ca9c2cb2bdf9a128561fa0915603)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "bootDiskKmsKey", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="diskSizeGb")
    def disk_size_gb(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "diskSizeGb"))

    @disk_size_gb.setter
    def disk_size_gb(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e17aefa685eea708e88d006fd3c11ea44aa6fbb10dc3a4b74d1b4a26b863d2e4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "diskSizeGb", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="diskType")
    def disk_type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "diskType"))

    @disk_type.setter
    def disk_type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0bd4acb8bee7c5a119073312fb6ac763964f0d7c011301790bf9bfcd1be9a512)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "diskType", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="enableConfidentialStorage")
    def enable_confidential_storage(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enableConfidentialStorage"))

    @enable_confidential_storage.setter
    def enable_confidential_storage(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a0dd3288c7bd5b436c555ba6b79677e9659ce55b9ae4b1f61a45e1b279414438)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableConfidentialStorage", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="flexStart")
    def flex_start(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "flexStart"))

    @flex_start.setter
    def flex_start(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f64e86ff210784f125aa2b194fe88b27febb341d099b10d89699d7cf7a24963d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "flexStart", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="imageType")
    def image_type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "imageType"))

    @image_type.setter
    def image_type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7fc81e6c09cdb8138641989e84c0bfb2147e9bf4b10ab380db9cff36eda0897a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "imageType", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="labels")
    def labels(self) -> typing.Mapping[builtins.str, builtins.str]:
        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.get(self, "labels"))

    @labels.setter
    def labels(self, value: typing.Mapping[builtins.str, builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ab6891456d23f0d5852c137162b621fa224ceb2b283d59947571b37c1378245a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "labels", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="localSsdCount")
    def local_ssd_count(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "localSsdCount"))

    @local_ssd_count.setter
    def local_ssd_count(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fd41f9c26b581bfc795d7a83347d46d981b2b4db3f0e7a2abd07a445b662ccdb)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "localSsdCount", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="localSsdEncryptionMode")
    def local_ssd_encryption_mode(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "localSsdEncryptionMode"))

    @local_ssd_encryption_mode.setter
    def local_ssd_encryption_mode(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8775c5aebf174d0ef8ce02a0b19473ad1a86be275a3dbcefafd09b4536d090be)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "localSsdEncryptionMode", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="loggingVariant")
    def logging_variant(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "loggingVariant"))

    @logging_variant.setter
    def logging_variant(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__799fa9144351f6696992764243e61e1679096f6f883820aa2c482a885fbdf7c4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "loggingVariant", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="machineType")
    def machine_type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "machineType"))

    @machine_type.setter
    def machine_type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a0cc645a01328411e806b3941d2a18461debc7096a4a69091f6661ea7290d3a3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "machineType", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="maxRunDuration")
    def max_run_duration(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "maxRunDuration"))

    @max_run_duration.setter
    def max_run_duration(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2ded9d5ae5a60bf8e5fcd8cd0b875bf93fec8f5bb848da497b470ec69fd102fc)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "maxRunDuration", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="metadata")
    def metadata(self) -> typing.Mapping[builtins.str, builtins.str]:
        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.get(self, "metadata"))

    @metadata.setter
    def metadata(self, value: typing.Mapping[builtins.str, builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c0be9a412ca74b8f46358ea6573fdce83eb5abb95bbaddf790ead52ca1ce2fc2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "metadata", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="minCpuPlatform")
    def min_cpu_platform(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "minCpuPlatform"))

    @min_cpu_platform.setter
    def min_cpu_platform(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bcb2d5293b818bc983e084d0df481cce3924fe4f494129581d1a794d6eb370bf)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "minCpuPlatform", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="nodeGroup")
    def node_group(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "nodeGroup"))

    @node_group.setter
    def node_group(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e9f6cbaffc68ee1a2656e2fc3a008ade6b4351658b6ebbcc4d13f295a8e4894b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "nodeGroup", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="oauthScopes")
    def oauth_scopes(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "oauthScopes"))

    @oauth_scopes.setter
    def oauth_scopes(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9c4820a1c528c7ece775ce49d7a7d8c2e11df5b0a68d548a361a7866f0156af8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "oauthScopes", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="preemptible")
    def preemptible(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "preemptible"))

    @preemptible.setter
    def preemptible(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__99efd4ca131d624c59bf2aef6cf0919d04a38ba4ff41a2952c529dc769700272)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "preemptible", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="resourceLabels")
    def resource_labels(self) -> typing.Mapping[builtins.str, builtins.str]:
        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.get(self, "resourceLabels"))

    @resource_labels.setter
    def resource_labels(
        self,
        value: typing.Mapping[builtins.str, builtins.str],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dd0291fcdf33839bc3bc19615372bd9b5db3f35e094d5bba38bfbf8443388964)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "resourceLabels", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="resourceManagerTags")
    def resource_manager_tags(self) -> typing.Mapping[builtins.str, builtins.str]:
        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.get(self, "resourceManagerTags"))

    @resource_manager_tags.setter
    def resource_manager_tags(
        self,
        value: typing.Mapping[builtins.str, builtins.str],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__956a20b039313bb2da0f14fe2a65699735b8e981852e5b98aa9f53fc4607586f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "resourceManagerTags", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="serviceAccount")
    def service_account(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "serviceAccount"))

    @service_account.setter
    def service_account(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0010f68e8f23ac167140be41b54c106d10b203cbe88c1b9bb1cf7e2a7b9e961d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "serviceAccount", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="spot")
    def spot(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "spot"))

    @spot.setter
    def spot(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e554915140d445524925c7ac0ca8468aa2842dc9e06b35bc835221a888c666a5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "spot", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="storagePools")
    def storage_pools(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "storagePools"))

    @storage_pools.setter
    def storage_pools(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2a440f749fa0568fd2eb769188678bc1574916bcfefeb949bfb1c864aa39da47)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "storagePools", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="tags")
    def tags(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "tags"))

    @tags.setter
    def tags(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__398d1001275b664f8f543dd498749a2d243fca94fd7ad17da199ddaeb5753c1b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "tags", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[ContainerClusterNodePoolNodeConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolNodeConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodePoolNodeConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5711dba9b227ca789cb8d81b9d4ec13cc5c18a094740a3628d88490394d00470)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigReservationAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "consume_reservation_type": "consumeReservationType",
        "key": "key",
        "values": "values",
    },
)
class ContainerClusterNodePoolNodeConfigReservationAffinity:
    def __init__(
        self,
        *,
        consume_reservation_type: builtins.str,
        key: typing.Optional[builtins.str] = None,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param consume_reservation_type: Corresponds to the type of reservation consumption. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#consume_reservation_type ContainerCluster#consume_reservation_type}
        :param key: The label key of a reservation resource. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#key ContainerCluster#key}
        :param values: The label values of the reservation resource. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#values ContainerCluster#values}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__77538922f2817c99fce603f56334ba769be7e64af4cbb2f2d0f95c2d70c4f9cd)
            check_type(argname="argument consume_reservation_type", value=consume_reservation_type, expected_type=type_hints["consume_reservation_type"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "consume_reservation_type": consume_reservation_type,
        }
        if key is not None:
            self._values["key"] = key
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def consume_reservation_type(self) -> builtins.str:
        '''Corresponds to the type of reservation consumption.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#consume_reservation_type ContainerCluster#consume_reservation_type}
        '''
        result = self._values.get("consume_reservation_type")
        assert result is not None, "Required property 'consume_reservation_type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The label key of a reservation resource.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#key ContainerCluster#key}
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The label values of the reservation resource.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#values ContainerCluster#values}
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodePoolNodeConfigReservationAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodePoolNodeConfigReservationAffinityOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigReservationAffinityOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ab35f352572d4474d195d8aebee99d8da237d0653536b5b213800f25bcd77d9e)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetKey")
    def reset_key(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetKey", []))

    @jsii.member(jsii_name="resetValues")
    def reset_values(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetValues", []))

    @builtins.property
    @jsii.member(jsii_name="consumeReservationTypeInput")
    def consume_reservation_type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "consumeReservationTypeInput"))

    @builtins.property
    @jsii.member(jsii_name="keyInput")
    def key_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyInput"))

    @builtins.property
    @jsii.member(jsii_name="valuesInput")
    def values_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "valuesInput"))

    @builtins.property
    @jsii.member(jsii_name="consumeReservationType")
    def consume_reservation_type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "consumeReservationType"))

    @consume_reservation_type.setter
    def consume_reservation_type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e948da3421195c81688d214dee8c75592bd0d0500fd600284afc567c1f653ff0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "consumeReservationType", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="key")
    def key(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "key"))

    @key.setter
    def key(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__541b5f1ad62bf2db58c415b3c88f980bdc68cea3b0a6b124118e049ba94008e0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "key", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="values")
    def values(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "values"))

    @values.setter
    def values(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__734dd7871fcfa07fffc465fbd72cabe0e44ed9c00bedd5815752eaf94f060605)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "values", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolNodeConfigReservationAffinity]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolNodeConfigReservationAffinity], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodePoolNodeConfigReservationAffinity],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__91b2d7690363ec82b1153c77871679d8db898ef6376d1cb93df9031a5c4831af)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigSecondaryBootDisks",
    jsii_struct_bases=[],
    name_mapping={"disk_image": "diskImage", "mode": "mode"},
)
class ContainerClusterNodePoolNodeConfigSecondaryBootDisks:
    def __init__(
        self,
        *,
        disk_image: builtins.str,
        mode: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param disk_image: Disk image to create the secondary boot disk from. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#disk_image ContainerCluster#disk_image}
        :param mode: Mode for how the secondary boot disk is used. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#mode ContainerCluster#mode}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7db166d944697cd00452b314923c3765d3c80ad3460637fabaee2394df4e19f5)
            check_type(argname="argument disk_image", value=disk_image, expected_type=type_hints["disk_image"])
            check_type(argname="argument mode", value=mode, expected_type=type_hints["mode"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "disk_image": disk_image,
        }
        if mode is not None:
            self._values["mode"] = mode

    @builtins.property
    def disk_image(self) -> builtins.str:
        '''Disk image to create the secondary boot disk from.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#disk_image ContainerCluster#disk_image}
        '''
        result = self._values.get("disk_image")
        assert result is not None, "Required property 'disk_image' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def mode(self) -> typing.Optional[builtins.str]:
        '''Mode for how the secondary boot disk is used.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#mode ContainerCluster#mode}
        '''
        result = self._values.get("mode")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodePoolNodeConfigSecondaryBootDisks(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodePoolNodeConfigSecondaryBootDisksList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigSecondaryBootDisksList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e162f5c72d8433ca9b33c9fde0943e60abc2d4863c81f8d767501046b0f24e77)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ContainerClusterNodePoolNodeConfigSecondaryBootDisksOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3ac62fc2f5a70075826b941349271932ee5bcd52377c77c6a8cd71e331185d06)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ContainerClusterNodePoolNodeConfigSecondaryBootDisksOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1327d1435d93df12f0c725954b733eb7e2ade95f0e3155ef814146bf7df3d5c0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__81a6f9860401b8293dcfce59fec5577420e673b18a286485d5f24f161f0aae7b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6a376ed1a020da9abff42d52e260366fc909e89c142582f1678bb67cb7d6f431)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodePoolNodeConfigSecondaryBootDisks]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodePoolNodeConfigSecondaryBootDisks]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodePoolNodeConfigSecondaryBootDisks]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e805e5625d85984ccbeae3766259ae6bec70576224236ff939a6d9804f351502)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ContainerClusterNodePoolNodeConfigSecondaryBootDisksOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigSecondaryBootDisksOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f7c07ffc7c9266cf78cf30af29a7b7528c5de9915938298da2539dfc55fd5919)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="resetMode")
    def reset_mode(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMode", []))

    @builtins.property
    @jsii.member(jsii_name="diskImageInput")
    def disk_image_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "diskImageInput"))

    @builtins.property
    @jsii.member(jsii_name="modeInput")
    def mode_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "modeInput"))

    @builtins.property
    @jsii.member(jsii_name="diskImage")
    def disk_image(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "diskImage"))

    @disk_image.setter
    def disk_image(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0605ee60ea3f7a80b568238f8e190d95c3d61e2964eedfbe052154cf571a2939)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "diskImage", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="mode")
    def mode(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "mode"))

    @mode.setter
    def mode(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cca7d6962a936cc659b69ef9cc821f3bb2fcc330e79a925adca298cbf66a6571)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "mode", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterNodePoolNodeConfigSecondaryBootDisks]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterNodePoolNodeConfigSecondaryBootDisks]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterNodePoolNodeConfigSecondaryBootDisks]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4a1e7b112060da2986c1d7ccbc5476ca7d4871f8f3d7be3ad9f3bb9e067c7141)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigShieldedInstanceConfig",
    jsii_struct_bases=[],
    name_mapping={
        "enable_integrity_monitoring": "enableIntegrityMonitoring",
        "enable_secure_boot": "enableSecureBoot",
    },
)
class ContainerClusterNodePoolNodeConfigShieldedInstanceConfig:
    def __init__(
        self,
        *,
        enable_integrity_monitoring: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        enable_secure_boot: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    ) -> None:
        '''
        :param enable_integrity_monitoring: Defines whether the instance has integrity monitoring enabled. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_integrity_monitoring ContainerCluster#enable_integrity_monitoring}
        :param enable_secure_boot: Defines whether the instance has Secure Boot enabled. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_secure_boot ContainerCluster#enable_secure_boot}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__99f4a6c29352235163ea27402916dfe7af868595550c9da4eb697a0fb170afb8)
            check_type(argname="argument enable_integrity_monitoring", value=enable_integrity_monitoring, expected_type=type_hints["enable_integrity_monitoring"])
            check_type(argname="argument enable_secure_boot", value=enable_secure_boot, expected_type=type_hints["enable_secure_boot"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if enable_integrity_monitoring is not None:
            self._values["enable_integrity_monitoring"] = enable_integrity_monitoring
        if enable_secure_boot is not None:
            self._values["enable_secure_boot"] = enable_secure_boot

    @builtins.property
    def enable_integrity_monitoring(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Defines whether the instance has integrity monitoring enabled.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_integrity_monitoring ContainerCluster#enable_integrity_monitoring}
        '''
        result = self._values.get("enable_integrity_monitoring")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def enable_secure_boot(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Defines whether the instance has Secure Boot enabled.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_secure_boot ContainerCluster#enable_secure_boot}
        '''
        result = self._values.get("enable_secure_boot")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodePoolNodeConfigShieldedInstanceConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodePoolNodeConfigShieldedInstanceConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigShieldedInstanceConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__539a6ccca8864f2f140ec5e3a7b868453d19cb74f9809fbe84ce3b411219d76f)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetEnableIntegrityMonitoring")
    def reset_enable_integrity_monitoring(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnableIntegrityMonitoring", []))

    @jsii.member(jsii_name="resetEnableSecureBoot")
    def reset_enable_secure_boot(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnableSecureBoot", []))

    @builtins.property
    @jsii.member(jsii_name="enableIntegrityMonitoringInput")
    def enable_integrity_monitoring_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enableIntegrityMonitoringInput"))

    @builtins.property
    @jsii.member(jsii_name="enableSecureBootInput")
    def enable_secure_boot_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enableSecureBootInput"))

    @builtins.property
    @jsii.member(jsii_name="enableIntegrityMonitoring")
    def enable_integrity_monitoring(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enableIntegrityMonitoring"))

    @enable_integrity_monitoring.setter
    def enable_integrity_monitoring(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9bdaf546c905a14bb4c0e9730139f6065e8366052ebc3808c7d30eb1737263e9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableIntegrityMonitoring", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="enableSecureBoot")
    def enable_secure_boot(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enableSecureBoot"))

    @enable_secure_boot.setter
    def enable_secure_boot(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ee4c71163e8bd189c266104290b6507c2769efb7b93bb1e4c83283f9969a2a22)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableSecureBoot", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolNodeConfigShieldedInstanceConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolNodeConfigShieldedInstanceConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodePoolNodeConfigShieldedInstanceConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6b73ff0563fe0390f6f7a33a9371d600ce11552a5a20c5cfb01026e1a5f35250)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigSoleTenantConfig",
    jsii_struct_bases=[],
    name_mapping={"node_affinity": "nodeAffinity", "min_node_cpus": "minNodeCpus"},
)
class ContainerClusterNodePoolNodeConfigSoleTenantConfig:
    def __init__(
        self,
        *,
        node_affinity: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ContainerClusterNodePoolNodeConfigSoleTenantConfigNodeAffinity", typing.Dict[builtins.str, typing.Any]]]],
        min_node_cpus: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param node_affinity: node_affinity block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#node_affinity ContainerCluster#node_affinity}
        :param min_node_cpus: Specifies the minimum number of vCPUs that each sole tenant node must have to use CPU overcommit. If not specified, the CPU overcommit feature is disabled. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#min_node_cpus ContainerCluster#min_node_cpus}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7daef7103a9eb81b67f3e588961d88d0d109821a45212892921edf53f00a7cb1)
            check_type(argname="argument node_affinity", value=node_affinity, expected_type=type_hints["node_affinity"])
            check_type(argname="argument min_node_cpus", value=min_node_cpus, expected_type=type_hints["min_node_cpus"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "node_affinity": node_affinity,
        }
        if min_node_cpus is not None:
            self._values["min_node_cpus"] = min_node_cpus

    @builtins.property
    def node_affinity(
        self,
    ) -> typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ContainerClusterNodePoolNodeConfigSoleTenantConfigNodeAffinity"]]:
        '''node_affinity block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#node_affinity ContainerCluster#node_affinity}
        '''
        result = self._values.get("node_affinity")
        assert result is not None, "Required property 'node_affinity' is missing"
        return typing.cast(typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ContainerClusterNodePoolNodeConfigSoleTenantConfigNodeAffinity"]], result)

    @builtins.property
    def min_node_cpus(self) -> typing.Optional[jsii.Number]:
        '''Specifies the minimum number of vCPUs that each sole tenant node must have to use CPU overcommit.

        If not specified, the CPU overcommit feature is disabled.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#min_node_cpus ContainerCluster#min_node_cpus}
        '''
        result = self._values.get("min_node_cpus")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodePoolNodeConfigSoleTenantConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigSoleTenantConfigNodeAffinity",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class ContainerClusterNodePoolNodeConfigSoleTenantConfigNodeAffinity:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Sequence[builtins.str],
    ) -> None:
        '''
        :param key: . Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#key ContainerCluster#key}
        :param operator: . Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#operator ContainerCluster#operator}
        :param values: . Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#values ContainerCluster#values}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2e75392c554153696163dd6e1890c00130742d1efa49412cdecdac1063c2641d)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "operator": operator,
            "values": values,
        }

    @builtins.property
    def key(self) -> builtins.str:
        '''.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#key ContainerCluster#key}
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#operator ContainerCluster#operator}
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.List[builtins.str]:
        '''.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#values ContainerCluster#values}
        '''
        result = self._values.get("values")
        assert result is not None, "Required property 'values' is missing"
        return typing.cast(typing.List[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodePoolNodeConfigSoleTenantConfigNodeAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodePoolNodeConfigSoleTenantConfigNodeAffinityList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigSoleTenantConfigNodeAffinityList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__14b8ba3e56d00d0209c3e214dfe98ba6fadef1cc21a3c6c3806541546a1da68d)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ContainerClusterNodePoolNodeConfigSoleTenantConfigNodeAffinityOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8eee06949b1860e7714d2abe306d764a4392e506c37dae46305ea5ac9bf2729e)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ContainerClusterNodePoolNodeConfigSoleTenantConfigNodeAffinityOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__394ee72883375001ce451352fe1142175200333f0b1f61f68c9fff4a217c4e1d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7bb9e00983b9843253fd0be2400812b81ec165bce47aa85ab9e9fe1f64eb70f6)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__82af5d34c9fc13e7e4ce2a50c6e97fb90ec5c40412df3d314869eeac0627c050)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodePoolNodeConfigSoleTenantConfigNodeAffinity]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodePoolNodeConfigSoleTenantConfigNodeAffinity]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodePoolNodeConfigSoleTenantConfigNodeAffinity]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__aefcd570fd2f389036785093edab778feac78915cb80df6079662085e61f345c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ContainerClusterNodePoolNodeConfigSoleTenantConfigNodeAffinityOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigSoleTenantConfigNodeAffinityOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2cebee02370f53ca4372a09cedf249caea4f38768bdaeee06775be02daa952a6)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @builtins.property
    @jsii.member(jsii_name="keyInput")
    def key_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyInput"))

    @builtins.property
    @jsii.member(jsii_name="operatorInput")
    def operator_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "operatorInput"))

    @builtins.property
    @jsii.member(jsii_name="valuesInput")
    def values_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "valuesInput"))

    @builtins.property
    @jsii.member(jsii_name="key")
    def key(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "key"))

    @key.setter
    def key(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9153460a86aeda55927699f6f72d72df7a593aa5780aab533ce8888b6d1dc8b2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "key", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="operator")
    def operator(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "operator"))

    @operator.setter
    def operator(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__74d373c96e63f994fba3ea2128547eb7846659b5c7f7cfb36b7ea1484338a22f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "operator", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="values")
    def values(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "values"))

    @values.setter
    def values(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1b7f4cf942c788f2a17e74000d95479fa00cd16fca7456eb5b52e3fba9cbb0bf)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "values", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterNodePoolNodeConfigSoleTenantConfigNodeAffinity]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterNodePoolNodeConfigSoleTenantConfigNodeAffinity]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterNodePoolNodeConfigSoleTenantConfigNodeAffinity]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6d1b46305b4f77b8c70d750c35623071d7739c95a44d39fb5dd74db2e1932692)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ContainerClusterNodePoolNodeConfigSoleTenantConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigSoleTenantConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__80bc703920ee3dd8a92947491602a661b09669dfe73a62deee1be097e2c597b3)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putNodeAffinity")
    def put_node_affinity(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ContainerClusterNodePoolNodeConfigSoleTenantConfigNodeAffinity, typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5a25f3fb5ce1e4349dced9dd7696bdad300398689680a75a895f1780251532cf)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putNodeAffinity", [value]))

    @jsii.member(jsii_name="resetMinNodeCpus")
    def reset_min_node_cpus(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMinNodeCpus", []))

    @builtins.property
    @jsii.member(jsii_name="nodeAffinity")
    def node_affinity(
        self,
    ) -> ContainerClusterNodePoolNodeConfigSoleTenantConfigNodeAffinityList:
        return typing.cast(ContainerClusterNodePoolNodeConfigSoleTenantConfigNodeAffinityList, jsii.get(self, "nodeAffinity"))

    @builtins.property
    @jsii.member(jsii_name="minNodeCpusInput")
    def min_node_cpus_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "minNodeCpusInput"))

    @builtins.property
    @jsii.member(jsii_name="nodeAffinityInput")
    def node_affinity_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodePoolNodeConfigSoleTenantConfigNodeAffinity]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodePoolNodeConfigSoleTenantConfigNodeAffinity]]], jsii.get(self, "nodeAffinityInput"))

    @builtins.property
    @jsii.member(jsii_name="minNodeCpus")
    def min_node_cpus(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "minNodeCpus"))

    @min_node_cpus.setter
    def min_node_cpus(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cf592a0c8201709ce97df176012aaa53c659174af743fdbaba5c0e351d41bc65)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "minNodeCpus", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolNodeConfigSoleTenantConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolNodeConfigSoleTenantConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodePoolNodeConfigSoleTenantConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0c32e1909d94c0f6e9aaf8d8a0b0bafb28a872a96493e1d7e4ccc4b38d775337)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigTaint",
    jsii_struct_bases=[],
    name_mapping={"effect": "effect", "key": "key", "value": "value"},
)
class ContainerClusterNodePoolNodeConfigTaint:
    def __init__(
        self,
        *,
        effect: builtins.str,
        key: builtins.str,
        value: builtins.str,
    ) -> None:
        '''
        :param effect: Effect for taint. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#effect ContainerCluster#effect}
        :param key: Key for taint. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#key ContainerCluster#key}
        :param value: Value for taint. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#value ContainerCluster#value}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0e936a4ccbedef9f19741eef29a1536b4d271168d4dac60caf30bf8dce07ea0c)
            check_type(argname="argument effect", value=effect, expected_type=type_hints["effect"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "effect": effect,
            "key": key,
            "value": value,
        }

    @builtins.property
    def effect(self) -> builtins.str:
        '''Effect for taint.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#effect ContainerCluster#effect}
        '''
        result = self._values.get("effect")
        assert result is not None, "Required property 'effect' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def key(self) -> builtins.str:
        '''Key for taint.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#key ContainerCluster#key}
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> builtins.str:
        '''Value for taint.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#value ContainerCluster#value}
        '''
        result = self._values.get("value")
        assert result is not None, "Required property 'value' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodePoolNodeConfigTaint(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodePoolNodeConfigTaintList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigTaintList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9abd632b209f148417812330e6da16cce5ff958664adc4993e269430e2aca1b8)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(
        self,
        index: jsii.Number,
    ) -> "ContainerClusterNodePoolNodeConfigTaintOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f867d9d9e3179c14632a93d4ce1c45abfcb2538d111fa14f7a9be0e2f66dc432)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ContainerClusterNodePoolNodeConfigTaintOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f659bb874cc95e11c7e20748b96271ecc88c915eee716696aa2eabd2a4272319)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__662441c9aa5ddcc8f18bec4b37a2c84175daa4a1d69d0f573e6aa2ab6def8d67)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ddbc28ddba120ddd043478652e0b358c1f88d367e3c39c42444631a82f0b3833)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodePoolNodeConfigTaint]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodePoolNodeConfigTaint]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodePoolNodeConfigTaint]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0ed42ccabaf080e7514ae2d00534b1ffd0f028f60ad7642ecae73634e8d28838)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ContainerClusterNodePoolNodeConfigTaintOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigTaintOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__47860b1d86c8fa47025ab0c8ab53ceff71466def5dcd83f5a5ebf90cc9ffb14c)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @builtins.property
    @jsii.member(jsii_name="effectInput")
    def effect_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "effectInput"))

    @builtins.property
    @jsii.member(jsii_name="keyInput")
    def key_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyInput"))

    @builtins.property
    @jsii.member(jsii_name="valueInput")
    def value_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "valueInput"))

    @builtins.property
    @jsii.member(jsii_name="effect")
    def effect(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "effect"))

    @effect.setter
    def effect(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1b716f7bbd0842e23601ff92b5e67cda8be0fc9d8f66a67ddd5af495511f7794)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "effect", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="key")
    def key(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "key"))

    @key.setter
    def key(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ef204238f0c2e7ccc645c619d90d1aec5e89eb1b959339ada7758b4930d2c66a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "key", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="value")
    def value(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "value"))

    @value.setter
    def value(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__05613cfd730db1d6be71c886de3cf1d53b0f0b0303480379a27eb155cb98c8df)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "value", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterNodePoolNodeConfigTaint]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterNodePoolNodeConfigTaint]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterNodePoolNodeConfigTaint]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d40197c7a9ea21f73d1de0ff27d0814f135286e845253d589152fabe8735456a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigWindowsNodeConfig",
    jsii_struct_bases=[],
    name_mapping={"osversion": "osversion"},
)
class ContainerClusterNodePoolNodeConfigWindowsNodeConfig:
    def __init__(self, *, osversion: typing.Optional[builtins.str] = None) -> None:
        '''
        :param osversion: The OS Version of the windows nodepool.Values are OS_VERSION_UNSPECIFIED,OS_VERSION_LTSC2019 and OS_VERSION_LTSC2022. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#osversion ContainerCluster#osversion}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7bcd2a35ff68e49833ce2cb5ce97af08b5d195d85e0d12c777a0b34fbc7046a9)
            check_type(argname="argument osversion", value=osversion, expected_type=type_hints["osversion"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if osversion is not None:
            self._values["osversion"] = osversion

    @builtins.property
    def osversion(self) -> typing.Optional[builtins.str]:
        '''The OS Version of the windows nodepool.Values are OS_VERSION_UNSPECIFIED,OS_VERSION_LTSC2019 and OS_VERSION_LTSC2022.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#osversion ContainerCluster#osversion}
        '''
        result = self._values.get("osversion")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodePoolNodeConfigWindowsNodeConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodePoolNodeConfigWindowsNodeConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigWindowsNodeConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b31daeb03362925dc05f3a2bdf5b80e41e016c47c9cb8f0f20e17114fb64f3b2)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetOsversion")
    def reset_osversion(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetOsversion", []))

    @builtins.property
    @jsii.member(jsii_name="osversionInput")
    def osversion_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "osversionInput"))

    @builtins.property
    @jsii.member(jsii_name="osversion")
    def osversion(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "osversion"))

    @osversion.setter
    def osversion(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9d8a2fdbd048414d0d03a1d853c8cada4168c6c1bcc360f824190e5866f485a7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "osversion", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolNodeConfigWindowsNodeConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolNodeConfigWindowsNodeConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodePoolNodeConfigWindowsNodeConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4cdbb9a5b922fa2e839ade6efb366dbf994a88105b9d35bf7428f5c81fd108b4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigWorkloadMetadataConfig",
    jsii_struct_bases=[],
    name_mapping={"mode": "mode"},
)
class ContainerClusterNodePoolNodeConfigWorkloadMetadataConfig:
    def __init__(self, *, mode: builtins.str) -> None:
        '''
        :param mode: Mode is the configuration for how to expose metadata to workloads running on the node. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#mode ContainerCluster#mode}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9c18fda88d977847a9f4b544c5038f65ff00eaf196bd66ce01d03c1808786402)
            check_type(argname="argument mode", value=mode, expected_type=type_hints["mode"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "mode": mode,
        }

    @builtins.property
    def mode(self) -> builtins.str:
        '''Mode is the configuration for how to expose metadata to workloads running on the node.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#mode ContainerCluster#mode}
        '''
        result = self._values.get("mode")
        assert result is not None, "Required property 'mode' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodePoolNodeConfigWorkloadMetadataConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodePoolNodeConfigWorkloadMetadataConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolNodeConfigWorkloadMetadataConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f169d8afdd813238c2b0a8c3e143048e07127c7d88356a0a8960f9d40d0ac4f0)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="modeInput")
    def mode_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "modeInput"))

    @builtins.property
    @jsii.member(jsii_name="mode")
    def mode(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "mode"))

    @mode.setter
    def mode(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__380b19ea5652ebc07c13879739841262fea4f60a8058071ddf76874f3e5e7b1b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "mode", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolNodeConfigWorkloadMetadataConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolNodeConfigWorkloadMetadataConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodePoolNodeConfigWorkloadMetadataConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5244e7de9a1741d43bb9c7d71417d355f76a504cddaa5599f850833278f566f8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ContainerClusterNodePoolOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d9ead4e0a31c83e8d73aee7e8b154f5a7377b3d0a5c0a2bf14090dd882bdf1a5)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="putAutoscaling")
    def put_autoscaling(
        self,
        *,
        location_policy: typing.Optional[builtins.str] = None,
        max_node_count: typing.Optional[jsii.Number] = None,
        min_node_count: typing.Optional[jsii.Number] = None,
        total_max_node_count: typing.Optional[jsii.Number] = None,
        total_min_node_count: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param location_policy: Location policy specifies the algorithm used when scaling-up the node pool. "BALANCED" - Is a best effort policy that aims to balance the sizes of available zones. "ANY" - Instructs the cluster autoscaler to prioritize utilization of unused reservations, and reduces preemption risk for Spot VMs. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#location_policy ContainerCluster#location_policy}
        :param max_node_count: Maximum number of nodes per zone in the node pool. Must be >= min_node_count. Cannot be used with total limits. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#max_node_count ContainerCluster#max_node_count}
        :param min_node_count: Minimum number of nodes per zone in the node pool. Must be >=0 and <= max_node_count. Cannot be used with total limits. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#min_node_count ContainerCluster#min_node_count}
        :param total_max_node_count: Maximum number of all nodes in the node pool. Must be >= total_min_node_count. Cannot be used with per zone limits. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#total_max_node_count ContainerCluster#total_max_node_count}
        :param total_min_node_count: Minimum number of all nodes in the node pool. Must be >=0 and <= total_max_node_count. Cannot be used with per zone limits. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#total_min_node_count ContainerCluster#total_min_node_count}
        '''
        value = ContainerClusterNodePoolAutoscaling(
            location_policy=location_policy,
            max_node_count=max_node_count,
            min_node_count=min_node_count,
            total_max_node_count=total_max_node_count,
            total_min_node_count=total_min_node_count,
        )

        return typing.cast(None, jsii.invoke(self, "putAutoscaling", [value]))

    @jsii.member(jsii_name="putManagement")
    def put_management(
        self,
        *,
        auto_repair: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        auto_upgrade: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    ) -> None:
        '''
        :param auto_repair: Whether the nodes will be automatically repaired. Enabled by default. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#auto_repair ContainerCluster#auto_repair}
        :param auto_upgrade: Whether the nodes will be automatically upgraded. Enabled by default. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#auto_upgrade ContainerCluster#auto_upgrade}
        '''
        value = ContainerClusterNodePoolManagement(
            auto_repair=auto_repair, auto_upgrade=auto_upgrade
        )

        return typing.cast(None, jsii.invoke(self, "putManagement", [value]))

    @jsii.member(jsii_name="putNetworkConfig")
    def put_network_config(
        self,
        *,
        additional_node_network_configs: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ContainerClusterNodePoolNetworkConfigAdditionalNodeNetworkConfigs, typing.Dict[builtins.str, typing.Any]]]]] = None,
        additional_pod_network_configs: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ContainerClusterNodePoolNetworkConfigAdditionalPodNetworkConfigs, typing.Dict[builtins.str, typing.Any]]]]] = None,
        create_pod_range: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        enable_private_nodes: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        network_performance_config: typing.Optional[typing.Union[ContainerClusterNodePoolNetworkConfigNetworkPerformanceConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        pod_cidr_overprovision_config: typing.Optional[typing.Union[ContainerClusterNodePoolNetworkConfigPodCidrOverprovisionConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        pod_ipv4_cidr_block: typing.Optional[builtins.str] = None,
        pod_range: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param additional_node_network_configs: additional_node_network_configs block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#additional_node_network_configs ContainerCluster#additional_node_network_configs}
        :param additional_pod_network_configs: additional_pod_network_configs block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#additional_pod_network_configs ContainerCluster#additional_pod_network_configs}
        :param create_pod_range: Whether to create a new range for pod IPs in this node pool. Defaults are provided for pod_range and pod_ipv4_cidr_block if they are not specified. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#create_pod_range ContainerCluster#create_pod_range}
        :param enable_private_nodes: Whether nodes have internal IP addresses only. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_private_nodes ContainerCluster#enable_private_nodes}
        :param network_performance_config: network_performance_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#network_performance_config ContainerCluster#network_performance_config}
        :param pod_cidr_overprovision_config: pod_cidr_overprovision_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#pod_cidr_overprovision_config ContainerCluster#pod_cidr_overprovision_config}
        :param pod_ipv4_cidr_block: The IP address range for pod IPs in this node pool. Only applicable if create_pod_range is true. Set to blank to have a range chosen with the default size. Set to /netmask (e.g. /14) to have a range chosen with a specific netmask. Set to a CIDR notation (e.g. 10.96.0.0/14) to pick a specific range to use. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#pod_ipv4_cidr_block ContainerCluster#pod_ipv4_cidr_block}
        :param pod_range: The ID of the secondary range for pod IPs. If create_pod_range is true, this ID is used for the new range. If create_pod_range is false, uses an existing secondary range with this ID. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#pod_range ContainerCluster#pod_range}
        '''
        value = ContainerClusterNodePoolNetworkConfig(
            additional_node_network_configs=additional_node_network_configs,
            additional_pod_network_configs=additional_pod_network_configs,
            create_pod_range=create_pod_range,
            enable_private_nodes=enable_private_nodes,
            network_performance_config=network_performance_config,
            pod_cidr_overprovision_config=pod_cidr_overprovision_config,
            pod_ipv4_cidr_block=pod_ipv4_cidr_block,
            pod_range=pod_range,
        )

        return typing.cast(None, jsii.invoke(self, "putNetworkConfig", [value]))

    @jsii.member(jsii_name="putNodeConfig")
    def put_node_config(
        self,
        *,
        advanced_machine_features: typing.Optional[typing.Union[ContainerClusterNodePoolNodeConfigAdvancedMachineFeatures, typing.Dict[builtins.str, typing.Any]]] = None,
        boot_disk: typing.Optional[typing.Union[ContainerClusterNodePoolNodeConfigBootDisk, typing.Dict[builtins.str, typing.Any]]] = None,
        boot_disk_kms_key: typing.Optional[builtins.str] = None,
        confidential_nodes: typing.Optional[typing.Union[ContainerClusterNodePoolNodeConfigConfidentialNodes, typing.Dict[builtins.str, typing.Any]]] = None,
        containerd_config: typing.Optional[typing.Union[ContainerClusterNodePoolNodeConfigContainerdConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        disk_size_gb: typing.Optional[jsii.Number] = None,
        disk_type: typing.Optional[builtins.str] = None,
        enable_confidential_storage: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        ephemeral_storage_local_ssd_config: typing.Optional[typing.Union[ContainerClusterNodePoolNodeConfigEphemeralStorageLocalSsdConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        fast_socket: typing.Optional[typing.Union[ContainerClusterNodePoolNodeConfigFastSocket, typing.Dict[builtins.str, typing.Any]]] = None,
        flex_start: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        gcfs_config: typing.Optional[typing.Union[ContainerClusterNodePoolNodeConfigGcfsConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        guest_accelerator: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ContainerClusterNodePoolNodeConfigGuestAccelerator, typing.Dict[builtins.str, typing.Any]]]]] = None,
        gvnic: typing.Optional[typing.Union[ContainerClusterNodePoolNodeConfigGvnic, typing.Dict[builtins.str, typing.Any]]] = None,
        host_maintenance_policy: typing.Optional[typing.Union[ContainerClusterNodePoolNodeConfigHostMaintenancePolicy, typing.Dict[builtins.str, typing.Any]]] = None,
        image_type: typing.Optional[builtins.str] = None,
        kubelet_config: typing.Optional[typing.Union[ContainerClusterNodePoolNodeConfigKubeletConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        linux_node_config: typing.Optional[typing.Union[ContainerClusterNodePoolNodeConfigLinuxNodeConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        local_nvme_ssd_block_config: typing.Optional[typing.Union[ContainerClusterNodePoolNodeConfigLocalNvmeSsdBlockConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        local_ssd_count: typing.Optional[jsii.Number] = None,
        local_ssd_encryption_mode: typing.Optional[builtins.str] = None,
        logging_variant: typing.Optional[builtins.str] = None,
        machine_type: typing.Optional[builtins.str] = None,
        max_run_duration: typing.Optional[builtins.str] = None,
        metadata: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        min_cpu_platform: typing.Optional[builtins.str] = None,
        node_group: typing.Optional[builtins.str] = None,
        oauth_scopes: typing.Optional[typing.Sequence[builtins.str]] = None,
        preemptible: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        reservation_affinity: typing.Optional[typing.Union[ContainerClusterNodePoolNodeConfigReservationAffinity, typing.Dict[builtins.str, typing.Any]]] = None,
        resource_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        resource_manager_tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        secondary_boot_disks: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ContainerClusterNodePoolNodeConfigSecondaryBootDisks, typing.Dict[builtins.str, typing.Any]]]]] = None,
        service_account: typing.Optional[builtins.str] = None,
        shielded_instance_config: typing.Optional[typing.Union[ContainerClusterNodePoolNodeConfigShieldedInstanceConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        sole_tenant_config: typing.Optional[typing.Union[ContainerClusterNodePoolNodeConfigSoleTenantConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        spot: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        storage_pools: typing.Optional[typing.Sequence[builtins.str]] = None,
        tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        taint: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ContainerClusterNodePoolNodeConfigTaint, typing.Dict[builtins.str, typing.Any]]]]] = None,
        windows_node_config: typing.Optional[typing.Union[ContainerClusterNodePoolNodeConfigWindowsNodeConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        workload_metadata_config: typing.Optional[typing.Union[ContainerClusterNodePoolNodeConfigWorkloadMetadataConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param advanced_machine_features: advanced_machine_features block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#advanced_machine_features ContainerCluster#advanced_machine_features}
        :param boot_disk: boot_disk block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#boot_disk ContainerCluster#boot_disk}
        :param boot_disk_kms_key: The Customer Managed Encryption Key used to encrypt the boot disk attached to each node in the node pool. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#boot_disk_kms_key ContainerCluster#boot_disk_kms_key}
        :param confidential_nodes: confidential_nodes block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#confidential_nodes ContainerCluster#confidential_nodes}
        :param containerd_config: containerd_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#containerd_config ContainerCluster#containerd_config}
        :param disk_size_gb: Size of the disk attached to each node, specified in GB. The smallest allowed disk size is 10GB. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#disk_size_gb ContainerCluster#disk_size_gb}
        :param disk_type: Type of the disk attached to each node. Such as pd-standard, pd-balanced or pd-ssd. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#disk_type ContainerCluster#disk_type}
        :param enable_confidential_storage: If enabled boot disks are configured with confidential mode. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_confidential_storage ContainerCluster#enable_confidential_storage}
        :param ephemeral_storage_local_ssd_config: ephemeral_storage_local_ssd_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#ephemeral_storage_local_ssd_config ContainerCluster#ephemeral_storage_local_ssd_config}
        :param fast_socket: fast_socket block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#fast_socket ContainerCluster#fast_socket}
        :param flex_start: Enables Flex Start provisioning model for the node pool. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#flex_start ContainerCluster#flex_start}
        :param gcfs_config: gcfs_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gcfs_config ContainerCluster#gcfs_config}
        :param guest_accelerator: guest_accelerator block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#guest_accelerator ContainerCluster#guest_accelerator}
        :param gvnic: gvnic block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gvnic ContainerCluster#gvnic}
        :param host_maintenance_policy: host_maintenance_policy block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#host_maintenance_policy ContainerCluster#host_maintenance_policy}
        :param image_type: The image type to use for this node. Note that for a given image type, the latest version of it will be used. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#image_type ContainerCluster#image_type}
        :param kubelet_config: kubelet_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#kubelet_config ContainerCluster#kubelet_config}
        :param labels: The map of Kubernetes labels (key/value pairs) to be applied to each node. These will added in addition to any default label(s) that Kubernetes may apply to the node. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#labels ContainerCluster#labels}
        :param linux_node_config: linux_node_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#linux_node_config ContainerCluster#linux_node_config}
        :param local_nvme_ssd_block_config: local_nvme_ssd_block_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#local_nvme_ssd_block_config ContainerCluster#local_nvme_ssd_block_config}
        :param local_ssd_count: The number of local SSD disks to be attached to the node. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#local_ssd_count ContainerCluster#local_ssd_count}
        :param local_ssd_encryption_mode: LocalSsdEncryptionMode specified the method used for encrypting the local SSDs attached to the node. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#local_ssd_encryption_mode ContainerCluster#local_ssd_encryption_mode}
        :param logging_variant: Type of logging agent that is used as the default value for node pools in the cluster. Valid values include DEFAULT and MAX_THROUGHPUT. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#logging_variant ContainerCluster#logging_variant}
        :param machine_type: The name of a Google Compute Engine machine type. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#machine_type ContainerCluster#machine_type}
        :param max_run_duration: The runtime of each node in the node pool in seconds, terminated by 's'. Example: "3600s". Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#max_run_duration ContainerCluster#max_run_duration}
        :param metadata: The metadata key/value pairs assigned to instances in the cluster. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#metadata ContainerCluster#metadata}
        :param min_cpu_platform: Minimum CPU platform to be used by this instance. The instance may be scheduled on the specified or newer CPU platform. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#min_cpu_platform ContainerCluster#min_cpu_platform}
        :param node_group: Setting this field will assign instances of this pool to run on the specified node group. This is useful for running workloads on sole tenant nodes. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#node_group ContainerCluster#node_group}
        :param oauth_scopes: The set of Google API scopes to be made available on all of the node VMs. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#oauth_scopes ContainerCluster#oauth_scopes}
        :param preemptible: Whether the nodes are created as preemptible VM instances. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#preemptible ContainerCluster#preemptible}
        :param reservation_affinity: reservation_affinity block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#reservation_affinity ContainerCluster#reservation_affinity}
        :param resource_labels: The GCE resource labels (a map of key/value pairs) to be applied to the node pool. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#resource_labels ContainerCluster#resource_labels}
        :param resource_manager_tags: A map of resource manager tags. Resource manager tag keys and values have the same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id}, and values are in the format tagValues/456. The field is ignored (both PUT & PATCH) when empty. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#resource_manager_tags ContainerCluster#resource_manager_tags}
        :param secondary_boot_disks: secondary_boot_disks block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#secondary_boot_disks ContainerCluster#secondary_boot_disks}
        :param service_account: The Google Cloud Platform Service Account to be used by the node VMs. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#service_account ContainerCluster#service_account}
        :param shielded_instance_config: shielded_instance_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#shielded_instance_config ContainerCluster#shielded_instance_config}
        :param sole_tenant_config: sole_tenant_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#sole_tenant_config ContainerCluster#sole_tenant_config}
        :param spot: Whether the nodes are created as spot VM instances. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#spot ContainerCluster#spot}
        :param storage_pools: The list of Storage Pools where boot disks are provisioned. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#storage_pools ContainerCluster#storage_pools}
        :param tags: The list of instance tags applied to all nodes. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#tags ContainerCluster#tags}
        :param taint: taint block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#taint ContainerCluster#taint}
        :param windows_node_config: windows_node_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#windows_node_config ContainerCluster#windows_node_config}
        :param workload_metadata_config: workload_metadata_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#workload_metadata_config ContainerCluster#workload_metadata_config}
        '''
        value = ContainerClusterNodePoolNodeConfig(
            advanced_machine_features=advanced_machine_features,
            boot_disk=boot_disk,
            boot_disk_kms_key=boot_disk_kms_key,
            confidential_nodes=confidential_nodes,
            containerd_config=containerd_config,
            disk_size_gb=disk_size_gb,
            disk_type=disk_type,
            enable_confidential_storage=enable_confidential_storage,
            ephemeral_storage_local_ssd_config=ephemeral_storage_local_ssd_config,
            fast_socket=fast_socket,
            flex_start=flex_start,
            gcfs_config=gcfs_config,
            guest_accelerator=guest_accelerator,
            gvnic=gvnic,
            host_maintenance_policy=host_maintenance_policy,
            image_type=image_type,
            kubelet_config=kubelet_config,
            labels=labels,
            linux_node_config=linux_node_config,
            local_nvme_ssd_block_config=local_nvme_ssd_block_config,
            local_ssd_count=local_ssd_count,
            local_ssd_encryption_mode=local_ssd_encryption_mode,
            logging_variant=logging_variant,
            machine_type=machine_type,
            max_run_duration=max_run_duration,
            metadata=metadata,
            min_cpu_platform=min_cpu_platform,
            node_group=node_group,
            oauth_scopes=oauth_scopes,
            preemptible=preemptible,
            reservation_affinity=reservation_affinity,
            resource_labels=resource_labels,
            resource_manager_tags=resource_manager_tags,
            secondary_boot_disks=secondary_boot_disks,
            service_account=service_account,
            shielded_instance_config=shielded_instance_config,
            sole_tenant_config=sole_tenant_config,
            spot=spot,
            storage_pools=storage_pools,
            tags=tags,
            taint=taint,
            windows_node_config=windows_node_config,
            workload_metadata_config=workload_metadata_config,
        )

        return typing.cast(None, jsii.invoke(self, "putNodeConfig", [value]))

    @jsii.member(jsii_name="putPlacementPolicy")
    def put_placement_policy(
        self,
        *,
        type: builtins.str,
        policy_name: typing.Optional[builtins.str] = None,
        tpu_topology: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param type: Type defines the type of placement policy. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#type ContainerCluster#type}
        :param policy_name: If set, refers to the name of a custom resource policy supplied by the user. The resource policy must be in the same project and region as the node pool. If not found, InvalidArgument error is returned. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#policy_name ContainerCluster#policy_name}
        :param tpu_topology: The TPU topology like "2x4" or "2x2x2". https://cloud.google.com/kubernetes-engine/docs/concepts/plan-tpus#topology. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#tpu_topology ContainerCluster#tpu_topology}
        '''
        value = ContainerClusterNodePoolPlacementPolicy(
            type=type, policy_name=policy_name, tpu_topology=tpu_topology
        )

        return typing.cast(None, jsii.invoke(self, "putPlacementPolicy", [value]))

    @jsii.member(jsii_name="putQueuedProvisioning")
    def put_queued_provisioning(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param enabled: Whether nodes in this node pool are obtainable solely through the ProvisioningRequest API. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        '''
        value = ContainerClusterNodePoolQueuedProvisioning(enabled=enabled)

        return typing.cast(None, jsii.invoke(self, "putQueuedProvisioning", [value]))

    @jsii.member(jsii_name="putUpgradeSettings")
    def put_upgrade_settings(
        self,
        *,
        blue_green_settings: typing.Optional[typing.Union["ContainerClusterNodePoolUpgradeSettingsBlueGreenSettings", typing.Dict[builtins.str, typing.Any]]] = None,
        max_surge: typing.Optional[jsii.Number] = None,
        max_unavailable: typing.Optional[jsii.Number] = None,
        strategy: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param blue_green_settings: blue_green_settings block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#blue_green_settings ContainerCluster#blue_green_settings}
        :param max_surge: The number of additional nodes that can be added to the node pool during an upgrade. Increasing max_surge raises the number of nodes that can be upgraded simultaneously. Can be set to 0 or greater. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#max_surge ContainerCluster#max_surge}
        :param max_unavailable: The number of nodes that can be simultaneously unavailable during an upgrade. Increasing max_unavailable raises the number of nodes that can be upgraded in parallel. Can be set to 0 or greater. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#max_unavailable ContainerCluster#max_unavailable}
        :param strategy: Update strategy for the given nodepool. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#strategy ContainerCluster#strategy}
        '''
        value = ContainerClusterNodePoolUpgradeSettings(
            blue_green_settings=blue_green_settings,
            max_surge=max_surge,
            max_unavailable=max_unavailable,
            strategy=strategy,
        )

        return typing.cast(None, jsii.invoke(self, "putUpgradeSettings", [value]))

    @jsii.member(jsii_name="resetAutoscaling")
    def reset_autoscaling(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAutoscaling", []))

    @jsii.member(jsii_name="resetInitialNodeCount")
    def reset_initial_node_count(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetInitialNodeCount", []))

    @jsii.member(jsii_name="resetManagement")
    def reset_management(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetManagement", []))

    @jsii.member(jsii_name="resetMaxPodsPerNode")
    def reset_max_pods_per_node(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMaxPodsPerNode", []))

    @jsii.member(jsii_name="resetName")
    def reset_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetName", []))

    @jsii.member(jsii_name="resetNamePrefix")
    def reset_name_prefix(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNamePrefix", []))

    @jsii.member(jsii_name="resetNetworkConfig")
    def reset_network_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNetworkConfig", []))

    @jsii.member(jsii_name="resetNodeConfig")
    def reset_node_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNodeConfig", []))

    @jsii.member(jsii_name="resetNodeCount")
    def reset_node_count(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNodeCount", []))

    @jsii.member(jsii_name="resetNodeLocations")
    def reset_node_locations(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNodeLocations", []))

    @jsii.member(jsii_name="resetPlacementPolicy")
    def reset_placement_policy(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPlacementPolicy", []))

    @jsii.member(jsii_name="resetQueuedProvisioning")
    def reset_queued_provisioning(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetQueuedProvisioning", []))

    @jsii.member(jsii_name="resetUpgradeSettings")
    def reset_upgrade_settings(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetUpgradeSettings", []))

    @jsii.member(jsii_name="resetVersion")
    def reset_version(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetVersion", []))

    @builtins.property
    @jsii.member(jsii_name="autoscaling")
    def autoscaling(self) -> ContainerClusterNodePoolAutoscalingOutputReference:
        return typing.cast(ContainerClusterNodePoolAutoscalingOutputReference, jsii.get(self, "autoscaling"))

    @builtins.property
    @jsii.member(jsii_name="instanceGroupUrls")
    def instance_group_urls(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "instanceGroupUrls"))

    @builtins.property
    @jsii.member(jsii_name="managedInstanceGroupUrls")
    def managed_instance_group_urls(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "managedInstanceGroupUrls"))

    @builtins.property
    @jsii.member(jsii_name="management")
    def management(self) -> ContainerClusterNodePoolManagementOutputReference:
        return typing.cast(ContainerClusterNodePoolManagementOutputReference, jsii.get(self, "management"))

    @builtins.property
    @jsii.member(jsii_name="networkConfig")
    def network_config(self) -> ContainerClusterNodePoolNetworkConfigOutputReference:
        return typing.cast(ContainerClusterNodePoolNetworkConfigOutputReference, jsii.get(self, "networkConfig"))

    @builtins.property
    @jsii.member(jsii_name="nodeConfig")
    def node_config(self) -> ContainerClusterNodePoolNodeConfigOutputReference:
        return typing.cast(ContainerClusterNodePoolNodeConfigOutputReference, jsii.get(self, "nodeConfig"))

    @builtins.property
    @jsii.member(jsii_name="placementPolicy")
    def placement_policy(
        self,
    ) -> "ContainerClusterNodePoolPlacementPolicyOutputReference":
        return typing.cast("ContainerClusterNodePoolPlacementPolicyOutputReference", jsii.get(self, "placementPolicy"))

    @builtins.property
    @jsii.member(jsii_name="queuedProvisioning")
    def queued_provisioning(
        self,
    ) -> "ContainerClusterNodePoolQueuedProvisioningOutputReference":
        return typing.cast("ContainerClusterNodePoolQueuedProvisioningOutputReference", jsii.get(self, "queuedProvisioning"))

    @builtins.property
    @jsii.member(jsii_name="upgradeSettings")
    def upgrade_settings(
        self,
    ) -> "ContainerClusterNodePoolUpgradeSettingsOutputReference":
        return typing.cast("ContainerClusterNodePoolUpgradeSettingsOutputReference", jsii.get(self, "upgradeSettings"))

    @builtins.property
    @jsii.member(jsii_name="autoscalingInput")
    def autoscaling_input(self) -> typing.Optional[ContainerClusterNodePoolAutoscaling]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolAutoscaling], jsii.get(self, "autoscalingInput"))

    @builtins.property
    @jsii.member(jsii_name="initialNodeCountInput")
    def initial_node_count_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "initialNodeCountInput"))

    @builtins.property
    @jsii.member(jsii_name="managementInput")
    def management_input(self) -> typing.Optional[ContainerClusterNodePoolManagement]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolManagement], jsii.get(self, "managementInput"))

    @builtins.property
    @jsii.member(jsii_name="maxPodsPerNodeInput")
    def max_pods_per_node_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "maxPodsPerNodeInput"))

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="namePrefixInput")
    def name_prefix_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "namePrefixInput"))

    @builtins.property
    @jsii.member(jsii_name="networkConfigInput")
    def network_config_input(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolNetworkConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolNetworkConfig], jsii.get(self, "networkConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="nodeConfigInput")
    def node_config_input(self) -> typing.Optional[ContainerClusterNodePoolNodeConfig]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolNodeConfig], jsii.get(self, "nodeConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="nodeCountInput")
    def node_count_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "nodeCountInput"))

    @builtins.property
    @jsii.member(jsii_name="nodeLocationsInput")
    def node_locations_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "nodeLocationsInput"))

    @builtins.property
    @jsii.member(jsii_name="placementPolicyInput")
    def placement_policy_input(
        self,
    ) -> typing.Optional["ContainerClusterNodePoolPlacementPolicy"]:
        return typing.cast(typing.Optional["ContainerClusterNodePoolPlacementPolicy"], jsii.get(self, "placementPolicyInput"))

    @builtins.property
    @jsii.member(jsii_name="queuedProvisioningInput")
    def queued_provisioning_input(
        self,
    ) -> typing.Optional["ContainerClusterNodePoolQueuedProvisioning"]:
        return typing.cast(typing.Optional["ContainerClusterNodePoolQueuedProvisioning"], jsii.get(self, "queuedProvisioningInput"))

    @builtins.property
    @jsii.member(jsii_name="upgradeSettingsInput")
    def upgrade_settings_input(
        self,
    ) -> typing.Optional["ContainerClusterNodePoolUpgradeSettings"]:
        return typing.cast(typing.Optional["ContainerClusterNodePoolUpgradeSettings"], jsii.get(self, "upgradeSettingsInput"))

    @builtins.property
    @jsii.member(jsii_name="versionInput")
    def version_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "versionInput"))

    @builtins.property
    @jsii.member(jsii_name="initialNodeCount")
    def initial_node_count(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "initialNodeCount"))

    @initial_node_count.setter
    def initial_node_count(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9ec4185a6a2affbfcca38432f4768cb61e15b79ffb22add7df21944afb635200)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "initialNodeCount", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="maxPodsPerNode")
    def max_pods_per_node(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "maxPodsPerNode"))

    @max_pods_per_node.setter
    def max_pods_per_node(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__99fcbeb6a2f5be5aee2f138f08d809ad680ae84ca4c03af35c6a02bd07e2cab8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "maxPodsPerNode", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a6e6105fc137ac002e2b06f1ddd6368cce132afdcf02687208d3b2c83f5986cc)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "name", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="namePrefix")
    def name_prefix(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "namePrefix"))

    @name_prefix.setter
    def name_prefix(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0a6f88bbaeb1840b3fea0aeb50dc70f0484dd8c1c2324063abc19caaff5da687)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "namePrefix", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="nodeCount")
    def node_count(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "nodeCount"))

    @node_count.setter
    def node_count(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c682c40530b1d5f661ade5337d41c283f274b82f889d9950f1f8949dd29c1183)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "nodeCount", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="nodeLocations")
    def node_locations(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "nodeLocations"))

    @node_locations.setter
    def node_locations(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__441f415d99554c764a0d77e624a44c6993629f964ad7393a56f3e71d1b3d9462)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "nodeLocations", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="version")
    def version(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "version"))

    @version.setter
    def version(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6d5f7a36c8acd1f522b86cf764ce7ba87dc3069053440052968618c794b586c2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "version", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterNodePool]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterNodePool]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterNodePool]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__04a85d9ec4ca090ad12c3b8854498884fbc74fae54a1f7e65923cb6f2819b360)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolPlacementPolicy",
    jsii_struct_bases=[],
    name_mapping={
        "type": "type",
        "policy_name": "policyName",
        "tpu_topology": "tpuTopology",
    },
)
class ContainerClusterNodePoolPlacementPolicy:
    def __init__(
        self,
        *,
        type: builtins.str,
        policy_name: typing.Optional[builtins.str] = None,
        tpu_topology: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param type: Type defines the type of placement policy. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#type ContainerCluster#type}
        :param policy_name: If set, refers to the name of a custom resource policy supplied by the user. The resource policy must be in the same project and region as the node pool. If not found, InvalidArgument error is returned. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#policy_name ContainerCluster#policy_name}
        :param tpu_topology: The TPU topology like "2x4" or "2x2x2". https://cloud.google.com/kubernetes-engine/docs/concepts/plan-tpus#topology. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#tpu_topology ContainerCluster#tpu_topology}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__52d1497473bd2424152be42217e2e2183e7f4a3e05d10a2f914ae26ec02f526e)
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument policy_name", value=policy_name, expected_type=type_hints["policy_name"])
            check_type(argname="argument tpu_topology", value=tpu_topology, expected_type=type_hints["tpu_topology"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "type": type,
        }
        if policy_name is not None:
            self._values["policy_name"] = policy_name
        if tpu_topology is not None:
            self._values["tpu_topology"] = tpu_topology

    @builtins.property
    def type(self) -> builtins.str:
        '''Type defines the type of placement policy.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#type ContainerCluster#type}
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def policy_name(self) -> typing.Optional[builtins.str]:
        '''If set, refers to the name of a custom resource policy supplied by the user.

        The resource policy must be in the same project and region as the node pool. If not found, InvalidArgument error is returned.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#policy_name ContainerCluster#policy_name}
        '''
        result = self._values.get("policy_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tpu_topology(self) -> typing.Optional[builtins.str]:
        '''The TPU topology like "2x4" or "2x2x2". https://cloud.google.com/kubernetes-engine/docs/concepts/plan-tpus#topology.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#tpu_topology ContainerCluster#tpu_topology}
        '''
        result = self._values.get("tpu_topology")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodePoolPlacementPolicy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodePoolPlacementPolicyOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolPlacementPolicyOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__47d1a3b59fed5ac1562895e4733f2e6c1f5348ceaa5837b69be5660225b8b3fe)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetPolicyName")
    def reset_policy_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPolicyName", []))

    @jsii.member(jsii_name="resetTpuTopology")
    def reset_tpu_topology(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTpuTopology", []))

    @builtins.property
    @jsii.member(jsii_name="policyNameInput")
    def policy_name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "policyNameInput"))

    @builtins.property
    @jsii.member(jsii_name="tpuTopologyInput")
    def tpu_topology_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "tpuTopologyInput"))

    @builtins.property
    @jsii.member(jsii_name="typeInput")
    def type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "typeInput"))

    @builtins.property
    @jsii.member(jsii_name="policyName")
    def policy_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "policyName"))

    @policy_name.setter
    def policy_name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f5bb8a84a1fe8c2e7024d6c4519e9f2298b32dc6b21bbbda335b24e6e7076d77)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "policyName", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="tpuTopology")
    def tpu_topology(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "tpuTopology"))

    @tpu_topology.setter
    def tpu_topology(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__651dfc5fcc0c6812b49cc94d8be352e2e1ff483943c8afeaec1e618b26a01eb8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "tpuTopology", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="type")
    def type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "type"))

    @type.setter
    def type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ccbbb2833f97008b0ee6026c44124444ce94f417b78b1b558c489bf1e54b62c7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "type", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolPlacementPolicy]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolPlacementPolicy], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodePoolPlacementPolicy],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1f9977a1037bd557bf01750a8171b2ab37444bc7d47e65c7c52ae45b7f5ccf50)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolQueuedProvisioning",
    jsii_struct_bases=[],
    name_mapping={"enabled": "enabled"},
)
class ContainerClusterNodePoolQueuedProvisioning:
    def __init__(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param enabled: Whether nodes in this node pool are obtainable solely through the ProvisioningRequest API. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__79619a1147f5c44967a2b4f37548cd165931e7e2f14d19f384818f554524c36f)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "enabled": enabled,
        }

    @builtins.property
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        '''Whether nodes in this node pool are obtainable solely through the ProvisioningRequest API.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        '''
        result = self._values.get("enabled")
        assert result is not None, "Required property 'enabled' is missing"
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodePoolQueuedProvisioning(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodePoolQueuedProvisioningOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolQueuedProvisioningOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dfc5e3eed7b8776f22c49db9f665b594f1c5e7dd0076faf60519f985e8614187)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="enabledInput")
    def enabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enabledInput"))

    @builtins.property
    @jsii.member(jsii_name="enabled")
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enabled"))

    @enabled.setter
    def enabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ae2c247e3262da668eb48bcf194a513483c182205d9c026a28a1686d1b9b8c94)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolQueuedProvisioning]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolQueuedProvisioning], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodePoolQueuedProvisioning],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__95d81eb1e36bb84b56b0efc449bea4910f5d9fbf402567d85c943816a92b241c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolUpgradeSettings",
    jsii_struct_bases=[],
    name_mapping={
        "blue_green_settings": "blueGreenSettings",
        "max_surge": "maxSurge",
        "max_unavailable": "maxUnavailable",
        "strategy": "strategy",
    },
)
class ContainerClusterNodePoolUpgradeSettings:
    def __init__(
        self,
        *,
        blue_green_settings: typing.Optional[typing.Union["ContainerClusterNodePoolUpgradeSettingsBlueGreenSettings", typing.Dict[builtins.str, typing.Any]]] = None,
        max_surge: typing.Optional[jsii.Number] = None,
        max_unavailable: typing.Optional[jsii.Number] = None,
        strategy: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param blue_green_settings: blue_green_settings block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#blue_green_settings ContainerCluster#blue_green_settings}
        :param max_surge: The number of additional nodes that can be added to the node pool during an upgrade. Increasing max_surge raises the number of nodes that can be upgraded simultaneously. Can be set to 0 or greater. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#max_surge ContainerCluster#max_surge}
        :param max_unavailable: The number of nodes that can be simultaneously unavailable during an upgrade. Increasing max_unavailable raises the number of nodes that can be upgraded in parallel. Can be set to 0 or greater. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#max_unavailable ContainerCluster#max_unavailable}
        :param strategy: Update strategy for the given nodepool. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#strategy ContainerCluster#strategy}
        '''
        if isinstance(blue_green_settings, dict):
            blue_green_settings = ContainerClusterNodePoolUpgradeSettingsBlueGreenSettings(**blue_green_settings)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__84ad1c885c19a96557e19b25cb4132a6b7c86aa72abcaa300bc71d27e46abb95)
            check_type(argname="argument blue_green_settings", value=blue_green_settings, expected_type=type_hints["blue_green_settings"])
            check_type(argname="argument max_surge", value=max_surge, expected_type=type_hints["max_surge"])
            check_type(argname="argument max_unavailable", value=max_unavailable, expected_type=type_hints["max_unavailable"])
            check_type(argname="argument strategy", value=strategy, expected_type=type_hints["strategy"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if blue_green_settings is not None:
            self._values["blue_green_settings"] = blue_green_settings
        if max_surge is not None:
            self._values["max_surge"] = max_surge
        if max_unavailable is not None:
            self._values["max_unavailable"] = max_unavailable
        if strategy is not None:
            self._values["strategy"] = strategy

    @builtins.property
    def blue_green_settings(
        self,
    ) -> typing.Optional["ContainerClusterNodePoolUpgradeSettingsBlueGreenSettings"]:
        '''blue_green_settings block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#blue_green_settings ContainerCluster#blue_green_settings}
        '''
        result = self._values.get("blue_green_settings")
        return typing.cast(typing.Optional["ContainerClusterNodePoolUpgradeSettingsBlueGreenSettings"], result)

    @builtins.property
    def max_surge(self) -> typing.Optional[jsii.Number]:
        '''The number of additional nodes that can be added to the node pool during an upgrade.

        Increasing max_surge raises the number of nodes that can be upgraded simultaneously. Can be set to 0 or greater.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#max_surge ContainerCluster#max_surge}
        '''
        result = self._values.get("max_surge")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def max_unavailable(self) -> typing.Optional[jsii.Number]:
        '''The number of nodes that can be simultaneously unavailable during an upgrade.

        Increasing max_unavailable raises the number of nodes that can be upgraded in parallel. Can be set to 0 or greater.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#max_unavailable ContainerCluster#max_unavailable}
        '''
        result = self._values.get("max_unavailable")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def strategy(self) -> typing.Optional[builtins.str]:
        '''Update strategy for the given nodepool.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#strategy ContainerCluster#strategy}
        '''
        result = self._values.get("strategy")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodePoolUpgradeSettings(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolUpgradeSettingsBlueGreenSettings",
    jsii_struct_bases=[],
    name_mapping={
        "standard_rollout_policy": "standardRolloutPolicy",
        "node_pool_soak_duration": "nodePoolSoakDuration",
    },
)
class ContainerClusterNodePoolUpgradeSettingsBlueGreenSettings:
    def __init__(
        self,
        *,
        standard_rollout_policy: typing.Union["ContainerClusterNodePoolUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy", typing.Dict[builtins.str, typing.Any]],
        node_pool_soak_duration: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param standard_rollout_policy: standard_rollout_policy block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#standard_rollout_policy ContainerCluster#standard_rollout_policy}
        :param node_pool_soak_duration: Time needed after draining entire blue pool. After this period, blue pool will be cleaned up. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#node_pool_soak_duration ContainerCluster#node_pool_soak_duration}
        '''
        if isinstance(standard_rollout_policy, dict):
            standard_rollout_policy = ContainerClusterNodePoolUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy(**standard_rollout_policy)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4c531a467ea7b9359a505c7bb3131f847ccb4a92d5aa3d54dfc569d84e1ffe0e)
            check_type(argname="argument standard_rollout_policy", value=standard_rollout_policy, expected_type=type_hints["standard_rollout_policy"])
            check_type(argname="argument node_pool_soak_duration", value=node_pool_soak_duration, expected_type=type_hints["node_pool_soak_duration"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "standard_rollout_policy": standard_rollout_policy,
        }
        if node_pool_soak_duration is not None:
            self._values["node_pool_soak_duration"] = node_pool_soak_duration

    @builtins.property
    def standard_rollout_policy(
        self,
    ) -> "ContainerClusterNodePoolUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy":
        '''standard_rollout_policy block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#standard_rollout_policy ContainerCluster#standard_rollout_policy}
        '''
        result = self._values.get("standard_rollout_policy")
        assert result is not None, "Required property 'standard_rollout_policy' is missing"
        return typing.cast("ContainerClusterNodePoolUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy", result)

    @builtins.property
    def node_pool_soak_duration(self) -> typing.Optional[builtins.str]:
        '''Time needed after draining entire blue pool. After this period, blue pool will be cleaned up.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#node_pool_soak_duration ContainerCluster#node_pool_soak_duration}
        '''
        result = self._values.get("node_pool_soak_duration")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodePoolUpgradeSettingsBlueGreenSettings(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodePoolUpgradeSettingsBlueGreenSettingsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolUpgradeSettingsBlueGreenSettingsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d4470d58db47fa37ebb74584453724484d48951ff2f5383e8d4721ef1a637193)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putStandardRolloutPolicy")
    def put_standard_rollout_policy(
        self,
        *,
        batch_node_count: typing.Optional[jsii.Number] = None,
        batch_percentage: typing.Optional[jsii.Number] = None,
        batch_soak_duration: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param batch_node_count: Number of blue nodes to drain in a batch. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#batch_node_count ContainerCluster#batch_node_count}
        :param batch_percentage: Percentage of the blue pool nodes to drain in a batch. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#batch_percentage ContainerCluster#batch_percentage}
        :param batch_soak_duration: Soak time after each batch gets drained. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#batch_soak_duration ContainerCluster#batch_soak_duration}
        '''
        value = ContainerClusterNodePoolUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy(
            batch_node_count=batch_node_count,
            batch_percentage=batch_percentage,
            batch_soak_duration=batch_soak_duration,
        )

        return typing.cast(None, jsii.invoke(self, "putStandardRolloutPolicy", [value]))

    @jsii.member(jsii_name="resetNodePoolSoakDuration")
    def reset_node_pool_soak_duration(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNodePoolSoakDuration", []))

    @builtins.property
    @jsii.member(jsii_name="standardRolloutPolicy")
    def standard_rollout_policy(
        self,
    ) -> "ContainerClusterNodePoolUpgradeSettingsBlueGreenSettingsStandardRolloutPolicyOutputReference":
        return typing.cast("ContainerClusterNodePoolUpgradeSettingsBlueGreenSettingsStandardRolloutPolicyOutputReference", jsii.get(self, "standardRolloutPolicy"))

    @builtins.property
    @jsii.member(jsii_name="nodePoolSoakDurationInput")
    def node_pool_soak_duration_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nodePoolSoakDurationInput"))

    @builtins.property
    @jsii.member(jsii_name="standardRolloutPolicyInput")
    def standard_rollout_policy_input(
        self,
    ) -> typing.Optional["ContainerClusterNodePoolUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy"]:
        return typing.cast(typing.Optional["ContainerClusterNodePoolUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy"], jsii.get(self, "standardRolloutPolicyInput"))

    @builtins.property
    @jsii.member(jsii_name="nodePoolSoakDuration")
    def node_pool_soak_duration(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "nodePoolSoakDuration"))

    @node_pool_soak_duration.setter
    def node_pool_soak_duration(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__552e87b3da502e4c2c4d0f6515586f9b56ad89edee23657621faeb3b7d764a33)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "nodePoolSoakDuration", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolUpgradeSettingsBlueGreenSettings]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolUpgradeSettingsBlueGreenSettings], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodePoolUpgradeSettingsBlueGreenSettings],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ca1576ef93d4f8b25b508081b0fcee9f080aceb412e652348e91e1cbd12824a8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy",
    jsii_struct_bases=[],
    name_mapping={
        "batch_node_count": "batchNodeCount",
        "batch_percentage": "batchPercentage",
        "batch_soak_duration": "batchSoakDuration",
    },
)
class ContainerClusterNodePoolUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy:
    def __init__(
        self,
        *,
        batch_node_count: typing.Optional[jsii.Number] = None,
        batch_percentage: typing.Optional[jsii.Number] = None,
        batch_soak_duration: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param batch_node_count: Number of blue nodes to drain in a batch. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#batch_node_count ContainerCluster#batch_node_count}
        :param batch_percentage: Percentage of the blue pool nodes to drain in a batch. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#batch_percentage ContainerCluster#batch_percentage}
        :param batch_soak_duration: Soak time after each batch gets drained. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#batch_soak_duration ContainerCluster#batch_soak_duration}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__209ac63d6eae326ebda1a5382ac1152192280883009462d8b17f05d80897b8b3)
            check_type(argname="argument batch_node_count", value=batch_node_count, expected_type=type_hints["batch_node_count"])
            check_type(argname="argument batch_percentage", value=batch_percentage, expected_type=type_hints["batch_percentage"])
            check_type(argname="argument batch_soak_duration", value=batch_soak_duration, expected_type=type_hints["batch_soak_duration"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if batch_node_count is not None:
            self._values["batch_node_count"] = batch_node_count
        if batch_percentage is not None:
            self._values["batch_percentage"] = batch_percentage
        if batch_soak_duration is not None:
            self._values["batch_soak_duration"] = batch_soak_duration

    @builtins.property
    def batch_node_count(self) -> typing.Optional[jsii.Number]:
        '''Number of blue nodes to drain in a batch.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#batch_node_count ContainerCluster#batch_node_count}
        '''
        result = self._values.get("batch_node_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def batch_percentage(self) -> typing.Optional[jsii.Number]:
        '''Percentage of the blue pool nodes to drain in a batch.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#batch_percentage ContainerCluster#batch_percentage}
        '''
        result = self._values.get("batch_percentage")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def batch_soak_duration(self) -> typing.Optional[builtins.str]:
        '''Soak time after each batch gets drained.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#batch_soak_duration ContainerCluster#batch_soak_duration}
        '''
        result = self._values.get("batch_soak_duration")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNodePoolUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNodePoolUpgradeSettingsBlueGreenSettingsStandardRolloutPolicyOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolUpgradeSettingsBlueGreenSettingsStandardRolloutPolicyOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2db8c3359efddcac4e786078f50c3b50d2e2768d944061e3ab4298be73452988)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetBatchNodeCount")
    def reset_batch_node_count(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBatchNodeCount", []))

    @jsii.member(jsii_name="resetBatchPercentage")
    def reset_batch_percentage(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBatchPercentage", []))

    @jsii.member(jsii_name="resetBatchSoakDuration")
    def reset_batch_soak_duration(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBatchSoakDuration", []))

    @builtins.property
    @jsii.member(jsii_name="batchNodeCountInput")
    def batch_node_count_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "batchNodeCountInput"))

    @builtins.property
    @jsii.member(jsii_name="batchPercentageInput")
    def batch_percentage_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "batchPercentageInput"))

    @builtins.property
    @jsii.member(jsii_name="batchSoakDurationInput")
    def batch_soak_duration_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "batchSoakDurationInput"))

    @builtins.property
    @jsii.member(jsii_name="batchNodeCount")
    def batch_node_count(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "batchNodeCount"))

    @batch_node_count.setter
    def batch_node_count(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e4da55ee10d9bf5562ddc15930da8bdb958be7fc8904b82adb311caaf3f4b620)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "batchNodeCount", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="batchPercentage")
    def batch_percentage(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "batchPercentage"))

    @batch_percentage.setter
    def batch_percentage(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7996fb36ce3c2f48d06351d16da721cd337ca604de5500e09e82fffe8151c62c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "batchPercentage", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="batchSoakDuration")
    def batch_soak_duration(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "batchSoakDuration"))

    @batch_soak_duration.setter
    def batch_soak_duration(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d16a1afe7f1b452d8b4963334050eff070ef0c32acf93fd12c7169ac560bbaf3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "batchSoakDuration", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodePoolUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__29950eaf2be55b0985fa13b48418c4597be5337e5ba835fdd34d680b9e29b078)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ContainerClusterNodePoolUpgradeSettingsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNodePoolUpgradeSettingsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__70a571a89b6b6771ae2db9bb405a6b34f691bdeceec9b8cc691bc297f8aa919c)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putBlueGreenSettings")
    def put_blue_green_settings(
        self,
        *,
        standard_rollout_policy: typing.Union[ContainerClusterNodePoolUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy, typing.Dict[builtins.str, typing.Any]],
        node_pool_soak_duration: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param standard_rollout_policy: standard_rollout_policy block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#standard_rollout_policy ContainerCluster#standard_rollout_policy}
        :param node_pool_soak_duration: Time needed after draining entire blue pool. After this period, blue pool will be cleaned up. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#node_pool_soak_duration ContainerCluster#node_pool_soak_duration}
        '''
        value = ContainerClusterNodePoolUpgradeSettingsBlueGreenSettings(
            standard_rollout_policy=standard_rollout_policy,
            node_pool_soak_duration=node_pool_soak_duration,
        )

        return typing.cast(None, jsii.invoke(self, "putBlueGreenSettings", [value]))

    @jsii.member(jsii_name="resetBlueGreenSettings")
    def reset_blue_green_settings(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBlueGreenSettings", []))

    @jsii.member(jsii_name="resetMaxSurge")
    def reset_max_surge(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMaxSurge", []))

    @jsii.member(jsii_name="resetMaxUnavailable")
    def reset_max_unavailable(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMaxUnavailable", []))

    @jsii.member(jsii_name="resetStrategy")
    def reset_strategy(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetStrategy", []))

    @builtins.property
    @jsii.member(jsii_name="blueGreenSettings")
    def blue_green_settings(
        self,
    ) -> ContainerClusterNodePoolUpgradeSettingsBlueGreenSettingsOutputReference:
        return typing.cast(ContainerClusterNodePoolUpgradeSettingsBlueGreenSettingsOutputReference, jsii.get(self, "blueGreenSettings"))

    @builtins.property
    @jsii.member(jsii_name="blueGreenSettingsInput")
    def blue_green_settings_input(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolUpgradeSettingsBlueGreenSettings]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolUpgradeSettingsBlueGreenSettings], jsii.get(self, "blueGreenSettingsInput"))

    @builtins.property
    @jsii.member(jsii_name="maxSurgeInput")
    def max_surge_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "maxSurgeInput"))

    @builtins.property
    @jsii.member(jsii_name="maxUnavailableInput")
    def max_unavailable_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "maxUnavailableInput"))

    @builtins.property
    @jsii.member(jsii_name="strategyInput")
    def strategy_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "strategyInput"))

    @builtins.property
    @jsii.member(jsii_name="maxSurge")
    def max_surge(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "maxSurge"))

    @max_surge.setter
    def max_surge(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__abc6a07be27782c3d02847ab1db6868b38143573f257e881e6f14cdfd6db84c4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "maxSurge", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="maxUnavailable")
    def max_unavailable(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "maxUnavailable"))

    @max_unavailable.setter
    def max_unavailable(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7130e073dae37a430d47828d690957ec5146f710b4cd836f0cbee25b78a73241)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "maxUnavailable", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def strategy(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "strategy"))

    @strategy.setter
    def strategy(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c4f03e583f5f8da5803c90c9527c6373edd69779f6ca320bcdac99be66275723)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "strategy", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNodePoolUpgradeSettings]:
        return typing.cast(typing.Optional[ContainerClusterNodePoolUpgradeSettings], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNodePoolUpgradeSettings],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eb115a9a571bb99cda030411e2997edc205bfb0e7f916268d494a5969f949b11)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNotificationConfig",
    jsii_struct_bases=[],
    name_mapping={"pubsub": "pubsub"},
)
class ContainerClusterNotificationConfig:
    def __init__(
        self,
        *,
        pubsub: typing.Union["ContainerClusterNotificationConfigPubsub", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''
        :param pubsub: pubsub block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#pubsub ContainerCluster#pubsub}
        '''
        if isinstance(pubsub, dict):
            pubsub = ContainerClusterNotificationConfigPubsub(**pubsub)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ef024d94e99c3464671fd4ea4155372ed7dd78594478ff258ade493d8c881e63)
            check_type(argname="argument pubsub", value=pubsub, expected_type=type_hints["pubsub"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "pubsub": pubsub,
        }

    @builtins.property
    def pubsub(self) -> "ContainerClusterNotificationConfigPubsub":
        '''pubsub block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#pubsub ContainerCluster#pubsub}
        '''
        result = self._values.get("pubsub")
        assert result is not None, "Required property 'pubsub' is missing"
        return typing.cast("ContainerClusterNotificationConfigPubsub", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNotificationConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNotificationConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNotificationConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a132251ccff1aa63fff2c489e30fdc99e6acd8494fb74bd08d4c61600acd2e87)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putPubsub")
    def put_pubsub(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
        filter: typing.Optional[typing.Union["ContainerClusterNotificationConfigPubsubFilter", typing.Dict[builtins.str, typing.Any]]] = None,
        topic: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param enabled: Whether or not the notification config is enabled. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        :param filter: filter block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#filter ContainerCluster#filter}
        :param topic: The pubsub topic to push upgrade notifications to. Must be in the same project as the cluster. Must be in the format: projects/{project}/topics/{topic}. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#topic ContainerCluster#topic}
        '''
        value = ContainerClusterNotificationConfigPubsub(
            enabled=enabled, filter=filter, topic=topic
        )

        return typing.cast(None, jsii.invoke(self, "putPubsub", [value]))

    @builtins.property
    @jsii.member(jsii_name="pubsub")
    def pubsub(self) -> "ContainerClusterNotificationConfigPubsubOutputReference":
        return typing.cast("ContainerClusterNotificationConfigPubsubOutputReference", jsii.get(self, "pubsub"))

    @builtins.property
    @jsii.member(jsii_name="pubsubInput")
    def pubsub_input(
        self,
    ) -> typing.Optional["ContainerClusterNotificationConfigPubsub"]:
        return typing.cast(typing.Optional["ContainerClusterNotificationConfigPubsub"], jsii.get(self, "pubsubInput"))

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[ContainerClusterNotificationConfig]:
        return typing.cast(typing.Optional[ContainerClusterNotificationConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNotificationConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ce023d46357d2ee14c0fdad9f77a5f7492004c8ba8de7eb6fc6064919f5b5c8e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNotificationConfigPubsub",
    jsii_struct_bases=[],
    name_mapping={"enabled": "enabled", "filter": "filter", "topic": "topic"},
)
class ContainerClusterNotificationConfigPubsub:
    def __init__(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
        filter: typing.Optional[typing.Union["ContainerClusterNotificationConfigPubsubFilter", typing.Dict[builtins.str, typing.Any]]] = None,
        topic: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param enabled: Whether or not the notification config is enabled. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        :param filter: filter block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#filter ContainerCluster#filter}
        :param topic: The pubsub topic to push upgrade notifications to. Must be in the same project as the cluster. Must be in the format: projects/{project}/topics/{topic}. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#topic ContainerCluster#topic}
        '''
        if isinstance(filter, dict):
            filter = ContainerClusterNotificationConfigPubsubFilter(**filter)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5db1897a226802835b59e7e14f5e61923bf69bdf5c7d8dbb967af15fc4780199)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
            check_type(argname="argument filter", value=filter, expected_type=type_hints["filter"])
            check_type(argname="argument topic", value=topic, expected_type=type_hints["topic"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "enabled": enabled,
        }
        if filter is not None:
            self._values["filter"] = filter
        if topic is not None:
            self._values["topic"] = topic

    @builtins.property
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        '''Whether or not the notification config is enabled.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        '''
        result = self._values.get("enabled")
        assert result is not None, "Required property 'enabled' is missing"
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], result)

    @builtins.property
    def filter(
        self,
    ) -> typing.Optional["ContainerClusterNotificationConfigPubsubFilter"]:
        '''filter block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#filter ContainerCluster#filter}
        '''
        result = self._values.get("filter")
        return typing.cast(typing.Optional["ContainerClusterNotificationConfigPubsubFilter"], result)

    @builtins.property
    def topic(self) -> typing.Optional[builtins.str]:
        '''The pubsub topic to push upgrade notifications to.

        Must be in the same project as the cluster. Must be in the format: projects/{project}/topics/{topic}.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#topic ContainerCluster#topic}
        '''
        result = self._values.get("topic")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNotificationConfigPubsub(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNotificationConfigPubsubFilter",
    jsii_struct_bases=[],
    name_mapping={"event_type": "eventType"},
)
class ContainerClusterNotificationConfigPubsubFilter:
    def __init__(self, *, event_type: typing.Sequence[builtins.str]) -> None:
        '''
        :param event_type: Can be used to filter what notifications are sent. Valid values include include UPGRADE_AVAILABLE_EVENT, UPGRADE_EVENT, SECURITY_BULLETIN_EVENT, and UPGRADE_INFO_EVENT. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#event_type ContainerCluster#event_type}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__48eb324acba6700db72efab299210df022d8cb1c4989fd9766ce4b7fad131e30)
            check_type(argname="argument event_type", value=event_type, expected_type=type_hints["event_type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "event_type": event_type,
        }

    @builtins.property
    def event_type(self) -> typing.List[builtins.str]:
        '''Can be used to filter what notifications are sent. Valid values include include UPGRADE_AVAILABLE_EVENT, UPGRADE_EVENT, SECURITY_BULLETIN_EVENT, and UPGRADE_INFO_EVENT.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#event_type ContainerCluster#event_type}
        '''
        result = self._values.get("event_type")
        assert result is not None, "Required property 'event_type' is missing"
        return typing.cast(typing.List[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterNotificationConfigPubsubFilter(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterNotificationConfigPubsubFilterOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNotificationConfigPubsubFilterOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__50e35a812a01a48aeefd379f74551a6608f997c89e316d0d33d0499d6f37485f)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="eventTypeInput")
    def event_type_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "eventTypeInput"))

    @builtins.property
    @jsii.member(jsii_name="eventType")
    def event_type(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "eventType"))

    @event_type.setter
    def event_type(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c5035b68ed4b7db6834f6f1667a46b63bae53f45e5ee5487f13b4b7ee7a073fd)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "eventType", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNotificationConfigPubsubFilter]:
        return typing.cast(typing.Optional[ContainerClusterNotificationConfigPubsubFilter], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNotificationConfigPubsubFilter],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9d92ef4c78b1f5a624156c1adedf8671cd243341c370fbd5f4226a00ffc6f7a7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ContainerClusterNotificationConfigPubsubOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterNotificationConfigPubsubOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5bd4bbe01da6b582fc567f6880df4dc6abd3775a2ffecf5261ab31eef6becdf4)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putFilter")
    def put_filter(self, *, event_type: typing.Sequence[builtins.str]) -> None:
        '''
        :param event_type: Can be used to filter what notifications are sent. Valid values include include UPGRADE_AVAILABLE_EVENT, UPGRADE_EVENT, SECURITY_BULLETIN_EVENT, and UPGRADE_INFO_EVENT. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#event_type ContainerCluster#event_type}
        '''
        value = ContainerClusterNotificationConfigPubsubFilter(event_type=event_type)

        return typing.cast(None, jsii.invoke(self, "putFilter", [value]))

    @jsii.member(jsii_name="resetFilter")
    def reset_filter(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetFilter", []))

    @jsii.member(jsii_name="resetTopic")
    def reset_topic(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTopic", []))

    @builtins.property
    @jsii.member(jsii_name="filter")
    def filter(self) -> ContainerClusterNotificationConfigPubsubFilterOutputReference:
        return typing.cast(ContainerClusterNotificationConfigPubsubFilterOutputReference, jsii.get(self, "filter"))

    @builtins.property
    @jsii.member(jsii_name="enabledInput")
    def enabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enabledInput"))

    @builtins.property
    @jsii.member(jsii_name="filterInput")
    def filter_input(
        self,
    ) -> typing.Optional[ContainerClusterNotificationConfigPubsubFilter]:
        return typing.cast(typing.Optional[ContainerClusterNotificationConfigPubsubFilter], jsii.get(self, "filterInput"))

    @builtins.property
    @jsii.member(jsii_name="topicInput")
    def topic_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "topicInput"))

    @builtins.property
    @jsii.member(jsii_name="enabled")
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enabled"))

    @enabled.setter
    def enabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__645b563accbcb9acf29af435703d43c317497e4489fc452e110cff650d62a1db)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="topic")
    def topic(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "topic"))

    @topic.setter
    def topic(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__44c62dfda69ee888068ab6f222a7703c6fd55f6ad5d5f2df6de8509b70f3899a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "topic", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterNotificationConfigPubsub]:
        return typing.cast(typing.Optional[ContainerClusterNotificationConfigPubsub], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterNotificationConfigPubsub],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__82399ad8df1c503da18d1a60469f44c1201eeb95e1e437b6154a42e0f6f6c8a8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterPodAutoscaling",
    jsii_struct_bases=[],
    name_mapping={"hpa_profile": "hpaProfile"},
)
class ContainerClusterPodAutoscaling:
    def __init__(self, *, hpa_profile: builtins.str) -> None:
        '''
        :param hpa_profile: HPA Profile is used to configure the Horizontal Pod Autoscaler (HPA) profile for the cluster. Available options include: - NONE: Customers explicitly opt-out of HPA profiles. - PERFORMANCE: PERFORMANCE is used when customers opt-in to the performance HPA profile. In this profile we support a higher number of HPAs per cluster and faster metrics collection for workload autoscaling. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#hpa_profile ContainerCluster#hpa_profile}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__367e1932a6a265ff38b22d577ebc3882aa2da7eba8d24648940d6788fdb11e98)
            check_type(argname="argument hpa_profile", value=hpa_profile, expected_type=type_hints["hpa_profile"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "hpa_profile": hpa_profile,
        }

    @builtins.property
    def hpa_profile(self) -> builtins.str:
        '''HPA Profile is used to configure the Horizontal Pod Autoscaler (HPA) profile for the cluster.

        Available options include:

        - NONE: Customers explicitly opt-out of HPA profiles.
        - PERFORMANCE: PERFORMANCE is used when customers opt-in to the performance HPA profile. In this profile we support a higher number of HPAs per cluster and faster metrics collection for workload autoscaling.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#hpa_profile ContainerCluster#hpa_profile}
        '''
        result = self._values.get("hpa_profile")
        assert result is not None, "Required property 'hpa_profile' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterPodAutoscaling(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterPodAutoscalingOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterPodAutoscalingOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__54614e627ff9907d9e66c9ebad715c4a0434e03df13109db4e627682ed6aed67)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="hpaProfileInput")
    def hpa_profile_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "hpaProfileInput"))

    @builtins.property
    @jsii.member(jsii_name="hpaProfile")
    def hpa_profile(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "hpaProfile"))

    @hpa_profile.setter
    def hpa_profile(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6f210841a9032c1b615608418e17eba1eed5922d7fa0c745acec6824166357de)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "hpaProfile", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[ContainerClusterPodAutoscaling]:
        return typing.cast(typing.Optional[ContainerClusterPodAutoscaling], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterPodAutoscaling],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d5bd68bb179054893b53e0f16ac1b9b74ccee1d1ebcf61fb2eda79b48b617f63)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterPrivateClusterConfig",
    jsii_struct_bases=[],
    name_mapping={
        "enable_private_endpoint": "enablePrivateEndpoint",
        "enable_private_nodes": "enablePrivateNodes",
        "master_global_access_config": "masterGlobalAccessConfig",
        "master_ipv4_cidr_block": "masterIpv4CidrBlock",
        "private_endpoint_subnetwork": "privateEndpointSubnetwork",
    },
)
class ContainerClusterPrivateClusterConfig:
    def __init__(
        self,
        *,
        enable_private_endpoint: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        enable_private_nodes: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        master_global_access_config: typing.Optional[typing.Union["ContainerClusterPrivateClusterConfigMasterGlobalAccessConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        master_ipv4_cidr_block: typing.Optional[builtins.str] = None,
        private_endpoint_subnetwork: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param enable_private_endpoint: When true, the cluster's private endpoint is used as the cluster endpoint and access through the public endpoint is disabled. When false, either endpoint can be used. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_private_endpoint ContainerCluster#enable_private_endpoint}
        :param enable_private_nodes: Enables the private cluster feature, creating a private endpoint on the cluster. In a private cluster, nodes only have RFC 1918 private addresses and communicate with the master's private endpoint via private networking. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_private_nodes ContainerCluster#enable_private_nodes}
        :param master_global_access_config: master_global_access_config block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#master_global_access_config ContainerCluster#master_global_access_config}
        :param master_ipv4_cidr_block: The IP range in CIDR notation to use for the hosted master network. This range will be used for assigning private IP addresses to the cluster master(s) and the ILB VIP. This range must not overlap with any other ranges in use within the cluster's network, and it must be a /28 subnet. See Private Cluster Limitations for more details. This field only applies to private clusters, when enable_private_nodes is true. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#master_ipv4_cidr_block ContainerCluster#master_ipv4_cidr_block}
        :param private_endpoint_subnetwork: Subnetwork in cluster's network where master's endpoint will be provisioned. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#private_endpoint_subnetwork ContainerCluster#private_endpoint_subnetwork}
        '''
        if isinstance(master_global_access_config, dict):
            master_global_access_config = ContainerClusterPrivateClusterConfigMasterGlobalAccessConfig(**master_global_access_config)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d158a60f1805765cb0e17481219cb23e719468db70e281716bb5bf9b653f09e7)
            check_type(argname="argument enable_private_endpoint", value=enable_private_endpoint, expected_type=type_hints["enable_private_endpoint"])
            check_type(argname="argument enable_private_nodes", value=enable_private_nodes, expected_type=type_hints["enable_private_nodes"])
            check_type(argname="argument master_global_access_config", value=master_global_access_config, expected_type=type_hints["master_global_access_config"])
            check_type(argname="argument master_ipv4_cidr_block", value=master_ipv4_cidr_block, expected_type=type_hints["master_ipv4_cidr_block"])
            check_type(argname="argument private_endpoint_subnetwork", value=private_endpoint_subnetwork, expected_type=type_hints["private_endpoint_subnetwork"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if enable_private_endpoint is not None:
            self._values["enable_private_endpoint"] = enable_private_endpoint
        if enable_private_nodes is not None:
            self._values["enable_private_nodes"] = enable_private_nodes
        if master_global_access_config is not None:
            self._values["master_global_access_config"] = master_global_access_config
        if master_ipv4_cidr_block is not None:
            self._values["master_ipv4_cidr_block"] = master_ipv4_cidr_block
        if private_endpoint_subnetwork is not None:
            self._values["private_endpoint_subnetwork"] = private_endpoint_subnetwork

    @builtins.property
    def enable_private_endpoint(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''When true, the cluster's private endpoint is used as the cluster endpoint and access through the public endpoint is disabled.

        When false, either endpoint can be used.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_private_endpoint ContainerCluster#enable_private_endpoint}
        '''
        result = self._values.get("enable_private_endpoint")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def enable_private_nodes(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Enables the private cluster feature, creating a private endpoint on the cluster.

        In a private cluster, nodes only have RFC 1918 private addresses and communicate with the master's private endpoint via private networking.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_private_nodes ContainerCluster#enable_private_nodes}
        '''
        result = self._values.get("enable_private_nodes")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def master_global_access_config(
        self,
    ) -> typing.Optional["ContainerClusterPrivateClusterConfigMasterGlobalAccessConfig"]:
        '''master_global_access_config block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#master_global_access_config ContainerCluster#master_global_access_config}
        '''
        result = self._values.get("master_global_access_config")
        return typing.cast(typing.Optional["ContainerClusterPrivateClusterConfigMasterGlobalAccessConfig"], result)

    @builtins.property
    def master_ipv4_cidr_block(self) -> typing.Optional[builtins.str]:
        '''The IP range in CIDR notation to use for the hosted master network.

        This range will be used for assigning private IP addresses to the cluster master(s) and the ILB VIP. This range must not overlap with any other ranges in use within the cluster's network, and it must be a /28 subnet. See Private Cluster Limitations for more details. This field only applies to private clusters, when enable_private_nodes is true.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#master_ipv4_cidr_block ContainerCluster#master_ipv4_cidr_block}
        '''
        result = self._values.get("master_ipv4_cidr_block")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def private_endpoint_subnetwork(self) -> typing.Optional[builtins.str]:
        '''Subnetwork in cluster's network where master's endpoint will be provisioned.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#private_endpoint_subnetwork ContainerCluster#private_endpoint_subnetwork}
        '''
        result = self._values.get("private_endpoint_subnetwork")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterPrivateClusterConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterPrivateClusterConfigMasterGlobalAccessConfig",
    jsii_struct_bases=[],
    name_mapping={"enabled": "enabled"},
)
class ContainerClusterPrivateClusterConfigMasterGlobalAccessConfig:
    def __init__(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param enabled: Whether the cluster master is accessible globally or not. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__263d5b660f522235058ecb06c1c71aa35d0597302f7f2fc71cadcf2b2a441042)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "enabled": enabled,
        }

    @builtins.property
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        '''Whether the cluster master is accessible globally or not.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        '''
        result = self._values.get("enabled")
        assert result is not None, "Required property 'enabled' is missing"
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterPrivateClusterConfigMasterGlobalAccessConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterPrivateClusterConfigMasterGlobalAccessConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterPrivateClusterConfigMasterGlobalAccessConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eddebe2880da91133f78e9d71dc0ee70be18db92678f7384e2697f80884542c0)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="enabledInput")
    def enabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enabledInput"))

    @builtins.property
    @jsii.member(jsii_name="enabled")
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enabled"))

    @enabled.setter
    def enabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__586ec22f66ba2d406cd3c3cd1ec5d163d43185f7e43d2d8c4963a2e2d1cae505)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterPrivateClusterConfigMasterGlobalAccessConfig]:
        return typing.cast(typing.Optional[ContainerClusterPrivateClusterConfigMasterGlobalAccessConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterPrivateClusterConfigMasterGlobalAccessConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__57da359dcb4b68369ab675636e4698a11a0ba6dd726c3f214040049a9feadc77)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ContainerClusterPrivateClusterConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterPrivateClusterConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fe9f4c4891d1edd8fbc04cccd26e35a0a7a9ce8ef55a15e987a0b3c23dde0d3d)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putMasterGlobalAccessConfig")
    def put_master_global_access_config(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param enabled: Whether the cluster master is accessible globally or not. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        '''
        value = ContainerClusterPrivateClusterConfigMasterGlobalAccessConfig(
            enabled=enabled
        )

        return typing.cast(None, jsii.invoke(self, "putMasterGlobalAccessConfig", [value]))

    @jsii.member(jsii_name="resetEnablePrivateEndpoint")
    def reset_enable_private_endpoint(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnablePrivateEndpoint", []))

    @jsii.member(jsii_name="resetEnablePrivateNodes")
    def reset_enable_private_nodes(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnablePrivateNodes", []))

    @jsii.member(jsii_name="resetMasterGlobalAccessConfig")
    def reset_master_global_access_config(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMasterGlobalAccessConfig", []))

    @jsii.member(jsii_name="resetMasterIpv4CidrBlock")
    def reset_master_ipv4_cidr_block(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMasterIpv4CidrBlock", []))

    @jsii.member(jsii_name="resetPrivateEndpointSubnetwork")
    def reset_private_endpoint_subnetwork(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPrivateEndpointSubnetwork", []))

    @builtins.property
    @jsii.member(jsii_name="masterGlobalAccessConfig")
    def master_global_access_config(
        self,
    ) -> ContainerClusterPrivateClusterConfigMasterGlobalAccessConfigOutputReference:
        return typing.cast(ContainerClusterPrivateClusterConfigMasterGlobalAccessConfigOutputReference, jsii.get(self, "masterGlobalAccessConfig"))

    @builtins.property
    @jsii.member(jsii_name="peeringName")
    def peering_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "peeringName"))

    @builtins.property
    @jsii.member(jsii_name="privateEndpoint")
    def private_endpoint(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "privateEndpoint"))

    @builtins.property
    @jsii.member(jsii_name="publicEndpoint")
    def public_endpoint(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "publicEndpoint"))

    @builtins.property
    @jsii.member(jsii_name="enablePrivateEndpointInput")
    def enable_private_endpoint_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enablePrivateEndpointInput"))

    @builtins.property
    @jsii.member(jsii_name="enablePrivateNodesInput")
    def enable_private_nodes_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enablePrivateNodesInput"))

    @builtins.property
    @jsii.member(jsii_name="masterGlobalAccessConfigInput")
    def master_global_access_config_input(
        self,
    ) -> typing.Optional[ContainerClusterPrivateClusterConfigMasterGlobalAccessConfig]:
        return typing.cast(typing.Optional[ContainerClusterPrivateClusterConfigMasterGlobalAccessConfig], jsii.get(self, "masterGlobalAccessConfigInput"))

    @builtins.property
    @jsii.member(jsii_name="masterIpv4CidrBlockInput")
    def master_ipv4_cidr_block_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "masterIpv4CidrBlockInput"))

    @builtins.property
    @jsii.member(jsii_name="privateEndpointSubnetworkInput")
    def private_endpoint_subnetwork_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "privateEndpointSubnetworkInput"))

    @builtins.property
    @jsii.member(jsii_name="enablePrivateEndpoint")
    def enable_private_endpoint(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enablePrivateEndpoint"))

    @enable_private_endpoint.setter
    def enable_private_endpoint(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__89c038692138bb4fd68437a8f2c59012fe7783027db95baf85e00912fd15e5de)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enablePrivateEndpoint", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="enablePrivateNodes")
    def enable_private_nodes(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enablePrivateNodes"))

    @enable_private_nodes.setter
    def enable_private_nodes(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c87f92a2a841235686489b8360a551805f507267523a9c7b556e6dd47ee2c589)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enablePrivateNodes", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="masterIpv4CidrBlock")
    def master_ipv4_cidr_block(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "masterIpv4CidrBlock"))

    @master_ipv4_cidr_block.setter
    def master_ipv4_cidr_block(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__35a0de6689cd0707a44a2c960b6367e75cbb12c56acfc4bce96d69f4d9cf6c62)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "masterIpv4CidrBlock", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="privateEndpointSubnetwork")
    def private_endpoint_subnetwork(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "privateEndpointSubnetwork"))

    @private_endpoint_subnetwork.setter
    def private_endpoint_subnetwork(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6c8ccca85db7e83d3d95836d1fa13084d0f205d988ebfd1b5d4c52ff45363b77)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "privateEndpointSubnetwork", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[ContainerClusterPrivateClusterConfig]:
        return typing.cast(typing.Optional[ContainerClusterPrivateClusterConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterPrivateClusterConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__694c4cc0c45c7a47930cde4b1c1f0ca626f5e204cde7a4e31f8426f7d21c995f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterRbacBindingConfig",
    jsii_struct_bases=[],
    name_mapping={
        "enable_insecure_binding_system_authenticated": "enableInsecureBindingSystemAuthenticated",
        "enable_insecure_binding_system_unauthenticated": "enableInsecureBindingSystemUnauthenticated",
    },
)
class ContainerClusterRbacBindingConfig:
    def __init__(
        self,
        *,
        enable_insecure_binding_system_authenticated: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        enable_insecure_binding_system_unauthenticated: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    ) -> None:
        '''
        :param enable_insecure_binding_system_authenticated: Setting this to true will allow any ClusterRoleBinding and RoleBinding with subjects system:authenticated. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_insecure_binding_system_authenticated ContainerCluster#enable_insecure_binding_system_authenticated}
        :param enable_insecure_binding_system_unauthenticated: Setting this to true will allow any ClusterRoleBinding and RoleBinding with subjects system:anonymous or system:unauthenticated. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_insecure_binding_system_unauthenticated ContainerCluster#enable_insecure_binding_system_unauthenticated}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8e50006c8fc7f9916d772c2bf66ee3247de302c42fde8e5dd810f1fbc8e8a78d)
            check_type(argname="argument enable_insecure_binding_system_authenticated", value=enable_insecure_binding_system_authenticated, expected_type=type_hints["enable_insecure_binding_system_authenticated"])
            check_type(argname="argument enable_insecure_binding_system_unauthenticated", value=enable_insecure_binding_system_unauthenticated, expected_type=type_hints["enable_insecure_binding_system_unauthenticated"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if enable_insecure_binding_system_authenticated is not None:
            self._values["enable_insecure_binding_system_authenticated"] = enable_insecure_binding_system_authenticated
        if enable_insecure_binding_system_unauthenticated is not None:
            self._values["enable_insecure_binding_system_unauthenticated"] = enable_insecure_binding_system_unauthenticated

    @builtins.property
    def enable_insecure_binding_system_authenticated(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Setting this to true will allow any ClusterRoleBinding and RoleBinding with subjects system:authenticated.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_insecure_binding_system_authenticated ContainerCluster#enable_insecure_binding_system_authenticated}
        '''
        result = self._values.get("enable_insecure_binding_system_authenticated")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def enable_insecure_binding_system_unauthenticated(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Setting this to true will allow any ClusterRoleBinding and RoleBinding with subjects system:anonymous or system:unauthenticated.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_insecure_binding_system_unauthenticated ContainerCluster#enable_insecure_binding_system_unauthenticated}
        '''
        result = self._values.get("enable_insecure_binding_system_unauthenticated")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterRbacBindingConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterRbacBindingConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterRbacBindingConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b9f39d430660ab855b69bf90fc7ed5d0605c9bdaac90183036f2e8bc17b28243)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetEnableInsecureBindingSystemAuthenticated")
    def reset_enable_insecure_binding_system_authenticated(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnableInsecureBindingSystemAuthenticated", []))

    @jsii.member(jsii_name="resetEnableInsecureBindingSystemUnauthenticated")
    def reset_enable_insecure_binding_system_unauthenticated(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnableInsecureBindingSystemUnauthenticated", []))

    @builtins.property
    @jsii.member(jsii_name="enableInsecureBindingSystemAuthenticatedInput")
    def enable_insecure_binding_system_authenticated_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enableInsecureBindingSystemAuthenticatedInput"))

    @builtins.property
    @jsii.member(jsii_name="enableInsecureBindingSystemUnauthenticatedInput")
    def enable_insecure_binding_system_unauthenticated_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enableInsecureBindingSystemUnauthenticatedInput"))

    @builtins.property
    @jsii.member(jsii_name="enableInsecureBindingSystemAuthenticated")
    def enable_insecure_binding_system_authenticated(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enableInsecureBindingSystemAuthenticated"))

    @enable_insecure_binding_system_authenticated.setter
    def enable_insecure_binding_system_authenticated(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0139d78e7e61313746f6082db72317f55524653f65c568677afa053b59ef924f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableInsecureBindingSystemAuthenticated", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="enableInsecureBindingSystemUnauthenticated")
    def enable_insecure_binding_system_unauthenticated(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enableInsecureBindingSystemUnauthenticated"))

    @enable_insecure_binding_system_unauthenticated.setter
    def enable_insecure_binding_system_unauthenticated(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__96e41b251ee10c2e3317d6e465c3066a54275440a5b8b710fe5ce2ad6f157bcf)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableInsecureBindingSystemUnauthenticated", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[ContainerClusterRbacBindingConfig]:
        return typing.cast(typing.Optional[ContainerClusterRbacBindingConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterRbacBindingConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e2f5bfc47d8f529e197d9a4e2e95b584400b8fa28b7f7e4ea6d164740ee1454c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterReleaseChannel",
    jsii_struct_bases=[],
    name_mapping={"channel": "channel"},
)
class ContainerClusterReleaseChannel:
    def __init__(self, *, channel: builtins.str) -> None:
        '''
        :param channel: The selected release channel. Accepted values are: - UNSPECIFIED: Not set. - RAPID: Weekly upgrade cadence; Early testers and developers who requires new features. - REGULAR: Multiple per month upgrade cadence; Production users who need features not yet offered in the Stable channel. - STABLE: Every few months upgrade cadence; Production users who need stability above all else, and for whom frequent upgrades are too risky. - EXTENDED: GKE provides extended support for Kubernetes minor versions through the Extended channel. With this channel, you can stay on a minor version for up to 24 months. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#channel ContainerCluster#channel}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dcd4ef1c3abe6b11c63feaa82d64a899488c6a6b4558a3320b856fcda679e148)
            check_type(argname="argument channel", value=channel, expected_type=type_hints["channel"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "channel": channel,
        }

    @builtins.property
    def channel(self) -> builtins.str:
        '''The selected release channel.

        Accepted values are:

        - UNSPECIFIED: Not set.
        - RAPID: Weekly upgrade cadence; Early testers and developers who requires new features.
        - REGULAR: Multiple per month upgrade cadence; Production users who need features not yet offered in the Stable channel.
        - STABLE: Every few months upgrade cadence; Production users who need stability above all else, and for whom frequent upgrades are too risky.
        - EXTENDED: GKE provides extended support for Kubernetes minor versions through the Extended channel. With this channel, you can stay on a minor version for up to 24 months.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#channel ContainerCluster#channel}
        '''
        result = self._values.get("channel")
        assert result is not None, "Required property 'channel' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterReleaseChannel(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterReleaseChannelOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterReleaseChannelOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fb27e88f64893e4a9abd34b820de5c87e99f7c59aca8391c9d510329e3d2e98b)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="channelInput")
    def channel_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "channelInput"))

    @builtins.property
    @jsii.member(jsii_name="channel")
    def channel(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "channel"))

    @channel.setter
    def channel(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__59d45c6b9f2a020d0b96d451267d8eb3908b67c44e728dbcde1ae6420e723b60)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "channel", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[ContainerClusterReleaseChannel]:
        return typing.cast(typing.Optional[ContainerClusterReleaseChannel], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterReleaseChannel],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d9edfb6fee70bb9c30c057e84b0e4473099472a635ab57cc5cf838d915975459)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterResourceUsageExportConfig",
    jsii_struct_bases=[],
    name_mapping={
        "bigquery_destination": "bigqueryDestination",
        "enable_network_egress_metering": "enableNetworkEgressMetering",
        "enable_resource_consumption_metering": "enableResourceConsumptionMetering",
    },
)
class ContainerClusterResourceUsageExportConfig:
    def __init__(
        self,
        *,
        bigquery_destination: typing.Union["ContainerClusterResourceUsageExportConfigBigqueryDestination", typing.Dict[builtins.str, typing.Any]],
        enable_network_egress_metering: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        enable_resource_consumption_metering: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    ) -> None:
        '''
        :param bigquery_destination: bigquery_destination block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#bigquery_destination ContainerCluster#bigquery_destination}
        :param enable_network_egress_metering: Whether to enable network egress metering for this cluster. If enabled, a daemonset will be created in the cluster to meter network egress traffic. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_network_egress_metering ContainerCluster#enable_network_egress_metering}
        :param enable_resource_consumption_metering: Whether to enable resource consumption metering on this cluster. When enabled, a table will be created in the resource export BigQuery dataset to store resource consumption data. The resulting table can be joined with the resource usage table or with BigQuery billing export. Defaults to true. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_resource_consumption_metering ContainerCluster#enable_resource_consumption_metering}
        '''
        if isinstance(bigquery_destination, dict):
            bigquery_destination = ContainerClusterResourceUsageExportConfigBigqueryDestination(**bigquery_destination)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__04c2f73000b1cacc47f4ad2326c76d769c88f68fbb392df0973a277fd0d11956)
            check_type(argname="argument bigquery_destination", value=bigquery_destination, expected_type=type_hints["bigquery_destination"])
            check_type(argname="argument enable_network_egress_metering", value=enable_network_egress_metering, expected_type=type_hints["enable_network_egress_metering"])
            check_type(argname="argument enable_resource_consumption_metering", value=enable_resource_consumption_metering, expected_type=type_hints["enable_resource_consumption_metering"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "bigquery_destination": bigquery_destination,
        }
        if enable_network_egress_metering is not None:
            self._values["enable_network_egress_metering"] = enable_network_egress_metering
        if enable_resource_consumption_metering is not None:
            self._values["enable_resource_consumption_metering"] = enable_resource_consumption_metering

    @builtins.property
    def bigquery_destination(
        self,
    ) -> "ContainerClusterResourceUsageExportConfigBigqueryDestination":
        '''bigquery_destination block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#bigquery_destination ContainerCluster#bigquery_destination}
        '''
        result = self._values.get("bigquery_destination")
        assert result is not None, "Required property 'bigquery_destination' is missing"
        return typing.cast("ContainerClusterResourceUsageExportConfigBigqueryDestination", result)

    @builtins.property
    def enable_network_egress_metering(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Whether to enable network egress metering for this cluster.

        If enabled, a daemonset will be created in the cluster to meter network egress traffic.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_network_egress_metering ContainerCluster#enable_network_egress_metering}
        '''
        result = self._values.get("enable_network_egress_metering")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def enable_resource_consumption_metering(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Whether to enable resource consumption metering on this cluster.

        When enabled, a table will be created in the resource export BigQuery dataset to store resource consumption data. The resulting table can be joined with the resource usage table or with BigQuery billing export. Defaults to true.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enable_resource_consumption_metering ContainerCluster#enable_resource_consumption_metering}
        '''
        result = self._values.get("enable_resource_consumption_metering")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterResourceUsageExportConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterResourceUsageExportConfigBigqueryDestination",
    jsii_struct_bases=[],
    name_mapping={"dataset_id": "datasetId"},
)
class ContainerClusterResourceUsageExportConfigBigqueryDestination:
    def __init__(self, *, dataset_id: builtins.str) -> None:
        '''
        :param dataset_id: The ID of a BigQuery Dataset. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#dataset_id ContainerCluster#dataset_id}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__46d422327542206c2071786cf2bbd7c46bee2763b0a2131fee279f1df77b182f)
            check_type(argname="argument dataset_id", value=dataset_id, expected_type=type_hints["dataset_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "dataset_id": dataset_id,
        }

    @builtins.property
    def dataset_id(self) -> builtins.str:
        '''The ID of a BigQuery Dataset.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#dataset_id ContainerCluster#dataset_id}
        '''
        result = self._values.get("dataset_id")
        assert result is not None, "Required property 'dataset_id' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterResourceUsageExportConfigBigqueryDestination(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterResourceUsageExportConfigBigqueryDestinationOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterResourceUsageExportConfigBigqueryDestinationOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b164fb0f9b2461fd06f0c2637b77c79267adb40627d8e2b7e5906f78051dcccb)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="datasetIdInput")
    def dataset_id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "datasetIdInput"))

    @builtins.property
    @jsii.member(jsii_name="datasetId")
    def dataset_id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "datasetId"))

    @dataset_id.setter
    def dataset_id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dfc7e435fc5a175db436e88607080e08cdb4f7268dfbdb881a433ff5cb1317b9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "datasetId", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterResourceUsageExportConfigBigqueryDestination]:
        return typing.cast(typing.Optional[ContainerClusterResourceUsageExportConfigBigqueryDestination], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterResourceUsageExportConfigBigqueryDestination],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2767e011a021fe674acdfc45a13b56ad8cf82675e7d6ccd2a63644beb1a1d5d5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ContainerClusterResourceUsageExportConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterResourceUsageExportConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__465167c98c5f4bde1d51a14ba7834a831f10ee398ddd6d833dd9fa6582a16615)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="putBigqueryDestination")
    def put_bigquery_destination(self, *, dataset_id: builtins.str) -> None:
        '''
        :param dataset_id: The ID of a BigQuery Dataset. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#dataset_id ContainerCluster#dataset_id}
        '''
        value = ContainerClusterResourceUsageExportConfigBigqueryDestination(
            dataset_id=dataset_id
        )

        return typing.cast(None, jsii.invoke(self, "putBigqueryDestination", [value]))

    @jsii.member(jsii_name="resetEnableNetworkEgressMetering")
    def reset_enable_network_egress_metering(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnableNetworkEgressMetering", []))

    @jsii.member(jsii_name="resetEnableResourceConsumptionMetering")
    def reset_enable_resource_consumption_metering(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnableResourceConsumptionMetering", []))

    @builtins.property
    @jsii.member(jsii_name="bigqueryDestination")
    def bigquery_destination(
        self,
    ) -> ContainerClusterResourceUsageExportConfigBigqueryDestinationOutputReference:
        return typing.cast(ContainerClusterResourceUsageExportConfigBigqueryDestinationOutputReference, jsii.get(self, "bigqueryDestination"))

    @builtins.property
    @jsii.member(jsii_name="bigqueryDestinationInput")
    def bigquery_destination_input(
        self,
    ) -> typing.Optional[ContainerClusterResourceUsageExportConfigBigqueryDestination]:
        return typing.cast(typing.Optional[ContainerClusterResourceUsageExportConfigBigqueryDestination], jsii.get(self, "bigqueryDestinationInput"))

    @builtins.property
    @jsii.member(jsii_name="enableNetworkEgressMeteringInput")
    def enable_network_egress_metering_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enableNetworkEgressMeteringInput"))

    @builtins.property
    @jsii.member(jsii_name="enableResourceConsumptionMeteringInput")
    def enable_resource_consumption_metering_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enableResourceConsumptionMeteringInput"))

    @builtins.property
    @jsii.member(jsii_name="enableNetworkEgressMetering")
    def enable_network_egress_metering(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enableNetworkEgressMetering"))

    @enable_network_egress_metering.setter
    def enable_network_egress_metering(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6282063d404766add73df4a90f8209bd908f88175042b03a3144ccaa9229b4f1)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableNetworkEgressMetering", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="enableResourceConsumptionMetering")
    def enable_resource_consumption_metering(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enableResourceConsumptionMetering"))

    @enable_resource_consumption_metering.setter
    def enable_resource_consumption_metering(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3664ff325d6b3878ce93106eb397dc194238d8b44a5e3eab4bc6b72d2d276fa0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableResourceConsumptionMetering", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterResourceUsageExportConfig]:
        return typing.cast(typing.Optional[ContainerClusterResourceUsageExportConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterResourceUsageExportConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__97cbc5809524357bc363bbb99c717f414719f2094e47734cd5c0d1db0f69343c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterSecretManagerConfig",
    jsii_struct_bases=[],
    name_mapping={"enabled": "enabled"},
)
class ContainerClusterSecretManagerConfig:
    def __init__(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param enabled: Enable the Secret manager csi component. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__92fa0631ade9233286e3f6b0a43ae22d581fc0a431c1560d4b05ffdc4fe9c236)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "enabled": enabled,
        }

    @builtins.property
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        '''Enable the Secret manager csi component.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        '''
        result = self._values.get("enabled")
        assert result is not None, "Required property 'enabled' is missing"
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterSecretManagerConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterSecretManagerConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterSecretManagerConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__20ad5755273c730a07c230697b4f92ad05930103c89c765b3e718775c12d46e2)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="enabledInput")
    def enabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enabledInput"))

    @builtins.property
    @jsii.member(jsii_name="enabled")
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enabled"))

    @enabled.setter
    def enabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bb9a74ecd280f05068591d849786cf862b11b755f71fb9d951bc283cd25a8895)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[ContainerClusterSecretManagerConfig]:
        return typing.cast(typing.Optional[ContainerClusterSecretManagerConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterSecretManagerConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6b6903029708137cf1393685954a5ab9c79be64876a7739477ba12eea357ba09)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterSecurityPostureConfig",
    jsii_struct_bases=[],
    name_mapping={"mode": "mode", "vulnerability_mode": "vulnerabilityMode"},
)
class ContainerClusterSecurityPostureConfig:
    def __init__(
        self,
        *,
        mode: typing.Optional[builtins.str] = None,
        vulnerability_mode: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param mode: Sets the mode of the Kubernetes security posture API's off-cluster features. Available options include DISABLED, BASIC, and ENTERPRISE. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#mode ContainerCluster#mode}
        :param vulnerability_mode: Sets the mode of the Kubernetes security posture API's workload vulnerability scanning. Available options include VULNERABILITY_DISABLED, VULNERABILITY_BASIC and VULNERABILITY_ENTERPRISE. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#vulnerability_mode ContainerCluster#vulnerability_mode}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d1d58312b705d0848fb44e3894ebc38dc88bd6c8a7b95fd2f32f203a8a868e53)
            check_type(argname="argument mode", value=mode, expected_type=type_hints["mode"])
            check_type(argname="argument vulnerability_mode", value=vulnerability_mode, expected_type=type_hints["vulnerability_mode"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if mode is not None:
            self._values["mode"] = mode
        if vulnerability_mode is not None:
            self._values["vulnerability_mode"] = vulnerability_mode

    @builtins.property
    def mode(self) -> typing.Optional[builtins.str]:
        '''Sets the mode of the Kubernetes security posture API's off-cluster features. Available options include DISABLED, BASIC, and ENTERPRISE.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#mode ContainerCluster#mode}
        '''
        result = self._values.get("mode")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def vulnerability_mode(self) -> typing.Optional[builtins.str]:
        '''Sets the mode of the Kubernetes security posture API's workload vulnerability scanning. Available options include VULNERABILITY_DISABLED, VULNERABILITY_BASIC and VULNERABILITY_ENTERPRISE.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#vulnerability_mode ContainerCluster#vulnerability_mode}
        '''
        result = self._values.get("vulnerability_mode")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterSecurityPostureConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterSecurityPostureConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterSecurityPostureConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b8e87333bc6613a3f0e8c3a3c022cc8275f60d25ccd153d8cf81f1cab4ac5754)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetMode")
    def reset_mode(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMode", []))

    @jsii.member(jsii_name="resetVulnerabilityMode")
    def reset_vulnerability_mode(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetVulnerabilityMode", []))

    @builtins.property
    @jsii.member(jsii_name="modeInput")
    def mode_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "modeInput"))

    @builtins.property
    @jsii.member(jsii_name="vulnerabilityModeInput")
    def vulnerability_mode_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "vulnerabilityModeInput"))

    @builtins.property
    @jsii.member(jsii_name="mode")
    def mode(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "mode"))

    @mode.setter
    def mode(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4b0bcfefbffd9193b334275b6c15c84d5b7acdd11182d38ab1fb2fed3080580b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "mode", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="vulnerabilityMode")
    def vulnerability_mode(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "vulnerabilityMode"))

    @vulnerability_mode.setter
    def vulnerability_mode(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__24646e1814b6c68d1da405027d7f0b1ad499fce59b0f05ff8a04532e12aab70a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "vulnerabilityMode", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[ContainerClusterSecurityPostureConfig]:
        return typing.cast(typing.Optional[ContainerClusterSecurityPostureConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterSecurityPostureConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1c4182ff7d73920b37101965d1406c02a8b01e816ec4dbaa027ee5e200bd9d12)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterServiceExternalIpsConfig",
    jsii_struct_bases=[],
    name_mapping={"enabled": "enabled"},
)
class ContainerClusterServiceExternalIpsConfig:
    def __init__(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param enabled: When enabled, services with external ips specified will be allowed. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__16f9337bd961dd07acf0866012b853c89c9065d9d83c175aea7fe50605c59588)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "enabled": enabled,
        }

    @builtins.property
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        '''When enabled, services with external ips specified will be allowed.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        '''
        result = self._values.get("enabled")
        assert result is not None, "Required property 'enabled' is missing"
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterServiceExternalIpsConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterServiceExternalIpsConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterServiceExternalIpsConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__25eae22b580be46a37717830b08cdf494d2df1c350fedde1b55fc2082eed1131)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="enabledInput")
    def enabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enabledInput"))

    @builtins.property
    @jsii.member(jsii_name="enabled")
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enabled"))

    @enabled.setter
    def enabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__09d7657d486f31b01f547d757a654e7daa1806671dd3b44d32efdc11ef31a8ea)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[ContainerClusterServiceExternalIpsConfig]:
        return typing.cast(typing.Optional[ContainerClusterServiceExternalIpsConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterServiceExternalIpsConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__79212bc8364725323b5041b65699ea4e35b23a3f4f5d08dd233cd4fb20bc279c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterTimeouts",
    jsii_struct_bases=[],
    name_mapping={
        "create": "create",
        "delete": "delete",
        "read": "read",
        "update": "update",
    },
)
class ContainerClusterTimeouts:
    def __init__(
        self,
        *,
        create: typing.Optional[builtins.str] = None,
        delete: typing.Optional[builtins.str] = None,
        read: typing.Optional[builtins.str] = None,
        update: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param create: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#create ContainerCluster#create}.
        :param delete: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#delete ContainerCluster#delete}.
        :param read: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#read ContainerCluster#read}.
        :param update: Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#update ContainerCluster#update}.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__01589ad40269d86c0a2ac99404f40a824fb9f3a8e466fb429cb38171272085ed)
            check_type(argname="argument create", value=create, expected_type=type_hints["create"])
            check_type(argname="argument delete", value=delete, expected_type=type_hints["delete"])
            check_type(argname="argument read", value=read, expected_type=type_hints["read"])
            check_type(argname="argument update", value=update, expected_type=type_hints["update"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if create is not None:
            self._values["create"] = create
        if delete is not None:
            self._values["delete"] = delete
        if read is not None:
            self._values["read"] = read
        if update is not None:
            self._values["update"] = update

    @builtins.property
    def create(self) -> typing.Optional[builtins.str]:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#create ContainerCluster#create}.'''
        result = self._values.get("create")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def delete(self) -> typing.Optional[builtins.str]:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#delete ContainerCluster#delete}.'''
        result = self._values.get("delete")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def read(self) -> typing.Optional[builtins.str]:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#read ContainerCluster#read}.'''
        result = self._values.get("read")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def update(self) -> typing.Optional[builtins.str]:
        '''Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#update ContainerCluster#update}.'''
        result = self._values.get("update")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterTimeouts(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterTimeoutsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterTimeoutsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9805da06bf8934785411a74a1adec198411bfe4d5c5ec85586bd41e1161e82b9)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetCreate")
    def reset_create(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCreate", []))

    @jsii.member(jsii_name="resetDelete")
    def reset_delete(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDelete", []))

    @jsii.member(jsii_name="resetRead")
    def reset_read(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRead", []))

    @jsii.member(jsii_name="resetUpdate")
    def reset_update(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetUpdate", []))

    @builtins.property
    @jsii.member(jsii_name="createInput")
    def create_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "createInput"))

    @builtins.property
    @jsii.member(jsii_name="deleteInput")
    def delete_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "deleteInput"))

    @builtins.property
    @jsii.member(jsii_name="readInput")
    def read_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "readInput"))

    @builtins.property
    @jsii.member(jsii_name="updateInput")
    def update_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "updateInput"))

    @builtins.property
    @jsii.member(jsii_name="create")
    def create(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "create"))

    @create.setter
    def create(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0f053a33a8a28b4ce73607e9b5103a9663f80ab7e91e1ed903c9f76adac623cc)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "create", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="delete")
    def delete(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "delete"))

    @delete.setter
    def delete(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c8db229541431b094f2ffc367ee89b833145d6daf08533ec8627283c56e1b4ec)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "delete", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="read")
    def read(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "read"))

    @read.setter
    def read(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__433a3340a39aa45b9fea39c5bc2fae41d7ded16c433b688c74e9514417f59314)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "read", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="update")
    def update(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "update"))

    @update.setter
    def update(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__392cbb0dce954d7c2a5db8819537464ffc6fa1ccc80a28d892dcc63a08748673)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "update", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterTimeouts]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterTimeouts]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterTimeouts]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__360ec49d022ecd12ecb02a52a6403a6c5c3ae6f77e92bac4490dab420ad90124)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterUserManagedKeysConfig",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation_ca": "aggregationCa",
        "cluster_ca": "clusterCa",
        "control_plane_disk_encryption_key": "controlPlaneDiskEncryptionKey",
        "etcd_api_ca": "etcdApiCa",
        "etcd_peer_ca": "etcdPeerCa",
        "gkeops_etcd_backup_encryption_key": "gkeopsEtcdBackupEncryptionKey",
        "service_account_signing_keys": "serviceAccountSigningKeys",
        "service_account_verification_keys": "serviceAccountVerificationKeys",
    },
)
class ContainerClusterUserManagedKeysConfig:
    def __init__(
        self,
        *,
        aggregation_ca: typing.Optional[builtins.str] = None,
        cluster_ca: typing.Optional[builtins.str] = None,
        control_plane_disk_encryption_key: typing.Optional[builtins.str] = None,
        etcd_api_ca: typing.Optional[builtins.str] = None,
        etcd_peer_ca: typing.Optional[builtins.str] = None,
        gkeops_etcd_backup_encryption_key: typing.Optional[builtins.str] = None,
        service_account_signing_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
        service_account_verification_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param aggregation_ca: The Certificate Authority Service caPool to use for the aggreation CA in this cluster. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#aggregation_ca ContainerCluster#aggregation_ca}
        :param cluster_ca: The Certificate Authority Service caPool to use for the cluster CA in this cluster. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cluster_ca ContainerCluster#cluster_ca}
        :param control_plane_disk_encryption_key: The Cloud KMS cryptoKey to use for Confidential Hyperdisk on the control plane nodes. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#control_plane_disk_encryption_key ContainerCluster#control_plane_disk_encryption_key}
        :param etcd_api_ca: The Certificate Authority Service caPool to use for the etcd API CA in this cluster. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#etcd_api_ca ContainerCluster#etcd_api_ca}
        :param etcd_peer_ca: The Certificate Authority Service caPool to use for the etcd peer CA in this cluster. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#etcd_peer_ca ContainerCluster#etcd_peer_ca}
        :param gkeops_etcd_backup_encryption_key: Resource path of the Cloud KMS cryptoKey to use for encryption of internal etcd backups. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gkeops_etcd_backup_encryption_key ContainerCluster#gkeops_etcd_backup_encryption_key}
        :param service_account_signing_keys: The Cloud KMS cryptoKeyVersions to use for signing service account JWTs issued by this cluster. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#service_account_signing_keys ContainerCluster#service_account_signing_keys}
        :param service_account_verification_keys: The Cloud KMS cryptoKeyVersions to use for verifying service account JWTs issued by this cluster. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#service_account_verification_keys ContainerCluster#service_account_verification_keys}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__57c425e3acf7f9163f91161561e9972907cb2522327898d4e9a0e87502a47916)
            check_type(argname="argument aggregation_ca", value=aggregation_ca, expected_type=type_hints["aggregation_ca"])
            check_type(argname="argument cluster_ca", value=cluster_ca, expected_type=type_hints["cluster_ca"])
            check_type(argname="argument control_plane_disk_encryption_key", value=control_plane_disk_encryption_key, expected_type=type_hints["control_plane_disk_encryption_key"])
            check_type(argname="argument etcd_api_ca", value=etcd_api_ca, expected_type=type_hints["etcd_api_ca"])
            check_type(argname="argument etcd_peer_ca", value=etcd_peer_ca, expected_type=type_hints["etcd_peer_ca"])
            check_type(argname="argument gkeops_etcd_backup_encryption_key", value=gkeops_etcd_backup_encryption_key, expected_type=type_hints["gkeops_etcd_backup_encryption_key"])
            check_type(argname="argument service_account_signing_keys", value=service_account_signing_keys, expected_type=type_hints["service_account_signing_keys"])
            check_type(argname="argument service_account_verification_keys", value=service_account_verification_keys, expected_type=type_hints["service_account_verification_keys"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if aggregation_ca is not None:
            self._values["aggregation_ca"] = aggregation_ca
        if cluster_ca is not None:
            self._values["cluster_ca"] = cluster_ca
        if control_plane_disk_encryption_key is not None:
            self._values["control_plane_disk_encryption_key"] = control_plane_disk_encryption_key
        if etcd_api_ca is not None:
            self._values["etcd_api_ca"] = etcd_api_ca
        if etcd_peer_ca is not None:
            self._values["etcd_peer_ca"] = etcd_peer_ca
        if gkeops_etcd_backup_encryption_key is not None:
            self._values["gkeops_etcd_backup_encryption_key"] = gkeops_etcd_backup_encryption_key
        if service_account_signing_keys is not None:
            self._values["service_account_signing_keys"] = service_account_signing_keys
        if service_account_verification_keys is not None:
            self._values["service_account_verification_keys"] = service_account_verification_keys

    @builtins.property
    def aggregation_ca(self) -> typing.Optional[builtins.str]:
        '''The Certificate Authority Service caPool to use for the aggreation CA in this cluster.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#aggregation_ca ContainerCluster#aggregation_ca}
        '''
        result = self._values.get("aggregation_ca")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def cluster_ca(self) -> typing.Optional[builtins.str]:
        '''The Certificate Authority Service caPool to use for the cluster CA in this cluster.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#cluster_ca ContainerCluster#cluster_ca}
        '''
        result = self._values.get("cluster_ca")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def control_plane_disk_encryption_key(self) -> typing.Optional[builtins.str]:
        '''The Cloud KMS cryptoKey to use for Confidential Hyperdisk on the control plane nodes.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#control_plane_disk_encryption_key ContainerCluster#control_plane_disk_encryption_key}
        '''
        result = self._values.get("control_plane_disk_encryption_key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def etcd_api_ca(self) -> typing.Optional[builtins.str]:
        '''The Certificate Authority Service caPool to use for the etcd API CA in this cluster.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#etcd_api_ca ContainerCluster#etcd_api_ca}
        '''
        result = self._values.get("etcd_api_ca")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def etcd_peer_ca(self) -> typing.Optional[builtins.str]:
        '''The Certificate Authority Service caPool to use for the etcd peer CA in this cluster.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#etcd_peer_ca ContainerCluster#etcd_peer_ca}
        '''
        result = self._values.get("etcd_peer_ca")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def gkeops_etcd_backup_encryption_key(self) -> typing.Optional[builtins.str]:
        '''Resource path of the Cloud KMS cryptoKey to use for encryption of internal etcd backups.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#gkeops_etcd_backup_encryption_key ContainerCluster#gkeops_etcd_backup_encryption_key}
        '''
        result = self._values.get("gkeops_etcd_backup_encryption_key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def service_account_signing_keys(
        self,
    ) -> typing.Optional[typing.List[builtins.str]]:
        '''The Cloud KMS cryptoKeyVersions to use for signing service account JWTs issued by this cluster.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#service_account_signing_keys ContainerCluster#service_account_signing_keys}
        '''
        result = self._values.get("service_account_signing_keys")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def service_account_verification_keys(
        self,
    ) -> typing.Optional[typing.List[builtins.str]]:
        '''The Cloud KMS cryptoKeyVersions to use for verifying service account JWTs issued by this cluster.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#service_account_verification_keys ContainerCluster#service_account_verification_keys}
        '''
        result = self._values.get("service_account_verification_keys")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterUserManagedKeysConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterUserManagedKeysConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterUserManagedKeysConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ad0b787361e7655d43a5f048d7333eed62f3900851ee5f6cdd7924f44d47e38a)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetAggregationCa")
    def reset_aggregation_ca(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAggregationCa", []))

    @jsii.member(jsii_name="resetClusterCa")
    def reset_cluster_ca(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetClusterCa", []))

    @jsii.member(jsii_name="resetControlPlaneDiskEncryptionKey")
    def reset_control_plane_disk_encryption_key(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetControlPlaneDiskEncryptionKey", []))

    @jsii.member(jsii_name="resetEtcdApiCa")
    def reset_etcd_api_ca(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEtcdApiCa", []))

    @jsii.member(jsii_name="resetEtcdPeerCa")
    def reset_etcd_peer_ca(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEtcdPeerCa", []))

    @jsii.member(jsii_name="resetGkeopsEtcdBackupEncryptionKey")
    def reset_gkeops_etcd_backup_encryption_key(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGkeopsEtcdBackupEncryptionKey", []))

    @jsii.member(jsii_name="resetServiceAccountSigningKeys")
    def reset_service_account_signing_keys(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetServiceAccountSigningKeys", []))

    @jsii.member(jsii_name="resetServiceAccountVerificationKeys")
    def reset_service_account_verification_keys(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetServiceAccountVerificationKeys", []))

    @builtins.property
    @jsii.member(jsii_name="aggregationCaInput")
    def aggregation_ca_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "aggregationCaInput"))

    @builtins.property
    @jsii.member(jsii_name="clusterCaInput")
    def cluster_ca_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "clusterCaInput"))

    @builtins.property
    @jsii.member(jsii_name="controlPlaneDiskEncryptionKeyInput")
    def control_plane_disk_encryption_key_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "controlPlaneDiskEncryptionKeyInput"))

    @builtins.property
    @jsii.member(jsii_name="etcdApiCaInput")
    def etcd_api_ca_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "etcdApiCaInput"))

    @builtins.property
    @jsii.member(jsii_name="etcdPeerCaInput")
    def etcd_peer_ca_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "etcdPeerCaInput"))

    @builtins.property
    @jsii.member(jsii_name="gkeopsEtcdBackupEncryptionKeyInput")
    def gkeops_etcd_backup_encryption_key_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "gkeopsEtcdBackupEncryptionKeyInput"))

    @builtins.property
    @jsii.member(jsii_name="serviceAccountSigningKeysInput")
    def service_account_signing_keys_input(
        self,
    ) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "serviceAccountSigningKeysInput"))

    @builtins.property
    @jsii.member(jsii_name="serviceAccountVerificationKeysInput")
    def service_account_verification_keys_input(
        self,
    ) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "serviceAccountVerificationKeysInput"))

    @builtins.property
    @jsii.member(jsii_name="aggregationCa")
    def aggregation_ca(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "aggregationCa"))

    @aggregation_ca.setter
    def aggregation_ca(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fe122d86887f645f3ca1c0dd3e67e777c457a5264ff5d1ec33a295b0f874a210)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "aggregationCa", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="clusterCa")
    def cluster_ca(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "clusterCa"))

    @cluster_ca.setter
    def cluster_ca(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__538f4b042cd9d4eab4ff39e74f699540e9c3944d5d8129521174494ba182a52c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "clusterCa", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="controlPlaneDiskEncryptionKey")
    def control_plane_disk_encryption_key(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "controlPlaneDiskEncryptionKey"))

    @control_plane_disk_encryption_key.setter
    def control_plane_disk_encryption_key(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c38e1c4a2447306f9c8bd7ca7af78963ff8885fae16322026b91aeab122af783)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "controlPlaneDiskEncryptionKey", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="etcdApiCa")
    def etcd_api_ca(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "etcdApiCa"))

    @etcd_api_ca.setter
    def etcd_api_ca(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__43d4d56eba5a25559fd12a34ba254e1b1698e0b4a707df3b755e542605db5ab5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "etcdApiCa", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="etcdPeerCa")
    def etcd_peer_ca(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "etcdPeerCa"))

    @etcd_peer_ca.setter
    def etcd_peer_ca(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a38b0820b97ceea127b846c918fab0940e4a02c0ff0e4f982d915bcb3133b85c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "etcdPeerCa", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="gkeopsEtcdBackupEncryptionKey")
    def gkeops_etcd_backup_encryption_key(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "gkeopsEtcdBackupEncryptionKey"))

    @gkeops_etcd_backup_encryption_key.setter
    def gkeops_etcd_backup_encryption_key(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6d2ca22482f04f4261bc12ca3df4007e39c6405ba2d0b3af0e83cc8e26cc2a48)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "gkeopsEtcdBackupEncryptionKey", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="serviceAccountSigningKeys")
    def service_account_signing_keys(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "serviceAccountSigningKeys"))

    @service_account_signing_keys.setter
    def service_account_signing_keys(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__991c6be0e12073760344a98bcfb6ab3fa5976efb0d07819a99c365571c190b4c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "serviceAccountSigningKeys", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="serviceAccountVerificationKeys")
    def service_account_verification_keys(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "serviceAccountVerificationKeys"))

    @service_account_verification_keys.setter
    def service_account_verification_keys(
        self,
        value: typing.List[builtins.str],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c7d8855a314232d33e14c6a56d5e33a062e04b4fc335182f50069527a7629350)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "serviceAccountVerificationKeys", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[ContainerClusterUserManagedKeysConfig]:
        return typing.cast(typing.Optional[ContainerClusterUserManagedKeysConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterUserManagedKeysConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__517bf4316db8500711871ee2ee80d3bb27635428ddbb2d56b434bf03fbaf2dae)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterVerticalPodAutoscaling",
    jsii_struct_bases=[],
    name_mapping={"enabled": "enabled"},
)
class ContainerClusterVerticalPodAutoscaling:
    def __init__(
        self,
        *,
        enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        '''
        :param enabled: Enables vertical pod autoscaling. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__719c6f14c481e8c53f898f0566b10cee9813b846685aa493657c158b3f168783)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "enabled": enabled,
        }

    @builtins.property
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        '''Enables vertical pod autoscaling.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#enabled ContainerCluster#enabled}
        '''
        result = self._values.get("enabled")
        assert result is not None, "Required property 'enabled' is missing"
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterVerticalPodAutoscaling(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterVerticalPodAutoscalingOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterVerticalPodAutoscalingOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b251cb7ceebfde916978ba08740f67aa9f65f0248061e66a64ac8a099850b51f)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @builtins.property
    @jsii.member(jsii_name="enabledInput")
    def enabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enabledInput"))

    @builtins.property
    @jsii.member(jsii_name="enabled")
    def enabled(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "enabled"))

    @enabled.setter
    def enabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3e4bb62dc5a6d38240b4257ca567e96b41ccd4bd838024d1294ac868bfd5d6dc)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[ContainerClusterVerticalPodAutoscaling]:
        return typing.cast(typing.Optional[ContainerClusterVerticalPodAutoscaling], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterVerticalPodAutoscaling],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__776d453e7569a936ddb8d5b345460bd673ce9da731fbf428f7c31b4c332a5e42)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterWorkloadIdentityConfig",
    jsii_struct_bases=[],
    name_mapping={"workload_pool": "workloadPool"},
)
class ContainerClusterWorkloadIdentityConfig:
    def __init__(self, *, workload_pool: typing.Optional[builtins.str] = None) -> None:
        '''
        :param workload_pool: The workload pool to attach all Kubernetes service accounts to. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#workload_pool ContainerCluster#workload_pool}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ac8af8f217da4566399eb2b5000faf5182fc76ebb46496eb2be4445fb24e04e4)
            check_type(argname="argument workload_pool", value=workload_pool, expected_type=type_hints["workload_pool"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if workload_pool is not None:
            self._values["workload_pool"] = workload_pool

    @builtins.property
    def workload_pool(self) -> typing.Optional[builtins.str]:
        '''The workload pool to attach all Kubernetes service accounts to.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.50.0/docs/resources/container_cluster#workload_pool ContainerCluster#workload_pool}
        '''
        result = self._values.get("workload_pool")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerClusterWorkloadIdentityConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ContainerClusterWorkloadIdentityConfigOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-google.containerCluster.ContainerClusterWorkloadIdentityConfigOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ae3fdbd9cefdf2385fa2e713de8623a50c6186f30e16fc3bb8b6b899b462e38c)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetWorkloadPool")
    def reset_workload_pool(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetWorkloadPool", []))

    @builtins.property
    @jsii.member(jsii_name="workloadPoolInput")
    def workload_pool_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "workloadPoolInput"))

    @builtins.property
    @jsii.member(jsii_name="workloadPool")
    def workload_pool(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "workloadPool"))

    @workload_pool.setter
    def workload_pool(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7e3025e520fe6a0b53c15539e5dd789d11691b5838d647033641be33de76c9ea)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "workloadPool", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[ContainerClusterWorkloadIdentityConfig]:
        return typing.cast(typing.Optional[ContainerClusterWorkloadIdentityConfig], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[ContainerClusterWorkloadIdentityConfig],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e1dd689a9478b2fe84a72a16a0fc0808a2fae948766e89984dbffee4b60ec8ed)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


__all__ = [
    "ContainerCluster",
    "ContainerClusterAddonsConfig",
    "ContainerClusterAddonsConfigCloudrunConfig",
    "ContainerClusterAddonsConfigCloudrunConfigOutputReference",
    "ContainerClusterAddonsConfigConfigConnectorConfig",
    "ContainerClusterAddonsConfigConfigConnectorConfigOutputReference",
    "ContainerClusterAddonsConfigDnsCacheConfig",
    "ContainerClusterAddonsConfigDnsCacheConfigOutputReference",
    "ContainerClusterAddonsConfigGcePersistentDiskCsiDriverConfig",
    "ContainerClusterAddonsConfigGcePersistentDiskCsiDriverConfigOutputReference",
    "ContainerClusterAddonsConfigGcpFilestoreCsiDriverConfig",
    "ContainerClusterAddonsConfigGcpFilestoreCsiDriverConfigOutputReference",
    "ContainerClusterAddonsConfigGcsFuseCsiDriverConfig",
    "ContainerClusterAddonsConfigGcsFuseCsiDriverConfigOutputReference",
    "ContainerClusterAddonsConfigGkeBackupAgentConfig",
    "ContainerClusterAddonsConfigGkeBackupAgentConfigOutputReference",
    "ContainerClusterAddonsConfigHorizontalPodAutoscaling",
    "ContainerClusterAddonsConfigHorizontalPodAutoscalingOutputReference",
    "ContainerClusterAddonsConfigHttpLoadBalancing",
    "ContainerClusterAddonsConfigHttpLoadBalancingOutputReference",
    "ContainerClusterAddonsConfigLustreCsiDriverConfig",
    "ContainerClusterAddonsConfigLustreCsiDriverConfigOutputReference",
    "ContainerClusterAddonsConfigNetworkPolicyConfig",
    "ContainerClusterAddonsConfigNetworkPolicyConfigOutputReference",
    "ContainerClusterAddonsConfigOutputReference",
    "ContainerClusterAddonsConfigParallelstoreCsiDriverConfig",
    "ContainerClusterAddonsConfigParallelstoreCsiDriverConfigOutputReference",
    "ContainerClusterAddonsConfigRayOperatorConfig",
    "ContainerClusterAddonsConfigRayOperatorConfigList",
    "ContainerClusterAddonsConfigRayOperatorConfigOutputReference",
    "ContainerClusterAddonsConfigRayOperatorConfigRayClusterLoggingConfig",
    "ContainerClusterAddonsConfigRayOperatorConfigRayClusterLoggingConfigOutputReference",
    "ContainerClusterAddonsConfigRayOperatorConfigRayClusterMonitoringConfig",
    "ContainerClusterAddonsConfigRayOperatorConfigRayClusterMonitoringConfigOutputReference",
    "ContainerClusterAddonsConfigStatefulHaConfig",
    "ContainerClusterAddonsConfigStatefulHaConfigOutputReference",
    "ContainerClusterAnonymousAuthenticationConfig",
    "ContainerClusterAnonymousAuthenticationConfigOutputReference",
    "ContainerClusterAuthenticatorGroupsConfig",
    "ContainerClusterAuthenticatorGroupsConfigOutputReference",
    "ContainerClusterBinaryAuthorization",
    "ContainerClusterBinaryAuthorizationOutputReference",
    "ContainerClusterClusterAutoscaling",
    "ContainerClusterClusterAutoscalingAutoProvisioningDefaults",
    "ContainerClusterClusterAutoscalingAutoProvisioningDefaultsManagement",
    "ContainerClusterClusterAutoscalingAutoProvisioningDefaultsManagementOutputReference",
    "ContainerClusterClusterAutoscalingAutoProvisioningDefaultsManagementUpgradeOptions",
    "ContainerClusterClusterAutoscalingAutoProvisioningDefaultsManagementUpgradeOptionsList",
    "ContainerClusterClusterAutoscalingAutoProvisioningDefaultsManagementUpgradeOptionsOutputReference",
    "ContainerClusterClusterAutoscalingAutoProvisioningDefaultsOutputReference",
    "ContainerClusterClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig",
    "ContainerClusterClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfigOutputReference",
    "ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings",
    "ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings",
    "ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsOutputReference",
    "ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy",
    "ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicyOutputReference",
    "ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsOutputReference",
    "ContainerClusterClusterAutoscalingOutputReference",
    "ContainerClusterClusterAutoscalingResourceLimits",
    "ContainerClusterClusterAutoscalingResourceLimitsList",
    "ContainerClusterClusterAutoscalingResourceLimitsOutputReference",
    "ContainerClusterConfidentialNodes",
    "ContainerClusterConfidentialNodesOutputReference",
    "ContainerClusterConfig",
    "ContainerClusterControlPlaneEndpointsConfig",
    "ContainerClusterControlPlaneEndpointsConfigDnsEndpointConfig",
    "ContainerClusterControlPlaneEndpointsConfigDnsEndpointConfigOutputReference",
    "ContainerClusterControlPlaneEndpointsConfigIpEndpointsConfig",
    "ContainerClusterControlPlaneEndpointsConfigIpEndpointsConfigOutputReference",
    "ContainerClusterControlPlaneEndpointsConfigOutputReference",
    "ContainerClusterCostManagementConfig",
    "ContainerClusterCostManagementConfigOutputReference",
    "ContainerClusterDatabaseEncryption",
    "ContainerClusterDatabaseEncryptionOutputReference",
    "ContainerClusterDefaultSnatStatus",
    "ContainerClusterDefaultSnatStatusOutputReference",
    "ContainerClusterDnsConfig",
    "ContainerClusterDnsConfigOutputReference",
    "ContainerClusterEnableK8SBetaApis",
    "ContainerClusterEnableK8SBetaApisOutputReference",
    "ContainerClusterEnterpriseConfig",
    "ContainerClusterEnterpriseConfigOutputReference",
    "ContainerClusterFleet",
    "ContainerClusterFleetOutputReference",
    "ContainerClusterGatewayApiConfig",
    "ContainerClusterGatewayApiConfigOutputReference",
    "ContainerClusterGkeAutoUpgradeConfig",
    "ContainerClusterGkeAutoUpgradeConfigOutputReference",
    "ContainerClusterIdentityServiceConfig",
    "ContainerClusterIdentityServiceConfigOutputReference",
    "ContainerClusterIpAllocationPolicy",
    "ContainerClusterIpAllocationPolicyAdditionalIpRangesConfig",
    "ContainerClusterIpAllocationPolicyAdditionalIpRangesConfigList",
    "ContainerClusterIpAllocationPolicyAdditionalIpRangesConfigOutputReference",
    "ContainerClusterIpAllocationPolicyAdditionalPodRangesConfig",
    "ContainerClusterIpAllocationPolicyAdditionalPodRangesConfigOutputReference",
    "ContainerClusterIpAllocationPolicyOutputReference",
    "ContainerClusterIpAllocationPolicyPodCidrOverprovisionConfig",
    "ContainerClusterIpAllocationPolicyPodCidrOverprovisionConfigOutputReference",
    "ContainerClusterLoggingConfig",
    "ContainerClusterLoggingConfigOutputReference",
    "ContainerClusterMaintenancePolicy",
    "ContainerClusterMaintenancePolicyDailyMaintenanceWindow",
    "ContainerClusterMaintenancePolicyDailyMaintenanceWindowOutputReference",
    "ContainerClusterMaintenancePolicyMaintenanceExclusion",
    "ContainerClusterMaintenancePolicyMaintenanceExclusionExclusionOptions",
    "ContainerClusterMaintenancePolicyMaintenanceExclusionExclusionOptionsOutputReference",
    "ContainerClusterMaintenancePolicyMaintenanceExclusionList",
    "ContainerClusterMaintenancePolicyMaintenanceExclusionOutputReference",
    "ContainerClusterMaintenancePolicyOutputReference",
    "ContainerClusterMaintenancePolicyRecurringWindow",
    "ContainerClusterMaintenancePolicyRecurringWindowOutputReference",
    "ContainerClusterMasterAuth",
    "ContainerClusterMasterAuthClientCertificateConfig",
    "ContainerClusterMasterAuthClientCertificateConfigOutputReference",
    "ContainerClusterMasterAuthOutputReference",
    "ContainerClusterMasterAuthorizedNetworksConfig",
    "ContainerClusterMasterAuthorizedNetworksConfigCidrBlocks",
    "ContainerClusterMasterAuthorizedNetworksConfigCidrBlocksList",
    "ContainerClusterMasterAuthorizedNetworksConfigCidrBlocksOutputReference",
    "ContainerClusterMasterAuthorizedNetworksConfigOutputReference",
    "ContainerClusterMeshCertificates",
    "ContainerClusterMeshCertificatesOutputReference",
    "ContainerClusterMonitoringConfig",
    "ContainerClusterMonitoringConfigAdvancedDatapathObservabilityConfig",
    "ContainerClusterMonitoringConfigAdvancedDatapathObservabilityConfigOutputReference",
    "ContainerClusterMonitoringConfigManagedPrometheus",
    "ContainerClusterMonitoringConfigManagedPrometheusAutoMonitoringConfig",
    "ContainerClusterMonitoringConfigManagedPrometheusAutoMonitoringConfigOutputReference",
    "ContainerClusterMonitoringConfigManagedPrometheusOutputReference",
    "ContainerClusterMonitoringConfigOutputReference",
    "ContainerClusterNetworkPerformanceConfig",
    "ContainerClusterNetworkPerformanceConfigOutputReference",
    "ContainerClusterNetworkPolicy",
    "ContainerClusterNetworkPolicyOutputReference",
    "ContainerClusterNodeConfig",
    "ContainerClusterNodeConfigAdvancedMachineFeatures",
    "ContainerClusterNodeConfigAdvancedMachineFeaturesOutputReference",
    "ContainerClusterNodeConfigBootDisk",
    "ContainerClusterNodeConfigBootDiskOutputReference",
    "ContainerClusterNodeConfigConfidentialNodes",
    "ContainerClusterNodeConfigConfidentialNodesOutputReference",
    "ContainerClusterNodeConfigContainerdConfig",
    "ContainerClusterNodeConfigContainerdConfigOutputReference",
    "ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfig",
    "ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig",
    "ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig",
    "ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfigOutputReference",
    "ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigList",
    "ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigOutputReference",
    "ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigOutputReference",
    "ContainerClusterNodeConfigEffectiveTaints",
    "ContainerClusterNodeConfigEffectiveTaintsList",
    "ContainerClusterNodeConfigEffectiveTaintsOutputReference",
    "ContainerClusterNodeConfigEphemeralStorageLocalSsdConfig",
    "ContainerClusterNodeConfigEphemeralStorageLocalSsdConfigOutputReference",
    "ContainerClusterNodeConfigFastSocket",
    "ContainerClusterNodeConfigFastSocketOutputReference",
    "ContainerClusterNodeConfigGcfsConfig",
    "ContainerClusterNodeConfigGcfsConfigOutputReference",
    "ContainerClusterNodeConfigGuestAccelerator",
    "ContainerClusterNodeConfigGuestAcceleratorGpuDriverInstallationConfig",
    "ContainerClusterNodeConfigGuestAcceleratorGpuDriverInstallationConfigOutputReference",
    "ContainerClusterNodeConfigGuestAcceleratorGpuSharingConfig",
    "ContainerClusterNodeConfigGuestAcceleratorGpuSharingConfigOutputReference",
    "ContainerClusterNodeConfigGuestAcceleratorList",
    "ContainerClusterNodeConfigGuestAcceleratorOutputReference",
    "ContainerClusterNodeConfigGvnic",
    "ContainerClusterNodeConfigGvnicOutputReference",
    "ContainerClusterNodeConfigHostMaintenancePolicy",
    "ContainerClusterNodeConfigHostMaintenancePolicyOutputReference",
    "ContainerClusterNodeConfigKubeletConfig",
    "ContainerClusterNodeConfigKubeletConfigEvictionMinimumReclaim",
    "ContainerClusterNodeConfigKubeletConfigEvictionMinimumReclaimOutputReference",
    "ContainerClusterNodeConfigKubeletConfigEvictionSoft",
    "ContainerClusterNodeConfigKubeletConfigEvictionSoftGracePeriod",
    "ContainerClusterNodeConfigKubeletConfigEvictionSoftGracePeriodOutputReference",
    "ContainerClusterNodeConfigKubeletConfigEvictionSoftOutputReference",
    "ContainerClusterNodeConfigKubeletConfigOutputReference",
    "ContainerClusterNodeConfigLinuxNodeConfig",
    "ContainerClusterNodeConfigLinuxNodeConfigHugepagesConfig",
    "ContainerClusterNodeConfigLinuxNodeConfigHugepagesConfigOutputReference",
    "ContainerClusterNodeConfigLinuxNodeConfigOutputReference",
    "ContainerClusterNodeConfigLocalNvmeSsdBlockConfig",
    "ContainerClusterNodeConfigLocalNvmeSsdBlockConfigOutputReference",
    "ContainerClusterNodeConfigOutputReference",
    "ContainerClusterNodeConfigReservationAffinity",
    "ContainerClusterNodeConfigReservationAffinityOutputReference",
    "ContainerClusterNodeConfigSecondaryBootDisks",
    "ContainerClusterNodeConfigSecondaryBootDisksList",
    "ContainerClusterNodeConfigSecondaryBootDisksOutputReference",
    "ContainerClusterNodeConfigShieldedInstanceConfig",
    "ContainerClusterNodeConfigShieldedInstanceConfigOutputReference",
    "ContainerClusterNodeConfigSoleTenantConfig",
    "ContainerClusterNodeConfigSoleTenantConfigNodeAffinity",
    "ContainerClusterNodeConfigSoleTenantConfigNodeAffinityList",
    "ContainerClusterNodeConfigSoleTenantConfigNodeAffinityOutputReference",
    "ContainerClusterNodeConfigSoleTenantConfigOutputReference",
    "ContainerClusterNodeConfigTaint",
    "ContainerClusterNodeConfigTaintList",
    "ContainerClusterNodeConfigTaintOutputReference",
    "ContainerClusterNodeConfigWindowsNodeConfig",
    "ContainerClusterNodeConfigWindowsNodeConfigOutputReference",
    "ContainerClusterNodeConfigWorkloadMetadataConfig",
    "ContainerClusterNodeConfigWorkloadMetadataConfigOutputReference",
    "ContainerClusterNodePool",
    "ContainerClusterNodePoolAutoConfig",
    "ContainerClusterNodePoolAutoConfigLinuxNodeConfig",
    "ContainerClusterNodePoolAutoConfigLinuxNodeConfigOutputReference",
    "ContainerClusterNodePoolAutoConfigNetworkTags",
    "ContainerClusterNodePoolAutoConfigNetworkTagsOutputReference",
    "ContainerClusterNodePoolAutoConfigNodeKubeletConfig",
    "ContainerClusterNodePoolAutoConfigNodeKubeletConfigOutputReference",
    "ContainerClusterNodePoolAutoConfigOutputReference",
    "ContainerClusterNodePoolAutoscaling",
    "ContainerClusterNodePoolAutoscalingOutputReference",
    "ContainerClusterNodePoolDefaults",
    "ContainerClusterNodePoolDefaultsNodeConfigDefaults",
    "ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfig",
    "ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigOutputReference",
    "ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig",
    "ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig",
    "ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig",
    "ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfigOutputReference",
    "ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigList",
    "ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigOutputReference",
    "ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigOutputReference",
    "ContainerClusterNodePoolDefaultsNodeConfigDefaultsGcfsConfig",
    "ContainerClusterNodePoolDefaultsNodeConfigDefaultsGcfsConfigOutputReference",
    "ContainerClusterNodePoolDefaultsNodeConfigDefaultsOutputReference",
    "ContainerClusterNodePoolDefaultsOutputReference",
    "ContainerClusterNodePoolList",
    "ContainerClusterNodePoolManagement",
    "ContainerClusterNodePoolManagementOutputReference",
    "ContainerClusterNodePoolNetworkConfig",
    "ContainerClusterNodePoolNetworkConfigAdditionalNodeNetworkConfigs",
    "ContainerClusterNodePoolNetworkConfigAdditionalNodeNetworkConfigsList",
    "ContainerClusterNodePoolNetworkConfigAdditionalNodeNetworkConfigsOutputReference",
    "ContainerClusterNodePoolNetworkConfigAdditionalPodNetworkConfigs",
    "ContainerClusterNodePoolNetworkConfigAdditionalPodNetworkConfigsList",
    "ContainerClusterNodePoolNetworkConfigAdditionalPodNetworkConfigsOutputReference",
    "ContainerClusterNodePoolNetworkConfigNetworkPerformanceConfig",
    "ContainerClusterNodePoolNetworkConfigNetworkPerformanceConfigOutputReference",
    "ContainerClusterNodePoolNetworkConfigOutputReference",
    "ContainerClusterNodePoolNetworkConfigPodCidrOverprovisionConfig",
    "ContainerClusterNodePoolNetworkConfigPodCidrOverprovisionConfigOutputReference",
    "ContainerClusterNodePoolNodeConfig",
    "ContainerClusterNodePoolNodeConfigAdvancedMachineFeatures",
    "ContainerClusterNodePoolNodeConfigAdvancedMachineFeaturesOutputReference",
    "ContainerClusterNodePoolNodeConfigBootDisk",
    "ContainerClusterNodePoolNodeConfigBootDiskOutputReference",
    "ContainerClusterNodePoolNodeConfigConfidentialNodes",
    "ContainerClusterNodePoolNodeConfigConfidentialNodesOutputReference",
    "ContainerClusterNodePoolNodeConfigContainerdConfig",
    "ContainerClusterNodePoolNodeConfigContainerdConfigOutputReference",
    "ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfig",
    "ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig",
    "ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig",
    "ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfigOutputReference",
    "ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigList",
    "ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigOutputReference",
    "ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigOutputReference",
    "ContainerClusterNodePoolNodeConfigEffectiveTaints",
    "ContainerClusterNodePoolNodeConfigEffectiveTaintsList",
    "ContainerClusterNodePoolNodeConfigEffectiveTaintsOutputReference",
    "ContainerClusterNodePoolNodeConfigEphemeralStorageLocalSsdConfig",
    "ContainerClusterNodePoolNodeConfigEphemeralStorageLocalSsdConfigOutputReference",
    "ContainerClusterNodePoolNodeConfigFastSocket",
    "ContainerClusterNodePoolNodeConfigFastSocketOutputReference",
    "ContainerClusterNodePoolNodeConfigGcfsConfig",
    "ContainerClusterNodePoolNodeConfigGcfsConfigOutputReference",
    "ContainerClusterNodePoolNodeConfigGuestAccelerator",
    "ContainerClusterNodePoolNodeConfigGuestAcceleratorGpuDriverInstallationConfig",
    "ContainerClusterNodePoolNodeConfigGuestAcceleratorGpuDriverInstallationConfigOutputReference",
    "ContainerClusterNodePoolNodeConfigGuestAcceleratorGpuSharingConfig",
    "ContainerClusterNodePoolNodeConfigGuestAcceleratorGpuSharingConfigOutputReference",
    "ContainerClusterNodePoolNodeConfigGuestAcceleratorList",
    "ContainerClusterNodePoolNodeConfigGuestAcceleratorOutputReference",
    "ContainerClusterNodePoolNodeConfigGvnic",
    "ContainerClusterNodePoolNodeConfigGvnicOutputReference",
    "ContainerClusterNodePoolNodeConfigHostMaintenancePolicy",
    "ContainerClusterNodePoolNodeConfigHostMaintenancePolicyOutputReference",
    "ContainerClusterNodePoolNodeConfigKubeletConfig",
    "ContainerClusterNodePoolNodeConfigKubeletConfigEvictionMinimumReclaim",
    "ContainerClusterNodePoolNodeConfigKubeletConfigEvictionMinimumReclaimOutputReference",
    "ContainerClusterNodePoolNodeConfigKubeletConfigEvictionSoft",
    "ContainerClusterNodePoolNodeConfigKubeletConfigEvictionSoftGracePeriod",
    "ContainerClusterNodePoolNodeConfigKubeletConfigEvictionSoftGracePeriodOutputReference",
    "ContainerClusterNodePoolNodeConfigKubeletConfigEvictionSoftOutputReference",
    "ContainerClusterNodePoolNodeConfigKubeletConfigOutputReference",
    "ContainerClusterNodePoolNodeConfigLinuxNodeConfig",
    "ContainerClusterNodePoolNodeConfigLinuxNodeConfigHugepagesConfig",
    "ContainerClusterNodePoolNodeConfigLinuxNodeConfigHugepagesConfigOutputReference",
    "ContainerClusterNodePoolNodeConfigLinuxNodeConfigOutputReference",
    "ContainerClusterNodePoolNodeConfigLocalNvmeSsdBlockConfig",
    "ContainerClusterNodePoolNodeConfigLocalNvmeSsdBlockConfigOutputReference",
    "ContainerClusterNodePoolNodeConfigOutputReference",
    "ContainerClusterNodePoolNodeConfigReservationAffinity",
    "ContainerClusterNodePoolNodeConfigReservationAffinityOutputReference",
    "ContainerClusterNodePoolNodeConfigSecondaryBootDisks",
    "ContainerClusterNodePoolNodeConfigSecondaryBootDisksList",
    "ContainerClusterNodePoolNodeConfigSecondaryBootDisksOutputReference",
    "ContainerClusterNodePoolNodeConfigShieldedInstanceConfig",
    "ContainerClusterNodePoolNodeConfigShieldedInstanceConfigOutputReference",
    "ContainerClusterNodePoolNodeConfigSoleTenantConfig",
    "ContainerClusterNodePoolNodeConfigSoleTenantConfigNodeAffinity",
    "ContainerClusterNodePoolNodeConfigSoleTenantConfigNodeAffinityList",
    "ContainerClusterNodePoolNodeConfigSoleTenantConfigNodeAffinityOutputReference",
    "ContainerClusterNodePoolNodeConfigSoleTenantConfigOutputReference",
    "ContainerClusterNodePoolNodeConfigTaint",
    "ContainerClusterNodePoolNodeConfigTaintList",
    "ContainerClusterNodePoolNodeConfigTaintOutputReference",
    "ContainerClusterNodePoolNodeConfigWindowsNodeConfig",
    "ContainerClusterNodePoolNodeConfigWindowsNodeConfigOutputReference",
    "ContainerClusterNodePoolNodeConfigWorkloadMetadataConfig",
    "ContainerClusterNodePoolNodeConfigWorkloadMetadataConfigOutputReference",
    "ContainerClusterNodePoolOutputReference",
    "ContainerClusterNodePoolPlacementPolicy",
    "ContainerClusterNodePoolPlacementPolicyOutputReference",
    "ContainerClusterNodePoolQueuedProvisioning",
    "ContainerClusterNodePoolQueuedProvisioningOutputReference",
    "ContainerClusterNodePoolUpgradeSettings",
    "ContainerClusterNodePoolUpgradeSettingsBlueGreenSettings",
    "ContainerClusterNodePoolUpgradeSettingsBlueGreenSettingsOutputReference",
    "ContainerClusterNodePoolUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy",
    "ContainerClusterNodePoolUpgradeSettingsBlueGreenSettingsStandardRolloutPolicyOutputReference",
    "ContainerClusterNodePoolUpgradeSettingsOutputReference",
    "ContainerClusterNotificationConfig",
    "ContainerClusterNotificationConfigOutputReference",
    "ContainerClusterNotificationConfigPubsub",
    "ContainerClusterNotificationConfigPubsubFilter",
    "ContainerClusterNotificationConfigPubsubFilterOutputReference",
    "ContainerClusterNotificationConfigPubsubOutputReference",
    "ContainerClusterPodAutoscaling",
    "ContainerClusterPodAutoscalingOutputReference",
    "ContainerClusterPrivateClusterConfig",
    "ContainerClusterPrivateClusterConfigMasterGlobalAccessConfig",
    "ContainerClusterPrivateClusterConfigMasterGlobalAccessConfigOutputReference",
    "ContainerClusterPrivateClusterConfigOutputReference",
    "ContainerClusterRbacBindingConfig",
    "ContainerClusterRbacBindingConfigOutputReference",
    "ContainerClusterReleaseChannel",
    "ContainerClusterReleaseChannelOutputReference",
    "ContainerClusterResourceUsageExportConfig",
    "ContainerClusterResourceUsageExportConfigBigqueryDestination",
    "ContainerClusterResourceUsageExportConfigBigqueryDestinationOutputReference",
    "ContainerClusterResourceUsageExportConfigOutputReference",
    "ContainerClusterSecretManagerConfig",
    "ContainerClusterSecretManagerConfigOutputReference",
    "ContainerClusterSecurityPostureConfig",
    "ContainerClusterSecurityPostureConfigOutputReference",
    "ContainerClusterServiceExternalIpsConfig",
    "ContainerClusterServiceExternalIpsConfigOutputReference",
    "ContainerClusterTimeouts",
    "ContainerClusterTimeoutsOutputReference",
    "ContainerClusterUserManagedKeysConfig",
    "ContainerClusterUserManagedKeysConfigOutputReference",
    "ContainerClusterVerticalPodAutoscaling",
    "ContainerClusterVerticalPodAutoscalingOutputReference",
    "ContainerClusterWorkloadIdentityConfig",
    "ContainerClusterWorkloadIdentityConfigOutputReference",
]

publication.publish()

def _typecheckingstub__af1997513508cac85424bc74f71db511ff5c7d660ba2550cc73e0ae55cf04b0a(
    scope: _constructs_77d1e7e8.Construct,
    id_: builtins.str,
    *,
    name: builtins.str,
    addons_config: typing.Optional[typing.Union[ContainerClusterAddonsConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    allow_net_admin: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    anonymous_authentication_config: typing.Optional[typing.Union[ContainerClusterAnonymousAuthenticationConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    authenticator_groups_config: typing.Optional[typing.Union[ContainerClusterAuthenticatorGroupsConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    binary_authorization: typing.Optional[typing.Union[ContainerClusterBinaryAuthorization, typing.Dict[builtins.str, typing.Any]]] = None,
    cluster_autoscaling: typing.Optional[typing.Union[ContainerClusterClusterAutoscaling, typing.Dict[builtins.str, typing.Any]]] = None,
    cluster_ipv4_cidr: typing.Optional[builtins.str] = None,
    confidential_nodes: typing.Optional[typing.Union[ContainerClusterConfidentialNodes, typing.Dict[builtins.str, typing.Any]]] = None,
    control_plane_endpoints_config: typing.Optional[typing.Union[ContainerClusterControlPlaneEndpointsConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    cost_management_config: typing.Optional[typing.Union[ContainerClusterCostManagementConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    database_encryption: typing.Optional[typing.Union[ContainerClusterDatabaseEncryption, typing.Dict[builtins.str, typing.Any]]] = None,
    datapath_provider: typing.Optional[builtins.str] = None,
    default_max_pods_per_node: typing.Optional[jsii.Number] = None,
    default_snat_status: typing.Optional[typing.Union[ContainerClusterDefaultSnatStatus, typing.Dict[builtins.str, typing.Any]]] = None,
    deletion_protection: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    description: typing.Optional[builtins.str] = None,
    disable_l4_lb_firewall_reconciliation: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    dns_config: typing.Optional[typing.Union[ContainerClusterDnsConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    enable_autopilot: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    enable_cilium_clusterwide_network_policy: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    enable_fqdn_network_policy: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    enable_intranode_visibility: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    enable_k8_s_beta_apis: typing.Optional[typing.Union[ContainerClusterEnableK8SBetaApis, typing.Dict[builtins.str, typing.Any]]] = None,
    enable_kubernetes_alpha: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    enable_l4_ilb_subsetting: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    enable_legacy_abac: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    enable_multi_networking: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    enable_shielded_nodes: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    enable_tpu: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    enterprise_config: typing.Optional[typing.Union[ContainerClusterEnterpriseConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    fleet: typing.Optional[typing.Union[ContainerClusterFleet, typing.Dict[builtins.str, typing.Any]]] = None,
    gateway_api_config: typing.Optional[typing.Union[ContainerClusterGatewayApiConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    gke_auto_upgrade_config: typing.Optional[typing.Union[ContainerClusterGkeAutoUpgradeConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    id: typing.Optional[builtins.str] = None,
    identity_service_config: typing.Optional[typing.Union[ContainerClusterIdentityServiceConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    initial_node_count: typing.Optional[jsii.Number] = None,
    in_transit_encryption_config: typing.Optional[builtins.str] = None,
    ip_allocation_policy: typing.Optional[typing.Union[ContainerClusterIpAllocationPolicy, typing.Dict[builtins.str, typing.Any]]] = None,
    location: typing.Optional[builtins.str] = None,
    logging_config: typing.Optional[typing.Union[ContainerClusterLoggingConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    logging_service: typing.Optional[builtins.str] = None,
    maintenance_policy: typing.Optional[typing.Union[ContainerClusterMaintenancePolicy, typing.Dict[builtins.str, typing.Any]]] = None,
    master_auth: typing.Optional[typing.Union[ContainerClusterMasterAuth, typing.Dict[builtins.str, typing.Any]]] = None,
    master_authorized_networks_config: typing.Optional[typing.Union[ContainerClusterMasterAuthorizedNetworksConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    mesh_certificates: typing.Optional[typing.Union[ContainerClusterMeshCertificates, typing.Dict[builtins.str, typing.Any]]] = None,
    min_master_version: typing.Optional[builtins.str] = None,
    monitoring_config: typing.Optional[typing.Union[ContainerClusterMonitoringConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    monitoring_service: typing.Optional[builtins.str] = None,
    network: typing.Optional[builtins.str] = None,
    networking_mode: typing.Optional[builtins.str] = None,
    network_performance_config: typing.Optional[typing.Union[ContainerClusterNetworkPerformanceConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    network_policy: typing.Optional[typing.Union[ContainerClusterNetworkPolicy, typing.Dict[builtins.str, typing.Any]]] = None,
    node_config: typing.Optional[typing.Union[ContainerClusterNodeConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    node_locations: typing.Optional[typing.Sequence[builtins.str]] = None,
    node_pool: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ContainerClusterNodePool, typing.Dict[builtins.str, typing.Any]]]]] = None,
    node_pool_auto_config: typing.Optional[typing.Union[ContainerClusterNodePoolAutoConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    node_pool_defaults: typing.Optional[typing.Union[ContainerClusterNodePoolDefaults, typing.Dict[builtins.str, typing.Any]]] = None,
    node_version: typing.Optional[builtins.str] = None,
    notification_config: typing.Optional[typing.Union[ContainerClusterNotificationConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    pod_autoscaling: typing.Optional[typing.Union[ContainerClusterPodAutoscaling, typing.Dict[builtins.str, typing.Any]]] = None,
    private_cluster_config: typing.Optional[typing.Union[ContainerClusterPrivateClusterConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    private_ipv6_google_access: typing.Optional[builtins.str] = None,
    project: typing.Optional[builtins.str] = None,
    rbac_binding_config: typing.Optional[typing.Union[ContainerClusterRbacBindingConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    release_channel: typing.Optional[typing.Union[ContainerClusterReleaseChannel, typing.Dict[builtins.str, typing.Any]]] = None,
    remove_default_node_pool: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    resource_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    resource_usage_export_config: typing.Optional[typing.Union[ContainerClusterResourceUsageExportConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    secret_manager_config: typing.Optional[typing.Union[ContainerClusterSecretManagerConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    security_posture_config: typing.Optional[typing.Union[ContainerClusterSecurityPostureConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    service_external_ips_config: typing.Optional[typing.Union[ContainerClusterServiceExternalIpsConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    subnetwork: typing.Optional[builtins.str] = None,
    timeouts: typing.Optional[typing.Union[ContainerClusterTimeouts, typing.Dict[builtins.str, typing.Any]]] = None,
    user_managed_keys_config: typing.Optional[typing.Union[ContainerClusterUserManagedKeysConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    vertical_pod_autoscaling: typing.Optional[typing.Union[ContainerClusterVerticalPodAutoscaling, typing.Dict[builtins.str, typing.Any]]] = None,
    workload_identity_config: typing.Optional[typing.Union[ContainerClusterWorkloadIdentityConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f97ab9e0e99bac83bd23fb992fefac1506b5a640bf6fa4a1628b4977a4779dbc(
    scope: _constructs_77d1e7e8.Construct,
    import_to_id: builtins.str,
    import_from_id: builtins.str,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__def24b0bab2637d0b9b35c4b7fca5c845eed84048b81fc3af2232b3db07ac2c1(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ContainerClusterNodePool, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d5c15cc7fb2a2d8d5523fe0f7da7df947fad97a0bd5b26658c6ce886bb3611d3(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__67623886670665df6107edc81983ce7619658a6e1d7244172828726c2ac0b6e8(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__615a96278b5f98a112fc3d5bca11c37a4fc559b32ed4f2e20f699459ff24166d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fd9dad9d5f16d1dea7536962ad7826ef751615f4337eb3441c18481cdbb65343(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6161c340f0072cb54615fec8a1ef3a17b791d2c8552d5a79d31b917f252a52af(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__28167017e9393fa2d955873ed002e448c5c4835f1ee2ef72156afd87b88f74a3(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4d0265084ee57d12d366397d2fdf8dc4423eaaae61b9b50dcddd814b5487b6b9(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__14d1bcab61ba35db086cefa53c36e1ca28568e51033792b326fdf8a4f455cd35(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6989332a5a61e9bbf059734b2da6c6a220208f98bebad60b1c22eb9d719d6dc6(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__478507f5575c1def237355171025a7885c3619da69dbca7f60928ea76578f81d(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9549f8a4eeafb85ecab6705d1d66626469a06cdf03bba9a62df6380309a84b18(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__709877277a977fa4fb1ec4aa11269a31cebd54e9bc6ca217b8a453b11124dad1(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2a8f9d16df64bd460e95f11fdfb8a8a499de0039586e11fc3e66646a8be9758f(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2fc5ae3fb89bb4319cadec2735d8f43e2526d2842aba604fcf90a05afd240878(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__532f25249ade8ee53fe536f19754286aab9b65276d60d6acb0e0827f47bbf1d0(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bfa8471401c848361329cb383a64e45010818802c08093a0c1350c0aac5ccbd6(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__96fbc3719e219096f4bcb2415af317779e666ca7c2f83d74672bd0a0d2ebdb30(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7a38046d9775897bf0227a36f427f4afd1600cd8d072483cca529a04600a3821(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cbb565b1c38b85be3a7ab342b4eb4e7574d1332a59e1c06b1580c449e55af9a6(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d954594b6ef735b0d5873e23bbd1f500df98ef2eaa158db3a6882ac726c56bd5(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bd011b58574d0c3fbdc34e6ef71c887c7c2ff1949df5769835f6124477c738a4(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d7a2c6390e1899fbce14c30cd5071e0bca19e56acd942c1a9a39a8576d1295be(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2d9e31e232eb879e1b25542c09cf8e80d24d153b3f421e4da34fd9a1b70bec82(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f756e6128d188efac08a07503f28e8b3462bcf9c294a547c6b488d3453245cf2(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__26b4a2a73024f018cc2bcc75cb4d4aa19c9edb93309b9222b0b6cc31a49a71b0(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__708c0f4ecb0c069a9af35efb3cb464a9345f465db4ace0dbecc0003f447ea423(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__13b292f88b4a4fc4097ef4ab70ca54abb7a81125eb9e781ef4689cf656123b0d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__de251d5e4e992cc4dc8c1e13410d32652f6ad7c19dc065a23a446e2b8dcd246c(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__146fc372af154a7a606a70a52423411c6cb0d5690ec04719e8216631292e2775(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f1e16d73b1ebae43e5cf76a80ec9b64c1cd3c805f95c957e2c07ea7c2f64ee1d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d2ef2f681192771b3e78e205c60b19c8fb77564dca07d2b05762b8163e7f3b27(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__945a5076c45095b19331b13817217d1ac301b3657a2dd0f5770f761b51009311(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__65ccd82c4b764468077e42e3e6eb073364f896b36fed9ea01c7f8bef99899b03(
    value: typing.Mapping[builtins.str, builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f0ea3e309e9ae8456d2454a88e71e1eaaba811ea5ac7f2181ff30656db05606d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__90d120aa82f3a9a996300b5c06bf091c103df155899cce463d6b347915676793(
    *,
    cloudrun_config: typing.Optional[typing.Union[ContainerClusterAddonsConfigCloudrunConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_connector_config: typing.Optional[typing.Union[ContainerClusterAddonsConfigConfigConnectorConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    dns_cache_config: typing.Optional[typing.Union[ContainerClusterAddonsConfigDnsCacheConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    gce_persistent_disk_csi_driver_config: typing.Optional[typing.Union[ContainerClusterAddonsConfigGcePersistentDiskCsiDriverConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    gcp_filestore_csi_driver_config: typing.Optional[typing.Union[ContainerClusterAddonsConfigGcpFilestoreCsiDriverConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    gcs_fuse_csi_driver_config: typing.Optional[typing.Union[ContainerClusterAddonsConfigGcsFuseCsiDriverConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    gke_backup_agent_config: typing.Optional[typing.Union[ContainerClusterAddonsConfigGkeBackupAgentConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    horizontal_pod_autoscaling: typing.Optional[typing.Union[ContainerClusterAddonsConfigHorizontalPodAutoscaling, typing.Dict[builtins.str, typing.Any]]] = None,
    http_load_balancing: typing.Optional[typing.Union[ContainerClusterAddonsConfigHttpLoadBalancing, typing.Dict[builtins.str, typing.Any]]] = None,
    lustre_csi_driver_config: typing.Optional[typing.Union[ContainerClusterAddonsConfigLustreCsiDriverConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    network_policy_config: typing.Optional[typing.Union[ContainerClusterAddonsConfigNetworkPolicyConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    parallelstore_csi_driver_config: typing.Optional[typing.Union[ContainerClusterAddonsConfigParallelstoreCsiDriverConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    ray_operator_config: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ContainerClusterAddonsConfigRayOperatorConfig, typing.Dict[builtins.str, typing.Any]]]]] = None,
    stateful_ha_config: typing.Optional[typing.Union[ContainerClusterAddonsConfigStatefulHaConfig, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4c477dd39d2b4195d82d9581e8bc009f264be96b74d042252a807513960ecda1(
    *,
    disabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    load_balancer_type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0b348612ee248f3577d1209e8b01ac14028218898bd73127c6ef08b5c4c68771(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7e97716f0fbf7a136259d00148931a35ae7b37e83985cca0337a6f991ebc9a19(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e2f912a3189f4c03f495c41da5452c20c0a5286dd0cc3698f51d157929c3a0b0(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5773740061f75538e42a9646b7645c1c0457f007f46adc3a48e2bd91d935d299(
    value: typing.Optional[ContainerClusterAddonsConfigCloudrunConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b56afc4251aa6b37c0c26d9e5e32d5313b315f0c2deb3d42b4b0fe9c4d0802b4(
    *,
    enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cd9883230801d139c01fc31c0ae487c366f256b7c9a7c34f0d5606114f0406cd(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__59790918ba40c43e056513c8a51a461f8ac0ae02b840c7fd86999bd25494c1a8(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3cc143b2c28765ede2f7e862d4130e43b4b11ee57c7c7edd201fa4e979d74d72(
    value: typing.Optional[ContainerClusterAddonsConfigConfigConnectorConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__86bdea2eac5d814741af3c7176f6773d536bac5909110afbbddd08641c1223d7(
    *,
    enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8e0e870d36b0781735c11536461d8d076d881f78e91c06f7493a0ec43e0128f0(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__200977125aa6f430872fcaf1523197a8a2c58a5d6af48a3b159870fd27bab09d(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9716da4547a51489f372db64921bac26897f524ff205244fb74661807868f166(
    value: typing.Optional[ContainerClusterAddonsConfigDnsCacheConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6a51b8100b3f4fb89bfe1598e03f9eb3d2b21fc9827146c304c31ab988e7cfa6(
    *,
    enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__76ed5cd456b2123e56cd7c8b60fe933ef91a97c4b9fb3327660d94676566fb12(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a4d4a7607061a429678e51121ae67b1628b5d7b2d88fa30ba93522142da929cf(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__68b12d6c6f49da67d106c0800cefbdd26e3cb708c208d0e660344578f6a91f58(
    value: typing.Optional[ContainerClusterAddonsConfigGcePersistentDiskCsiDriverConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__150f68648e9c90c0fad5a574d76641e0e05da4e36463a4967c3217221e4fe815(
    *,
    enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1f8283559e8624e57b354605b2cb68e896a6cb733b76c3c8338ccdc0c2135f71(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1c27d2293acb1863e5764f809cdb7efe427b650605868d9419df3efbef460440(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e0ebb5fbb94c2fad8b0c53003a219131f1d0bf310e0e6b276d05fc2476da8702(
    value: typing.Optional[ContainerClusterAddonsConfigGcpFilestoreCsiDriverConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__644f3396bdaffbafc2a49611d50934397567f5550e4042f6f89659f9ff0e1c9c(
    *,
    enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a94679b9b5d632a4bad77a0dc648c80ea8d3d125fd3cbb3cc5ccee2aa93f0dd1(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5562250d3bcb1fb28778e597fd26e1609d7ced57c2a26d4844f49904bfed8a5c(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b7427e240ef183d29d7318c126ce00de4a7063df04cf3d16880a6ad687df77cb(
    value: typing.Optional[ContainerClusterAddonsConfigGcsFuseCsiDriverConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__989f596a11acd76c10a326f34c759a2053d7aea34f7e2e9a05deba6b1bbd66b1(
    *,
    enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b3bdccd924b462eb999947cda1d97a019ac8af5b885011c2bb66fe24c66689c3(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f164f4aa97f839541ef206406f094a721a72daf1da3d23ac9409e8388e394295(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dbaa56e118c7f05410da2e85833c938f425029d06a150afad5988344c6b78876(
    value: typing.Optional[ContainerClusterAddonsConfigGkeBackupAgentConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b01935ed28d24ec2099c6dc1a932402c8c8da8e384af529c4c683d1a3060acea(
    *,
    disabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__efa11872fca046f234fb9628e3404466f6b4545b26354971ab96d055332de4c6(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b8bbb9eaa2d2c79974be760fdde10fcd509788b188e892d766d403e08e149204(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a05240c58c16189985b111614a8d90cf4be73a3555999343bbe11210dd057f05(
    value: typing.Optional[ContainerClusterAddonsConfigHorizontalPodAutoscaling],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3da9ee6068566b9c546474fc3058017daf9737fb11f363293e05a676b1eeea11(
    *,
    disabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e165a83a8c4a200fe0527c0d21812ba1eabc7622985b3bcdd4a4e571a01f4810(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9e4f2e684377db24491054ac766901e1ae51aed761b8950a097db395ce7fe6e6(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6a8135b71daf78e5df3c91da6a9be0070b6638898371cc3c3bbf56e5384988ab(
    value: typing.Optional[ContainerClusterAddonsConfigHttpLoadBalancing],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2c0cabe685c48877f52f0e4d08da01473cbb29380ce18b3024ec8db01fab1c77(
    *,
    enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    enable_legacy_lustre_port: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c5700d2192a39807e6c89763b0bc922cc0349e26fe5fafed88ec44f16499bb0c(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ac632c3dded9765c8d5ded1a285339a308fc6fe3cf520d9fd330f47f486f0825(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__03a1f57f5af5e149ec617c6c45384d135a20194648439dc46d3ba45c53d3d023(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__12d1978a1010d9f2d9a0cdb99340f5b1b49cecae6ae31df0c651e549fc32f0bf(
    value: typing.Optional[ContainerClusterAddonsConfigLustreCsiDriverConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__80c0b93cfdd2a9b98ae41fe0c3ee4d323639bf447b333a125039875069b36b81(
    *,
    disabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__17855c4eba19645e88cd40d508f2140501716a550f6f2895e4f0bdd057ef5db6(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__97b7994a2b9992e1009161acd7ab3ae9cdc3343729fb85a0b20dbb46ad30e987(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__20a9836a01d40156d3fc1821ca69e04b7bf7bda439b1c0886d2e20782ec4f6e7(
    value: typing.Optional[ContainerClusterAddonsConfigNetworkPolicyConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f39d5b03006661a43a2b9c38effae803b7dc05d85eba319c10a46e32186dabcc(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c391a9eb40a1b3d709719d647144bdb947812c23fec583589307f2374929e9e5(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ContainerClusterAddonsConfigRayOperatorConfig, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d29a68bebb7bb8134bd4f0cf3b09b9543f819953467fdca53f4e63656e0e2c14(
    value: typing.Optional[ContainerClusterAddonsConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9c630b0d9eba01688e9149d858723a2afb2207540e9be9b5a49d3dcbc0bf4f1d(
    *,
    enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__69635665349f4cbb0eb4219a207eb0c1c086e1d4a0e8d0ca70f44e28edb6f985(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d7ab155bf9860a70fa14183c099246a3d1c9e0b7e9a1c10dad7a643ccc2fe0b3(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1413430194a1cdb6b3cbbf9045cfb209b88a6c426e694e15f04848702f191e38(
    value: typing.Optional[ContainerClusterAddonsConfigParallelstoreCsiDriverConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5e691af36ee05ef458a6187fbfed8b405d3671e96d10f030a390b4845a6cea75(
    *,
    enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ray_cluster_logging_config: typing.Optional[typing.Union[ContainerClusterAddonsConfigRayOperatorConfigRayClusterLoggingConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    ray_cluster_monitoring_config: typing.Optional[typing.Union[ContainerClusterAddonsConfigRayOperatorConfigRayClusterMonitoringConfig, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1e0779e681f4d297cb332db6e4b9f52ca6d77ad0542b3691b77d878bc6231077(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__63cb85a281550fe142765ad25811000e8d448e65930bad8add60202d692fe3a7(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1f448dc02029cc807ae90bcc2c0052cddce8de7ef30d05368f44160d9ec0c2eb(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__10e48240153b9367dd553bf966485705d9c9f5daec125a24bf45169eeb9ed81d(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__76db9258d6f9741345ec10fc605e6e69345ce52259069c06712425dafcdb5e42(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dd350102ec9bb06e87b9a38e26813ccfd76a8b7ab78ce5b59ed3850f4eb9f6db(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterAddonsConfigRayOperatorConfig]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6ab00aba0c52d8a5359640c949e32eb4044c43a6d27feafeeed2c1256eb3439e(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__06bf63e6aa860c106d7006b1f9ade952d41317a64e08d02ae108e90469ffbc02(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8ec7dece3dd6e0d945902fe2162740a8473c4d4c8ee8a8ac7736163440d6edd1(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterAddonsConfigRayOperatorConfig]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ec9bf4a625835b4d93999e27921a395863ef37f89d5b014a00c9b4c98bec0f2d(
    *,
    enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0f5f852bfc4d1cd50f0a1001744667fc5c003b5a7e2b683aa1ab3e200b2aaed9(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1c1d23b31ead2813fdf143b8be556e67d0790e046060d72f2aaff143ddc30353(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a317c372c8dbd94e1bf11db928eb748a7987de4d708a269839e250eb52aab55c(
    value: typing.Optional[ContainerClusterAddonsConfigRayOperatorConfigRayClusterLoggingConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7a70243680210ec4b25654d007b3da5f5f52f8040f3230336587c89deb496151(
    *,
    enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__37bb6c91d4d8bd9b48b644b89d2411987a847943b45d75311b7e3056e0074f0a(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c67942bd79368d6e15197080a98d5107497405e4ba694b3caa20f296f0e2fc42(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2316418e1bbc04a922837b0721879876276e0cdecf9e8c580ca94969786e28a0(
    value: typing.Optional[ContainerClusterAddonsConfigRayOperatorConfigRayClusterMonitoringConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5aa68f247db3560a14a74fe0acf6ed9eed30286b4f2e5b6901293d631c6f33fc(
    *,
    enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__501fc546a2c274b5b28ba62ac712efd69f9766bc9657a69d37b78ffc065e8927(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__076a90986b71f9e4afa7f1b3020e9be00f4862c1c7ea61d60297a89b21927a72(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c6b0c610bc894798edea347afb83f3066092a67dfc037e627c88b9f2ba15ff76(
    value: typing.Optional[ContainerClusterAddonsConfigStatefulHaConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8fedf79bb992981fd4d7aca30a8674f24cf8116e225d00a7ce08e04fc0a1ad0e(
    *,
    mode: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ea43f9ec240624692693a39ffc3bd6d66495240ccf8871125bb372616efaed00(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c9068b11a731782ef938d6f846b845d40af6cde97945f72d764efcd59aba56f5(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c04a59b37eeeeb3eddac491ce0b0eb3524e24663569cc258cdb8c8942c6a6857(
    value: typing.Optional[ContainerClusterAnonymousAuthenticationConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__622fd5b79b23d4cc0de7ab8b47d3a05c014d7c6f6f5f1d50701723af7e4bba5b(
    *,
    security_group: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e458c9db8a6dd7e422fab6ce9cce7c22c7fc1df0fd8a34ce939bd291221c3225(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3ffa35eab86a93c60a65d3e4508fafb94e597f6ee3dec495e2713bf5cc600279(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__137a7bff00b018827873a10ec827f7ee4942ca200495cd4a100d735c185d6dd2(
    value: typing.Optional[ContainerClusterAuthenticatorGroupsConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__231c80f1060a38982e2320c8452f5261be47733fbcd906cd0d78d2c3a3d92d54(
    *,
    enabled: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    evaluation_mode: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__006d122e9c3b9189ff387b1bdad93f294df12d37204ad0b72f64c306d0189dc9(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b912479483e9d0fc7110c735ca775caf1205b164db3e934296b8a3646b178c19(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b1b352d1834c0a04e73b9f148fcf6aba1f494ad94cdf0b44fd926a61039ae83d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__da58dd09e51a0238a84b30edc59e54eccc4a486065d1f77abbf85db9d027b9b0(
    value: typing.Optional[ContainerClusterBinaryAuthorization],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0d25194b7d9cf20caf650f3110c037a567a6e63304005bcecb0325a3a8f849e5(
    *,
    auto_provisioning_defaults: typing.Optional[typing.Union[ContainerClusterClusterAutoscalingAutoProvisioningDefaults, typing.Dict[builtins.str, typing.Any]]] = None,
    auto_provisioning_locations: typing.Optional[typing.Sequence[builtins.str]] = None,
    autoscaling_profile: typing.Optional[builtins.str] = None,
    enabled: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    resource_limits: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ContainerClusterClusterAutoscalingResourceLimits, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c74b2155b4b89544db85ab5c397b7d5c13c90bc909cf9502de5e3abff9e49285(
    *,
    boot_disk_kms_key: typing.Optional[builtins.str] = None,
    disk_size: typing.Optional[jsii.Number] = None,
    disk_type: typing.Optional[builtins.str] = None,
    image_type: typing.Optional[builtins.str] = None,
    management: typing.Optional[typing.Union[ContainerClusterClusterAutoscalingAutoProvisioningDefaultsManagement, typing.Dict[builtins.str, typing.Any]]] = None,
    min_cpu_platform: typing.Optional[builtins.str] = None,
    oauth_scopes: typing.Optional[typing.Sequence[builtins.str]] = None,
    service_account: typing.Optional[builtins.str] = None,
    shielded_instance_config: typing.Optional[typing.Union[ContainerClusterClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    upgrade_settings: typing.Optional[typing.Union[ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3bf9e4f4eb84edbd79450d408b85a28e0e241ea803c4d7514a58455d596da423(
    *,
    auto_repair: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    auto_upgrade: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2f514f563acf67f9169cd9c733365c436c300e541bfe477edbca819a82bcdef3(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__28ab4aba3ea072447f4e798f83f8ec281d173dc6ddd1e743a2bd9efa7fd16685(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1ffefb8729a466a019472e7deb10a636fe32381b475c127cb8bdbccb99e9e388(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6abc2a75ac2bbaae465807d02234c6f3e45f434d1cbcf97acdd7df127dc9466d(
    value: typing.Optional[ContainerClusterClusterAutoscalingAutoProvisioningDefaultsManagement],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__39f904226154338db3612a21f36ca6df26cc0943f6630de01f1da7f85e4c77e9(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__52a4506425e95a32761696b5e012f213034dbf90209afaf6d0144b2d067dbd10(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b9dbc58934ce3b5c7053756499ef05c631e6a894895dabb9c2a6da01e8f6ceea(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__958dc4b1d894fa626b8cc9959ccb3fe1558430f5d79600042647dde6b1a388b9(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__89d325fd41507dc8b0e229a77c6b92181f8483dc34751603f4dc605ae82972cc(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__45b930c7cdcc4ed0a34cc2539a31ae9b1900934881420ffb829de9262aa32891(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__039d10f88a2d72ceb54c003746658355e5b233f36be2dbec2341e375d4fbeba3(
    value: typing.Optional[ContainerClusterClusterAutoscalingAutoProvisioningDefaultsManagementUpgradeOptions],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__305c75f62d4ad7c5e00caee370ac194278c620a4c0ebede0e9978f3e7e444347(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b241fea7029d5696976cbcdf7f2c3481ac82d3d9fb74fa7e45f23051cb931d8c(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4260cd34d913af8160fd63600d8b7db8e827471d25055ea91d0596e90e6a5d21(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__914bcbc8430ccbc828fa56ea8c1ab8b4a022ba4c1ae0d0ad791c4f4b6fa9209f(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__192791ac221dfb6f89365a3d812a8d6d3211fdb95f5939359f54321f5d4023b8(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e97a99f2adf23415cc916dbe0b51a67c9afee2928b79d1efe54499e2a62584e5(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f61162fc09cc65c4d8fbea82d40b8630894f84eb82418be83b1b2876029c924c(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__428882f11777d22b0e65b93b22040568082a20f0e792fd6b359454827f3a61f9(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__38684d28f2226a0d9b10d1b1136e818426e8ac026ea0cb9ffe45d6719e243d80(
    value: typing.Optional[ContainerClusterClusterAutoscalingAutoProvisioningDefaults],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__87e28f88bbbfb1b469c3bb66cb17bc2de1932fcb3b63dfc54a1588aaee1ddfc9(
    *,
    enable_integrity_monitoring: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    enable_secure_boot: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__254e08c121849aff16daaa18317c7634ad9b8be1bf723fe3f2b714d9112b6d3d(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__64e8ada630c48097efbaa93b384ab99cbb798575828701b294bc866b6fa816fc(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__630fcc82ec1bf511483d7c7b613a59f3959b9ff928aaa35932ac5af91417a435(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__32409bbe2453058b65777fdd898f744f81bccd6a18282fd98bcb2e26e15a0cf0(
    value: typing.Optional[ContainerClusterClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8065934130c74122f72c4ff71bd486d68452b181adc2beee88e278b4490b7a1f(
    *,
    blue_green_settings: typing.Optional[typing.Union[ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings, typing.Dict[builtins.str, typing.Any]]] = None,
    max_surge: typing.Optional[jsii.Number] = None,
    max_unavailable: typing.Optional[jsii.Number] = None,
    strategy: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__52034160074bd10cb960d1e16ce0cd4e6c6e37662b2a33e51403918feb095b74(
    *,
    node_pool_soak_duration: typing.Optional[builtins.str] = None,
    standard_rollout_policy: typing.Optional[typing.Union[ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1c33439da99c9a2a9b93d4bed072b078c24fcfd9340522aed5e17b8b8ab35e28(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__582b2e1795b513abdc7cbc910b792cd8efb564e20bfa8fb4568c9a6d2b243023(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__06c0a28c161f26164e3f30eeaa488f577049cb69b0bd16355dc7a76bed8365f4(
    value: typing.Optional[ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__846b0746342b4ffddac22329da27ec4a2771c6488c1fd092d48d9864d247426e(
    *,
    batch_node_count: typing.Optional[jsii.Number] = None,
    batch_percentage: typing.Optional[jsii.Number] = None,
    batch_soak_duration: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6dd77cb9733caee1396c665d15fe44865735a321a5e4e2bbbb75039672c45023(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2c74ddbdf6f27a28efd9731832f599c7200fed79f373904fe9dbb273ee7ca00a(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__04ebe6f7667976dab5da6dc82f49724002f43cbc0fd13a77b63c70ed84f7f0e0(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7c44f9020c8fee7930961c69f9e22031c6452325b5379620ab422c57a77c1eaa(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fb72006866b5af0f5063edf548bb09fc0bef52692fc3a71ab60ae4d1d8d79b9c(
    value: typing.Optional[ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__18396b0f297045d72556cd5d32c4b44f4d404f82ff4caba2a10f6f4df37a25bf(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f00da0dfc81944ef978e0a83968cdf0c91c32de3c3b91029c8b7438366811148(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0173e3339f90cfecf3aa3f0783cacdc5ce1063266ac4c450dbcd8cb044378438(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7c0ba61c1ebb03025f54833b9307add892fa8082c2a670758f70cba6ad8f35ad(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7d4f00a288b5cdbd9bc949e8d4fba35c41bb720ea37e64a6e10b125a9f6ab537(
    value: typing.Optional[ContainerClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4e8d95af5e1845e22289b374af7f78b0fb9e93922a937adb319fff440d21e510(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__31ec9a56bad94b9d271190676be4a7b364b429122300331d3aa25b4a696cf3bd(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ContainerClusterClusterAutoscalingResourceLimits, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__922705163d15f2d9da872c3e97b5570e5af2e81a5cdf6ee6bae0f6ffcd928c9a(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__316e29e69e433eb2b681de775be238e30b8e80dca1234d791e6fede215c7ce27(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cf558e68f007248106a98e56b0385517956f11cb24c5465697aa482402239927(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5938fd47a50207ed91492229dd2402708d41f8134fa239807debd57f6faf90ee(
    value: typing.Optional[ContainerClusterClusterAutoscaling],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f298985a310c2edbe2d0c51da0facddd0d7ae153702fdb975f9c2a7d9032decd(
    *,
    maximum: jsii.Number,
    resource_type: builtins.str,
    minimum: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__16ef6a2120327c2606d1c8018707a7153f5287ecd704376b75a3582f4e41a7fb(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__aacc3e4cdec8dcb54d4b1df644b4347ffa7b58db61c67e93863f6e6d90e6253a(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f2ae9adbf7b9ed228bc9e1b1719a3db1a5ab5d994764cf7984aaa9c0cf878752(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ae879f806176b547b2ec1c210183ffb83168a1e1c52c5cbe038e099fa1f9cc45(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f7fdd40c4e814e3288e5da5ffd6fad8656e016e40bcd8d0b38ae17c0d65a0c6d(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f73130eccf6ab704714fd77dcb600a887f4eadb1a57be48c65a4b60719924e0d(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterClusterAutoscalingResourceLimits]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__79bb5cf00dca605877d137a244be8467e6ffa50389f279cece9f5a651dee36a5(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2cd4c1bb0889413c909781551388758bdf55f7ed215bc1573c59233f169c1012(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__77f55efd38ed7f4af15d38c459f23babce77b02727b3728397825a0898a2d8cc(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__757bfeb6641b9d78cbf0bcf0141d52d31b5091a90111fc030dc2c4393965d480(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fe42725cb9692c6b35263c30713d809e780c529fa4615c079e9fdf0539d95177(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterClusterAutoscalingResourceLimits]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4b3262c9ad6523a323e92c430530922547eef99b6ec92e6e80b0a01397e2c303(
    *,
    enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    confidential_instance_type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f18d28c3e99b0c50c295ee508e193dbcf9138b6c7bbe0950a5eb3ac5d859176c(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9b56d84d6fadb2c0ecec03e72ce79e3b3a3e6404fd9095798407ab3e0d4d2912(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d7ae8f58c2e47da85d3626244cb234110ae1d5394a5aeebb109f721f6ba056f0(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__af3763e29e3e2842e7e864d60aaca9a508eb54e8f37813f0a817c765c1b094da(
    value: typing.Optional[ContainerClusterConfidentialNodes],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__86583242019dd13fdb8a135b5185f2d527c88d5e9deca2e90bce8e0c8bc7a6b4(
    *,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    name: builtins.str,
    addons_config: typing.Optional[typing.Union[ContainerClusterAddonsConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    allow_net_admin: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    anonymous_authentication_config: typing.Optional[typing.Union[ContainerClusterAnonymousAuthenticationConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    authenticator_groups_config: typing.Optional[typing.Union[ContainerClusterAuthenticatorGroupsConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    binary_authorization: typing.Optional[typing.Union[ContainerClusterBinaryAuthorization, typing.Dict[builtins.str, typing.Any]]] = None,
    cluster_autoscaling: typing.Optional[typing.Union[ContainerClusterClusterAutoscaling, typing.Dict[builtins.str, typing.Any]]] = None,
    cluster_ipv4_cidr: typing.Optional[builtins.str] = None,
    confidential_nodes: typing.Optional[typing.Union[ContainerClusterConfidentialNodes, typing.Dict[builtins.str, typing.Any]]] = None,
    control_plane_endpoints_config: typing.Optional[typing.Union[ContainerClusterControlPlaneEndpointsConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    cost_management_config: typing.Optional[typing.Union[ContainerClusterCostManagementConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    database_encryption: typing.Optional[typing.Union[ContainerClusterDatabaseEncryption, typing.Dict[builtins.str, typing.Any]]] = None,
    datapath_provider: typing.Optional[builtins.str] = None,
    default_max_pods_per_node: typing.Optional[jsii.Number] = None,
    default_snat_status: typing.Optional[typing.Union[ContainerClusterDefaultSnatStatus, typing.Dict[builtins.str, typing.Any]]] = None,
    deletion_protection: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    description: typing.Optional[builtins.str] = None,
    disable_l4_lb_firewall_reconciliation: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    dns_config: typing.Optional[typing.Union[ContainerClusterDnsConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    enable_autopilot: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    enable_cilium_clusterwide_network_policy: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    enable_fqdn_network_policy: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    enable_intranode_visibility: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    enable_k8_s_beta_apis: typing.Optional[typing.Union[ContainerClusterEnableK8SBetaApis, typing.Dict[builtins.str, typing.Any]]] = None,
    enable_kubernetes_alpha: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    enable_l4_ilb_subsetting: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    enable_legacy_abac: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    enable_multi_networking: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    enable_shielded_nodes: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    enable_tpu: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    enterprise_config: typing.Optional[typing.Union[ContainerClusterEnterpriseConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    fleet: typing.Optional[typing.Union[ContainerClusterFleet, typing.Dict[builtins.str, typing.Any]]] = None,
    gateway_api_config: typing.Optional[typing.Union[ContainerClusterGatewayApiConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    gke_auto_upgrade_config: typing.Optional[typing.Union[ContainerClusterGkeAutoUpgradeConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    id: typing.Optional[builtins.str] = None,
    identity_service_config: typing.Optional[typing.Union[ContainerClusterIdentityServiceConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    initial_node_count: typing.Optional[jsii.Number] = None,
    in_transit_encryption_config: typing.Optional[builtins.str] = None,
    ip_allocation_policy: typing.Optional[typing.Union[ContainerClusterIpAllocationPolicy, typing.Dict[builtins.str, typing.Any]]] = None,
    location: typing.Optional[builtins.str] = None,
    logging_config: typing.Optional[typing.Union[ContainerClusterLoggingConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    logging_service: typing.Optional[builtins.str] = None,
    maintenance_policy: typing.Optional[typing.Union[ContainerClusterMaintenancePolicy, typing.Dict[builtins.str, typing.Any]]] = None,
    master_auth: typing.Optional[typing.Union[ContainerClusterMasterAuth, typing.Dict[builtins.str, typing.Any]]] = None,
    master_authorized_networks_config: typing.Optional[typing.Union[ContainerClusterMasterAuthorizedNetworksConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    mesh_certificates: typing.Optional[typing.Union[ContainerClusterMeshCertificates, typing.Dict[builtins.str, typing.Any]]] = None,
    min_master_version: typing.Optional[builtins.str] = None,
    monitoring_config: typing.Optional[typing.Union[ContainerClusterMonitoringConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    monitoring_service: typing.Optional[builtins.str] = None,
    network: typing.Optional[builtins.str] = None,
    networking_mode: typing.Optional[builtins.str] = None,
    network_performance_config: typing.Optional[typing.Union[ContainerClusterNetworkPerformanceConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    network_policy: typing.Optional[typing.Union[ContainerClusterNetworkPolicy, typing.Dict[builtins.str, typing.Any]]] = None,
    node_config: typing.Optional[typing.Union[ContainerClusterNodeConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    node_locations: typing.Optional[typing.Sequence[builtins.str]] = None,
    node_pool: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ContainerClusterNodePool, typing.Dict[builtins.str, typing.Any]]]]] = None,
    node_pool_auto_config: typing.Optional[typing.Union[ContainerClusterNodePoolAutoConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    node_pool_defaults: typing.Optional[typing.Union[ContainerClusterNodePoolDefaults, typing.Dict[builtins.str, typing.Any]]] = None,
    node_version: typing.Optional[builtins.str] = None,
    notification_config: typing.Optional[typing.Union[ContainerClusterNotificationConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    pod_autoscaling: typing.Optional[typing.Union[ContainerClusterPodAutoscaling, typing.Dict[builtins.str, typing.Any]]] = None,
    private_cluster_config: typing.Optional[typing.Union[ContainerClusterPrivateClusterConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    private_ipv6_google_access: typing.Optional[builtins.str] = None,
    project: typing.Optional[builtins.str] = None,
    rbac_binding_config: typing.Optional[typing.Union[ContainerClusterRbacBindingConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    release_channel: typing.Optional[typing.Union[ContainerClusterReleaseChannel, typing.Dict[builtins.str, typing.Any]]] = None,
    remove_default_node_pool: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    resource_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    resource_usage_export_config: typing.Optional[typing.Union[ContainerClusterResourceUsageExportConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    secret_manager_config: typing.Optional[typing.Union[ContainerClusterSecretManagerConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    security_posture_config: typing.Optional[typing.Union[ContainerClusterSecurityPostureConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    service_external_ips_config: typing.Optional[typing.Union[ContainerClusterServiceExternalIpsConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    subnetwork: typing.Optional[builtins.str] = None,
    timeouts: typing.Optional[typing.Union[ContainerClusterTimeouts, typing.Dict[builtins.str, typing.Any]]] = None,
    user_managed_keys_config: typing.Optional[typing.Union[ContainerClusterUserManagedKeysConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    vertical_pod_autoscaling: typing.Optional[typing.Union[ContainerClusterVerticalPodAutoscaling, typing.Dict[builtins.str, typing.Any]]] = None,
    workload_identity_config: typing.Optional[typing.Union[ContainerClusterWorkloadIdentityConfig, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e1269be8ac94e1b6299362e60b3b6e57091417b4f53d3adc695280904e400913(
    *,
    dns_endpoint_config: typing.Optional[typing.Union[ContainerClusterControlPlaneEndpointsConfigDnsEndpointConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    ip_endpoints_config: typing.Optional[typing.Union[ContainerClusterControlPlaneEndpointsConfigIpEndpointsConfig, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a769311967206be50968be9e800cf5dfe36b48ff96dc22fbb9d552b83e336576(
    *,
    allow_external_traffic: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    endpoint: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__128c0c91d0464c58859fcfc7af19c00a836b1530de1fd8b22139b57ff924f863(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ba87e8ec6eda7d51debc7108d4257021a26b96295c0015f225b4dc2af09a7958(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dd1d548fc11eebf9bb2409bd761c034d6778309d4294f918459d22af082654b5(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dc1e9d2145383d47d7d005139d4c305e50332e9357a8abbb22bb26faa22a50d7(
    value: typing.Optional[ContainerClusterControlPlaneEndpointsConfigDnsEndpointConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d2e3fd93530086a6bc2dfdbe81706f53f5e0bcb52125fc407bfbee89e2228515(
    *,
    enabled: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0059ad3ff3a7ba4c9ad3df92d42c80d7bf10c4bc52d62cbf8952f91cbe4ddb9d(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c6a0fcd589ede2da31c04003c4e2c44bd355cebfe41917438cdb2f471777ebae(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1074c362dc3a5edd9137f09503904e6f2b6672e11cc4cb2da827d65401f0044b(
    value: typing.Optional[ContainerClusterControlPlaneEndpointsConfigIpEndpointsConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a43d9146e315dfb096571251def552583f806aa77d78ca84d5d36aad486f6782(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9d2f5a95e3d2ed5318e1d8313741dcd8fe627fb90456fc9f7dc592cca013f4e7(
    value: typing.Optional[ContainerClusterControlPlaneEndpointsConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__53f94f622604f508c61a26dafac9189b13186d0494e1bb527c6169284eb3172d(
    *,
    enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c4ae1f8632618dc8678ab8b94841c62e5b47f078804f7d658094ca9adace050a(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__085919719eb66df9bc48d11cf3fa1923d97a49f32fc2e8d81de77211c988009f(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__33c06c5851952876184de73102553f77db3bfa84fc2aabd9ef91457f74ebf246(
    value: typing.Optional[ContainerClusterCostManagementConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b4203bf92b9a35241e2b86718f171be7ad42ed110398d6641d6b16457828693f(
    *,
    state: builtins.str,
    key_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e50e25d5af0319f7e23d6213366afbd5edaadc7b71bae807d24c1cd5ecc6f806(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__69a15842a9c1933078a389209bd015aa70f380ea03f6d2c9c38faec860815f39(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dd120cf9cf115d833106a15e8b2ce8a206f1e1806cf9d73af7b1964a02e554b1(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__df1eee8d9911a1c36692753649dc91f7a54a0c5c2fa1a18981bc835f62296502(
    value: typing.Optional[ContainerClusterDatabaseEncryption],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e5a3b8b4e99414f7b195db122b48d3b2d0bc6e27d68415557df17c9c2f3b8386(
    *,
    disabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d3d10964004d66068c90b9084a031fac04327bc643e5a21b04823a92ab651b72(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d39e501a5efafe90f40292a4971b0f91cd7cc194b57b3bd45270ff03966a25ce(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3924acd8dfe4a7ce7eb998500b2c1c11ef4ec99fd17b5f3420707d45a290fa5e(
    value: typing.Optional[ContainerClusterDefaultSnatStatus],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__155d0834b0bfacd35418367002f3a8a4fb1a087c15bdad407b1e4cb4d1b05602(
    *,
    additive_vpc_scope_dns_domain: typing.Optional[builtins.str] = None,
    cluster_dns: typing.Optional[builtins.str] = None,
    cluster_dns_domain: typing.Optional[builtins.str] = None,
    cluster_dns_scope: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5ad89177ab8b61f1e91912886784b26ef403fbdd2283499a1a2ba0fec73ac270(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0a807bd21410bc911c476585ab0bbd3e5947ff9817ea1644c1288a9aa16e5c1b(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5d2d03462df744d03c381d7cd24103a450ee14ace85e9bfc7d03687efc4dca59(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7aeca965c5e56db8d1273a185037e6e7f21f7fdb3f5fa8a3d8903816296b58e7(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3405ccb32ca7ca987cc637cb23862a38fb307075ff457862fba5e9ab2031b1cd(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4453ba5cd82bfe07d011f2dd3bbe3d907eb36f052c6c028a4faa265cf33de32a(
    value: typing.Optional[ContainerClusterDnsConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__17e8e3d61ea9cec84aaec791a29a95c292d696a3f2651a3cbc2caacf016e1e17(
    *,
    enabled_apis: typing.Sequence[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__854f61857974b7c4de758e456c53320ab1f70f3817420b1ee9068f3ee8d13a05(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6841bbc4340f5c758f5018db4dfccd36d9b4b9881fba5c9aa6d5365c7bdbc069(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ebd9dccaeb8cca687d21c9f6e689e7daff8b690858dc167a6bd0dbc75d9ac751(
    value: typing.Optional[ContainerClusterEnableK8SBetaApis],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9119beeca678b9e9a7f49519a8ff230f9d11e95cf6fd085e8d490d9ebdfa32cf(
    *,
    desired_tier: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d70b402e32809ad6ff2305277de9feb54d1d930eb52378461371a72e6365edec(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7194abcbd09d7e731b31db23818e0c80c93b8d5ea87a5ed44309c1aafd331c7a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__67643b6611fc6f6eccd92db59351871152682e525714f55d390f7d2f5fc641bc(
    value: typing.Optional[ContainerClusterEnterpriseConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6d3925f1d0bbb0310d2055b98284eb9428aaa5886c6714a3636b7f4419b7cae9(
    *,
    project: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__91e482a8e2c45a41e6ff9510219eb2f4e2160cc26b5fd8679a1fb9e7adc0927d(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__827ac1b2b5a2c8a3b9c048b8b0a4de25d6001933435d55a1a564385c76ab1535(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1422273da7bf5f6c6e5141eca43a946c73c8b5dbc62d365a9656a9be8e1a023c(
    value: typing.Optional[ContainerClusterFleet],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0578535ebb5b2405b26c23a6217d0fb4f0510595231fdfebdf88a5530ddbfb1f(
    *,
    channel: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__86eb46426d75c2c04d73989d0c08f2804e583099c051cae35d60c77bfb3fbbe8(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__355efbb62ea1178a864e32727b64223c26bc49489b5cfab8d8b29ef6f77ec837(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__83006e163075035aed8eb10f20d392c025321a1f656e4539998c824fe1920c07(
    value: typing.Optional[ContainerClusterGatewayApiConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__53c11213c323c84a3d0915dabb481d7dfa0c6d668663ed1782c419a04146515d(
    *,
    patch_mode: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2be7248baf577e7d2bbe5871c7e3e22992b907d60f83ddae477e81e068e43486(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1b3e395b1d253f431120b4cc38a951768d79a63df027a48381c9265265ea7b44(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cceae5ee2f69495bbacaa6f9ca414a84d07f7d82c38d1e22d944ac096053c9a6(
    value: typing.Optional[ContainerClusterGkeAutoUpgradeConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4eae44db020422f9295523b416de4d8132bfb46958dd382c163dbe51972e99f0(
    *,
    enabled: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3c81fa1bfefd0a12da56ac59a1b026d80a2268845377508fbc1b295bc81a5e6f(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1dd954f86defaa8787e97fc95c154a7f8df3f8db9b3bd277b6e5d3ef5b885423(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1c36546adc0a09f132ed3e05ed4598eda370ffff1fd5ce296f60606771a189d3(
    value: typing.Optional[ContainerClusterIdentityServiceConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c6c3a74e37b7ba5b8cae681999b3a7b285f08704c47d23563b47ced34374b444(
    *,
    additional_ip_ranges_config: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ContainerClusterIpAllocationPolicyAdditionalIpRangesConfig, typing.Dict[builtins.str, typing.Any]]]]] = None,
    additional_pod_ranges_config: typing.Optional[typing.Union[ContainerClusterIpAllocationPolicyAdditionalPodRangesConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    cluster_ipv4_cidr_block: typing.Optional[builtins.str] = None,
    cluster_secondary_range_name: typing.Optional[builtins.str] = None,
    pod_cidr_overprovision_config: typing.Optional[typing.Union[ContainerClusterIpAllocationPolicyPodCidrOverprovisionConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    services_ipv4_cidr_block: typing.Optional[builtins.str] = None,
    services_secondary_range_name: typing.Optional[builtins.str] = None,
    stack_type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__22bce20eced8a5c2b2457e3433e8dc1342579d0ad7d7d659de953706a041c3a8(
    *,
    subnetwork: builtins.str,
    pod_ipv4_range_names: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__23674470711cc82411b2b2a80661f6fe90a00727450a709090ae13cc47b9f91d(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__202bf4bcb35b00830bbb3ae7c06012aa08f4220cf30e4e10a332322860a8b5f4(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e7b8bc2fa2421804b1b4e6ce1ce456ea42db02516bbe646bb5e147542d40dfb6(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c5d2f41d8b7345bd7a44aa7b73165c3a67ff5a3e4de0b24e2db3b79a87538cfd(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bf5ee652e20abbc8b4ce4d4b1000bb39febffee193c21070904c954dfc981683(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__02e97ab68752659eeda82fcaf649f47ea68af4d81da3414e00227260f4afa299(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterIpAllocationPolicyAdditionalIpRangesConfig]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6f7f6745be3eb01246555a01bcd97374c06f0765d5026f13acb5f24514e38ce6(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dcdf31f406d723c18b774e705f155989df75d25734de2f8c14cf113beeef3bc2(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a814e5bba44ff5cbc789eb040e3b8f18b41a7601108adfec06d369cfe1e56da8(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6d6541a2433dcec497071db9b204420261f74955926273a09ef112346158ce5f(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterIpAllocationPolicyAdditionalIpRangesConfig]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dc2ea5d3bc702f7e6abd081fa46e851cc16124806f874ef75c2552888afa7866(
    *,
    pod_range_names: typing.Sequence[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1e4bc979083d2f868bea5d1013876a02ffb0d61d63bfbe8fdeb8677f653ff627(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__371f59eab3caec4893a99b5a6a85d0085b70ef05fed048274a6e7a8a7ddc0694(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__55fbe27f848c40e9b6d0f5323607953a819ceee923c896022cdc00d337dececb(
    value: typing.Optional[ContainerClusterIpAllocationPolicyAdditionalPodRangesConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__11b75519f866737d8a5444dd8b7d0eea2fe21007f173e06efc02a9d315313911(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ae9813d02888749790c14be240524df40ce48d7560344b8b931d79ef97911fc7(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ContainerClusterIpAllocationPolicyAdditionalIpRangesConfig, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d2e6d52678821d732a0e3e2f35ae74e543d4ccd885626d9100e237c470acedc7(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a053976795ee791290238e6d8a8477c9ead942345736d6a3a0f22f4056120542(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bca27133200ea17c6b362823da2f4c84bae6373275f817501f07e59f5b1849c3(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__97e8dc2e462a7622a344989ee853fb301bd422519d842a5d3c26fd20764f5296(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0f85a718f23806dd2898490273a40da7fe87a10d35d2656dc764a2f53e89cd84(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ea8674fc107cadc5afd7e6f3952ed350fe0fa3325ee11c9a615466db7c490923(
    value: typing.Optional[ContainerClusterIpAllocationPolicy],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__907c3fd004d203ee37b586ea9361981a269e14332717f8fbd0a41f9bb7ef1de6(
    *,
    disabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2cf0566144b2904576dc2b86ad81bd4a39dcd613cf2a0ca825dc86f3f934e94f(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cf5496ffb7055b26dc73996209f3f5f042acf2cda2b6168484d4408a3f280587(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__00665f6cbe8deee0003306461fe5e6a2ac5827738d71d78784d10002f829855b(
    value: typing.Optional[ContainerClusterIpAllocationPolicyPodCidrOverprovisionConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f1d09b4715752fdd3d7ea5d6a71f05b22ddf89b8164a6bc3a51cb78c1a02e5ac(
    *,
    enable_components: typing.Sequence[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d35f9d6a0af2283b399108fa5615e7274d44be4758522edad591eac4f6739100(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d828e9a97639b895a439d4987309b5fdb19e2eb48953f26ac58d8c381061f5b5(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e30ab8d5171bf9f3b30d1ebfed57301771a4061e1e1b983a9831eec901724bb2(
    value: typing.Optional[ContainerClusterLoggingConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__85e86e040fceb174eee2a58a8eb4b4806c4ce36aed9b0595689073b958d5c84a(
    *,
    daily_maintenance_window: typing.Optional[typing.Union[ContainerClusterMaintenancePolicyDailyMaintenanceWindow, typing.Dict[builtins.str, typing.Any]]] = None,
    maintenance_exclusion: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ContainerClusterMaintenancePolicyMaintenanceExclusion, typing.Dict[builtins.str, typing.Any]]]]] = None,
    recurring_window: typing.Optional[typing.Union[ContainerClusterMaintenancePolicyRecurringWindow, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ce4404d63aa1b33e3bcd14975f1f7def2297b13f9f9359b28b9ddeaa951df145(
    *,
    start_time: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__65bc866d9fcb2720c072385614d29c4fa364dc93c011f41d44a5d5d08c08fd74(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2c7c8da9e827ff7e4ed73c3fdfb1fb3f31513357b34798452121634e617bb2e0(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d13091c879afced2b7c59ff4ebb331ca0c3aa239d0934ab9877097c4aa9692f5(
    value: typing.Optional[ContainerClusterMaintenancePolicyDailyMaintenanceWindow],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__04cc040b8ef035c4322e5e0c555739edacb0c80d1058584bcafa9b365dabd68a(
    *,
    end_time: builtins.str,
    exclusion_name: builtins.str,
    start_time: builtins.str,
    exclusion_options: typing.Optional[typing.Union[ContainerClusterMaintenancePolicyMaintenanceExclusionExclusionOptions, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b3561e0f4f6fb3cd8220551c023272f2ae849bbef4736cfc783d2490ba2843d2(
    *,
    scope: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__600a65ce65f6c45ad1696ebc8447aad4034972ab4077e22dd23c1aeab9b2b962(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f15411f938956a90e1649f0c769bd0215435d42b0ce9d3241f55bfd2dfad8e17(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8c86904886b506d47ba0eb5dd8ca2fad22092eb3dab94341893e23cb5aeafcd9(
    value: typing.Optional[ContainerClusterMaintenancePolicyMaintenanceExclusionExclusionOptions],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__afcacc9cd484fbc361de7032aa35fe9b3ee7cf433d9d495427cf9d77c721a085(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__35178713abd07f5fb7263aac550caf2299170703ddfdd94cb92970d7228db8cc(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__df0d41c5527270e9b78de139cfc59b63cf8048caaaf76f4d88ad857d3eb4a6c4(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8565fec3d3aa636427178e2697dab2b1d059e616056f2b000e86b4d4dd552c62(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__06c611b92bd544d939b4972ba6076cf8044b459a49d9009dad5f0aae412f80c2(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__51019af4065118393ad60f78da5079ad3e2977391d8ea47b359b574bfddec91f(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterMaintenancePolicyMaintenanceExclusion]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__63eb1a6abe19edf7f4c43a83cd97f2c8a0a16cdbff5af43e056e8f89dd8ebbbf(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ba4a997bb50bbafab9253ab6b1d62c700377f32ffc02e1414694d9a559020654(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__511e57219aae2f0a510da1bb72352ee747d602897eba441efd16e632a969d42b(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0400251c13efede28160ca7e9bb406b431ce2b97c76a43663007b789276c9d74(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__aaabce3faa108a8c5c7315d14edecc6b26b9280e2df56797c18a39847c911e58(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterMaintenancePolicyMaintenanceExclusion]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1912b39503a0bb65bd34adf07f1ef91eebf64e987eefee2ad4ff6058b41b1834(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__88246072852858dca0dc1f14f02d611d032264e9ecbc1e355a8794b0b963dfe2(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ContainerClusterMaintenancePolicyMaintenanceExclusion, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__67f0ad35f8a6f6fbc4acf00948024aa2e0a2a5a166981b5bf64d8590626caed9(
    value: typing.Optional[ContainerClusterMaintenancePolicy],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e3d103324de579b4e34d42ac2f8c90c56f97d541c3dee2e1fcecc2b581c22391(
    *,
    end_time: builtins.str,
    recurrence: builtins.str,
    start_time: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9db128fc349e0c249b18320aa00954d6ee982c0ddd52a0d68b0532b2622dfff6(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f84c24eba6534a419c9d20b0bb4ad808aae921eaa91e63469beb2ee98bc186ff(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0f3bb7aeec1cee371b184f50ed9bfc71c9713883f3e12d89710563d45833c353(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2384e075f15f9746b1abe48b35a8cd26bf49a466a22c26d39721e5b37cd4e93d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__591510413922d594441f7cba9d92c1485aa070ecdcb093af204c794c838d4355(
    value: typing.Optional[ContainerClusterMaintenancePolicyRecurringWindow],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__968fe97dd5834db895800250ef761af272f871bb557690f7dd131dcdc6517e95(
    *,
    client_certificate_config: typing.Union[ContainerClusterMasterAuthClientCertificateConfig, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d2161a6f2f26a1c4f286d9bb1b59387070bee814b44073b9c9a92c39a4128a61(
    *,
    issue_client_certificate: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9e149c6c9b87a481cab1680b6575aac108dccd98374d10f607383bd2a05398b9(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__daaabc6e99fd723a1eccdfbc94f1e90986d9414c112b10df622415e4310169e3(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fd4bfc5857afb5732ced1a0d66268dc78a8add8f3b5ca913ca633e697a189cc1(
    value: typing.Optional[ContainerClusterMasterAuthClientCertificateConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__016d715602ebc797c5c130863ab6295d589e26a1a79050e42aac509dc6ef431c(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__22c725bca29b2261fd094ce699f851a117ce80cd63cfe9a79de9be95bdbda136(
    value: typing.Optional[ContainerClusterMasterAuth],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__32f3ad8ce6e91df3db7d74e3463a91e10fb984b33b36d0c7080c67b6faa322bc(
    *,
    cidr_blocks: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ContainerClusterMasterAuthorizedNetworksConfigCidrBlocks, typing.Dict[builtins.str, typing.Any]]]]] = None,
    gcp_public_cidrs_access_enabled: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    private_endpoint_enforcement_enabled: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6f530592e6029be37494b2762be789c9cdb1933c3a1ae623d0912fdfa823bf77(
    *,
    cidr_block: builtins.str,
    display_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f0939365b520ae951104c295b4787984444f0f14a41ec618af91854e90be1afb(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dbf8407230043669fd46ae610e995897f6862babb21429d492ef85011eee2627(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1a71600061d2dfd54a519638376e16c5821119f9f9bef5d791d32a0c3d9c3452(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d64fc636eaeccca6794fdb4432e4c7122601de8d66a893c425c3f99689664c5f(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cf6e3b39b586f86a34c8a96aa7b2e8486fc3122567db58d8717016cee3e19770(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9b99774016051e3e7a23fb255ebd6f31071106728c404d103ceb5f344d773f8e(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterMasterAuthorizedNetworksConfigCidrBlocks]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__08c499c5ed3f1edfc969f398190bf2053cbaf8fdae4233f420976678ad0d200d(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ded229e793d9768fc768cc02886a0fe259ae335079e2bcf17ed34b437430cc57(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b633fd3f1667bef0e5e0b7a2c69159de8c03ecad2d27ae6ca9b849ec2de1e1c1(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__692d208b2fac89bb9b63cb01e4e418719861be04a0467054616c1c1a70abdba4(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterMasterAuthorizedNetworksConfigCidrBlocks]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__222a6a47e1902d37d8589ca25cae3f893f07f8023f4932cd12a0c6d49208b766(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7171fbe7f2297fb504b96290326e963f326ed86a700f19a187698f91c0224f91(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ContainerClusterMasterAuthorizedNetworksConfigCidrBlocks, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fa3ebdb87ccaeacac2717ca6311ae34c865874bf394033b3d3a7462d489c7c82(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6466b7b570f5d1db754dae8a755c69a2db111dba47118687031c47462eb7cde2(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2c5ce0e36b2047a6a2534918a355243edde20a442de3b0dd9a41790f9c07a5dc(
    value: typing.Optional[ContainerClusterMasterAuthorizedNetworksConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7437f2259f2fc7a0f3f0acec8a169ac131aeea3bdce3341755da2ada077ac18b(
    *,
    enable_certificates: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__318aa1e1a871b6abe5c54656c5590768596c12d1e9c10a24ddfb0642a8eb1916(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__530cb3a266a6cf0e0fd6e5fa13e10d00220f5db4192c707aa4774b25528c1096(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__67375068bcad5601fb6daef18245f06e1be8a8bd09939dec1bf6bfbd69fdaf4e(
    value: typing.Optional[ContainerClusterMeshCertificates],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d13e042cc0983ab440c8f25b5617c09f9dba19dd3a974a078ab8f066100b1a0e(
    *,
    advanced_datapath_observability_config: typing.Optional[typing.Union[ContainerClusterMonitoringConfigAdvancedDatapathObservabilityConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    enable_components: typing.Optional[typing.Sequence[builtins.str]] = None,
    managed_prometheus: typing.Optional[typing.Union[ContainerClusterMonitoringConfigManagedPrometheus, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__87236b98735081096d9dbd991112ea1fbecdd7f8d800e972639ef47c190c0f16(
    *,
    enable_metrics: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    enable_relay: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f120ad08aecbde74c7f30c6015fccf960d2022fd9b9542985a9dda8f93f203b0(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c35a065fc36701963a8bea5a7630a089be6cd4dc4689acc90d658162fb0f13eb(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__32e8248060a9d87747e21bb1f628a0d5fd55c1063116413ce86c6732899fd985(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4fc22ba6f17891a567fd0c98aee2be09d015172105e7c7df32b4d7c5912e7020(
    value: typing.Optional[ContainerClusterMonitoringConfigAdvancedDatapathObservabilityConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ce1ece3de3c33954c9ed5ebe2dec28b8787ad86fa496ecc450352c7460e5410a(
    *,
    enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    auto_monitoring_config: typing.Optional[typing.Union[ContainerClusterMonitoringConfigManagedPrometheusAutoMonitoringConfig, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cec1671713fc86719cb92f6e45257fd2029219f1f724630c46b3356f3b67838b(
    *,
    scope: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6ccab2cb0ecddad078c2daeb63496cef569b33636e936ba96c62a18ee8a5feb3(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6f2f548b779a87dea8e74b31a3b612c68a3f04383d728087eef9f28dadda5343(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__362faebf9d74569890520b389340e83f5bb972c6f861971394299a0cfddbf49d(
    value: typing.Optional[ContainerClusterMonitoringConfigManagedPrometheusAutoMonitoringConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2b8e2883bb04f0f48b3458f9b76e670994a149ccb4d26607d94a1afe593f033f(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__92637993d44b4b70057b82edf2624928e34501c97c501ec385d4e28fd7c06f19(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b98dd6537e46d32666df968dafb88bdc7a3d2d9c9b62ef4bfff68a46770df4a4(
    value: typing.Optional[ContainerClusterMonitoringConfigManagedPrometheus],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4917923504de9de8a2c649aaff32d40e4c2cfeb7d596ff88d9a2eb8f1c478f3f(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8b5c512cd5b80b0b74fc0a4f964035d88594dd2fa25390b165fb96c5c38809ec(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e34b5cb4937fbdb20e85ee3c1d157599e958264947856d8307872592245980bc(
    value: typing.Optional[ContainerClusterMonitoringConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__402e8d15351d6e3309ab425c11e318c87375f8258ef18a9a3b9bea6f82431baa(
    *,
    total_egress_bandwidth_tier: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0d02a6d2a9ec82fbd232f0d00926da6904804929be421eb492ce4d69391ff792(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9684012e2f91af8b004f7c340b9be5e974dce6dbac096836837c9f594291bae5(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__15d5402addb7dcc981ef855a71a63ccff319d1b647c301be9eaf3c6293da8117(
    value: typing.Optional[ContainerClusterNetworkPerformanceConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__774f983346304a3a8a094ee9aca160236945223a9f9b714fe1b50465882228f6(
    *,
    enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    provider: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__aae757873a58d74781d2c35e39f0983b428b327582f8a7dfad993d3824e01201(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f553923b01971069b14a7756e7e871e94a3058b5c432cc08222307bc5879d5df(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__98a6822dd3d51eaa91290a42b751fb1c54e01fd0e061e494800e6ac65a0c0089(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eda4e6dba835ba2f35b5cf8645181641d125f6b4ee46173eb1432f4e858dc807(
    value: typing.Optional[ContainerClusterNetworkPolicy],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__448963f7ee6542097477681f0898df77bb3ea4f85eee2dab7e70fbbef0d9b48d(
    *,
    advanced_machine_features: typing.Optional[typing.Union[ContainerClusterNodeConfigAdvancedMachineFeatures, typing.Dict[builtins.str, typing.Any]]] = None,
    boot_disk: typing.Optional[typing.Union[ContainerClusterNodeConfigBootDisk, typing.Dict[builtins.str, typing.Any]]] = None,
    boot_disk_kms_key: typing.Optional[builtins.str] = None,
    confidential_nodes: typing.Optional[typing.Union[ContainerClusterNodeConfigConfidentialNodes, typing.Dict[builtins.str, typing.Any]]] = None,
    containerd_config: typing.Optional[typing.Union[ContainerClusterNodeConfigContainerdConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    disk_size_gb: typing.Optional[jsii.Number] = None,
    disk_type: typing.Optional[builtins.str] = None,
    enable_confidential_storage: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    ephemeral_storage_local_ssd_config: typing.Optional[typing.Union[ContainerClusterNodeConfigEphemeralStorageLocalSsdConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    fast_socket: typing.Optional[typing.Union[ContainerClusterNodeConfigFastSocket, typing.Dict[builtins.str, typing.Any]]] = None,
    flex_start: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    gcfs_config: typing.Optional[typing.Union[ContainerClusterNodeConfigGcfsConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    guest_accelerator: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ContainerClusterNodeConfigGuestAccelerator, typing.Dict[builtins.str, typing.Any]]]]] = None,
    gvnic: typing.Optional[typing.Union[ContainerClusterNodeConfigGvnic, typing.Dict[builtins.str, typing.Any]]] = None,
    host_maintenance_policy: typing.Optional[typing.Union[ContainerClusterNodeConfigHostMaintenancePolicy, typing.Dict[builtins.str, typing.Any]]] = None,
    image_type: typing.Optional[builtins.str] = None,
    kubelet_config: typing.Optional[typing.Union[ContainerClusterNodeConfigKubeletConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    linux_node_config: typing.Optional[typing.Union[ContainerClusterNodeConfigLinuxNodeConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    local_nvme_ssd_block_config: typing.Optional[typing.Union[ContainerClusterNodeConfigLocalNvmeSsdBlockConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    local_ssd_count: typing.Optional[jsii.Number] = None,
    local_ssd_encryption_mode: typing.Optional[builtins.str] = None,
    logging_variant: typing.Optional[builtins.str] = None,
    machine_type: typing.Optional[builtins.str] = None,
    max_run_duration: typing.Optional[builtins.str] = None,
    metadata: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    min_cpu_platform: typing.Optional[builtins.str] = None,
    node_group: typing.Optional[builtins.str] = None,
    oauth_scopes: typing.Optional[typing.Sequence[builtins.str]] = None,
    preemptible: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    reservation_affinity: typing.Optional[typing.Union[ContainerClusterNodeConfigReservationAffinity, typing.Dict[builtins.str, typing.Any]]] = None,
    resource_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    resource_manager_tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    secondary_boot_disks: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ContainerClusterNodeConfigSecondaryBootDisks, typing.Dict[builtins.str, typing.Any]]]]] = None,
    service_account: typing.Optional[builtins.str] = None,
    shielded_instance_config: typing.Optional[typing.Union[ContainerClusterNodeConfigShieldedInstanceConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    sole_tenant_config: typing.Optional[typing.Union[ContainerClusterNodeConfigSoleTenantConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    spot: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    storage_pools: typing.Optional[typing.Sequence[builtins.str]] = None,
    tags: typing.Optional[typing.Sequence[builtins.str]] = None,
    taint: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ContainerClusterNodeConfigTaint, typing.Dict[builtins.str, typing.Any]]]]] = None,
    windows_node_config: typing.Optional[typing.Union[ContainerClusterNodeConfigWindowsNodeConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    workload_metadata_config: typing.Optional[typing.Union[ContainerClusterNodeConfigWorkloadMetadataConfig, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b4b9fab3d583cb2d6859161d5c136253a03433bb75ecb8f1fe4fefd2cacc08e5(
    *,
    threads_per_core: jsii.Number,
    enable_nested_virtualization: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    performance_monitoring_unit: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fff8d155dd304176ed92c24e2fa561227e24000d4ba84c3881b91edb10eddb6a(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4e70060c163923424bed68fda3352249979fc39dc714668da8387a765b73311a(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c2ad76ee4c483667bb90fbb1cc062d3b09d439587431bc4cd1ff74779c8c0e76(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2599dfad4ec6f1af825ff6081ae7d2e07c43d3772f547ff12a692ebcaeaeeb4b(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__559878f1e4afbe5663969887fd00ac4cad5db9862703b3fe9491d97c47bf1840(
    value: typing.Optional[ContainerClusterNodeConfigAdvancedMachineFeatures],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7141f77c0c271d0c8cc54f3a0120bd06a06d1ec82cbcd1927a46211ddb4523e9(
    *,
    disk_type: typing.Optional[builtins.str] = None,
    provisioned_iops: typing.Optional[jsii.Number] = None,
    provisioned_throughput: typing.Optional[jsii.Number] = None,
    size_gb: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1f6f884660facf73ca2682e67805c1405707416b9fb417abedba603133ca49ca(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5c09cfe1c3e1c352b6e988246472726d1990852008b43fc011683499930e464e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__086cf95d21544fa5b0180ecadde14df69dc2e73820fe1a10051b0353e5a370c5(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d023a53f339fb99586de0799a1ee55f972111338d95ae22dddcd8eea772aa0de(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e036b5ab0ce0596d7ea8ec15aeca9fb2fe32a17883ffc4935a0542ecc988710b(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__95935476cd5fd318b0d53790b2be11bad0842a8aefe3113616d7a748ebf8023b(
    value: typing.Optional[ContainerClusterNodeConfigBootDisk],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e3f8750c4dfbfe848a890a47f21a187ef1445b89095056b80325479e1a2cc9ab(
    *,
    enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    confidential_instance_type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eeac8d0082d3cd690faafbe349af6301d4c714bd4938713bc1fa044eb3c541ee(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a869db5e1b176d956bc7789899a660838c35dd1239ee47f752d39934f3d801b2(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b9ed030c28f9a927782b539ca2403f5672b34e4cf18de245052bd804f394a6ed(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a0b5c998c92e7a28de70fae80597b98cc61198b74ec686f428b27456b225bb9e(
    value: typing.Optional[ContainerClusterNodeConfigConfidentialNodes],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b5ee928e90d84c3d5b27f82015075351ee74f4aa464e1e2623ae00df808d37ef(
    *,
    private_registry_access_config: typing.Optional[typing.Union[ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfig, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__24d42bfba1550f89ffcef5b7e31ad15a9d5237847abb1c13bea7771406f6b8ed(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3bb1224503e91b778fb68d6d33787907edfc06824693a3d7b08a287b4d45cbab(
    value: typing.Optional[ContainerClusterNodeConfigContainerdConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7e20c9f011b832e7e1ad481ec9a61245e259038eeb6760d2aefb67072f58fe84(
    *,
    enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    certificate_authority_domain_config: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bccbf6b60b46aaf5a96a53815ab501ab0e095a5b88d5efcf6dfab440182ef720(
    *,
    fqdns: typing.Sequence[builtins.str],
    gcp_secret_manager_certificate_config: typing.Union[ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__06c49365d2a6050102c0210ab05c4d760992666502685184eacaa5f29f149fcc(
    *,
    secret_uri: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0ead7cf6abb82687479e7270a136eabd16f31e89c9ec8a7c797694ff0b1d8179(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8c5e06371ce58e2cedcd726fa052ccdfa07525f37ff93476c88ea2fb37c75759(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f22cd4efaceb95e24f5de3d47f2c39b90db3cbc2027cb57f483aad698643a21b(
    value: typing.Optional[ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__42f1295fda1535cc0a281ce8647441f6c2fe80cc35477eb4301e59acc8eeb48d(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__37f7463ea2f3ecfc9279f866401ac2ad252df5787ca28c530a94b307fe6b85c0(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__af4351325f6e61eb50b54d7dfba463391cb9579777e6726827b95e27e2717010(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c70075fff45e96275f277ae91d687708f732ac4c24c42c1feec12f32abc57d7e(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__512c1d8a029795ff02e123954fa662050d79732b6d48146e52389cceff9eefbf(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__66bcc4a504e792b164999bdf23b8f46dc3ef92b7a72705965ace55579ef3f638(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3ca79593c23a6c9da597526c8da600d074f1d182d7f0c13c61d5ad126a244f7d(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3257febb26623257e13da5e2552c4840979134e856c89b2b676eb53d057f1d0f(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__73b39f425b582a5de35ad8e8f91d04bf3594249efe50b2e786a3a3dbf7e9935d(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fa52a26fede32dc81a8247f97ae3f82cd9f178294d9f06290b6f999cf9a1a70d(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3e0e32ad0d8388f6d79c65f9f5593015b48b03c063c0d633c72a07a8efdd71d9(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c455c3d14b61cf2ec14b12b41d6bcb09abb4b6a9eb5ef73c927b005a23ec8a78(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c3386a8c32a64fb3d7feb4da5db21f7ddf246113959c13b61d7ea319460d24de(
    value: typing.Optional[ContainerClusterNodeConfigContainerdConfigPrivateRegistryAccessConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7ce61be4ea9c8146473d93b22cf340633828ef0a23f9a3420dadef8131471afe(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e3a907e6679801babdc867df7ff63e3b31559fe25af9b0d6d330c63ec0bca409(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c7e664f04690c2311a2f4e7b3e2b40a49ab4a3fdbd523090fec7584644f41119(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d6be0c41283bb87abbcefc3b73688259729ffe1bd5696d5687e208a19b11e05e(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a97d46de429c4bae18f9c53243ba1142cdaff75bfe7a4036fa0790a32c251fe0(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__64636821a0f073abbb4a41d3557ea335b79365f56e4c9d35bc97a654092d00b7(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6c8a4d07f071be7731dc5f7db11098247d163bdbb6b835c22a6a5e72bc09cd64(
    value: typing.Optional[ContainerClusterNodeConfigEffectiveTaints],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__642653687b84db2df0ec8d8969c9b0838171fe3f4a96b61892fd28ee41800c1e(
    *,
    local_ssd_count: jsii.Number,
    data_cache_count: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4eb45a7189179a5f7f0801c9d267f820e144871fefc0cbe1819a096a5f347863(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2f73a2f3c706b6062d9e7302856a45da7345027f52c7e8ef430baaad77a34668(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__26fb57418954f934c2c015697c4f3bd22c9c21d9a26a7a7adf963224dfc2847d(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__897aa1c34e6280c649200a31e2d6f57863bce059bed9386dc3b134e320f735e4(
    value: typing.Optional[ContainerClusterNodeConfigEphemeralStorageLocalSsdConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0e16c1035a1dabda9c3758d4e09d8359081a8209f933c4e612022e7cee381fd0(
    *,
    enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b1ab85979020fdc0a3d1987f0e8da79f5f60b3745bacd222aef2e5f2f0b38d96(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eb07f8d0c26212336fa8d7039625215b7829d6fe130984ff8177f397ab1eab50(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f68aa227aa87cc69385c805d57428701c0dcef3d5d60aa38b84fee1546e6faa7(
    value: typing.Optional[ContainerClusterNodeConfigFastSocket],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__82e3b98fab98b795ab54b2cff2d5fe2a7da2f7c206f9aa18991d4991c1abf3d0(
    *,
    enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__adbd6f965369f896a0d5fe9b3f404f1613074c0cdd11cdeb8aac972a877c2d7c(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2edc4cadef68c97f8381d4300eaac3a7dcfee943571fc58f21fa98279c72009a(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__386090f5e9dc7433bda89b01b20a0df79d3f20d1c9d0d6a1f1d71797e91ff3b8(
    value: typing.Optional[ContainerClusterNodeConfigGcfsConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4d74f983a9b48e00efdced93c0393cf39ab6c8022060081b2cf3c47696254a2c(
    *,
    count: jsii.Number,
    type: builtins.str,
    gpu_driver_installation_config: typing.Optional[typing.Union[ContainerClusterNodeConfigGuestAcceleratorGpuDriverInstallationConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    gpu_partition_size: typing.Optional[builtins.str] = None,
    gpu_sharing_config: typing.Optional[typing.Union[ContainerClusterNodeConfigGuestAcceleratorGpuSharingConfig, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2df323d390381c6b6268ab9f2153e8e6ce2849677b6fcabfbc98659b404b1fb2(
    *,
    gpu_driver_version: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__78954ede51a1fa83e49afaca8eecf02e13486c62f6d9f664ee32ba9408236d8d(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4d264d3f740a8d9587a061685f50820971beab1d6f4075fb04c7b8aad9bca199(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1c4b28a3d392fe97f254e277ac51c7479e311658bfd95c34320b91201cb17cf3(
    value: typing.Optional[ContainerClusterNodeConfigGuestAcceleratorGpuDriverInstallationConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__87cf09e4d1ccb984f1c5455697e19a1d886647d0a683338eb1e14808ce289204(
    *,
    gpu_sharing_strategy: builtins.str,
    max_shared_clients_per_gpu: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1f8a936dccd31db2ee19977734177a99ce9efaf270f2cbeeb6bd81c2de328e3b(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__14a4f64375f531672fc191f4c72c39ce7cc5d7f78ccc36fb88825a05480ddf30(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d0944c979fd7875197d6620ef0477e09ac1a7dacf334510729ff171410ccf33f(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__89b6788d95869424b78920384e645ce5ef5af4c5ddc16e25f1ce4274088985b2(
    value: typing.Optional[ContainerClusterNodeConfigGuestAcceleratorGpuSharingConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d46bcd252915de788b4ecb45e3f6fc276b6cf510a7bb220976e6a7d81e480b18(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c450c930867714c6f6d1395a172679fc787f89f476267b927da61f8af5028710(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a289a84d8300cd82c404ae298f07fa9995b7bb722e311cce2cf6f26ca1f3cb04(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__599691efd702ac1970da501a314f22cefa727c6929b48d5ebb67047c34180811(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__51f4148153bdbdf23e75f2f6c0100b327d1f99c027bd81b7fbbeef58b27f6281(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7096b004b371090d792fe7c7c8b85acb50d4c581baf4e2f8bab9aa752fa77043(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodeConfigGuestAccelerator]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f4e063e8d365cefbd3ecdef3edd3ee6ed4b346970ac9241a0acc7793378e85e1(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a8b4521525ac49b57da0d456a4a85798caacf728fed41cfcf13961ea119e48ce(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__06d64f51ee642e5976a75802b5540fcdc0e499d0a281b87ff9f1c73c25f18334(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2e7eabb2f3efe6c846d092b0d6cf1addfc1379cfc0cdcf324035bc7147658d77(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__10d6c706587cf7dad2ba53766c06efd0999bd38cd1219e9d7ef40c23ec7ee843(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterNodeConfigGuestAccelerator]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__464e26794c2fdf7db27634920718bdc70d328c14f168ea7fbdcbf758548f94c7(
    *,
    enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f0a347c3f0d14d5c7858821ba6d9f37f37d6a322000bee7dc384192d09ab7f37(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c5455f61e7443bfc8b15fbbc222698fe368978f00c50f6a58568f4859af7a3ca(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3bc0f505dff146c71be8b8b445e32be0ab5c98d0387f77447d1816b024a3b3a3(
    value: typing.Optional[ContainerClusterNodeConfigGvnic],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a153ee3f964117eed4f6b82a731a7cedbfd57a6ac793c4a65e862f07faacfa38(
    *,
    maintenance_interval: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eacf1b9a1cbc681aaa054f3af56af346ab52f44d742d96286ecba6f5e90a9cb1(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3a731e849dfb5240546794aa47d574ba867d92480b8acd3add76eb084b2ec1f3(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__73ff82385ef19c5c0d0f57c2d10a0f0de354bf0de65a1ead4828d9c6d9eed63d(
    value: typing.Optional[ContainerClusterNodeConfigHostMaintenancePolicy],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__625b0c1d1df47f851a31e29b959b6754d9d8ce0c66a19020772a658913cb425d(
    *,
    allowed_unsafe_sysctls: typing.Optional[typing.Sequence[builtins.str]] = None,
    container_log_max_files: typing.Optional[jsii.Number] = None,
    container_log_max_size: typing.Optional[builtins.str] = None,
    cpu_cfs_quota: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    cpu_cfs_quota_period: typing.Optional[builtins.str] = None,
    cpu_manager_policy: typing.Optional[builtins.str] = None,
    eviction_max_pod_grace_period_seconds: typing.Optional[jsii.Number] = None,
    eviction_minimum_reclaim: typing.Optional[typing.Union[ContainerClusterNodeConfigKubeletConfigEvictionMinimumReclaim, typing.Dict[builtins.str, typing.Any]]] = None,
    eviction_soft: typing.Optional[typing.Union[ContainerClusterNodeConfigKubeletConfigEvictionSoft, typing.Dict[builtins.str, typing.Any]]] = None,
    eviction_soft_grace_period: typing.Optional[typing.Union[ContainerClusterNodeConfigKubeletConfigEvictionSoftGracePeriod, typing.Dict[builtins.str, typing.Any]]] = None,
    image_gc_high_threshold_percent: typing.Optional[jsii.Number] = None,
    image_gc_low_threshold_percent: typing.Optional[jsii.Number] = None,
    image_maximum_gc_age: typing.Optional[builtins.str] = None,
    image_minimum_gc_age: typing.Optional[builtins.str] = None,
    insecure_kubelet_readonly_port_enabled: typing.Optional[builtins.str] = None,
    max_parallel_image_pulls: typing.Optional[jsii.Number] = None,
    pod_pids_limit: typing.Optional[jsii.Number] = None,
    single_process_oom_kill: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c73bad66a39b4cb7a5c359d34713f07bdf549da7c7c3b5d6bb639f55f445930d(
    *,
    imagefs_available: typing.Optional[builtins.str] = None,
    imagefs_inodes_free: typing.Optional[builtins.str] = None,
    memory_available: typing.Optional[builtins.str] = None,
    nodefs_available: typing.Optional[builtins.str] = None,
    nodefs_inodes_free: typing.Optional[builtins.str] = None,
    pid_available: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cf264ca1910c7e7589ddc8aaacbf0371f98c5d68a49e8dd56c6569d96e9b16a7(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f53e19e8922be6d502c87fc10dc61199e7f002730e93dd22e05610f1557ae185(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__809dc2098ce506ca1d5cbf766b67cbea304d56328c428a87e2fbecaa17310331(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1fb47be92be3331f1ab4075d563b6135121f19a97b9a6ebf1fbaf00ec04b07b8(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bd7553bafd581eaf204d4f4042df8b94ba5ae2da63905459dca0db9f82f4e39c(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f457a525b79e805d8aeb6b47775e669b0903557fc634c7bafad7004628b03174(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b574672b807a9f2d0efe3b19b3a29f29bf8397990ab2283461aa37dc275a3c06(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__14ec39835952c81639992a0a8488587f14aa1d73ed2f43c9c797e1a9c834d1cd(
    value: typing.Optional[ContainerClusterNodeConfigKubeletConfigEvictionMinimumReclaim],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1bfcb35216cd72e322de0d2d71a5c72acfc82832a8b8fc82e9e07c243711d116(
    *,
    imagefs_available: typing.Optional[builtins.str] = None,
    imagefs_inodes_free: typing.Optional[builtins.str] = None,
    memory_available: typing.Optional[builtins.str] = None,
    nodefs_available: typing.Optional[builtins.str] = None,
    nodefs_inodes_free: typing.Optional[builtins.str] = None,
    pid_available: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__030e126bb6a8b727606f7a22ae08ae48b42bac28512c47cbc888f538fb74bbd0(
    *,
    imagefs_available: typing.Optional[builtins.str] = None,
    imagefs_inodes_free: typing.Optional[builtins.str] = None,
    memory_available: typing.Optional[builtins.str] = None,
    nodefs_available: typing.Optional[builtins.str] = None,
    nodefs_inodes_free: typing.Optional[builtins.str] = None,
    pid_available: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b381415903e8aed0fed95be522c3118a90b03f1eee93a214ffa2e95aebb91528(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__551f1922a30ad2fb0b8edbeca0276296171d4c6bc87deccf9dba222023f3fb27(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__aad375cfb885fe4120a36041f7db62bbc7b2d4eceb91fcc38de6966511f502af(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e05d1c99ccb8e130a31527bcc5c9a3c8328cd2b0945d25fedd3b9c73c5a22744(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b39c0a46fa7d18b91cca69de5ced39e90c98167bcc4909f09b0794915777d445(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bf4aa701cd2972fbd0284f688cdd03cc2479b5583276444d04a829e918ee0688(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1e83bf840646f5c55f8d179226f4156b4ca089354cb0f68ea29ce5bc2ac928cc(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__428dd79079927869c58a39526b67639dc48df81e7a035d1902ef0d6f38248c72(
    value: typing.Optional[ContainerClusterNodeConfigKubeletConfigEvictionSoftGracePeriod],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8f8d01cfc653296c3bdd853424679914abb8a6a60ad1332ba3e884a1c2985461(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9f2ee4ae9fda05d326d8ff0d52713855540203019ed803e81ba0af5eb2c7e471(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c7088fb2b7229694486ea25871c4ee121a4694444bb73739ffc87fc03059ce99(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ba3d9c3b5ec07eca6754dca9ec89f71819381c0c09472504a63db5a667846226(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1c0c0641ca30ca2e9b6cece132635bfbcc18892cfe23d7bbb72aad512b73e388(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4b62554c895e318bb0b3e02a79d84d418d8aa46d90e8ac6e7dbfcf4edeecc48c(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8f36f4a370c15f64bb88b9dab06c3846191dbbba436f80a25adb09e9b47cb25a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__31c04b4ea9d62a81a8b371f102556e9f8fbf583efec88ff9a81eb06360721bd3(
    value: typing.Optional[ContainerClusterNodeConfigKubeletConfigEvictionSoft],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c577999341f4102ca553014b2adc85c8acbbfdb7a92248d87bcf04d85672dc8d(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__56d17e0fbf9299224aad19af67c2fb227762a92c673cb3f470508db363a431eb(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__04c7c4cd7e253eec2b93767920006f955d77ff9de7c63e29a4de7c25c0a36d75(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__120f354152198caf726f10c779f18b0cd59188206840075a6a5dfe9046e1bc0b(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1c20bde77f030d4af9282b53ab42a20a06654698f204d2a4b3dced71d1f2a8b2(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0e9e1a26c2467648706d35292d5464e74c73866f5c012d5f1f7f5f7ad051da5f(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2e384d698ce3ccc0faec262f20df56b6d11d670df2a160ed6fefb03668aca7b5(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7a277a871af2618e0492b5efd490247007e188df92fa32002f37953bb1f805dc(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dd4d2def7d7aafbf275a4402d6914dfca8c7bc8942b89f07ab9b5d0b118c4eec(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3b958724edeab4d5c9ee6121f0279ea631581468ab500893707b06cd51e3d4e3(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bb1ca122bc6030895804f07902e156a8644f3c64a944457ae9366e3c1dc3eeb9(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ca9765dc5fe46066f56ef2dcd972869c7ae113ac15460fedf6682af83cf9711d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cc0f620dcd3ee56a9683e207b6b27ee66b04abd55ae173ae773daa535091eace(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8c03aed89ee35179c62e022f11ed197c39b2a3656ef8cadb4be31b7a844e4b8c(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bc06092394a13b232d6de044022412b151b6dd260cc85194d84799d034253c5d(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a8423057fe52abf644d9cd6072a513c1159d0df86b19202824e6f6105dab6766(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cdbca4b36a12086580d30b5da0314b12b3021ca6e9402b9a975d6ede0d31a092(
    value: typing.Optional[ContainerClusterNodeConfigKubeletConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7531f4ed33feb764dd52c8c2bff8672f6117ed9f35387b95fc69f77f6bc716e6(
    *,
    cgroup_mode: typing.Optional[builtins.str] = None,
    hugepages_config: typing.Optional[typing.Union[ContainerClusterNodeConfigLinuxNodeConfigHugepagesConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    sysctls: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    transparent_hugepage_defrag: typing.Optional[builtins.str] = None,
    transparent_hugepage_enabled: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cf6052ff0ddab3720dc422a178af64e70a0317665ec2f83fc97d21f80c3eadaf(
    *,
    hugepage_size1_g: typing.Optional[jsii.Number] = None,
    hugepage_size2_m: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6f588651ce9dfbaa19c145543b06f8265e82a9f33e1fbdc10df0495faf5d56d4(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b23a1d2f6f4c5518b54dc502ae0457ba2c4bc13311e31ec2e413d4fc2280b4f0(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e62b1a4a16db1dd9492ac5f0e6da33c14ff09b7733b3ef96c0638cb1daf6e3d7(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5833360597da091c5b75f29e93ae2319dc022a18b85d3a6e7dcf361bf6d465fa(
    value: typing.Optional[ContainerClusterNodeConfigLinuxNodeConfigHugepagesConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8bc5e812915c00ea7dff61ace7daf546fa1ddd0a5bc5e114de835d1ef2b6bcd8(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7f2c260107460b2bd5996d575d13b65b3a7af8710eb5c42659baa6075700fea2(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c1fc897ee88b66f4acfde811e413dbaa380e52fe38bda4472e7449f54d22f719(
    value: typing.Mapping[builtins.str, builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__997f761644d5b527e5feb043443ae42984a61a5c3a939baa60e848d05997ae51(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2597a37a56d639610a5e256b25ba5aef45d84ab31cf0ad0a5110f274ed0bd8b2(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__509c25824318351a2e9b168d6bdda9056dcfebdf1ea308945db7dee5b96b3c09(
    value: typing.Optional[ContainerClusterNodeConfigLinuxNodeConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ab03526e0d5c9c90af4813520aa351057d3edd21bd7c09a4dc33cc035455cba8(
    *,
    local_ssd_count: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0f348db9ce559b17adad46d2836730781d01741161e25f1d4f54b294bfa6e198(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__091af90821921e1113006b6b4d6af161b17405c3f6564a9c40a18cc135d8c766(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__978de684bdfcc6de9bcf9ed92fbba73b4e2da66f1b06a1139b0c9948e9289923(
    value: typing.Optional[ContainerClusterNodeConfigLocalNvmeSsdBlockConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__aed119682c2c6721dd6cba0d1f00874749c3adcdd9defdafeb691cbce36aa8b3(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a569e4de6fb926f17fc931735d77034f840e5cf13cce43d1ee352f8fc6ad2c9e(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ContainerClusterNodeConfigGuestAccelerator, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0a1f64505b9e4d775ec3fef35f6988a357b31c0dd4ad4627fae22854cd6ca117(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ContainerClusterNodeConfigSecondaryBootDisks, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3af481c7002ae14a5fb9cd46bca70bdd00e64139605db4c6458c10194b5620cd(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ContainerClusterNodeConfigTaint, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7aadcbd0e1eae74284144863afa22ddd01bbb4ae849f667e084d378ecbca6287(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__902b89b0ba307eb1ae13313ae034505380bdfcae406bd97b71d8ef76fe5a2fdc(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b91aa25f4cc5133f88f9a6dd89b1e7e69fa7d6e897f53ef2249353bbb9ce807b(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f770e77b42ffd94433f13c9ca3bc08a6da0e74ba18e011d0c1e7c3b016848007(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4172ebe562c55dc973d275faf3368c35af5ee9ca21ca5983ce1e1ea8857a0faa(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5473d4fcc0144b62c7905cb542919b103d166f386a585abd86d31ab08eb44672(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bbbe1075adcffa367f536c02e75d8313de3898bfeb81db09df6c37497cd72714(
    value: typing.Mapping[builtins.str, builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c11d2b83c2df2d5c21db17ed28050741b50633644ba70a6b543742a03e06f655(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fafc84ed7ce3566d4d418b6bc28af5f802ef6480a11249d9541552d0cb49ff57(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__49935e656ddf1abffa71f3b38ca7dca5cd0a1b10c2ba12abacaba42596e603a2(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8e528d4670f62f2b98f05a3890a10f1ed9cde20a72bbce442cf9796e0800c112(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fee9813a0bc25c2422ab1f856759fcfafcb9115150cfb32d3754881fda81bbde(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__238fb38036f61ab19ad7f0c24360b163d466fa4fb27f176e1830ca477e429be5(
    value: typing.Mapping[builtins.str, builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__053f91a4d1139f7763eeadecec17c3e5c96796a64bcf9d7016de66a2a43d61bd(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b054514b429441430ebece8ba25f50cc16732b730e00b69dcdbf74c8a83d4198(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b3a5f9936ca7493bc8f0d81cd642ce28074d9005e8427f31b520ab17381c9198(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9ab3c75f93a1cc0b8bff629c33dc555bfa274b424684c1725bea73bd9029604f(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__23c4d340767c1f9049c758967a691bbeed23cff88d33e200d5f7b0a50c283d16(
    value: typing.Mapping[builtins.str, builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a292848329377f17e7ef4a46918da7bbf0c71784db1c24d93e4aa9f764acd0af(
    value: typing.Mapping[builtins.str, builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6464401e4091b304b9b1edbbd95f9ea083bc84a6f80866911723871ce1d8c343(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3ee2ff4cea3fb33bc3fd97dc25b3ef795020747413f15750d3c874b745c640dc(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__19a9fd589bbe4cb6b3aea246bf4e96e838e3fd0a9a93ff0546d7bd95320973e4(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c9dd150b1ef477d41820dc47a6a8d3ddc0773271ab436a315daac45f6e60242e(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1b1ab86b937be40f548f40501a7fe5a1702d9dc67db3b100aaeca08f74c61441(
    value: typing.Optional[ContainerClusterNodeConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2b159929b6a46ec40a6772744b1a05be469844fb554a37470af4f2f100839b25(
    *,
    consume_reservation_type: builtins.str,
    key: typing.Optional[builtins.str] = None,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8dcd82b50f84a89303c398a3bd770f38e0ecf1c460b930e1963d5a8c0dda7048(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__552ce2a78e4bd785c4835ac58078dd969540a8b0edb6531e30fd1a34e41536f6(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cfee46f05db71983ce3a25855dfc004efef21e93f2af795784a561d0637ca7a3(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6285b7629db787bf89e5b2cb668a82bfa42c2a68a14f1ffd6daa83ef148edc36(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3f9c7793852a4c95ffc2424da3891803905c3e08cec871360d412780b572c168(
    value: typing.Optional[ContainerClusterNodeConfigReservationAffinity],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eeb65a098b9939ce77cad2b6a9f3e814ab57dc2ad2a3f4c0a28e47af0233d99f(
    *,
    disk_image: builtins.str,
    mode: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d246edf8d450fc2ccd163072aa85b22fa8694194c87b66b404fd4c188ab4d6ca(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f7eeb58c4d09585d0dacdfbd60c5d91d5ba0b74275f40cf34047071ffb08a719(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__08984c164ac1a1fe60bd2b3c8166f1f69c8b4c73a0ae3924abf657019cea7e7c(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__07600f8878201d3afe820caa7490e08d31d1a45d2a9c2d188094441f4e0eaf66(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3831df75970018ca3fff8899d3d2b5237a8acba3931b2ba195a83dd65f45d1cc(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d19fce76459ae4049e2c4526b899e2cfa0fd636a3e9f545437afc3be0601ee35(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodeConfigSecondaryBootDisks]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__adb93e0bf60c711428c496f43f4de7de80a4224f286dc5652b081679e35ba9a6(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d2e1e56c5c6166f31f7baa31b09707da8bb96c9d192cc1a6131a7b6a4afbc028(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c7327be35de166e65138394f3b87a7abf9bc159b7de4084265ace15641129315(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__40becdc4e8ad52883bb68cf348e3e91add57f9288019471ded6fcd4518b4fd88(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterNodeConfigSecondaryBootDisks]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1939af5159de8ec74ec2f7bcf4dd4a3ca860811444a44881a1a2a00942c426a0(
    *,
    enable_integrity_monitoring: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    enable_secure_boot: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5b7e5f88c08fde5d8472c3ad77ac45902fba225f2cad9e533ef7620eb7bbc9fd(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f79fa257f06df23c93aac74e319a6ab08a62999b0ea2802ed7591d774b4bd76c(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6ab8086056a1584d7f9740fcf602e5037d9daaaffbb06cfb9017f9ddfbcbb847(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ac7609ebc33cc70392605c449d63b40d2e611489733bc08473c25cad76594bb3(
    value: typing.Optional[ContainerClusterNodeConfigShieldedInstanceConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9d46f04489e657674b299b88cccffacba5b587a25bc013ac2a28423bedff0543(
    *,
    node_affinity: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ContainerClusterNodeConfigSoleTenantConfigNodeAffinity, typing.Dict[builtins.str, typing.Any]]]],
    min_node_cpus: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eb39204df1f0b38fff5d868a80b803c58b35b60b9a8e401b2e3bebe0b246652f(
    *,
    key: builtins.str,
    operator: builtins.str,
    values: typing.Sequence[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__88793ee8772bb13ddf9ba9d3cde0b8d9e45d36048092ffea2b9012b00cec85ad(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__998f989ccfb63ee01ed009f811818a3d25e7e506892e6fa4ce69286c4e4e20b2(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b13008489349c17c651aeb60a7e1a2993adfa1fc7f2e940518047965ba980721(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ec9ed8718fc32e6bc5a24dabe30a60b62d1283213e5d69a0a8fcb38fd56c3c4e(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c83d17e9b737c16e78388d28111c687dace79d7f965aa372e17ed0c1d3e2e8b7(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2f7f93a8e2be839686d6b78abb0263289980780078232941dd93cda019304c76(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodeConfigSoleTenantConfigNodeAffinity]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c59d1be2ef86d19cee75decae60d524fd779f9ee5145e05aa8e6587cc66bf6ee(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e47955c5f141cc8b1e8067f8939280c2088e0a7b1fa21c236037d9b54f954444(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7bda5bbb5c24b256f24f8b757e84e4cc0138cf65d3cf9578020c6b8610276381(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c39fdf46653306b5935b6eaaf75b5a1fb9a22e70f950dad0681bdadb18e77652(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7d18a1c37cd60cad69fbc6f9d3c795564f6add823180d0b06029812afa7c24b6(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterNodeConfigSoleTenantConfigNodeAffinity]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e4471675c4b11e0f5eb9d0a2185b17e7bfb0cebdeda845e50c95a81e2d85485f(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fbd827427e0fd657833f7cc0158552406355f146f2a418caf867bf9623e10082(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ContainerClusterNodeConfigSoleTenantConfigNodeAffinity, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bad92ad455935e346fbac3c01120f4022792f3e8c6e6ac0c16cbb71b70c555cc(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__70d932fb54de98b6ac4eee0ec9ec92235900a66433c7832b3fc9650cca12388c(
    value: typing.Optional[ContainerClusterNodeConfigSoleTenantConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1502a0e3f6b7944d2d306818e5acd3872bd53685ed5cc1f16ce88d53cd22e22a(
    *,
    effect: builtins.str,
    key: builtins.str,
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e99f3f5a27f018687d76f03a8c538540c866d93c3bd30c0219156ae0e96f7547(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c8825da9a476761a1f02c47f6bef1d56ac7bb760d24b468a021a2cc6d332a68a(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9cefee5938f456863ed4b650449352c7f02e3c02d70bfd55811b8f1c5f6fa95d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__36d2bd31d11d257c28f83ccd11ad0d557189ed49c3ae16452c338ab62b57c9a4(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__08358079eb6cecfd12b5b0d21745e3f680cc842d90401ffcb973f19ed01781e3(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__014560ff434c1000a8b54315b378327b0ec58abec23edb46117f9c32cc2733df(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodeConfigTaint]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3fbce8286c49cc63e4cc56b43d60820241aef8b7f5039975d3497a607e1b0b8c(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__714ff64aee441978553f481e535360824fa8770d94536219445d767f8b2234de(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1a7b4b110122027fd35cdcbdfeef492c9fe1fac8471e28cd276f0064e17111e1(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__62da9da7243510893849be8f2311beaa87d2676148d2a41f501747238e681603(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ff200b0dffce35c1d4cef18bf8b343e388d1eb8211370b67da77ed298e1ae160(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterNodeConfigTaint]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__49f0256a1e5ea7870d61eed8e8ba06146f38b7b42161212f1ba4944bd7cb7938(
    *,
    osversion: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cce9a81b9e017ff4d67515629c76dbe01007ee2f2fdf7e76251c252fec9b4042(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__464fda9f6805221bff22d4d8c9e1199976dc033d23b21ada7112f114fbd120b0(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3878bea5fffb612d0269c88eec29920651dd03823e2e10302b9d68b651640137(
    value: typing.Optional[ContainerClusterNodeConfigWindowsNodeConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c8530768049758423cb79adabf875a9de8ca2948255cbf1713937501768fae48(
    *,
    mode: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0fc265104e4173e5e86df159e0a4c402d5f4200bb4ff1e86154497e24a0bd674(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0ce1a446de20b6793901cb424644c3de656a1a35b41d1a1eaac393dd7e7939c8(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__32104ad2e354610e9096164ee05f6a4b4bb1436d46134247b3f595cdf52175ae(
    value: typing.Optional[ContainerClusterNodeConfigWorkloadMetadataConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ac0abc9503d9dd4de16d9e29878b6835e86cdd611755f67114409b71d11c3a29(
    *,
    autoscaling: typing.Optional[typing.Union[ContainerClusterNodePoolAutoscaling, typing.Dict[builtins.str, typing.Any]]] = None,
    initial_node_count: typing.Optional[jsii.Number] = None,
    management: typing.Optional[typing.Union[ContainerClusterNodePoolManagement, typing.Dict[builtins.str, typing.Any]]] = None,
    max_pods_per_node: typing.Optional[jsii.Number] = None,
    name: typing.Optional[builtins.str] = None,
    name_prefix: typing.Optional[builtins.str] = None,
    network_config: typing.Optional[typing.Union[ContainerClusterNodePoolNetworkConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    node_config: typing.Optional[typing.Union[ContainerClusterNodePoolNodeConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    node_count: typing.Optional[jsii.Number] = None,
    node_locations: typing.Optional[typing.Sequence[builtins.str]] = None,
    placement_policy: typing.Optional[typing.Union[ContainerClusterNodePoolPlacementPolicy, typing.Dict[builtins.str, typing.Any]]] = None,
    queued_provisioning: typing.Optional[typing.Union[ContainerClusterNodePoolQueuedProvisioning, typing.Dict[builtins.str, typing.Any]]] = None,
    upgrade_settings: typing.Optional[typing.Union[ContainerClusterNodePoolUpgradeSettings, typing.Dict[builtins.str, typing.Any]]] = None,
    version: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ed97fff1dc5c2a9cd7ab4f45c50c6e1f30f655150f9c626a370141c0dd644457(
    *,
    linux_node_config: typing.Optional[typing.Union[ContainerClusterNodePoolAutoConfigLinuxNodeConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    network_tags: typing.Optional[typing.Union[ContainerClusterNodePoolAutoConfigNetworkTags, typing.Dict[builtins.str, typing.Any]]] = None,
    node_kubelet_config: typing.Optional[typing.Union[ContainerClusterNodePoolAutoConfigNodeKubeletConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    resource_manager_tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c2019df13f292afeac713d4e0f7cc1b20db4c51a041bba85fb155a8ca12e1ba0(
    *,
    cgroup_mode: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__10b507380b603e9efa6f025deb781442591ef0ac4fa13d8f77523e08d5efdd6c(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0d55989bdef4957158cde7e6b4fd5da160e2e9654bc760d5bc5f1c5faba21dce(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__37c4226072b4ff5fa83a52e674ec2d52f0b969f4df700328c82583da05518ae2(
    value: typing.Optional[ContainerClusterNodePoolAutoConfigLinuxNodeConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1f91e39fecaccabbac30da81a7751b53a982d736ed9e8f543a9a3ae0b5d9fe30(
    *,
    tags: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4f9a5d966d5888a9e8f52129c163ae981d3e2e8b9755e33d3ab92967c0855487(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c990b4c44658b9bc69a79fff249b7e44709dc4835b8c3638040f50b22c124a77(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8e8d420710dc6dbb5b9163dfc6a3c214c0fea74f34be51a5cafb5159795d1239(
    value: typing.Optional[ContainerClusterNodePoolAutoConfigNetworkTags],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__049ed898d76843ef0656eb81b6070ab23633ec3906eb48c8455a851f79d47706(
    *,
    insecure_kubelet_readonly_port_enabled: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ce829216439ae0147fe4085e1c06d8b30b1605ac8a324ee1421b1f9b27354fef(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bb531503f3dc8c4dd5ca8719f1b2b9df92e0b53a76d4fba81b48a7b7637f773a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f622ed1fa4cdf706fb21261c99b892e2e7d8199f41249d28bd97086b233dc83f(
    value: typing.Optional[ContainerClusterNodePoolAutoConfigNodeKubeletConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__081c6d11867fe647a5b4a67f98f7aa4708873abd8c5eee49801f7afcde017b0f(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__333cefb4115d05689c2cf708ab2c55d92f46412237ac28dc843f36690430f5f5(
    value: typing.Mapping[builtins.str, builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__149f3c7b3c8d7fd7d16667d9153aa0f34d42864379310e2fd6b7a1091a50368b(
    value: typing.Optional[ContainerClusterNodePoolAutoConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f37e6afeb20e35ed90359571195810a7457d804ab67055e18827e76ffcb9531a(
    *,
    location_policy: typing.Optional[builtins.str] = None,
    max_node_count: typing.Optional[jsii.Number] = None,
    min_node_count: typing.Optional[jsii.Number] = None,
    total_max_node_count: typing.Optional[jsii.Number] = None,
    total_min_node_count: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__43b54b0a5864c7a4d43781465a0d61ffe6614e577636517ad1a08acf3c9b0db2(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cb90c3496cf19b2f4130a6854f3e9d1d9b87f8e5fb13a96c40082d4949797605(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4e759f3aebbe36d5de18f11d16b19bb947f3f7dcad9354f3d146da1302d5805b(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e4eef3a0241b3a030c335197d11ca760626150c67a070231401d27c90af8662d(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c10a9181e0350c8f5871ddf3b85b47b63e567914b4ef5e5327b0189440f10041(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6ecc419e04e5f07c79228f9cd5f26b84461fb5a5f5ef9752c31209c6dab668f5(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ff6c7c4dec5523a1a5fb740282bc2294ee560c4ad20f7c969f9cc7e69f61dcb0(
    value: typing.Optional[ContainerClusterNodePoolAutoscaling],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d290ee536ba1a19948d2d50116bb6629465ed34f3a96ed675f4327abdcce9784(
    *,
    node_config_defaults: typing.Optional[typing.Union[ContainerClusterNodePoolDefaultsNodeConfigDefaults, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d58e2c7bbd3d3cfcca11f1b397643a730777de7884845c92a128c97ddfb60ce5(
    *,
    containerd_config: typing.Optional[typing.Union[ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    gcfs_config: typing.Optional[typing.Union[ContainerClusterNodePoolDefaultsNodeConfigDefaultsGcfsConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    insecure_kubelet_readonly_port_enabled: typing.Optional[builtins.str] = None,
    logging_variant: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b989e3891af65bae8ad9453a554ac52b6e785c7bec0cbbfff4bba57abce8cc4e(
    *,
    private_registry_access_config: typing.Optional[typing.Union[ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3cb924ff2dcf327b370c72919c11f9b6be994ba124f3ba68f6dec8620b347017(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1dcd3ba82b2f3ecf12d4620e55c05ac7a24219e66c803acb44cb936562823bf7(
    value: typing.Optional[ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d6321c2be34b42b86ec19ab683b893ed05c454011bbf82e400e4a54f1e9a910f(
    *,
    enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    certificate_authority_domain_config: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d13af45f5a7d0b0c7e7603efec819600693120b0de961e7787f21ad656701977(
    *,
    fqdns: typing.Sequence[builtins.str],
    gcp_secret_manager_certificate_config: typing.Union[ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4cd790fbcdec4b31a75644d57773de15d21fa2adaf143bcddc8873836224ed98(
    *,
    secret_uri: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4d36e9b0d95ba519df827eb853736505443d87fbfc7937e71cf1d7806676a0f9(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__91ebef9f13e5e588e5c7957fee7dcbd5e73a8278dc65625100ca0f359f16d249(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__69ca128b9e40a37f82ecac5ecc4f50631527de32abada1e6579dd81105027c7d(
    value: typing.Optional[ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8d477408ff2cf424705ba535cfea7ea693446ee866ccff887194b5d24390fead(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__99cfe49e8f7301c6ebd7e6552f705036b037f2f8877d1791011a853434ee4434(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__097f14ddf58da021d2f2c8d292230cf8e4b8ad3529f9c805146c85a856db660e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__064c93bbc4307092c3a9a2814038a115119bb5fccefd5ae4316b751cda62b567(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1eb5c4475bdb470a796c8fde539b21dc3da9099c632c3de5920176fa77d68000(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9acad653bb4be3cb23b6091153ccd689ac022b6958c9b4f030383dbead0de3c5(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ff4774d57b4c7c09ebea7d1c36104a11156de852a3ca70b110acc4ee4b60902a(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ea545da6d4e37564557204446dc57231d4cf2b103a7fa1dcc119c62aa08bf3ee(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__536674119c31732d4f1f563048656ff508bf7b8ac8e7d51770fd9aca7e3c0b1c(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3115df67b02ac5081ecfe44b6b1ed05ff6a89f0519959155655df2703f8aba13(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ac86bd951e738bf283d14c9a6ad649246e87e6913f5fd693d11271d8bfbde454(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bc13bef8cbf97aa033e9326d554c397a18b5efa73f0c4a4396685618105a0ab5(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__aafdf67ef89d660e52bebc63601e46f312701627d5d8501e426d4ee33a0349d7(
    value: typing.Optional[ContainerClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ab1bb5c11879af027445e40afc406158813fca3bbf93c537e2a624c43a64ab98(
    *,
    enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__87842d9a22f82f97923702b36a69165f5b4481611b0683d68f44178f35dda1d9(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__82a37d764dfed7807565002948c0e9baa0d261a34c5f201b2272e73fd1cd0072(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b14d570e69b1235b6bb0be3c2c5cde218419c7ca7da1e06c93b67e4a03bf9312(
    value: typing.Optional[ContainerClusterNodePoolDefaultsNodeConfigDefaultsGcfsConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d03d924502e31c0eed1cddad4efa9a56e9c5ae67415d3b5c6996ecf24b7b82f4(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b46cf63eb75aab98ecd7a3a900530fa03f703e0eff7abda2af6c84f41e554503(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__13848a47360611359e6427dae3a499e245dbce3073920716160d3169933e3dca(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__54613196202259694905bcf8379245aeabdbe98165dac257f94b91e659fe5f84(
    value: typing.Optional[ContainerClusterNodePoolDefaultsNodeConfigDefaults],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__20ccf7ebea6606a82f40a613ac80caf61fd44d211e618721abe728bc44f44105(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3b7d04e62fe56713e712488a769fb8c7e8ff15d1ecf43ca8e5969778a573cb88(
    value: typing.Optional[ContainerClusterNodePoolDefaults],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__501b372a997596371ef0e3bac9325d8dab9728d4012087d6759c4912456b67a3(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ea7dcdc843610e113a16ef44a5b2acab98cd160d89f30b057ea7407d08b1b8a4(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0b8c5ad32ec57de8744212f4f69018d344844d2e89f67f79aec02489b9e1a3f5(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3842025773b3e45fa99e72a84d0bec2e7d2753c6b77793731c35a7053e94121f(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__59ad4b59a226878dbe302647f430007134c3d5c0b851e38b6448c4cde6fe4571(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0eaa4fdd9b5e4e5b7697f9f55e7f6a97840cddf975372a3809b70b3139c73398(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodePool]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d5b08e7f6ab990f91bb03c1087044a27abc2a423828ba1d6a362ca69b7382ccd(
    *,
    auto_repair: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    auto_upgrade: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0a120e363b46d8504ec517f6172c790032c6057dad7f3c112ceb0332592f2cfe(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__10391539e42dd2fac09214ef204d039fe0c2ae13fc06e0be6a2c6129da3cece0(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__84e091cf562e096616ed155c508accb45a8aca5e15a73d5e35b56745cd888e77(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d5ffd902a805a308ea02ab8e867160a92e2fb5ab2484cd192a23325f005305e9(
    value: typing.Optional[ContainerClusterNodePoolManagement],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bcaa1d5fff84b3273f9f810f80f62e9a2ee78fda7ce195bcb03c5ae7fcb0a925(
    *,
    additional_node_network_configs: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ContainerClusterNodePoolNetworkConfigAdditionalNodeNetworkConfigs, typing.Dict[builtins.str, typing.Any]]]]] = None,
    additional_pod_network_configs: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ContainerClusterNodePoolNetworkConfigAdditionalPodNetworkConfigs, typing.Dict[builtins.str, typing.Any]]]]] = None,
    create_pod_range: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    enable_private_nodes: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    network_performance_config: typing.Optional[typing.Union[ContainerClusterNodePoolNetworkConfigNetworkPerformanceConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    pod_cidr_overprovision_config: typing.Optional[typing.Union[ContainerClusterNodePoolNetworkConfigPodCidrOverprovisionConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    pod_ipv4_cidr_block: typing.Optional[builtins.str] = None,
    pod_range: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__59488a84313fd413b54ca252888ee68fc264b40ff8b991e689b6528b7378ea83(
    *,
    network: typing.Optional[builtins.str] = None,
    subnetwork: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bd8da296f2905b228fe3c0544656838069a64f3b29c52e33dad8f60ff8b3a98b(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8f8d3cc4bc9293ba3f163d505b74e8210514ca9ac64fdcf9cf048c014459c749(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6a32457def4778e0a60928e44c78a0ef631e512d056fcc9fb90f8d9386c06e66(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f5be276c92322c8a89ec439e0df1268f88c3c6e6ffdf1fd60788eeee86f632b8(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1029555ccc4d5be306a96ff7f2544583c6a078b95092f08e5c8f9f018e83b2d4(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d0603d9647b9e5fd9173c73ec2c7cf77c26dc1be179deb72ba50e24862057c36(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodePoolNetworkConfigAdditionalNodeNetworkConfigs]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__efa3264fec53199009465355f2ec0a6cb1b3ca6419c56643764113e9b8658faa(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__766d4bc36a240c5cba869e89cd8097355ca16d5fe967f62673b0d83d47f9ba3b(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cebe04aea55fceb737af294c85ac903755bd39c4036d4c1a4274cca7b105804b(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__df46d9088e6e7c95228873e22680b89be581f58099c9e09a9aab72225181fc6e(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterNodePoolNetworkConfigAdditionalNodeNetworkConfigs]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__55823b066e4f9d6f1e886bf1f2d7d892c73080ee27078ddd0d8a4023d014ff23(
    *,
    max_pods_per_node: typing.Optional[jsii.Number] = None,
    secondary_pod_range: typing.Optional[builtins.str] = None,
    subnetwork: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c47cbe6696c2ee27df9d030f9cc1e58862b2adfb73044ada5a0bea8900d109fc(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__61bdfd58fd44e36bff55c12bac760216845375f9460f751f70e51b8deba30351(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__671308bb0b775442c2313e42b5028623be0a4148c6d093cf534e66c9e67abde9(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e29ebd100f03e38170b24be3652c851fedc485e20589e71043b772f175d8282f(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b45ea2a224c63aa1ff23b3b5a2c0de1fd3fed60795cad88e5e62181eda6578d1(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__37e74b9ec4444f7128d63e9cfb04f86240a9d92e788051488c3e1429872a1a5e(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodePoolNetworkConfigAdditionalPodNetworkConfigs]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__050b4aba9f20b3f0167889296896015a6a32c670e93aa64338d3e28c492f71a5(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f8796b81c3ddf74c6c4baca8c9de7f16dc26677ace3176e4835baafc49fa1f85(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__25e199eac1c8abaf6f014e84a1a924e42ee8a47c9186e96eb6cd0a6557cb2c76(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e7bca4857339bb3495f7ee06a6d3e72b9277967268e14d1296c0b8fa939aff82(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0a48467024086c37237c8a74d16ed5e1dbc2da3b6ca87a05ee7d65b0d0363e21(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterNodePoolNetworkConfigAdditionalPodNetworkConfigs]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d67792a8422e7c121612f13f549b1dba48fdff2629d185cc274cb59c9153c1aa(
    *,
    total_egress_bandwidth_tier: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2acc7a3dd513d7ac5b2105926a33b948ed8237f74ea928c5aa15d228c1512efa(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e85916b6a06f2ec2b84fdb14c67869586b7a10696a1f5d92046f3c1e6fd9f08b(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fb37105d674f8bc16813822039ef13f37f412414d043bc69e766d64b2853c819(
    value: typing.Optional[ContainerClusterNodePoolNetworkConfigNetworkPerformanceConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3be27225729ff71d2b22e3150820d8078edf8fde7754a743b95494b222d909ba(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__29638403988821d5253807d7d4de8451f0a2b22fe871f811a3e85693e12fddee(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ContainerClusterNodePoolNetworkConfigAdditionalNodeNetworkConfigs, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__24572967e8b8f65e3f03fd4d26e7bb9255d25d0d6cff504bb9a271fbfa59f96d(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ContainerClusterNodePoolNetworkConfigAdditionalPodNetworkConfigs, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__604a9fd6e5e5aa9a95bc9beb632040863e2d75912179dab397a64f7c1ec47529(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d5996dbc6a93da1649d271dae51d3ef211f417e41f9e82683e8f94f2d704325f(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d164ecbbdaad8af840ac9ebfa2ab2bd28451e369defeeca06d4b927b451a9a43(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6f3bfa558e423935b09222f1688f3d503d5f4c3d4ee9cbcd88e5b89dca4ac1bc(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4cef7c6b5ee8154c273cba49c7284d8c7f5570685d3027f6546e97fa92eb5e86(
    value: typing.Optional[ContainerClusterNodePoolNetworkConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b087f24f9fb413cf2edfa067ba48203729af1ce439467b881d19bdcc3ae73a80(
    *,
    disabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__88b1a4da55ade8a871aae9b3dc08225b88c959facc17107cbdcef33ed6f3e413(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fb5955b00d872cbf3a93409fb1163f39f66ba0eb465cbc73b1cf619b276b0658(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cdda960c79a276b91951c543d9364d4f356a31f01de629ba0eeabd7b2c405ce8(
    value: typing.Optional[ContainerClusterNodePoolNetworkConfigPodCidrOverprovisionConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__be965926d2825b4376a88b0ab45cf8481d4377ad56abd4470e7938b3498b809a(
    *,
    advanced_machine_features: typing.Optional[typing.Union[ContainerClusterNodePoolNodeConfigAdvancedMachineFeatures, typing.Dict[builtins.str, typing.Any]]] = None,
    boot_disk: typing.Optional[typing.Union[ContainerClusterNodePoolNodeConfigBootDisk, typing.Dict[builtins.str, typing.Any]]] = None,
    boot_disk_kms_key: typing.Optional[builtins.str] = None,
    confidential_nodes: typing.Optional[typing.Union[ContainerClusterNodePoolNodeConfigConfidentialNodes, typing.Dict[builtins.str, typing.Any]]] = None,
    containerd_config: typing.Optional[typing.Union[ContainerClusterNodePoolNodeConfigContainerdConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    disk_size_gb: typing.Optional[jsii.Number] = None,
    disk_type: typing.Optional[builtins.str] = None,
    enable_confidential_storage: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    ephemeral_storage_local_ssd_config: typing.Optional[typing.Union[ContainerClusterNodePoolNodeConfigEphemeralStorageLocalSsdConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    fast_socket: typing.Optional[typing.Union[ContainerClusterNodePoolNodeConfigFastSocket, typing.Dict[builtins.str, typing.Any]]] = None,
    flex_start: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    gcfs_config: typing.Optional[typing.Union[ContainerClusterNodePoolNodeConfigGcfsConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    guest_accelerator: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ContainerClusterNodePoolNodeConfigGuestAccelerator, typing.Dict[builtins.str, typing.Any]]]]] = None,
    gvnic: typing.Optional[typing.Union[ContainerClusterNodePoolNodeConfigGvnic, typing.Dict[builtins.str, typing.Any]]] = None,
    host_maintenance_policy: typing.Optional[typing.Union[ContainerClusterNodePoolNodeConfigHostMaintenancePolicy, typing.Dict[builtins.str, typing.Any]]] = None,
    image_type: typing.Optional[builtins.str] = None,
    kubelet_config: typing.Optional[typing.Union[ContainerClusterNodePoolNodeConfigKubeletConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    linux_node_config: typing.Optional[typing.Union[ContainerClusterNodePoolNodeConfigLinuxNodeConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    local_nvme_ssd_block_config: typing.Optional[typing.Union[ContainerClusterNodePoolNodeConfigLocalNvmeSsdBlockConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    local_ssd_count: typing.Optional[jsii.Number] = None,
    local_ssd_encryption_mode: typing.Optional[builtins.str] = None,
    logging_variant: typing.Optional[builtins.str] = None,
    machine_type: typing.Optional[builtins.str] = None,
    max_run_duration: typing.Optional[builtins.str] = None,
    metadata: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    min_cpu_platform: typing.Optional[builtins.str] = None,
    node_group: typing.Optional[builtins.str] = None,
    oauth_scopes: typing.Optional[typing.Sequence[builtins.str]] = None,
    preemptible: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    reservation_affinity: typing.Optional[typing.Union[ContainerClusterNodePoolNodeConfigReservationAffinity, typing.Dict[builtins.str, typing.Any]]] = None,
    resource_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    resource_manager_tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    secondary_boot_disks: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ContainerClusterNodePoolNodeConfigSecondaryBootDisks, typing.Dict[builtins.str, typing.Any]]]]] = None,
    service_account: typing.Optional[builtins.str] = None,
    shielded_instance_config: typing.Optional[typing.Union[ContainerClusterNodePoolNodeConfigShieldedInstanceConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    sole_tenant_config: typing.Optional[typing.Union[ContainerClusterNodePoolNodeConfigSoleTenantConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    spot: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    storage_pools: typing.Optional[typing.Sequence[builtins.str]] = None,
    tags: typing.Optional[typing.Sequence[builtins.str]] = None,
    taint: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ContainerClusterNodePoolNodeConfigTaint, typing.Dict[builtins.str, typing.Any]]]]] = None,
    windows_node_config: typing.Optional[typing.Union[ContainerClusterNodePoolNodeConfigWindowsNodeConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    workload_metadata_config: typing.Optional[typing.Union[ContainerClusterNodePoolNodeConfigWorkloadMetadataConfig, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cf28aacd12be6625c735af9e591e9458fc217c241592ccf3906aa5b83854afde(
    *,
    threads_per_core: jsii.Number,
    enable_nested_virtualization: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    performance_monitoring_unit: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c2794bf04f73271dd4bb6f45de44a9521b3e6ba2d9b6dc107274942437043c13(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__02abf2705b35df1e0f53b236eff28868762efc9ae912287c2ad2e7732fb23f1c(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__88a8c27edde2d695813dd59b348bf0e05af1f34c333dcc360fef69c78c760b36(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f022d134b97f0a2e1d50065296170f95cecaa17f201e6f13fc3d0b78c67fa134(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a6741dcae86074693f271cfd64afb741b1fd87ff4c05d50b63dd8f44fd1dfc6f(
    value: typing.Optional[ContainerClusterNodePoolNodeConfigAdvancedMachineFeatures],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fd3683846a431888441d45bfe7d33dd72bf81cd839b5931abdf3c37be6032c1b(
    *,
    disk_type: typing.Optional[builtins.str] = None,
    provisioned_iops: typing.Optional[jsii.Number] = None,
    provisioned_throughput: typing.Optional[jsii.Number] = None,
    size_gb: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1eb640ca6b28a7814e677ea00d229fd8ca9dba493aaafd17b506025b23dace13(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b4298bb191503bbdb42e69a251d6f805bbda678d23ab9ec3f95949a79d636ad9(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b587f3534367057a9a86377b3e80cf5e3562a9dad3c27c76405e8278e85279d1(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7b5a196d7635afca3adf7b5cb1bf0c6398a8d083f2eff0eae464cbbfc3569684(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5df3cd3fdcb92509ad45cf0266523feaaba95a69edd859ca4e8c997973ccf7a9(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__009f9f1f1a30acb16d5f1c52204e69eed061af21f8d142d4f91107e17939f15d(
    value: typing.Optional[ContainerClusterNodePoolNodeConfigBootDisk],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e6c395174f0caf88fa0279c2fcde4da58593e6beb008d8841cca254bdd7d4e3c(
    *,
    enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    confidential_instance_type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ae2d765bd48c72b4e57714e927d4986f18fa560bbdd5ff94c5bcfdd12d97381c(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fd732ada6fa1b517367ae768a33ec6a122e1212e44b52935b9ab29bed3a7ed9e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f59ca7c194740942d8e664b74aa24b5c9b1cb7ae25bbb63007beef24f540bec1(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__85de66673b352f189442871c723cd4c2512d01df54b8a47ebee8ca91e6b2e836(
    value: typing.Optional[ContainerClusterNodePoolNodeConfigConfidentialNodes],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1d76227ea7307cd430327f6684c67bd0edab50c2fcdd1676448db65fc71015ee(
    *,
    private_registry_access_config: typing.Optional[typing.Union[ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfig, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eea7a5fcd530c986c5e435090734d85f89a654930ed3138cc8feadf0d8698fd7(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__490fa88eb8531aba5f62066121bf87050ebb0830ebdf414626af1020a94cff63(
    value: typing.Optional[ContainerClusterNodePoolNodeConfigContainerdConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__20f5729ac786be4bdefb07806f5dc68c27fbf423d1c1a14ee5dabdd8113b04ae(
    *,
    enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    certificate_authority_domain_config: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__43cb3584d481618b8cca43134c2e5c2e55dfe880cfe155f2490f25b034a95d46(
    *,
    fqdns: typing.Sequence[builtins.str],
    gcp_secret_manager_certificate_config: typing.Union[ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__91b8b57944bb1bd31a2c2ee814a4af7a30eaefb16784d31336c24f86618839be(
    *,
    secret_uri: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__78b01f7a12cb74deafea09bf15b5b3700d0628a8af5b68a36af2156f10229eec(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__93e2d397cc58c0b950a681c2a90f65b6a6791f602d4dfecfa0d8f823d1159175(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6255af41f4873a4ecd14121788f7161cd34405f8164788d96acc783dd5acaadc(
    value: typing.Optional[ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6505c286b894bb0656d3d83e889402a4a8e9897dff560d2f834e1c51db1410b5(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bfbf7670fa95faee2a01ee8097218a90ba062a93a01dde4132a4ec9ae1a7eaf5(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4c83951a4e4a583be733d58e9410615a34162ff9f1c1315fd3163c4f53e6ad19(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f098c007a31e9f1028d4b7119cee9358d5bd8b614898dc04c035e7f4df9fba50(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f17711b611f3d67ee67ec8ecfeb44b8c1eee3ae14cd67ffdb96a309a9c952016(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c9525754bda3fe56fbda56d19a6cad0f1e0d05ab424df2c82612f0b11e2a88f4(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8f0591c617ae95d4cf82a7bb9d7a05710220dee4e6515dacee9824aba607d192(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__855b171fb68f2cdaff60e7ada23f77b544cc00b2e44056cde293c3abd5efd884(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0b8b60e4f1fbb31185a6df32e3a5a1a0e7d94b9c8e90675bb554e09b8eecdc1d(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a97bbf0ed2adcbf94d81d1ca179d862a8f7d10915787ad80cb8e7e1354fac6c1(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__da99f0ee7bec8e0295ea923e45c1fcda06267e592de92bf20b6c741b6211405a(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cab6c3f2f73d2305701072b48c597c98f8a8aaa294e0d15cd229a0a5d8fd0543(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__38b907842288686112fd634a375c81f0e52ba0e61130a57651c6bc29589871c0(
    value: typing.Optional[ContainerClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3a3d266cb4028fbcfb89265b8ff8b62188a00d1a178de622a41ae1593e6b329e(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3d8bb9d7d4c5c0436909d25909c2f0e24a737fd36648f65a4bd3cb095b4da476(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5fbdb999a6567e3e2929d553e026476937eb8f75aa5d10df88bba67c0e2b35e0(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__49a29a6fd844b38b95ccb278f147b753dab91b56047eee9515b218c202c6466b(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2e97cc201f825eecdd6718396132b343bf9f88334acb77b430b7eb9d2274ebdd(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7d100fb9b589fb71e2d85959c0456c76eac3d5be682f62a4bd27ef02c0d6431e(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__98389dc47cedc60966e6b2e62098c20cbf6030a4cebee32684db424096e6007b(
    value: typing.Optional[ContainerClusterNodePoolNodeConfigEffectiveTaints],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d7d532bc4036070da93c1bbabde0a3bb4e6fa4e86a5f84816d19abc7b7f55101(
    *,
    local_ssd_count: jsii.Number,
    data_cache_count: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e7d9a2b3965781dfceaf15cb0ba4b60b8089b32682217667a6a9511b2ce1f9b4(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e2af8e39cc30f5c9a8826bee88b3b1b7be84640d46d05a2e759f723986d4d782(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__579d2322078b0ad351720a30bf39c91ef56e5b2cb47c33c3f834f07e8cf94789(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__76a57bbb01a0f2a90af168a4d6ac6fb171b5d597014b4fdf1370e35d700428ca(
    value: typing.Optional[ContainerClusterNodePoolNodeConfigEphemeralStorageLocalSsdConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eae97e3c9237544ebc5e08135ba32e0194e35d4932f82a8a527c097b0c6d02d3(
    *,
    enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1c7ae44e206be0c66c45e2d386a8038fe338df7b34f762e3bbc54980220cd3e1(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__96488c094be448eb97323164a8e797ded22fbbe59be7d3fdbae70d1864c59a5d(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e5f7f5ca73b4dc4f78af9f2854b74ad61b465f12545e79bb399963153788af92(
    value: typing.Optional[ContainerClusterNodePoolNodeConfigFastSocket],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__322e77a049aaea739b7970052120f0687c986d787108ee6222795d29c77b8d3b(
    *,
    enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__954746095aba4e54c1c2f931757a6c6a149b034e4ee8e6064dd5fcaedd4554e5(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e4fef4a7b2a7968403bab2586b25c470655ff194d92a2601b6ea5452ffa61d08(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__22c7a50bd30815789274601d1e3ba8d2a571643fa171bb74568f0cbb62e3986e(
    value: typing.Optional[ContainerClusterNodePoolNodeConfigGcfsConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__55b2a152c157398862bae4565126d2ede0b7005999dfdf4b1e088a54ceff0a18(
    *,
    count: jsii.Number,
    type: builtins.str,
    gpu_driver_installation_config: typing.Optional[typing.Union[ContainerClusterNodePoolNodeConfigGuestAcceleratorGpuDriverInstallationConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    gpu_partition_size: typing.Optional[builtins.str] = None,
    gpu_sharing_config: typing.Optional[typing.Union[ContainerClusterNodePoolNodeConfigGuestAcceleratorGpuSharingConfig, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__256cea0e78afbc2802b60a186403653c54a7aa483313a822bf3cba147a967dd7(
    *,
    gpu_driver_version: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__60a8600d320238f234b935ae764554a1051a063d7c2a1fceb354dce74d9e7eb5(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5cbe6b0e6cc797fee904c5cdefdf81a3526eb0c3482ab94d93633572e84d8f24(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__82771ca21caf29aecce8965227658c10444a8e1f413effdba21c7a03603161ac(
    value: typing.Optional[ContainerClusterNodePoolNodeConfigGuestAcceleratorGpuDriverInstallationConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2fa12660bf052e16b16af3356986ffdf0e844487d8b75e27c51d6ee0a54ea546(
    *,
    gpu_sharing_strategy: builtins.str,
    max_shared_clients_per_gpu: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__50ade9daea746cbd832feecc6d9018b04cff8c6bef292d7838c059d430c05162(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a83e0a21744ff00e11fefc2db0dad71791b9b47763aa9f04a579f2b4f66a5d01(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__697fd0df6f3a46ff06f35730922a85c5ccc1a25d6311a0a16d91c4440366ea79(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__481793bcf3550cc4e12657ecfa329a493d5757e09d3ec4aaf6d820512975c277(
    value: typing.Optional[ContainerClusterNodePoolNodeConfigGuestAcceleratorGpuSharingConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d87917881aaa7ce7aad94f95d60eb17f0355ef3640f928109620e48366b9f730(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a349bea151887dab3058a90370c218a4281538820e19c1bd7be55435e3441f81(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fdefbda83a1228b519bfbd19d5226d9731a6764b5f847a79473f6717bdfee7ee(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bb4ef658bff467060ee92629c76a78af157bdfc840f22205829bc47762f0c3e3(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__95e9d5b45f08197bbdf87b449a8db49b7a796beee2e019996bd7099de008cd1f(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__66d16b12985fb0b68e4a3f6f6c99117279335619cd70ab8fd0bdb9400caf8bda(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodePoolNodeConfigGuestAccelerator]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__32d8fd39e1613e65cdbc4dcf59775f7c92780894750bdfb86f048d98afc99b01(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4d746ef920a8739f700aa43385c14a4bcbef71d9e38973c9582b2d67181f3d51(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3bd99ed23be565fab643fff1c3aeea618cf2ffd28174dc6009f46473316a653e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c56247843c96a0cc67e33bc8b25c826f684a5c3d1da534e32772ff74a7d751cb(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__12f7b2611d488118d9f52d6e55d954b642efa242c365725c006da72c6f36e367(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterNodePoolNodeConfigGuestAccelerator]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e369d40ec7ca8c1d6d432f66ea27ded5a88c450e2eefbc5bba476cbeac3a2eee(
    *,
    enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b739808075c2f295dc109632023c57a288ccc0c00616a553013d647dfe8cdd99(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2cf7c314d12fb90ab87f10e5a23a888e892d97ae2d0f8999fd60e54338a427b0(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4dad6c7843e3100675e80deb529df59292c51a2ef4dcbf41f388381a08db7cb4(
    value: typing.Optional[ContainerClusterNodePoolNodeConfigGvnic],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a16d48176d430934793339dad2f00425c019623bd618098116fb2c9a2421e1bf(
    *,
    maintenance_interval: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c4be3b677e4ba565a595d78c2ecccb2d4e038aab30b45164477dbad70e5ea2de(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__65a45a787681a4dd89f134ea85bf3c66d230a2f8d3171b8aee943d90262f42f9(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e26a6f7525d2ca8e84d069717b77026c837eb7e3fb45aed7303f9176ee4f4fd2(
    value: typing.Optional[ContainerClusterNodePoolNodeConfigHostMaintenancePolicy],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7981cb432c5947da5bb61b86448537df695595b5439d1f2cb8531257784dbddd(
    *,
    allowed_unsafe_sysctls: typing.Optional[typing.Sequence[builtins.str]] = None,
    container_log_max_files: typing.Optional[jsii.Number] = None,
    container_log_max_size: typing.Optional[builtins.str] = None,
    cpu_cfs_quota: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    cpu_cfs_quota_period: typing.Optional[builtins.str] = None,
    cpu_manager_policy: typing.Optional[builtins.str] = None,
    eviction_max_pod_grace_period_seconds: typing.Optional[jsii.Number] = None,
    eviction_minimum_reclaim: typing.Optional[typing.Union[ContainerClusterNodePoolNodeConfigKubeletConfigEvictionMinimumReclaim, typing.Dict[builtins.str, typing.Any]]] = None,
    eviction_soft: typing.Optional[typing.Union[ContainerClusterNodePoolNodeConfigKubeletConfigEvictionSoft, typing.Dict[builtins.str, typing.Any]]] = None,
    eviction_soft_grace_period: typing.Optional[typing.Union[ContainerClusterNodePoolNodeConfigKubeletConfigEvictionSoftGracePeriod, typing.Dict[builtins.str, typing.Any]]] = None,
    image_gc_high_threshold_percent: typing.Optional[jsii.Number] = None,
    image_gc_low_threshold_percent: typing.Optional[jsii.Number] = None,
    image_maximum_gc_age: typing.Optional[builtins.str] = None,
    image_minimum_gc_age: typing.Optional[builtins.str] = None,
    insecure_kubelet_readonly_port_enabled: typing.Optional[builtins.str] = None,
    max_parallel_image_pulls: typing.Optional[jsii.Number] = None,
    pod_pids_limit: typing.Optional[jsii.Number] = None,
    single_process_oom_kill: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3b6c80a4c03fec2d3536c2631578d4ddfa6b7eb2d4b27cd3c326ba9509ec55e5(
    *,
    imagefs_available: typing.Optional[builtins.str] = None,
    imagefs_inodes_free: typing.Optional[builtins.str] = None,
    memory_available: typing.Optional[builtins.str] = None,
    nodefs_available: typing.Optional[builtins.str] = None,
    nodefs_inodes_free: typing.Optional[builtins.str] = None,
    pid_available: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__72420c58d89ddf09a2aeaf3084315ccdaf8b84eb2c85bd13239e3465cc32681e(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1d441c78259b523f8922c2faf75188e949af004805d5e09f868b23dc8e312407(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__452b92683412e76afc614c977182bcb3cf337b69431906e8b6341e9ca8c7e69a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a538d0d4af228bed560a507618e1fe3b559e427defd0b65224eb1290c052beec(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f4e85515afefb7e1b5f23249e7df26deb9a24d96c3d76983a48de3b76cdf1862(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__24ddfab9726caf01715e0f2b76f92d9632c384e2e80d6384c78e83585b72bbdf(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0083cd1f4058eadc72cf40adffe56b55d355d094e88d80abc8b8e0e6c6b0d727(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7c423061562b5c35b4452ba0049f416b780c5a6effab1ea10f8ab91fefbd290c(
    value: typing.Optional[ContainerClusterNodePoolNodeConfigKubeletConfigEvictionMinimumReclaim],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4bec9b950c1b35af28e94b186eb2e5b0dd7c75f3cae3f1d993036c591c1533d4(
    *,
    imagefs_available: typing.Optional[builtins.str] = None,
    imagefs_inodes_free: typing.Optional[builtins.str] = None,
    memory_available: typing.Optional[builtins.str] = None,
    nodefs_available: typing.Optional[builtins.str] = None,
    nodefs_inodes_free: typing.Optional[builtins.str] = None,
    pid_available: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__04f15e3cd119962331bbeed39edaf9c9fb1f2502e2d4f795ad7cff3e6796eca1(
    *,
    imagefs_available: typing.Optional[builtins.str] = None,
    imagefs_inodes_free: typing.Optional[builtins.str] = None,
    memory_available: typing.Optional[builtins.str] = None,
    nodefs_available: typing.Optional[builtins.str] = None,
    nodefs_inodes_free: typing.Optional[builtins.str] = None,
    pid_available: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a87d33af639a9d8b7ca39f8476ccb60071ee868d2c32db0263dd71960806a795(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__19332fba63d5337f74e87a86918d8c7402d829a14f8728ccd216ea9ceb8db91f(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b79aa85e67e79f5022e68b1ed05cccfecf2474368a0c38cfd7b9726654b947ce(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b65733fade713c99f372ee58679c0d7bdd98926f8958e781d6523deaadd0b6fa(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__482048a372f004eb1d48e67ad15a6a9b85d89958b7a49515512d8ee538478a86(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__af5b1ca480442d8795e980ac4ce0c4ffa80dd896a83cf55effd5af08689b9823(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e28ef50b18c4b1a5c92d5de4bcf489753ced1cffa9b0de7c69a08019ceeab374(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3a51f521468203ac470aa8735c4a4f5566efe70c08b0b976e161da9dc7489880(
    value: typing.Optional[ContainerClusterNodePoolNodeConfigKubeletConfigEvictionSoftGracePeriod],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9c4e6b74953672daa624485323ab335358345643bb0bdf32825f503cbb23abaa(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fb303b2f2c11f561db71abb2d28d7bb665afda0ecf872a2814edb28ecbe6b680(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b7f48becb896fc13082b88891e659cd25df0c9d238493f27c995971ba570e6ab(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b17c8df12743a0c981fe6ec967c459e9d0fd5a83c7c9cdc0a9722d7076af7074(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bf0254476f448870b9086dd28a69f777e0246f07e8483e9df6d4798ea4645b73(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a461f2a00acdc4b2d755d0ff83eb8d08f3e970d54d3cebb0729d1567b4f3b164(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c7227fb61963fe2b7d03890581d4da50ed04ccf7bf9ad23ed6b07050e67c8be3(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d8dffdbc5550f7f63dc2bddf8c7035d3aa40e1831630126f3793c2644765f7f4(
    value: typing.Optional[ContainerClusterNodePoolNodeConfigKubeletConfigEvictionSoft],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d109feba51f4c70d724a5ffb8b4544a37d9f7b459957db51588737139ba200bf(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__925af7399f34670b29aa4137be9f55e7af1503b677f57172775172a7d6830b9c(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c02de33cce0a92f2c4214bb0d78163925f56810691423b2fef8813dd80d020a8(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d0ded689ed72b935b7c6c835f9693c065ac02d3cedfa52a6f6e70350cd3ca4fc(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e2ceafaa1e2a312b37ce288ccdcb85c42bdf66834f095634dc510f150e1eca4a(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cfc5b99345d39675314cc585fad9b2816759e4179f9059a02f10e44a2c8cc0e2(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__64feda1719659002731944fa22febc08a371e841221d9d7ecd91f02ba3f3e8c9(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__537e0ac27586fe8a6a584e80ab30304ba931d785bea2ceae588ca63a8b72eae3(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__37cfb978e4ba03a89223fac561c8634bd8ebf1d149b640c2710576ef4f6055c3(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9fcde601c73e28ddc527e394236597acd0135ac4850aa7ad182edffe7836829c(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b44aa4154aeb6c3aa69becd892741052d29a2235b03bf2e201cc1644c46827e4(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b8238cfc352a6b4a014d3bc024697f46a77c0208a2565d84d8870c42d3255add(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e370123d0ace95ce23c565c7688e479f5349465a4173a8281ca2b9253abde255(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0c37fcf2b957e282c9eac9227a935249b8bc7c69c815083609eedd6b61354a04(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b7579fec24ebb7b93199c18f2742e1e9b2488ca11b9babfaf459db9b8fb61000(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b2c670c8572013c32638e394604720436e9b802b847a1a627d259a4bc08cdd49(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0015c7c68c9ee2ac08e755b437f441647a38ea071b69c124f616e2db6de88049(
    value: typing.Optional[ContainerClusterNodePoolNodeConfigKubeletConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6e61ef93528399ecc12e219a25332af83b87c0aac293478edb6d786de5da95fc(
    *,
    cgroup_mode: typing.Optional[builtins.str] = None,
    hugepages_config: typing.Optional[typing.Union[ContainerClusterNodePoolNodeConfigLinuxNodeConfigHugepagesConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    sysctls: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    transparent_hugepage_defrag: typing.Optional[builtins.str] = None,
    transparent_hugepage_enabled: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fd1208040507b6153c45a951f27037c30813df18dfcb4b661e0868ef85638b6f(
    *,
    hugepage_size1_g: typing.Optional[jsii.Number] = None,
    hugepage_size2_m: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__94934ecb7cd69032a6503cf225e26d5dbf4001ad9ad4b3d3af3e386c3481fc3c(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__601a64fbc6f9e5daa8d1a83155d3d47f245530d1563948ba3936ea2a3a925916(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9e4267d8ce57146de83620280df5a651ea3af1f2696dc09d745c813b1e76f829(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__35a661da13b8fac81cf9497ee624b524f944ebc701a2392aaf837812a290a71c(
    value: typing.Optional[ContainerClusterNodePoolNodeConfigLinuxNodeConfigHugepagesConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bcad1595df79fba622f5fda30036322c24ebb850db912ed22c48c5499bf4c32b(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ae9c5dfc8a662949b1c6df0eb0de3b2eada71b310da8c40bb8bba385326f2814(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e461ede9f682827922296d0c34e7297bb3f5219c860d220ad42660733a8560fa(
    value: typing.Mapping[builtins.str, builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1d34e10966144e543fc4afe56b34d186d7992bf51b6815aa48dff35dc2220496(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6e34901439e4d6de96793db63c0cb567cd3b33064b0d1a5f74a7e98bfee9154c(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1903c99927304b1af90737ece869dd58b811945f6c21d0c5628c1b8336372e0b(
    value: typing.Optional[ContainerClusterNodePoolNodeConfigLinuxNodeConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3d86581ae32dd1636fc3581095fa297470b8cd9ed4109ee5d960cf16ccb097b7(
    *,
    local_ssd_count: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3d2f17c8c35e78bd665014f3ff93fe78ba490329740c5a21baadfb3c523ab652(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__26654ededbe8f1eb9d77b3b00c6d0266725ad899eb4c535596b52f8fedcd9e76(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__99669bce26a25d375935811c74fbe99b28ff5c32fd19f959d31501f0d181b2d0(
    value: typing.Optional[ContainerClusterNodePoolNodeConfigLocalNvmeSsdBlockConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6f49fc053ac152ed5cec516aec36fb4d3c18f9cc338f660d59fa2ee8bc80ef24(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__78f7608483721a816fc2b7d1d95a12e57b86a2089a225a89a87bc30a70e7ac3c(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ContainerClusterNodePoolNodeConfigGuestAccelerator, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__90e44878380b2bbeda6f96aa2c6313c5e7a797b44872add995d9b4e45bee7283(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ContainerClusterNodePoolNodeConfigSecondaryBootDisks, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__885cfaadacdf1a19ca65dbe946617174a9ac7c71958b2e72feb93f3bb1318b11(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ContainerClusterNodePoolNodeConfigTaint, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__45eba2c595e7f25b00f647e4930182165c23ca9c2cb2bdf9a128561fa0915603(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e17aefa685eea708e88d006fd3c11ea44aa6fbb10dc3a4b74d1b4a26b863d2e4(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0bd4acb8bee7c5a119073312fb6ac763964f0d7c011301790bf9bfcd1be9a512(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a0dd3288c7bd5b436c555ba6b79677e9659ce55b9ae4b1f61a45e1b279414438(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f64e86ff210784f125aa2b194fe88b27febb341d099b10d89699d7cf7a24963d(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7fc81e6c09cdb8138641989e84c0bfb2147e9bf4b10ab380db9cff36eda0897a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ab6891456d23f0d5852c137162b621fa224ceb2b283d59947571b37c1378245a(
    value: typing.Mapping[builtins.str, builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fd41f9c26b581bfc795d7a83347d46d981b2b4db3f0e7a2abd07a445b662ccdb(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8775c5aebf174d0ef8ce02a0b19473ad1a86be275a3dbcefafd09b4536d090be(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__799fa9144351f6696992764243e61e1679096f6f883820aa2c482a885fbdf7c4(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a0cc645a01328411e806b3941d2a18461debc7096a4a69091f6661ea7290d3a3(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2ded9d5ae5a60bf8e5fcd8cd0b875bf93fec8f5bb848da497b470ec69fd102fc(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c0be9a412ca74b8f46358ea6573fdce83eb5abb95bbaddf790ead52ca1ce2fc2(
    value: typing.Mapping[builtins.str, builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bcb2d5293b818bc983e084d0df481cce3924fe4f494129581d1a794d6eb370bf(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e9f6cbaffc68ee1a2656e2fc3a008ade6b4351658b6ebbcc4d13f295a8e4894b(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9c4820a1c528c7ece775ce49d7a7d8c2e11df5b0a68d548a361a7866f0156af8(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__99efd4ca131d624c59bf2aef6cf0919d04a38ba4ff41a2952c529dc769700272(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dd0291fcdf33839bc3bc19615372bd9b5db3f35e094d5bba38bfbf8443388964(
    value: typing.Mapping[builtins.str, builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__956a20b039313bb2da0f14fe2a65699735b8e981852e5b98aa9f53fc4607586f(
    value: typing.Mapping[builtins.str, builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0010f68e8f23ac167140be41b54c106d10b203cbe88c1b9bb1cf7e2a7b9e961d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e554915140d445524925c7ac0ca8468aa2842dc9e06b35bc835221a888c666a5(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2a440f749fa0568fd2eb769188678bc1574916bcfefeb949bfb1c864aa39da47(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__398d1001275b664f8f543dd498749a2d243fca94fd7ad17da199ddaeb5753c1b(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5711dba9b227ca789cb8d81b9d4ec13cc5c18a094740a3628d88490394d00470(
    value: typing.Optional[ContainerClusterNodePoolNodeConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__77538922f2817c99fce603f56334ba769be7e64af4cbb2f2d0f95c2d70c4f9cd(
    *,
    consume_reservation_type: builtins.str,
    key: typing.Optional[builtins.str] = None,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ab35f352572d4474d195d8aebee99d8da237d0653536b5b213800f25bcd77d9e(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e948da3421195c81688d214dee8c75592bd0d0500fd600284afc567c1f653ff0(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__541b5f1ad62bf2db58c415b3c88f980bdc68cea3b0a6b124118e049ba94008e0(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__734dd7871fcfa07fffc465fbd72cabe0e44ed9c00bedd5815752eaf94f060605(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__91b2d7690363ec82b1153c77871679d8db898ef6376d1cb93df9031a5c4831af(
    value: typing.Optional[ContainerClusterNodePoolNodeConfigReservationAffinity],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7db166d944697cd00452b314923c3765d3c80ad3460637fabaee2394df4e19f5(
    *,
    disk_image: builtins.str,
    mode: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e162f5c72d8433ca9b33c9fde0943e60abc2d4863c81f8d767501046b0f24e77(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3ac62fc2f5a70075826b941349271932ee5bcd52377c77c6a8cd71e331185d06(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1327d1435d93df12f0c725954b733eb7e2ade95f0e3155ef814146bf7df3d5c0(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__81a6f9860401b8293dcfce59fec5577420e673b18a286485d5f24f161f0aae7b(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6a376ed1a020da9abff42d52e260366fc909e89c142582f1678bb67cb7d6f431(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e805e5625d85984ccbeae3766259ae6bec70576224236ff939a6d9804f351502(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodePoolNodeConfigSecondaryBootDisks]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f7c07ffc7c9266cf78cf30af29a7b7528c5de9915938298da2539dfc55fd5919(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0605ee60ea3f7a80b568238f8e190d95c3d61e2964eedfbe052154cf571a2939(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cca7d6962a936cc659b69ef9cc821f3bb2fcc330e79a925adca298cbf66a6571(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4a1e7b112060da2986c1d7ccbc5476ca7d4871f8f3d7be3ad9f3bb9e067c7141(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterNodePoolNodeConfigSecondaryBootDisks]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__99f4a6c29352235163ea27402916dfe7af868595550c9da4eb697a0fb170afb8(
    *,
    enable_integrity_monitoring: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    enable_secure_boot: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__539a6ccca8864f2f140ec5e3a7b868453d19cb74f9809fbe84ce3b411219d76f(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9bdaf546c905a14bb4c0e9730139f6065e8366052ebc3808c7d30eb1737263e9(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ee4c71163e8bd189c266104290b6507c2769efb7b93bb1e4c83283f9969a2a22(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6b73ff0563fe0390f6f7a33a9371d600ce11552a5a20c5cfb01026e1a5f35250(
    value: typing.Optional[ContainerClusterNodePoolNodeConfigShieldedInstanceConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7daef7103a9eb81b67f3e588961d88d0d109821a45212892921edf53f00a7cb1(
    *,
    node_affinity: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ContainerClusterNodePoolNodeConfigSoleTenantConfigNodeAffinity, typing.Dict[builtins.str, typing.Any]]]],
    min_node_cpus: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2e75392c554153696163dd6e1890c00130742d1efa49412cdecdac1063c2641d(
    *,
    key: builtins.str,
    operator: builtins.str,
    values: typing.Sequence[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__14b8ba3e56d00d0209c3e214dfe98ba6fadef1cc21a3c6c3806541546a1da68d(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8eee06949b1860e7714d2abe306d764a4392e506c37dae46305ea5ac9bf2729e(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__394ee72883375001ce451352fe1142175200333f0b1f61f68c9fff4a217c4e1d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7bb9e00983b9843253fd0be2400812b81ec165bce47aa85ab9e9fe1f64eb70f6(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__82af5d34c9fc13e7e4ce2a50c6e97fb90ec5c40412df3d314869eeac0627c050(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__aefcd570fd2f389036785093edab778feac78915cb80df6079662085e61f345c(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodePoolNodeConfigSoleTenantConfigNodeAffinity]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2cebee02370f53ca4372a09cedf249caea4f38768bdaeee06775be02daa952a6(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9153460a86aeda55927699f6f72d72df7a593aa5780aab533ce8888b6d1dc8b2(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__74d373c96e63f994fba3ea2128547eb7846659b5c7f7cfb36b7ea1484338a22f(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1b7f4cf942c788f2a17e74000d95479fa00cd16fca7456eb5b52e3fba9cbb0bf(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6d1b46305b4f77b8c70d750c35623071d7739c95a44d39fb5dd74db2e1932692(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterNodePoolNodeConfigSoleTenantConfigNodeAffinity]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__80bc703920ee3dd8a92947491602a661b09669dfe73a62deee1be097e2c597b3(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5a25f3fb5ce1e4349dced9dd7696bdad300398689680a75a895f1780251532cf(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ContainerClusterNodePoolNodeConfigSoleTenantConfigNodeAffinity, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cf592a0c8201709ce97df176012aaa53c659174af743fdbaba5c0e351d41bc65(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0c32e1909d94c0f6e9aaf8d8a0b0bafb28a872a96493e1d7e4ccc4b38d775337(
    value: typing.Optional[ContainerClusterNodePoolNodeConfigSoleTenantConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0e936a4ccbedef9f19741eef29a1536b4d271168d4dac60caf30bf8dce07ea0c(
    *,
    effect: builtins.str,
    key: builtins.str,
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9abd632b209f148417812330e6da16cce5ff958664adc4993e269430e2aca1b8(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f867d9d9e3179c14632a93d4ce1c45abfcb2538d111fa14f7a9be0e2f66dc432(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f659bb874cc95e11c7e20748b96271ecc88c915eee716696aa2eabd2a4272319(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__662441c9aa5ddcc8f18bec4b37a2c84175daa4a1d69d0f573e6aa2ab6def8d67(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ddbc28ddba120ddd043478652e0b358c1f88d367e3c39c42444631a82f0b3833(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0ed42ccabaf080e7514ae2d00534b1ffd0f028f60ad7642ecae73634e8d28838(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ContainerClusterNodePoolNodeConfigTaint]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__47860b1d86c8fa47025ab0c8ab53ceff71466def5dcd83f5a5ebf90cc9ffb14c(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1b716f7bbd0842e23601ff92b5e67cda8be0fc9d8f66a67ddd5af495511f7794(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ef204238f0c2e7ccc645c619d90d1aec5e89eb1b959339ada7758b4930d2c66a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__05613cfd730db1d6be71c886de3cf1d53b0f0b0303480379a27eb155cb98c8df(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d40197c7a9ea21f73d1de0ff27d0814f135286e845253d589152fabe8735456a(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterNodePoolNodeConfigTaint]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7bcd2a35ff68e49833ce2cb5ce97af08b5d195d85e0d12c777a0b34fbc7046a9(
    *,
    osversion: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b31daeb03362925dc05f3a2bdf5b80e41e016c47c9cb8f0f20e17114fb64f3b2(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9d8a2fdbd048414d0d03a1d853c8cada4168c6c1bcc360f824190e5866f485a7(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4cdbb9a5b922fa2e839ade6efb366dbf994a88105b9d35bf7428f5c81fd108b4(
    value: typing.Optional[ContainerClusterNodePoolNodeConfigWindowsNodeConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9c18fda88d977847a9f4b544c5038f65ff00eaf196bd66ce01d03c1808786402(
    *,
    mode: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f169d8afdd813238c2b0a8c3e143048e07127c7d88356a0a8960f9d40d0ac4f0(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__380b19ea5652ebc07c13879739841262fea4f60a8058071ddf76874f3e5e7b1b(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5244e7de9a1741d43bb9c7d71417d355f76a504cddaa5599f850833278f566f8(
    value: typing.Optional[ContainerClusterNodePoolNodeConfigWorkloadMetadataConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d9ead4e0a31c83e8d73aee7e8b154f5a7377b3d0a5c0a2bf14090dd882bdf1a5(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9ec4185a6a2affbfcca38432f4768cb61e15b79ffb22add7df21944afb635200(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__99fcbeb6a2f5be5aee2f138f08d809ad680ae84ca4c03af35c6a02bd07e2cab8(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a6e6105fc137ac002e2b06f1ddd6368cce132afdcf02687208d3b2c83f5986cc(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0a6f88bbaeb1840b3fea0aeb50dc70f0484dd8c1c2324063abc19caaff5da687(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c682c40530b1d5f661ade5337d41c283f274b82f889d9950f1f8949dd29c1183(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__441f415d99554c764a0d77e624a44c6993629f964ad7393a56f3e71d1b3d9462(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6d5f7a36c8acd1f522b86cf764ce7ba87dc3069053440052968618c794b586c2(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__04a85d9ec4ca090ad12c3b8854498884fbc74fae54a1f7e65923cb6f2819b360(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterNodePool]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__52d1497473bd2424152be42217e2e2183e7f4a3e05d10a2f914ae26ec02f526e(
    *,
    type: builtins.str,
    policy_name: typing.Optional[builtins.str] = None,
    tpu_topology: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__47d1a3b59fed5ac1562895e4733f2e6c1f5348ceaa5837b69be5660225b8b3fe(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f5bb8a84a1fe8c2e7024d6c4519e9f2298b32dc6b21bbbda335b24e6e7076d77(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__651dfc5fcc0c6812b49cc94d8be352e2e1ff483943c8afeaec1e618b26a01eb8(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ccbbb2833f97008b0ee6026c44124444ce94f417b78b1b558c489bf1e54b62c7(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1f9977a1037bd557bf01750a8171b2ab37444bc7d47e65c7c52ae45b7f5ccf50(
    value: typing.Optional[ContainerClusterNodePoolPlacementPolicy],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__79619a1147f5c44967a2b4f37548cd165931e7e2f14d19f384818f554524c36f(
    *,
    enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dfc5e3eed7b8776f22c49db9f665b594f1c5e7dd0076faf60519f985e8614187(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ae2c247e3262da668eb48bcf194a513483c182205d9c026a28a1686d1b9b8c94(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__95d81eb1e36bb84b56b0efc449bea4910f5d9fbf402567d85c943816a92b241c(
    value: typing.Optional[ContainerClusterNodePoolQueuedProvisioning],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__84ad1c885c19a96557e19b25cb4132a6b7c86aa72abcaa300bc71d27e46abb95(
    *,
    blue_green_settings: typing.Optional[typing.Union[ContainerClusterNodePoolUpgradeSettingsBlueGreenSettings, typing.Dict[builtins.str, typing.Any]]] = None,
    max_surge: typing.Optional[jsii.Number] = None,
    max_unavailable: typing.Optional[jsii.Number] = None,
    strategy: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4c531a467ea7b9359a505c7bb3131f847ccb4a92d5aa3d54dfc569d84e1ffe0e(
    *,
    standard_rollout_policy: typing.Union[ContainerClusterNodePoolUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy, typing.Dict[builtins.str, typing.Any]],
    node_pool_soak_duration: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d4470d58db47fa37ebb74584453724484d48951ff2f5383e8d4721ef1a637193(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__552e87b3da502e4c2c4d0f6515586f9b56ad89edee23657621faeb3b7d764a33(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ca1576ef93d4f8b25b508081b0fcee9f080aceb412e652348e91e1cbd12824a8(
    value: typing.Optional[ContainerClusterNodePoolUpgradeSettingsBlueGreenSettings],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__209ac63d6eae326ebda1a5382ac1152192280883009462d8b17f05d80897b8b3(
    *,
    batch_node_count: typing.Optional[jsii.Number] = None,
    batch_percentage: typing.Optional[jsii.Number] = None,
    batch_soak_duration: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2db8c3359efddcac4e786078f50c3b50d2e2768d944061e3ab4298be73452988(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e4da55ee10d9bf5562ddc15930da8bdb958be7fc8904b82adb311caaf3f4b620(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7996fb36ce3c2f48d06351d16da721cd337ca604de5500e09e82fffe8151c62c(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d16a1afe7f1b452d8b4963334050eff070ef0c32acf93fd12c7169ac560bbaf3(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__29950eaf2be55b0985fa13b48418c4597be5337e5ba835fdd34d680b9e29b078(
    value: typing.Optional[ContainerClusterNodePoolUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__70a571a89b6b6771ae2db9bb405a6b34f691bdeceec9b8cc691bc297f8aa919c(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__abc6a07be27782c3d02847ab1db6868b38143573f257e881e6f14cdfd6db84c4(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7130e073dae37a430d47828d690957ec5146f710b4cd836f0cbee25b78a73241(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c4f03e583f5f8da5803c90c9527c6373edd69779f6ca320bcdac99be66275723(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eb115a9a571bb99cda030411e2997edc205bfb0e7f916268d494a5969f949b11(
    value: typing.Optional[ContainerClusterNodePoolUpgradeSettings],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ef024d94e99c3464671fd4ea4155372ed7dd78594478ff258ade493d8c881e63(
    *,
    pubsub: typing.Union[ContainerClusterNotificationConfigPubsub, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a132251ccff1aa63fff2c489e30fdc99e6acd8494fb74bd08d4c61600acd2e87(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ce023d46357d2ee14c0fdad9f77a5f7492004c8ba8de7eb6fc6064919f5b5c8e(
    value: typing.Optional[ContainerClusterNotificationConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5db1897a226802835b59e7e14f5e61923bf69bdf5c7d8dbb967af15fc4780199(
    *,
    enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    filter: typing.Optional[typing.Union[ContainerClusterNotificationConfigPubsubFilter, typing.Dict[builtins.str, typing.Any]]] = None,
    topic: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__48eb324acba6700db72efab299210df022d8cb1c4989fd9766ce4b7fad131e30(
    *,
    event_type: typing.Sequence[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__50e35a812a01a48aeefd379f74551a6608f997c89e316d0d33d0499d6f37485f(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c5035b68ed4b7db6834f6f1667a46b63bae53f45e5ee5487f13b4b7ee7a073fd(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9d92ef4c78b1f5a624156c1adedf8671cd243341c370fbd5f4226a00ffc6f7a7(
    value: typing.Optional[ContainerClusterNotificationConfigPubsubFilter],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5bd4bbe01da6b582fc567f6880df4dc6abd3775a2ffecf5261ab31eef6becdf4(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__645b563accbcb9acf29af435703d43c317497e4489fc452e110cff650d62a1db(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__44c62dfda69ee888068ab6f222a7703c6fd55f6ad5d5f2df6de8509b70f3899a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__82399ad8df1c503da18d1a60469f44c1201eeb95e1e437b6154a42e0f6f6c8a8(
    value: typing.Optional[ContainerClusterNotificationConfigPubsub],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__367e1932a6a265ff38b22d577ebc3882aa2da7eba8d24648940d6788fdb11e98(
    *,
    hpa_profile: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__54614e627ff9907d9e66c9ebad715c4a0434e03df13109db4e627682ed6aed67(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6f210841a9032c1b615608418e17eba1eed5922d7fa0c745acec6824166357de(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d5bd68bb179054893b53e0f16ac1b9b74ccee1d1ebcf61fb2eda79b48b617f63(
    value: typing.Optional[ContainerClusterPodAutoscaling],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d158a60f1805765cb0e17481219cb23e719468db70e281716bb5bf9b653f09e7(
    *,
    enable_private_endpoint: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    enable_private_nodes: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    master_global_access_config: typing.Optional[typing.Union[ContainerClusterPrivateClusterConfigMasterGlobalAccessConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    master_ipv4_cidr_block: typing.Optional[builtins.str] = None,
    private_endpoint_subnetwork: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__263d5b660f522235058ecb06c1c71aa35d0597302f7f2fc71cadcf2b2a441042(
    *,
    enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eddebe2880da91133f78e9d71dc0ee70be18db92678f7384e2697f80884542c0(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__586ec22f66ba2d406cd3c3cd1ec5d163d43185f7e43d2d8c4963a2e2d1cae505(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__57da359dcb4b68369ab675636e4698a11a0ba6dd726c3f214040049a9feadc77(
    value: typing.Optional[ContainerClusterPrivateClusterConfigMasterGlobalAccessConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fe9f4c4891d1edd8fbc04cccd26e35a0a7a9ce8ef55a15e987a0b3c23dde0d3d(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__89c038692138bb4fd68437a8f2c59012fe7783027db95baf85e00912fd15e5de(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c87f92a2a841235686489b8360a551805f507267523a9c7b556e6dd47ee2c589(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__35a0de6689cd0707a44a2c960b6367e75cbb12c56acfc4bce96d69f4d9cf6c62(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6c8ccca85db7e83d3d95836d1fa13084d0f205d988ebfd1b5d4c52ff45363b77(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__694c4cc0c45c7a47930cde4b1c1f0ca626f5e204cde7a4e31f8426f7d21c995f(
    value: typing.Optional[ContainerClusterPrivateClusterConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8e50006c8fc7f9916d772c2bf66ee3247de302c42fde8e5dd810f1fbc8e8a78d(
    *,
    enable_insecure_binding_system_authenticated: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    enable_insecure_binding_system_unauthenticated: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b9f39d430660ab855b69bf90fc7ed5d0605c9bdaac90183036f2e8bc17b28243(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0139d78e7e61313746f6082db72317f55524653f65c568677afa053b59ef924f(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__96e41b251ee10c2e3317d6e465c3066a54275440a5b8b710fe5ce2ad6f157bcf(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e2f5bfc47d8f529e197d9a4e2e95b584400b8fa28b7f7e4ea6d164740ee1454c(
    value: typing.Optional[ContainerClusterRbacBindingConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dcd4ef1c3abe6b11c63feaa82d64a899488c6a6b4558a3320b856fcda679e148(
    *,
    channel: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fb27e88f64893e4a9abd34b820de5c87e99f7c59aca8391c9d510329e3d2e98b(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__59d45c6b9f2a020d0b96d451267d8eb3908b67c44e728dbcde1ae6420e723b60(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d9edfb6fee70bb9c30c057e84b0e4473099472a635ab57cc5cf838d915975459(
    value: typing.Optional[ContainerClusterReleaseChannel],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__04c2f73000b1cacc47f4ad2326c76d769c88f68fbb392df0973a277fd0d11956(
    *,
    bigquery_destination: typing.Union[ContainerClusterResourceUsageExportConfigBigqueryDestination, typing.Dict[builtins.str, typing.Any]],
    enable_network_egress_metering: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    enable_resource_consumption_metering: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__46d422327542206c2071786cf2bbd7c46bee2763b0a2131fee279f1df77b182f(
    *,
    dataset_id: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b164fb0f9b2461fd06f0c2637b77c79267adb40627d8e2b7e5906f78051dcccb(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dfc7e435fc5a175db436e88607080e08cdb4f7268dfbdb881a433ff5cb1317b9(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2767e011a021fe674acdfc45a13b56ad8cf82675e7d6ccd2a63644beb1a1d5d5(
    value: typing.Optional[ContainerClusterResourceUsageExportConfigBigqueryDestination],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__465167c98c5f4bde1d51a14ba7834a831f10ee398ddd6d833dd9fa6582a16615(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6282063d404766add73df4a90f8209bd908f88175042b03a3144ccaa9229b4f1(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3664ff325d6b3878ce93106eb397dc194238d8b44a5e3eab4bc6b72d2d276fa0(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__97cbc5809524357bc363bbb99c717f414719f2094e47734cd5c0d1db0f69343c(
    value: typing.Optional[ContainerClusterResourceUsageExportConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__92fa0631ade9233286e3f6b0a43ae22d581fc0a431c1560d4b05ffdc4fe9c236(
    *,
    enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__20ad5755273c730a07c230697b4f92ad05930103c89c765b3e718775c12d46e2(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bb9a74ecd280f05068591d849786cf862b11b755f71fb9d951bc283cd25a8895(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6b6903029708137cf1393685954a5ab9c79be64876a7739477ba12eea357ba09(
    value: typing.Optional[ContainerClusterSecretManagerConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d1d58312b705d0848fb44e3894ebc38dc88bd6c8a7b95fd2f32f203a8a868e53(
    *,
    mode: typing.Optional[builtins.str] = None,
    vulnerability_mode: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b8e87333bc6613a3f0e8c3a3c022cc8275f60d25ccd153d8cf81f1cab4ac5754(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4b0bcfefbffd9193b334275b6c15c84d5b7acdd11182d38ab1fb2fed3080580b(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__24646e1814b6c68d1da405027d7f0b1ad499fce59b0f05ff8a04532e12aab70a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1c4182ff7d73920b37101965d1406c02a8b01e816ec4dbaa027ee5e200bd9d12(
    value: typing.Optional[ContainerClusterSecurityPostureConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__16f9337bd961dd07acf0866012b853c89c9065d9d83c175aea7fe50605c59588(
    *,
    enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__25eae22b580be46a37717830b08cdf494d2df1c350fedde1b55fc2082eed1131(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__09d7657d486f31b01f547d757a654e7daa1806671dd3b44d32efdc11ef31a8ea(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__79212bc8364725323b5041b65699ea4e35b23a3f4f5d08dd233cd4fb20bc279c(
    value: typing.Optional[ContainerClusterServiceExternalIpsConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__01589ad40269d86c0a2ac99404f40a824fb9f3a8e466fb429cb38171272085ed(
    *,
    create: typing.Optional[builtins.str] = None,
    delete: typing.Optional[builtins.str] = None,
    read: typing.Optional[builtins.str] = None,
    update: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9805da06bf8934785411a74a1adec198411bfe4d5c5ec85586bd41e1161e82b9(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0f053a33a8a28b4ce73607e9b5103a9663f80ab7e91e1ed903c9f76adac623cc(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c8db229541431b094f2ffc367ee89b833145d6daf08533ec8627283c56e1b4ec(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__433a3340a39aa45b9fea39c5bc2fae41d7ded16c433b688c74e9514417f59314(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__392cbb0dce954d7c2a5db8819537464ffc6fa1ccc80a28d892dcc63a08748673(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__360ec49d022ecd12ecb02a52a6403a6c5c3ae6f77e92bac4490dab420ad90124(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ContainerClusterTimeouts]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__57c425e3acf7f9163f91161561e9972907cb2522327898d4e9a0e87502a47916(
    *,
    aggregation_ca: typing.Optional[builtins.str] = None,
    cluster_ca: typing.Optional[builtins.str] = None,
    control_plane_disk_encryption_key: typing.Optional[builtins.str] = None,
    etcd_api_ca: typing.Optional[builtins.str] = None,
    etcd_peer_ca: typing.Optional[builtins.str] = None,
    gkeops_etcd_backup_encryption_key: typing.Optional[builtins.str] = None,
    service_account_signing_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
    service_account_verification_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ad0b787361e7655d43a5f048d7333eed62f3900851ee5f6cdd7924f44d47e38a(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fe122d86887f645f3ca1c0dd3e67e777c457a5264ff5d1ec33a295b0f874a210(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__538f4b042cd9d4eab4ff39e74f699540e9c3944d5d8129521174494ba182a52c(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c38e1c4a2447306f9c8bd7ca7af78963ff8885fae16322026b91aeab122af783(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__43d4d56eba5a25559fd12a34ba254e1b1698e0b4a707df3b755e542605db5ab5(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a38b0820b97ceea127b846c918fab0940e4a02c0ff0e4f982d915bcb3133b85c(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6d2ca22482f04f4261bc12ca3df4007e39c6405ba2d0b3af0e83cc8e26cc2a48(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__991c6be0e12073760344a98bcfb6ab3fa5976efb0d07819a99c365571c190b4c(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c7d8855a314232d33e14c6a56d5e33a062e04b4fc335182f50069527a7629350(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__517bf4316db8500711871ee2ee80d3bb27635428ddbb2d56b434bf03fbaf2dae(
    value: typing.Optional[ContainerClusterUserManagedKeysConfig],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__719c6f14c481e8c53f898f0566b10cee9813b846685aa493657c158b3f168783(
    *,
    enabled: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b251cb7ceebfde916978ba08740f67aa9f65f0248061e66a64ac8a099850b51f(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3e4bb62dc5a6d38240b4257ca567e96b41ccd4bd838024d1294ac868bfd5d6dc(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__776d453e7569a936ddb8d5b345460bd673ce9da731fbf428f7c31b4c332a5e42(
    value: typing.Optional[ContainerClusterVerticalPodAutoscaling],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ac8af8f217da4566399eb2b5000faf5182fc76ebb46496eb2be4445fb24e04e4(
    *,
    workload_pool: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ae3fdbd9cefdf2385fa2e713de8623a50c6186f30e16fc3bb8b6b899b462e38c(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7e3025e520fe6a0b53c15539e5dd789d11691b5838d647033641be33de76c9ea(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e1dd689a9478b2fe84a72a16a0fc0808a2fae948766e89984dbffee4b60ec8ed(
    value: typing.Optional[ContainerClusterWorkloadIdentityConfig],
) -> None:
    """Type checking stubs"""
    pass
