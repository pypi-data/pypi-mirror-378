# Copyright (C) 2025 Livrädo Sandoval
# Licensed under GPL-3.0

import dbm
import json
import time
import portalocker
import errno
import logging
from pathlib import Path
from typing import Optional, Dict, Any
from bloom_filter2 import BloomFilter

# Default cache directory
DEFAULT_CACHE_DIR = Path.home() / ".cache" / "pipq"
DEFAULT_DB_PATH = DEFAULT_CACHE_DIR / "vuln.db"

# 1 week in seconds
DEFAULT_CACHE_EXPIRATION = 7 * 24 * 60 * 60

class VulnerabilityDB:
    """
    Manages the local vulnerability database (using Python's dbm).
    Improved with proper lock handling and cross-platform support using portalocker.
    """
    def __init__(self, db_path: Path = DEFAULT_DB_PATH, timeout: float = 10.0):
        self.db_path = db_path
        self.db_path.parent.mkdir(parents=True, exist_ok=True)
        self.lock_file = self.db_path.with_suffix('.lock')
        self.db: Optional[Any] = None
        self._lock_fd: Optional[Any] = None
        self.timeout = timeout
        self._lock_acquired = False
        self.fallback_cache = FileBasedVulnerabilityCache()

    def __enter__(self):
        logger = logging.getLogger(__name__)
        logger.debug("Entering VulnerabilityDB context.")
        try:
            self.db = self._open_with_timeout()
            return self
        except Exception as e:
            logger.warning(f"Could not open vulnerability cache: {e}")
            return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.db:
            try:
                self.db.close()
            except Exception as e:
                logger.warning(f"Error closing vulnerability DB: {e}")
            finally:
                self.db = None

        if self._lock_acquired and self._lock_fd:
            try:
                portalocker.unlock(self._lock_fd)
                self._lock_fd.close()
            except Exception as e:
                logger.warning(f"Error unlocking/closing lock file: {e}")
            finally:
                self._lock_fd = None
                self._lock_acquired = False

    def _open_with_timeout(self):
        start_time = time.time()
        last_exception = None

        while time.time() - start_time < self.timeout:
            try:
                # Acquire lock on separate lock file first
                self._lock_fd = open(self.lock_file, 'w')
                portalocker.lock(self._lock_fd, portalocker.LOCK_EX | portalocker.LOCK_NB)
                self._lock_acquired = True

                # Now open the database safely
                db_file_path = str(self.db_path)
                db = dbm.open(db_file_path, 'c')
                return db
            except (portalocker.LockException, OSError) as e:
                last_exception = e
                if isinstance(e, OSError) and e.errno in (errno.EAGAIN, errno.EACCES):
                    time.sleep(0.1)
                    continue
                elif isinstance(e, portalocker.LockException):
                    time.sleep(0.1)
                    continue
                else:
                    # Release lock if acquired but db open failed
                    if self._lock_acquired and self._lock_fd:
                        try:
                            portalocker.unlock(self._lock_fd)
                            self._lock_fd.close()
                        except:
                            pass
                        finally:
                            self._lock_fd = None
                            self._lock_acquired = False
                    raise e

        raise TimeoutError(f"Could not open vulnerability database within {self.timeout}s. Last error: {last_exception}")

    def get_vulnerability(self, package_name: str) -> Optional[Dict[str, Any]]:
        logger = logging.getLogger(__name__)

        # Try DBM cache first
        if self.db:
            key = f"vuln:{package_name}"
            try:
                if key.encode('utf-8') not in self.db:
                    logger.debug(f"DBM cache miss for vulnerability: {package_name}")
                else:
                    cached_data = self.db[key.encode('utf-8')]
                    data = json.loads(cached_data.decode('utf-8'))
                    if time.time() - data.get("timestamp", 0) > DEFAULT_CACHE_EXPIRATION:
                        logger.info(f"DBM cache expired for vulnerability: {package_name}")
                    else:
                        logger.debug(f"DBM cache hit for vulnerability: {package_name}")
                        return data.get("vulnerabilities")
            except (json.JSONDecodeError, KeyError, TypeError, dbm.error) as e:
                logger.warning(f"Error reading DBM cache for {package_name}: {e}")

        # Fallback to file-based cache
        logger.debug(f"Trying file-based cache for vulnerability: {package_name}")
        return self.fallback_cache.get_vulnerability(package_name)

    def update_vulnerability(self, package_name: str, vulnerabilities: Dict[str, Any]):
        logger = logging.getLogger(__name__)

        # Try DBM cache first
        if self.db:
            key = f"vuln:{package_name}"
            logger.debug(f"Updating DBM cache for {package_name}")
            data = {
                "timestamp": time.time(),
                "vulnerabilities": vulnerabilities,
            }

            try:
                self.db[key.encode('utf-8')] = json.dumps(data).encode('utf-8')
                return  # Success, no need for fallback
            except (dbm.error, OSError) as e:
                logger.warning(f"Could not update DBM cache for {package_name}: {e}")

        # Fallback to file-based cache
        logger.debug(f"Updating file-based cache for {package_name}")
        self.fallback_cache.update_vulnerability(package_name, vulnerabilities)

    def close(self):
        """Manually close the database and release lock."""
        if self.db:
            try:
                self.db.close()
            except Exception as e:
                logger.warning(f"Error closing vulnerability database: {e}")
            finally:
                self.db = None

        if self._lock_acquired and self._lock_fd:
            try:
                portalocker.unlock(self._lock_fd)
                self._lock_fd.close()
            except Exception as e:
                logger.warning(f"Error unlocking/closing lock file: {e}")
            finally:
                self._lock_fd = None
                self._lock_acquired = False

class FileBasedVulnerabilityCache:
    """
    Fallback vulnerability cache using individual JSON files instead of DBM.
    Used when DBM is not available or has locking issues.
    """
    def __init__(self, cache_dir: Path = DEFAULT_CACHE_DIR):
        self.cache_dir = cache_dir / "vuln_cache"
        self.cache_dir.mkdir(parents=True, exist_ok=True)

    def get_vulnerability(self, package_name: str) -> Optional[Dict[str, Any]]:
        logger = logging.getLogger(__name__)
        """Get vulnerability data from individual JSON file."""
        cache_file = self.cache_dir / f"{package_name}.json"
        
        if not cache_file.exists():
            logger.debug(f"File cache miss for vulnerability: {package_name}")
            return None
            
        try:
            with open(cache_file, 'r') as f:
                data = json.load(f)
                
            if time.time() - data.get("timestamp", 0) > DEFAULT_CACHE_EXPIRATION:
                # Cache expired, remove file
                logger.info(f"File cache expired for vulnerability: {package_name}")
                cache_file.unlink(missing_ok=True)
                return None
            
            logger.debug(f"File cache hit for vulnerability: {package_name}")
            return data.get("vulnerabilities")
        except (json.JSONDecodeError, IOError) as e:
            logger.warning(f"Error reading vulnerability cache file for {package_name}: {e}")
            return None

    def update_vulnerability(self, package_name: str, vulnerabilities: Dict[str, Any]):
        logger = logging.getLogger(__name__)
        """Update vulnerability data in individual JSON file."""
        logger.debug(f"Updating file cache for {package_name}")
        cache_file = self.cache_dir / f"{package_name}.json"
        data = {
            "timestamp": time.time(),
            "vulnerabilities": vulnerabilities,
        }
        
        try:
            with open(cache_file, 'w') as f:
                json.dump(data, f)
        except IOError as e:
            logger.warning(f"Could not update vulnerability cache file for {package_name}: {e}")


class VulnerabilityCache:
    def __init__(self):
        self.bloom_filter = BloomFilter(capacity=100000, error_rate=0.001)

    def check_vulnerability(self, package: str, version: str):
        key = f"{package}:{version}"
        if key not in self.bloom_filter:
            return None  # Definitivamente no vulnerable
        # Si está en bloom filter, verificar en DB real