# Copyright (C) 2025 LivrÃ¤do Sandoval
# Licensed under GPL-3.0

"""
Validator to detect suspicious patterns in package files, indicative of malware.
"""
import os
import re
from typing import Dict, Any, Optional

from ..core.base_validator import BaseValidator
from ..core.config import Config

class MalwareDetector(BaseValidator):
    """
    Scans all files in a package for suspicious string patterns,
    such as encoded payloads, IP addresses, and cryptocurrency-related keywords.
    """
    name = "Malware Detector"
    category = "Security"
    description = "Detects suspicious patterns in package files."

    def __init__(self, pkg_name: str, metadata: Dict[str, Any], config: Config, extracted_path: Optional[str] = None, downloaded_file_path: Optional[str] = None) -> None:
        super().__init__(pkg_name, metadata, config, extracted_path=extracted_path, downloaded_file_path=downloaded_file_path)

    def _validate(self) -> None:
        if not self.extracted_path:
            self.add_info("Malware Detection", "Skipped (package not extracted).")
            return

        for root, _, files in os.walk(self.extracted_path):
            for file in files:
                file_path = os.path.join(root, file)
                try:
                    with open(file_path, "r", encoding="utf-8", errors="ignore") as f:
                        content = f.read(1024 * 1024)  # Max 1MB
                        self._find_suspicious_patterns(content, file_path)
                except (IOError, OSError):
                    # Could be a binary file, or we don't have permission. Skip it.
                    continue

    def _find_suspicious_patterns(self, content: str, file_path: str) -> None:
        # 1. Long encoded strings (Base64-like)
        # This regex looks for long strings of Base64 characters.
        # It's not perfect but can be a good indicator.
        for match in re.finditer(r'[A-Za-z0-9+/=]{50,}', content):
            self.add_warning(f"Found long, potentially encoded string in {file_path} (at position {match.start()})")

        # 2. Hex strings
        for match in re.finditer(r'(?:[0-9a-fA-F]{2}){20,}', content):
             self.add_warning(f"Found long, potentially hex-encoded string in {file_path} (at position {match.start()})")

        # 3. IP Addresses
        for match in re.finditer(r'\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b', content):
            ip = match.group(0)
            # Exclude private and loopback addresses to reduce noise
            if not (ip.startswith("192.168.") or ip.startswith("10.") or ip.startswith("172.16.") or ip == "127.0.0.1"):
                self.add_warning(f"Found public IP address {ip} in {file_path}")

        # 4. Crypto keywords
        crypto_keywords = ["cryptonight", "monero", "stratum", "xmr-stak"]
        for keyword in crypto_keywords:
            if keyword in content.lower():
                self.add_warning(f"Found cryptocurrency-related keyword '{keyword}' in {file_path}")
