# Copyright (C) 2025 Livrädo Sandoval
# Licensed under GPL-3.0

import json
from pathlib import Path
import time
import requests
from packaging.specifiers import SpecifierSet
from packaging.version import parse as parse_version

from ..core.base_validator import BaseValidator
from ..utils.vulnerability_db import VulnerabilityDB
from typing import Dict, Any, List
from ..core.config import Config


class VulnerabilityValidator(BaseValidator):
    """
    Validator that checks for known security vulnerabilities using OSV, Safety DB, Snyk, and Semgrep.

    This validator queries vulnerability data from multiple sources to detect
    whether a given version of a package is affected by known security issues. It provides
    warnings or errors depending on the severity and source of the information.
    """

    name = "Vulnerabilities"
    category = "Security"
    description = "Detects known vulnerabilities in packages using multiple sources"

    # API endpoints
    OSV_API_URL = "https://api.osv.dev/v1/query"
    SNYK_API_URL = "https://snyk.io/api/v1/vuln/pypi/"

    def __init__(self, pkg_name: str, metadata: Dict[str, Any], config: Config, **kwargs):
        super().__init__(pkg_name, metadata, config)
        self.timeout = self.config.get("validators.Vulnerabilities.timeout", 30)
        self.db_timeout = self.config.get("db_timeout", 10)
        self.snyk_api_key = self.config.get("api_keys.snyk")

    def _validate(self) -> None:
        """
        Validates the package by checking for vulnerabilities from multiple sources.
        """
        pkg_name = self.get_metadata_field("name")
        version = self.get_metadata_field("version")

        if not pkg_name:
            self.add_warning("Could not determine package name, skipping vulnerability check.")
            return
        if not version or version == 'latest':
            self.add_warning(f"Could not determine version for '{pkg_name}', skipping vulnerability check.")
            return

        self._check_osv(pkg_name, version)
        self._check_safety_db(pkg_name, version)
        self._check_snyk(pkg_name, version)
        self._check_semgrep_rules(pkg_name, version)

    def _check_osv(self, pkg_name: str, version: str) -> None:
        """
        Checks for vulnerabilities using the OSV API.
        """
        # ✅ Instanciar VulnerabilityDB solo cuando se necesite y usar context manager
        try:
            with VulnerabilityDB(timeout=self.db_timeout) as db:
                vulnerabilities = db.get_vulnerability(pkg_name)

                if vulnerabilities is None:
                    vulnerabilities = self._fetch_osv_vulnerabilities(pkg_name)
                    db.update_vulnerability(pkg_name, vulnerabilities)

                if not vulnerabilities or not vulnerabilities.get("vulns"):
                    self.add_info("Vulnerability Scan (OSV)", f"No known vulnerabilities found for v{version}.")
                    return

                for vuln in vulnerabilities["vulns"]:
                    if self._is_version_affected(version, vuln.get("affected", [])):
                        summary = vuln.get('summary', 'No summary available.')
                        osv_id = vuln.get('id', 'N/A')
                        self.add_error(f"Vulnerability Found (OSV): {osv_id} - {summary}")
        except Exception as e:
            # ✅ Manejo graceful de errores de DBM
            self.add_warning(f"Could not check OSV vulnerability database: {e}")
            # Fallback: consultar OSV directamente sin caché
            self._check_osv_direct(pkg_name, version)

    def _check_osv_direct(self, pkg_name: str, version: str) -> None:
        """
        Fallback method to check OSV directly without caching.
        """
        try:
            vulnerabilities = self._fetch_osv_vulnerabilities(pkg_name)
            
            if not vulnerabilities or not vulnerabilities.get("vulns"):
                self.add_info("Vulnerability Scan (OSV Direct)", f"No known vulnerabilities found for v{version}.")
                return

            for vuln in vulnerabilities["vulns"]:
                if self._is_version_affected(version, vuln.get("affected", [])):
                    summary = vuln.get('summary', 'No summary available.')
                    osv_id = vuln.get('id', 'N/A')
                    self.add_error(f"Vulnerability Found (OSV): {osv_id} - {summary}")
        except Exception as e:
            self.add_warning(f"Could not check OSV API: {e}")

    def _check_safety_db(self, pkg_name: str, version: str) -> None:
        """
        Checks for vulnerabilities using the Safety DB.
        """
        try:
            safety_db = self._get_safety_db()
            if pkg_name in safety_db:
                for spec, cve, description in safety_db[pkg_name]:
                    spec_set = SpecifierSet(spec)
                    if parse_version(version) in spec_set:
                        self.add_error(f"Vulnerability Found (Safety DB): {cve} - {description}")
        except Exception as e:
            self.add_warning(f"Could not check Safety DB: {e}")

    def _check_snyk(self, pkg_name: str, version: str) -> None:
        """
        Checks for vulnerabilities using the Snyk API.
        """
        if not self.snyk_api_key:
            self.add_info("Vulnerability Scan (Snyk)", "Premium option: configure SNYK_API_KEY for advanced vulnerability analysis.")
            return

        headers = {"Authorization": f"token {self.snyk_api_key}"}
        url = f"{self.SNYK_API_URL}{pkg_name}/{version}"

        try:
            response = requests.get(url, headers=headers, timeout=self.timeout)
            if response.status_code == 404:
                self.add_info("Vulnerability Scan (Snyk)", f"No known vulnerabilities found for v{version}.")
                return
            response.raise_for_status()
            data = response.json()
            for vuln in data.get("vulnerabilities", []):
                self.add_error(f"Vulnerability Found (Snyk): {vuln['id']} - {vuln['title']}")
        except requests.exceptions.RequestException as e:
            self.add_warning(f"Could not check Snyk: {e}")

    def _check_semgrep_rules(self, pkg_name: str, version: str) -> None:
        """
        Checks for vulnerabilities using Semgrep rules.
        This is a placeholder for a more sophisticated implementation.
        """
        self.add_info("Vulnerability Scan (Semgrep)", "Semgrep scanning is not yet implemented.")

    def _get_safety_db(self) -> Dict[str, Any]:
        """
        Fetches the Safety DB from GitHub, with local caching.
        """
        cache_path = Path.home() / ".cache" / "pipq" / "safety_db.json"
        if cache_path.exists() and time.time() - cache_path.stat().st_mtime < 3600:
            with open(cache_path, "r") as f:
                return json.load(f)

        response = requests.get("https://raw.githubusercontent.com/pyupio/safety-db/refs/heads/master/data/insecure_full.json", timeout=self.timeout)
        response.raise_for_status()
        data = response.json()

        cache_path.parent.mkdir(parents=True, exist_ok=True)
        with open(cache_path, "w") as f:
            json.dump(data, f)

        return data

    def _fetch_osv_vulnerabilities(self, package_name: str) -> Dict[str, Any]:
        """
        Fetches vulnerabilities from the OSV API.
        """
        query = {
            "package": {
                "name": package_name,
                "ecosystem": "PyPI"
            }
        }
        try:
            response = requests.post(self.OSV_API_URL, json=query, timeout=self.timeout)
            response.raise_for_status()
            return response.json()
        except requests.exceptions.RequestException as e:
            self.add_warning(f"Could not fetch vulnerability data for {package_name}: {e}")
            return {}

    def _is_version_affected(self, package_version_str: str, affected_ranges: List[Dict[str, Any]]) -> bool:
        """
        Checks if a package version is within the affected ranges from OSV.
        """
        try:
            package_version = parse_version(package_version_str)
        except Exception as e:
            self.add_warning(f"Could not parse version '{package_version_str}': {e}")
            return False # Cannot parse version, assume not affected

        for affected in affected_ranges:
            for range_info in affected.get("ranges", []):
                if range_info["type"] == "ECOSYSTEM":
                    events = range_info.get("events", [])
                    # Sort events: introduced versions first, then fixed versions
                    events.sort(key=lambda e: list(e.keys())[0] != 'introduced')
                    
                    affected_specifiers = []
                    is_affected = False

                    for event in events:
                        if 'introduced' in event:
                            version = event['introduced']
                            if version != "0": # "0" means all prior versions are affected
                                affected_specifiers.append(f">={version}")
                            is_affected = True

                        if 'fixed' in event:
                            version = event['fixed']
                            affected_specifiers.append(f"<{version}")
                            is_affected = False # No longer affected after this version
                    
                    if is_affected and not affected_specifiers:
                         # Affected from the start and never fixed
                         return True

                    if affected_specifiers:
                        spec_str = ",".join(affected_specifiers)
                        spec = SpecifierSet(spec_str)
                        if package_version in spec:
                            return True
        return False