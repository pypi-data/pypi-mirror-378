*
* optknitro.def
*

presolve boolean 1059 1 1 4 Determine whether or not to use the Knitro presolver to try to simplify the model by removing variables or constraints
 0 (no) Do not use the Knitro presolver.
 1 (yes) Enable the Knitro presolver.
tuner boolean 1070 0 1 12 Indicates whether to invoke the Knitro-Tuner
 0 (off) Do not invoke the Knitro-Tuner.
 1 (on) Invoke the Knitro-Tuner.
algorithm enumint 1003 0 1 1 Indicates which algorithm to use to solve the problem
 0 1 (auto) let Knitro automatically choose an algorithm, based on the problem characteristics.
 1 1 (direct) use the Interior/Direct algorithm.
 2 1 (cg) use the Interior/CG algorithm.
 3 1 (active) use the Active Set algorithm.
 4 1 (sqp) use the SQP algorithm.
 5 1 (multi) run all algorithms, perhaps in parallel (see Algorithms).
blasoption enumint 1042 -1 1 1 Specifies the BLAS/LAPACK function library to use for basic vector and matrix computations
 -1 1 (auto) Let Knitro automatically choose which BLAS to use.
 0 1 (knitro) Use Knitro built-in functions.
 1 1 (intel) Use Intel Math Kernel Library (MKL) functions on available platforms.
 2 1 (dynamic) Use the dynamic library specified with option blasoptionlib.
 3 1 (blis) Use BLIS functions on available platforms (currently not available on Windows OS).
 4 1 (apple) Use Apple Accelerate (only available on Mac with M1 processor).
blasoptionlib string 1045 "" 1 1 Specifies a dynamic library name that contains object code for BLAS/LAPACK functions
bndrange double 1112 1e+20 0 maxdouble 1 1 Specifies max limits on the magnitude of constraint and variable bounds
cg_maxit integer 1013 -1 -1 maxint 1 1 Determines the maximum allowable number of inner conjugate gradient (CG) iterations per Knitro minor iteration
 -1 Let Knitro automatically determine a value.
 0 Knitro will set a maximum value based on the problem size.
 n At most n&gt;0 CG iterations may be performed during one minor iteration of Knitro.
cg_pmem integer 1103 10 0 maxint 1 1 Specifies the amount of nonzero elements per column of the Hessian of the Lagrangian which are retained when computing the incomplete Cholesky preconditioner
 n At most n&gt;0 nonzero elements per column.
cg_precond boolean 1041 0 1 1 Specifies whether an incomplete Cholesky preconditioner is applied during CG iterations in barrier algorithms
 0 (no) Not applied.
 1 (chol) Preconditioner is applied.
cg_stoptol double 1099 0.01 0 maxdouble 1 1 Specifies the relative stopping tolerance used for the conjugate gradient (CG) subproblem solves
convex integer 1114 -1 -1 1 1 1 Declare the problem as convex by setting to 1 or non-convex by setting to 0
cpuplatform integer 1120 -1 -1 5 1 1 This option can be used to specify the target instruction set architecture for the machine on which Knitro is running
datacheck boolean 1087 0 1 1 Specifies whether to perform more extensive data checks to look for errors in the problem input to Knitro (in particular, this option looks for errors in the sparse Jacobian and/or sparse Hessian structure)
delta double 1020 1 9.5367431640625e-07 maxdouble 1 1 Specifies the initial trust region radius scaling factor used to determine the initial trust region size
eval_cost integer 1159 0 0 2 1 1 Use this option to tell Knitro the relative cost of performing callback (e.g. function, gradient and Hessian) evaluations
honorbnds enumint 1002 -1 1 1 Indicates whether or not to enforce satisfaction of simple variable bounds throughout the optimization
 -1 1 (auto) Knitro automatically determine the best setting.
 0 1 (no) Knitro does not require that the bounds on the variables be satisfied at intermediate iterates.
 1 1 (always) Knitro enforces that the initial point and all subsequent solution estimates satisfy the bounds on the variables.
 2 1 (initpt) Knitro enforces that the initial point satisfies the bounds on the variables.
initpenalty double 1097 10 0 maxdouble 1 1 Specifies the initial penalty parameter used in the Knitro merit functions
initpt_strategy enumint 1158 -1 1 1 Specifies the initial point strategy used for the continuous algorithms
 -1 1 (auto) Automatically determine the initial point strategy.
 1 1 (basic) Try a basic initial point strategy.
 2 1 (advanced) Try a more advanced initial point strategy.
linesearch enumint 1095 0 1 1 Indicates which linesearch strategy to use for the Interior/Direct or SQP algorithm to search for a new acceptable iterate
 0 1 (auto) Let Knitro automatically choose the strategy.
 1 1 (backtrack) Use a simple backtracking scheme.
 2 1 (interpolate) Use a cubic interpolation scheme.
 3 1 (weakwolfe) Use a linesearch that satisfies the weak Wolfe conditions (unconstrained only).
linesearch_maxtrials integer 1044 3 0 maxint 1 1 Indicates the maximum allowable number of trial points during the linesearch of the Interior/Direct or SQP algorithm before treating the linesearch step as a failure and generating a new step
linsolver enumint 1057 0 1 1 Indicates which linear solver to use to solve linear systems arising in Knitro algorithms
 0 1 (auto) Let Knitro automatically choose the linear solver.
 1 1 (internal) Not currently used; reserved for future use. Same as  auto for now.
 2 1 (hybrid) Use a hybrid approach where the solver chosen depends on the particular linear system which needs to be solved.
 3 1 (qr) Use a dense QR method.  This approach uses LAPACK QR routines. Since it uses a dense method, it is only efficient for small problems. It may often be the most efficient method for small problems with dense Jacobians or Hessian matrices.
 4 1 (ma27) Use the HSL MA27 sparse symmetric indefinite solver.
 5 1 (ma57) Use the HSL MA57 sparse symmetric indefinite solver.
 6 1 (mklpardiso) Use the Intel MKL PARDISO (parallel, deterministic) sparse symmetric indefinite solver.
 7 1 (ma97) Use the HSL MA97 (parallel, deterministic) sparse symmetric indefinite solver.
 8 1 (ma86) Use the HSL MA86 (parallel, non-deterministic) sparse symmetric indefinite solver.
linsolver_maxitref integer 1130 2 0 maxint 1 1 Indicates the maximum allowable number of iterative refinement steps applied when a linear system is solved inside Knitro
linsolver_nodeamalg integer 1145 0 0 maxint 1 1 Controls the node amalgamation setting for the MA57, MA86 and MA97 linear solvers
linsolver_ooc enumint 1076 0 1 1 Indicates whether to use Intel MKL PARDISO out-of-core solve of linear systems when \ref KNITROlinsolver "linsolver" = mklpardiso
 0 1 (no) Do not use Intel MKL PARDISO out-of-core option.
 1 1 (maybe) Maybe solve out-of-core depending on how much space is needed.
 2 1 (yes) Solve linear systems out-of-core when using Intel MKL PARDISO.
linsolver_ordering enumint 1144 -1 1 1 Sets the ordering method used for the linear system solver
 -1 1 (auto) Let Knitro automatically choose the ordering strategy.
 0 1 (best) Choose the best between AMD and METIS (try both).
 1 1 (amd) Use AMD ordering (minimum degree for MKL PARDISO).
 2 1 (metis) Use METIS ordering.
linsolver_pivottol double 1029 1e-08 0 0.5 1 1 Specifies the initial pivot threshold used in factorization routines
linsolver_scaling enumint 1156 0 1 1 Enables scaling for the linear system solver
 0 1 (none) Do not apply scaling in the linear system solves.
 1 1 (always) Always apply scaling in the linear system solves.
 2 1 (dynamic) Dynamically apply scaling in the linear system solves.
ncvx_qcqp_init enumint 1139 -1 1 1 Specifies the initialization strategy used for non-convex QPs and QCQPs
 -1 1 (auto) Knitro will automatically determine the strategy.
 0 1 (none) No special initialization strategy is used.
 1 1 (linear) Initialize by solving a linear relaxation.
 2 1 (hybrid) Initialize by solving a hybrid formulation.
 3 1 (penalty) Initialize by solving a penalty formulation.
 4 1 (cvxquad) Initialize by solving a convex quadratic relaxation.
objrange double 1026 1e+20 0 maxdouble 1 1 Specifies the extreme limits of the objective function for purposes of determining unboundedness
restarts integer 1100 -1 -1 maxint 1 1 Specifies whether or not to enable automatic restarts in Knitro
 0 No automatic restarts allowed.
 n At most n&gt;0 automatic restarts may be performed.
restarts_maxit integer 1101 0 0 maxint 1 1 When restarts are enabled, this option can be used to specify a maximum number of iterations before enforcing a restart
 0 No iteration limit on restarts enforced.
 n At most n&gt;0 iterations are allowed without convergence before enforcing an automatic restart, if restarts are enabled.
scale enumint 1017 1 1 1 Specifies whether to perform problem scaling of the objective function, constraint functions, or possibly variables
 0 1 (no) No scaling is performed.
 1 1 (user_internal) User provided scaling is used if defined, otherwise Knitro internal scaling is applied.
 2 1 (user_none) User provided scaling is used if defined, otherwise no scaling is applied.
 3 1 (internal) Knitro internal scaling is applied.
scale_vars boolean 1153 0 1 1 Specifies the strategy for scaling variables
 0 (none) No variable scaling is performed.
 1 (bnds) Scaling of variables is applied based on their bound values.
soc enumint 1019 1 1 1 Specifies whether or not to try second order corrections (SOC)
 0 1 (no) No second order correction steps are attempted.
 1 1 (maybe) Second order correction steps may be attempted on some iterations.
 2 1 (yes) Second order correction steps are always attempted if the original step is rejected and there are nonlinear constraints.
strat_warm_start boolean 1118 0 1 1 Specifies whether or not to invoke a warm-start strategy
 0 (no) No warm-start strategy is applied.
 1 (yes) Knitro will apply a warm-start strategy with special tunings.
bfgs_scaling enumint 1131 0 1 2 Specify the initial scaling to use for the BFGS or L-BFGS Hessian approximation
 0 1 (dynamic) Dynamically choose which scaling to use.
 1 1 (invhess) The scaling approximates the scale of the inverse Hessian.
 2 1 (hess) The scaling approximates the scale of the Hessian.
derivcheck enumint 1080 0 0 2 Determine whether or not to perform a derivative check on the model
 0 1 (none) Do not perform a derivative check.
 1 1 (first) Check first derivatives only.
 2 1 (second) Check second derivatives (i.e. the Hessian) only.
 3 1 (all) Check both first and second derivatives.
derivcheck_terminate enumint 1088 1 0 2 Determine whether to always terminate after the derivative check or only when the derivative checker detects a possible error
 1 1 (error) Terminate only when an error is detected.
 2 1 (always) Always terminate when the derivative check is finished.
derivcheck_tol double 1082 1e-06 0 maxdouble 0 2 Specifies the relative tolerance used for detecting derivative errors, when the Knitro derivative checker is enabled
derivcheck_type enumint 1081 1 0 2 Specifies whether to use forward or central finite differencing for the derivative checker when it is enabled
 1 1 (forward) Use forward finite differencing for the derivative checker.
 2 1 (central) Use central finite differencing for the derivative checker.
gradopt enumint 1007 1 1 2 Specifies how to compute the gradients of the objective and constraint functions
 1 1 (exact) User provides a routine for computing the exact gradients.
 2 1 (forward) Knitro computes gradients by forward finite differences.
 3 1 (central) Knitro computes gradients by central finite differences.
hessopt enumint 1008 0 1 2 Specifies how to compute the (approximate) Hessian of the Lagrangian
 0 1 (auto)
 1 1 (exact) User provides a routine for computing the exact Hessian.
 2 1 (bfgs) Knitro computes a (dense) quasi-Newton BFGS Hessian.
 3 1 (sr1) Knitro computes a (dense) quasi-Newton SR1 Hessian.
 4 1 (product_findiff) Knitro computes Hessian-vector products using finite-differences.
 5 1 (product) User provides a routine to compute the Hessian-vector products.
 6 1 (lbfgs) Knitro computes a limited-memory quasi-Newton BFGS Hessian (its size is determined by the option lmsize).
 7 1 (gauss_newton) Knitro computes a Gauss-Newton approximation of the hessian (available for least-squares only, and default value for least-squares)
lmsize integer 1038 10 1 100 1 2 Specifies the number of limited memory pairs stored when approximating the Hessian using the limited-memory quasi-Newton BFGS option
feastol double 1022 1e-06 0 maxdouble 1 3 Specifies the final relative stopping tolerance for the feasibility error
feastolabs double 1023 0.001 0 maxdouble 1 3 Specifies the final absolute stopping tolerance for the feasibility error
findiff_estnoise enumint 1140 0 1 2 This option can be used to enable an estimate of the noise in the model when using finite-difference gradients
 0 1 (no) Do not enable any noise estimation procedure for finite-difference gradients.
 1 1 (yes) Enable noise estimation procedure for finite-difference gradients.
 2 1 (withcurv) Enable noise estimation and curvature factor for finite-difference gradients.
findiff_relstepsize double 1123 0 mindouble maxdouble 1 2 Specifies the relative stepsize used for finite-difference gradients during the optimization
findiff_terminate boolean 1119 1 1 2 This option specifies the termination criteria when using finite-difference gradients
 0 (none) No special criteria; use the standard stopping conditions.
 1 (errest) Allow termination based on estimates of the finite-difference error (when no more significant progress is likely).
fstopval double 1086 maxdouble mindouble maxdouble 1 3 Used to implement a custom stopping condition based on the objective function value
ftol double 1090 1e-15 0 maxdouble 1 3 The optimization process will terminate if the relative change in the objective function is less than \ref KNITROftol "ftol" for \ref KNITROftol_iters "ftol_iters" consecutive feasible iterations
ftol_iters integer 1091 5 1 maxint 1 3 The optimization process will terminate if the relative change in the objective function is less than \ref KNITROftol "ftol" for \ref KNITROftol_iters "ftol_iters" consecutive feasible iterations
infeastol double 1056 1e-08 0 maxdouble 1 3 Specifies the (relative) tolerance used for declaring infeasibility of a model
infeastol_iters integer 1124 50 1 maxint 1 3 The optimization process will terminate if the relative change in the feasibility error is less than \ref KNITROinfeastol "infeastol" for \ref KNITROinfeastol_iters "infeastol_iters" consecutive infeas****
maxfevals integer 1085 -1 minint maxint 1 3 Specifies the maximum number of function evaluations before termination
maxit integer 1014 0 0 maxint 1 3 Specifies the maximum number of iterations before termination
 0 Let Knitro automatically choose a value based on the problem type. Currently Knitro sets this value to 10000 for LPs/NLPs and 3000 for MIP problems.
 n At most n&gt;0 iterations may be performed before terminating.
maxtime double 1163 100000000 0 maxdouble 1 3 Specifies, in seconds, the maximum allowable real time before termination
opttol double 1027 1e-06 0 maxdouble 1 3 Specifies the final relative stopping tolerance for the KKT (optimality) error
opttolabs double 1028 0.001 0 maxdouble 1 3 Specifies the final absolute stopping tolerance for the KKT (optimality) error
soltype boolean 1161 0 1 3 This option specifies the solution returned by Knitro
 0 (final) Always return the final solution to which Knitro converges.
 1 (bestfeas) Always return the best feasible solution encountered during the optimization.
xtol double 1030 1e-12 0 maxdouble 1 3 The optimization process will terminate if the relative change in all components of the solution point estimate is less than \ref KNITROxtol "xtol" for \ref KNITROxtol_iters "xtol_iters"
xtol_iters integer 1094 0 0 maxint 1 3 The optimization process will terminate if the relative change in the solution estimate is less than \ref KNITROxtol "xtol" for \ref KNITROxtol_iters "xtol_iters" consecutive iterations
presolve_level enumint 1122 -1 1 4 Set the level of presolve operations to enable through the Knitro presolver
 -1 1 (auto) Let Knitro automatically choose the presolve level.
 1 1 (level1) Enable the most basic presolve operations.
 2 1 (level2) Enable more advanced presolve operations.
presolve_initpt enumint 1127 -1 1 4 Control whether the Knitro presolver can shift a user-supplied initial point
 -1 1 (auto) Let Knitro automatically choose whether to allow shifting.
 0 1 (noshift) Do not allow presolver to shift user-supplied initial point.
 1 1 (linshift) Allow presolver to shift user-supplied initial point if it only appears in linear constraints.
 2 1 (anyshift) Allow presolver to shift any user-supplied initial point.
presolve_passes integer 1121 10 0 maxint 1 4 Set a maximum limit on the number of passes through the Knitro presolve operations
presolve_tol double 1060 1e-06 0 maxdouble 1 4 Determines the tolerance used by the Knitro presolver to remove variables and constraints from the model
presolveop_redundant enumint 1143 1 1 4 Determine whether or not to enable the Knitro presolve operation to detect and remove redundant constraints
 0 1 (none) Do not remove redundant constraints.
 1 1 (dupcon) Detect and remove duplicate constraints.
 2 1 (depcon) Detect and remove linearly dependent constraints.
presolveop_substitution enumint 1146 -1 1 4 Determine whether or not to enable the Knitro presolve operation to substitute out variables when possible
 -1 1 (auto) Automatically determined (may depend on the algorithm).
 0 1 (none) Do not perform any variable substitution.
 1 1 (simple) Enable simple substitutions involving doubleton equality constraints.
 2 1 (all) Enable all possible variable substitutions.
presolveop_substitution_tol double 1147 0.01 0 maxdouble 1 4 Tolerance for applying a substitution
presolveop_tighten enumint 1125 -1 1 4 Determine whether or not to enable the Knitro presolve operation to tighten variable bounds or coefficients
 -1 1 (auto) Automatically determined (may depend on the algorithm).
 0 1 (none) Do not tighten variable bounds (unless it removes a constraint).
 1 1 (varbnd) Enable tightening variable bounds always.
 2 1 (coef) Enable tightening coefficients in linear constraints.
 3 1 (all) Enable tightening variable bounds and coefficients.
bar_conic_enable enumint 1113 -1 1 5 Enable special treatments for conic constraints when using the Interior/Direct algorithm (has no affect when using the Interior/CG algorithm)
 -1 1 (auto) Let Knitro automatically choose the strategy.
 0 1 (none) Do not apply any special treatment for conic constraints.
 1 1 (soc) Apply special treatments for any Second Order Cone (SOC) constraints identified in the model.
bar_directinterval integer 1058 -1 -1 maxint 1 5 Controls the maximum number of consecutive conjugate gradient (CG) steps before Knitro will try to enforce that a step is taken using direct linear algebra
bar_feasible enumint 1006 0 1 5 Specifies whether special emphasis is placed on getting and staying feasible in the interior-point algorithms
 0 1 (no) No special emphasis on feasibility.
 1 1 (stay) Iterates must satisfy inequality constraints once they become sufficiently feasible.
 2 1 (get) Special emphasis is placed on getting feasible before trying to optimize.
 3 1 (get_stay) Implement both options 1 and 2 above.
bar_feasmodetol double 1021 0.0001 0 maxdouble 1 5 Specifies the tolerance in equation that determines whether Knitro will force subsequent iterates to remain feasible
bar_globalize enumint 1155 2 1 5 Specifies the globalization strategy used in the interior-point algorithms
 0 1 (none) No globalization strategy is applied.
 1 1 (kkt) Apply a globalization strategy based on decreasing the KKT error.
 2 1 (filter) Apply a globalization strategy using a filter based on the objective and constraint violation.
bar_initmu double 1025 -1 mindouble maxdouble 1 5 Specifies the initial value for the barrier parameter \f$\mu\f$ used with the barrier algorithms
bar_initpi_mpec double 1093 0 0 maxdouble 1 5 Specifies the initial value for the MPEC penalty parameter \f$\pi\f$ used when solving problems with complementarity constraints using the barrier algorithms
bar_initpt enumint 1009 0 1 5 Indicates initial point strategy for x, slacks and multipliers when using a barrier algorithm
 0 1 (auto) Let Knitro automatically choose the strategy.
 1 1 (convex) Initialization designed for convex models.
 2 1 (nearbnd) Initialization strategy that stays closer to the bounds.
 3 1 (central) Initialization strategy that is more central on double-bounded variables.
bar_linsys enumint 1126 -1 1 5 Indicates which linear system form is used inside the Interior/Direct algorithm for computing primal-dual steps
 -1 1 (auto) Let Knitro automatically choose the linear system form.
 0 1 (full) Use the full linear system.
 1 1 (slacks) Eliminate the slack variables.
 2 1 (bounds) Eliminate the slack variables and bounds.
 3 1 (ineqs) Eliminate the slack variables, bounds, and some inequalities.
bar_linsys_storage enumint 1129 -1 1 5 Indicates how to store in memory the linear systems used inside the Interior/Direct algorithm for computing primal-dual steps
 -1 1 (auto) Let Knitro automatically choose the linear system storage approach.
 1 1 (lowmem) Use common storage for multiple linear systems.
 2 1 (normal) Use separate storage for different linear systems.
bar_maxcorrectors integer 1117 -1 -1 maxint 1 5 Specifies the maximum number of corrector steps allowed for primal-dual steps
bar_maxcrossit integer 1039 0 0 maxint 1 5 Specifies the maximum number of crossover iterations before termination
bar_maxmu double 1154 1e+16 2.08157871384174e-07 1e+16 1 5 Specifies the maximum allowable value for the barrier parameter \f$\mu\f$ used with the barrier algorithms
bar_maxrefactor integer 1043 -1 -1 maxint 1 5 Indicates the maximum number of refactorizations of the KKT system per iteration of the Interior/Direct algorithm before reverting to a CG step
bar_mpec_heuristic boolean 1142 0 1 5 Specifies whether or not to use a heuristic approach when solving MPEC models with the barrier algorithm
 0 (no) Do not enable the heuristic for MPEC models.
 1 (yes) Enable the heuristic for MPEC models.
bar_murule enumint 1004 0 1 5 Indicates which strategy to use for modifying the barrier parameter \f$mu\f$ in the barrier algorithms
 0 1 (auto) Let Knitro automatically choose the strategy.
 1 1 (monotone) Monotonically decrease the barrier parameter. Available for both barrier algorithms.
 2 1 (adaptive) Use an adaptive rule based on the complementarity gap to determine the value of the barrier parameter. Available for both barrier algorithms.
 3 1 (probing) Use a probing (affine-scaling) step to dynamically determine the barrier parameter. Available only for the Interior/Direct algorithm.
 4 1 (dampmpc) Use a Mehrotra predictor-corrector type rule to determine the barrier parameter, with safeguards on the corrector step. Available only for the Interior/Direct algorithm.
 5 1 (fullmpc) Use a Mehrotra predictor-corrector type rule to determine the barrier parameter, without safeguards on the corrector step. Available only for the Interior/Direct algorithm.
 6 1 (quality) Minimize a quality function at each iteration to determine the barrier parameter. Available only for the Interior/Direct algorithm.
bar_penaltycons enumint 1050 -1 1 5 Indicates whether a penalty approach is applied to the constraints
 -1 1 (auto) Let Knitro automatically choose the strategy.
 0 1 (none) No constraints are penalized.
 2 1 (all) A penalty approach is applied to all general constraints.
 3 1 (equalities) Apply a penalty approach to equality constraints only.
bar_penaltyrule enumint 1049 0 1 5 Indicates which penalty parameter strategy to use for determining whether or not to accept a trial iterate
 0 1 (auto) Let Knitro automatically choose the strategy.
 1 1 (single) Use a single penalty parameter in the merit function to weight feasibility versus optimality.
 2 1 (flex) Use a more tolerant and flexible step acceptance procedure based on a range of penalty parameter values.
bar_refinement boolean 1079 0 1 5 Specifies whether to try to refine the barrier solution for better precision
bar_relaxcons enumint 1077 2 1 5 Indicates whether a relaxation approach is applied to the constraints
 0 1 (none) No constraints are relaxed.
 1 1 (eqs) A relaxation approach is applied to general equality constraints.
 2 1 (ineqs) A relaxation approach is applied to general inequality constraints.
 3 1 (all) A relaxation approach is applied to all general constraints.
bar_slackboundpush double 1102 -1 mindouble maxdouble 1 5 Specifies the amount by which the barrier slack variables are initially pushed inside the bounds
bar_switchobj enumint 1104 1 1 5 Indicates which objective function to use when the barrier algorithms switch to a pure feasibility phase
 0 1 (none) No (or zero) objective.
 1 1 (scalarprox) Proximal point objective with scalar weighting.
 2 1 (diagprox) Proximal point objective with diagonal weighting.
bar_switchrule enumint 1061 -1 1 5 Indicates whether or not the barrier algorithms will allow switching from an optimality phase to a pure feasibility phase
 -1 1 (auto) Let Knitro determine the switching procedure.
 0 1 (never) Never switch to feasibility phase.
 2 1 (moderate) Allow switches to feasibility phase.
 3 1 (aggressive) Use a more aggressive switching rule.
bar_watchdog boolean 1089 0 1 5 Specifies whether to enable watchdog heuristic for barrier algorithms
act_lpalg enumint 1109 0 0 6 Indicates which algorithm to use to solve linear programming (LP) subproblems when using the Knitro Active Set or SQP algorithms
 0 1 (default) use the default algorithm for the chosen LP solver.
 1 1 (primal) use a primal simplex algorithm.
 2 1 (dual) use a dual simplex algorithm.
 3 1 (barrier) use a barrier/interior-point algorithm.
act_lpfeastol double 1098 1e-08 0 maxdouble 1 6 Specifies the feasibility tolerance used for linear programming subproblems solved when using the Active Set or SQP algorithms
act_lppenalty enumint 1111 1 1 6 Indicates whether to use a penalty formulation for linear programming subproblems in the Knitro Active Set or SQP algorithms
 1 1 (all) penalize all constraints.
 2 1 (nonlinear) penalize only nonlinear constraints.
 3 1 (dynamic) dynamically choose which constraints to penalize.
act_lppresolve boolean 1110 0 1 6 Indicates whether to apply a presolve for linear programming subproblems in the Knitro Active Set or SQP algorithms
 0 (off) presolve turned off for LP subproblems.
 1 (on) presolve turned on for LP subproblems.
act_lpsolver enumint 1012 1 0 6 Indicates which linear programming simplex solver the Knitro Active Set or SQP algorithms use when solving internal LP subproblems
 1 1 (internal) Knitro uses its default LP solver.
 2 1 (cplex) Knitro uses IBM ILOG-CPLEX(R), provided the user has a valid CPLEX license.  The CPLEX library is loaded dynamically after KN_solve() is called.
 3 1 (xpress) Knitro uses the FICO Xpress(R) solver, provided the user has a valid Xpress license.  The Xpress library is loaded dynamically after KN_solve() is called.
act_parametric enumint 1107 1 1 6 Indicates whether to use a parametric approach when solving linear programming (LP) subproblems when using the Knitro Active Set or SQP algorithms
 0 1 (no) do not use a parametric solve (i.e. solve a single LP).
 1 1 (maybe) use a parametric solve sometimes.
 2 1 (yes) always try a parametric solve.
act_qpalg enumint 1092 0 1 6 Indicates which algorithm to use to solve quadratic programming (QP) subproblems when using the Knitro Active Set or SQP algorithms
 0 1 (auto) let Knitro automatically choose an algorithm, based on the problem characteristics.
 1 1 (direct) use the Interior/Direct algorithm.
 2 1 (cg) use the Interior/CG algorithm.
 3 1 (active) use the Active Set algorithm.
act_qppenalty enumint 1128 -1 1 6 Indicates whether to use a penalty formulation for quadratic programming subproblems in the Knitro SQP algorithm
 -1 1 (auto) let Knitro automatically decide.
 0 1 (none) do not penalize constraints in QP subproblems.
 1 1 (all) penalize all constraints in QP subproblems.
cplexlibname string 1048 "" 0 6 See option \ref KNITROact_lpsolver "act_lpsolver"
xpresslibname string 1069 "" 0 6 See option \ref KNITROact_lpsolver "act_lpsolver"
mip_branchrule enumint 2002 0 1 7 Specifies which branching rule to use for MIP branch and bound procedure
 0 1 (auto) Let Knitro automatically choose the branching rule.
 1 1 (most_frac) Use most fractional (most infeasible) branching.
 2 1 (pseudcost) Use pseudo-cost branching.
 3 1 (strong) Use strong branching (see options  mip_strong_candlim, mip_strong_level and  mip_strong_maxit for further control of strong branching procedure).
mip_clique enumint 2038 -1 1 7 Specifies rules for adding clique cuts
 -1 1 (auto) Automatically determine whether to add clique cuts.
 0 1 (none) Do not add clique cuts.
 1 1 (root) Add clique cuts derived from the root node only.
 2 1 (tree) Add clique cuts derived at every node depending on the solution of the relaxation and the cut generation strategy.
mip_cut_flowcover enumint 2053 -1 1 6 Specifies rules for adding flow cover cuts
 -1 1 (auto) Automatically determine whether to add flow cover cuts.
 0 1 (none) Do not add flow cover cuts.
 1 1 (root) Add flow cover cuts derived from the root node only.
 2 1 (tree) Add flow cover cuts derived at every node depending on the solution of the relaxation and the cut generation strategy.
mip_cut_probing enumint 2052 -1 1 6 Specifies rules for adding probing cuts
 -1 1 (auto) Automatically determine whether to add probing cuts.
 0 1 (none) Do not add probing cuts.
 1 1 (root) Add probing cuts derived from the root node only.
 2 1 (tree) Add probing cuts derived at every node depending on the solution of the relaxation and the cut generation strategy.
mip_cutfactor double 2035 1 0 maxdouble 1 7 This value specifies a limit on the number of cuts added to a node subproblem
mip_cutoff double 2044 maxdouble mindouble maxdouble 1 7 This value specifies the objective cutoff value for MIP
mip_cutting_plane boolean 2043 1 1 7 Specifies when to apply the cutting plane procedure
 0 (none) No cutting plane procedure enabled.
 1 (root) Perform cutting plane procedure at the root node only.
mip_debug boolean 2013 0 0 7 Specifies debugging level for MIP solution
 0 (none) No MIP debugging output created.
 1 (all) Write MIP debugging output to the file  kdbg_mip.log.
mip_gomory enumint 2051 -1 1 7 Specifies rules for adding Gomory mixed-integer cuts
 -1 1 (auto) Automatically determine whether to add Gomory cuts.
 0 1 (none) Do not add Gomory cuts.
 1 1 (root) Add Gomory cuts derived from the root node only.
 2 1 (tree) Add Gomory cuts derived at every node depending on the solution of the relaxation and the cut generation strategy.
mip_gub_branch boolean 2015 0 1 7 Specifies whether or not to branch on generalized upper bounds (GUBs)
 0 (no) Do not branch on GUBs.
 1 (yes) Allow branching on GUBs.
mip_heuristic_diving enumint 2042 -1 1 7 Specifies whether or not to enable the MIP diving heuristic
 -1 1 (auto) Let Knitro determine automaticallyfrom mip_heuristic_strategy.
 1 1 (bit 0) Enable fractional diving heuristic.
 2 1 (bit 1) Enable vector length diving heuristic.
 4 1 (bit 2) Enable coefficient diving heuristic.
 8 1 (bit 3) Enable linesearch diving heuristic.
 16 1 (bit 4) Enable guided diving heuristic.
mip_heuristic_feaspump enumint 2040 -1 1 7 Specifies whether or not to enable the MIP feasibility pump heuristic
 -1 1 (auto) Let Knitro determine automatically from mip_heuristic_strategy.
 0 1 (off) Feasibility pump heuristic is not applied.
 1 1 (on) Feasibility pump heuristic is enabled.
mip_heuristic_lns enumint 2045 -1 1 7 Specifies whether or not to enable the MIP large neighborhood search (LNS) heuristics
 -1 1 (auto) Let Knitro determine automatically from mip_heuristic_strategy.
 1 1 (bit 0) Enable relaxation enforced neighborhood search (RENS) heuristic.
 2 1 (bit 1) Enable relaxation induced neighborhood search (RINS) heuristic.
mip_heuristic_maxit integer 2023 100 0 maxint 1 7 Specifies the maximum number of iterations to allow for MIP heuristic, if one is enabled
mip_heuristic_misqp enumint 2049 -1 1 7 Specifies whether or not to enable the MIP MISQP heuristic
 -1 1 (auto) Let Knitro determine automatically from mip_heuristic_strategy.
 0 1 (off) MISQP heuristic is not applied.
 1 1 (on) MISQP heuristic is enabled.
mip_heuristic_mpec enumint 2041 -1 1 7 Specifies whether or not to enable the MIP MPEC heuristic
 -1 1 (auto) Let Knitro determine automatically from mip_heuristic_strategy.
 0 1 (off) MPEC heuristic is not applied.
 1 1 (on) MPEC heuristic is enabled.
mip_heuristic_localsearch enumint 2054 -1 1 6 Specifies whether or not to enable the MIP local search heuristic
 -1 1 (auto) Let Knitro determine automatically from mip_heuristic_strategy.
 0 1 (off) Local search heuristic is not applied.
 1 1 (on) Local search heuristic is enabled.
mip_heuristic_strategy enumint 2039 -1 1 7 Specifies the level of effort applied for the MIP heuristic search used to try to find an initial integer feasible point
 -1 1 (auto) Let Knitro choose the heuristic strategy to apply (if any).
 0 1 (none) No heuristic search applied.
 1 1 (basic) Apply basic heuristics.
 2 1 (advanced) Apply more advanced heuristics.
 3 1 (extensive) Apply most extensive heuristics.
mip_heuristic_terminate enumint 2033 1 1 7 Specifies the condition for terminating the MIP heuristic
 1 1 (feasible) Terminate at first feasible point or iteration limit (whichever comes first).
 2 1 (limit) Always run to the iteration limit.
mip_implications boolean 2014 1 1 7 Specifies whether or not to add constraints to the MIP derived from logical implications
 0 (no) Do not add constraints from logical implications.
 1 (yes) Knitro adds constraints from logical implications.
mip_integer_tol double 2009 1e-08 0 1 1 7 This value specifies the threshold for deciding whether or not a variable is determined to be an integer
mip_intvar_strategy enumint 2030 0 1 7 Specifies how to handle integer variables
 0 1 (none) No special treatment applied.
 1 1 (relax) Relax all integer variables.
 2 1 (mpec) Convert all binary variables to complementarity constraints.
mip_knapsack enumint 2016 -1 1 7 Specifies rules for adding MIP knapsack cuts
 -1 1 (auto) Automatically determine whether to add knapsack cuts.
 0 1 (none) Do not add knapsack cuts.
 1 1 (root) Add knapsack cuts derived from the root node only.
 2 1 (tree) Add knapsack cuts derived at every node depending on the solution of the relaxation and the cut generation strategy.
mip_liftproject integer 2047 -1 -1 1 1 7 Specifies rules for adding lift and project cuts
 -1 (auto) Automatically determine whether to add lift and project cuts.
 0 (none) Do not add lift and project cuts.
 1 (root) Add lift and project cuts at the root node only.
mip_lpalg enumint 2019 0 1 7 Specifies which algorithm to use for any linear programming (LP) subproblem solves that may occur in the MIP branch-and-bound procedure
 0 1 (auto) Let Knitro automatically choose an algorithm, based on the problem characteristics.
 1 1 (direct) Use the Interior/Direct (barrier) algorithm.
 2 1 (cg) Use the Interior/CG (barrier) algorithm.
 3 1 (active) Use the Active Set (simplex) algorithm.
mip_maxnodes integer 2021 0 0 maxint 1 7 Specifies the maximum number of nodes explored (0 means no limit)
mip_maxsolves integer 2008 0 0 maxint 1 7 Specifies the maximum number of subproblem solves allowed (0 means no limit)
mip_method enumint 2001 0 1 7 Specifies which MIP method to use
 0 1 (auto) Let Knitro automatically choose the method.
 1 1 (BB) Use the standard branch-and-bound method.
 2 1 (HQG) Use the hybrid Quesada-Grossman method (for convex, nonlinear problems only).
 3 1 (MISQP) Use mixed-integer SQP method (allows for non-relaxable integer variables).
mip_mir enumint 2037 -1 1 7 Specifies rules for adding mixed-integer rounding cuts
 -1 1 (auto) Let Knitro decide whether to add mixed-integer rounding cuts.
 0 1 (none) Do not add mixed-integer rounding cuts.
 1 1 (root) Add mixed-integer rounding cuts derived from the root node only.
 2 1 (tree) Add mixed-integer rounding cuts derived at every node depending on the solution of the relaxation and the cut generation strategy.
mip_multistart boolean 2046 0 1 7 Use to enable MIP multi-start at the branch-and-bound level
 0 (off) Do not enable MIP multi-start for branch-and-bound.
 1 (on) Enable MIP multi-start for branch-and-bound.
mip_nodealg integer 2032 0 0 5 1 7 Specifies which algorithm to use for standard node subproblem solves in MIP (same options as \ref KNITROalgorithm "algorithm" user option)
mip_numthreads integer 2048 0 0 maxint 1 7 Specify the number of threads to use for MIP branch-and-bound (when \ref KNITROmip_method "mip_method" = 1)
mip_opt_gap_abs double 2004 1e-06 -1 maxdouble 1 7 The absolute optimality gap stop tolerance for MIP
mip_opt_gap_rel double 2005 0.0001 -1 maxdouble 1 7 The relative optimality gap stop tolerance for MIP
mip_outinterval integer 2011 0 0 maxint 1 7 Specifies node printing interval for \ref KNITROmip_outlevel "mip_outlevel" when \ref KNITROmip_outlevel "mip_outlevel" &gt; 0
 0 Let Knitro decide.
 1 Print output every node.
 2 Print output every 2nd node.
 n Print output every Nth node.
mip_outlevel enumint 2010 2 1 7 Specifies how much MIP information to print
 0 1 (none) Do not print any MIP node information.
 1 1 (iters) Print one line of output for every node.
 2 1 (iterstime) Also print accumulated time for every node.
 3 1 (root) Also print detailed log from root node solve.
mip_outsub enumint 2012 0 0 7 Specifies MIP subproblem solve debug output control
 0 1 Do not print any debug output from subproblem solves.
 1 1 Subproblem debug output enabled, controlled by option  outlev.
 2 1 Subproblem debug output enabled and print problem characteristics.
mip_pseudoinit enumint 2026 0 1 7 Specifies the method used to initialize pseudo-costs corresponding to variables that have not yet been branched on in the MIP method
 0 1 Let Knitro automatically choose the method.
 1 1 Initialize using the average value of computed pseudo-costs.
 2 1 Initialize using strong branching.
mip_relaxable boolean 2031 1 1 7 Specifies whether integer variables are relaxable
 0 (none) Integer variables are not relaxable.
 1 (all) All integer variables are relaxable.
mip_restart boolean 2050 1 1 7 Specifies whether to enable the MIP restart procedure
 0 (off) Do not enable the MIP restart procedure.
 1 (on) Enable the MIP restart procedure.
mip_rootalg integer 2018 0 0 5 1 7 Specifies which algorithm to use for the root node solve in MIP (same options as \ref KNITROalgorithm "algorithm" user option)
mip_rounding enumint 2017 -1 1 7 Specifies the MIP rounding rule to apply
 -1 1 (auto) Let Knitro choose the rounding rule.
 0 1 (none) No rounding heuristic is used.
 2 1 (heur_only) Round using a fast heuristic only.
 3 1 (nlp_sometimes) Round and solve a subproblem if likely to succeed.
 4 1 (nlp_always) Always round and solve a subproblem.
mip_selectdir boolean 2034 0 1 7 Specifies the MIP node selection direction rule (for tiebreakers) for choosing the next node in the branch-and-bound tree
 0 (down) Choose the down (i.e. &lt;=) node first.
 1 (up) Choose the up (i.e. &gt;=) node first.
mip_selectrule enumint 2003 0 1 7 Specifies the MIP select rule for choosing the next node in the branch-and-bound tree
 0 1 (auto) Let Knitro choose the node selection rule.
 1 1 (depth_first) Search the tree using a depth first procedure.
 2 1 (best_bound) Select the node with the best relaxation bound.
 3 1 (combo_1) Use depth first unless pruned, then best bound.
mip_strong_candlim integer 2028 128 0 maxint 1 7 Specifies the maximum number of candidates to explore for MIP strong branching
mip_strong_level integer 2029 10 0 maxint 1 7 Specifies the maximum number of tree levels on which to perform MIP strong branching
mip_strong_maxit integer 2027 1000 0 maxint 1 7 Specifies the maximum number of iterations to allow for MIP strong branching solves
mip_sub_maxtime double 2055 100000000 0 maxdouble 1 7 Specifies the maximum allowable real time in seconds for MIP node subproblems
mip_terminate enumint 2020 0 1 7 Specifies conditions for terminating the MIP algorithm
 0 1 (optimal) Terminate at optimum.
 1 1 (feasible) Terminate at first integer feasible point.
mip_zerohalf enumint 2036 -1 1 7 Specifies rules for adding zero-half cuts
 -1 1 (auto) Automatically determine whether to add zero-half cuts.
 0 1 (none) Do not add zero-half cuts.
 1 1 (root) Add zero-half cuts derived from the root node only.
 2 1 (tree) Add zero-half cuts derived at every node depending on the solution of the relaxation and the cut generation strategy.
ma_outsub boolean 1067 0 1 8 Enable writing algorithm output to files for the multi-algorithm (\ref KNITROalgorithm "algorithm"=5) procedure
 0 Do not write detailed algorithm output to files.
 1 Write detailed algorithm output to files named knitro_ma_*.log.
ma_sub_maxtime double 1164 100000000 0 maxdouble 1 8 Specifies, in seconds, the maximum allowable real time for multi-algorithm ("MA") subproblems (\ref KNITROalgorithm "algorithm"=5)
ma_terminate enumint 1063 1 1 8 Define the termination condition for the multi-algorithm (\ref KNITROalgorithm "algorithm"=5) procedure
 0 1 Terminate after all algorithms have completed.
 1 1 Terminate at first locally optimal solution.
 2 1 Terminate at first feasible solution estimate.
 3 1 Terminate at first solution estimate of any type.
ms_enable boolean 1033 0 1 9 Indicates whether Knitro will solve from multiple start points to find a better local minimum
 0 (no) Knitro solves from a single initial point.
 1 (yes) Knitro solves using multiple start points.
ms_initpt_cluster boolean 1149 0 1 9 The strategy for clustering initial points in multi-start
 0 (none) Do not apply clustering.
 1 (sl) Apply single linkage based clustering.
ms_maxbndrange double 1035 1000 0 maxdouble 1 9 Specifies the maximum range that an unbounded variable can take when determining new start points
ms_maxsolves integer 1034 0 0 maxint 1 9 Specifies how many start points to try in multi-start
 0 Let Knitro automatically choose a value based on the problem size and context.
 n Try n&gt;0 start points.
ms_num_to_save integer 1051 0 0 maxint 1 9 Specifies the number of distinct feasible points to save in a file named knitro_mspoints
ms_numthreads integer 1137 0 0 maxint 1 9 Specify the number of threads to use for multi-start (when \ref KNITROms_enable "ms_enable" = 1)
ms_outsub boolean 1068 0 1 9 Enable writing algorithm output to files for the parallel multi-start procedure
 0 Do not write detailed algorithm output to files.
 1 Write detailed algorithm output to files named knitro_ms_*.log.
ms_savetol double 1052 1e-06 0 maxdouble 1 9 Specifies the tolerance for deciding if two feasible points are distinct
ms_seed integer 1066 0 0 maxint 1 9 Seed value used to generate random initial points in multi-start; should be a non-negative integer
ms_startptrange double 1055 1e+20 0 maxdouble 1 9 Specifies the maximum range that each variable can take when determining new start points
ms_sub_maxtime double 1165 100000000 0 maxdouble 1 9 Specifies, in seconds, the maximum allowable real time for multi-start subproblems (i.e. local solves from a given initial point)
ms_terminate enumint 1054 4 1 9 Specifies the condition for terminating multi-start
 0 1 (maxsolves) Terminate after  ms_maxsolves.
 1 1 (optimal) Terminate after the first local optimal solution is found or ms_maxsolves, whichever comes first.
 2 1 (feasible) Terminate after the first feasible solution estimate is found or ms_maxsolves, whichever comes first.
 3 1 (any) Terminate after the first solution estimate of any type is found or ms_maxsolves, whichever comes first.
 4 1 (rulebased) Terminate using rules that estimate when the probability of finding new local solutions is low.
ms_terminaterule_tol double 1160 0 0 1 1 9 The tolerance in (0,1] for the rule-based termination of multi-start
blas_numthreads integer 1135 0 0 maxint 1 10 Specify the number of threads to use for BLAS operations when \ref KNITROblasoption "blasoption" = 1
conic_numthreads integer 1138 0 minint maxint 1 10 Specify the number of threads to use for operations in the conic algorithm (when \ref KNITRObar_conic_enable "bar_conic_enable" = 1)
linsolver_numthreads integer 1136 0 0 maxint 1 10 Specify the number of threads to use for linear system solve operations when \ref KNITROlinsolver "linsolver" = 6
debug enumint 1031 0 0 1 Controls the level of debugging output
 0 1 (none) No debugging output.
 1 1 (problem) Print algorithm information to  kdbg*.logoutput files.
 2 1 (execution) Print program execution information.
newpoint enumint 1001 0 1 1 Specifies additional action to take after every iteration in a solve of a continuous problem, or after every new incumbent of the NLPBB algorithm
 0 1 (none) Knitro takes no additional action.
 1 1 (saveone) Knitro writes x and lambda to the file knitro_newpoint.log.  Previous contents of the file are overwritten.
 2 1 (saveall) Knitro appends x and lambda to the file knitro_newpoint.log.  Warning: this option can generate a very large file.  All iterates, including the start point, crossover points, and the final solution are saved.
out_csvinfo boolean 1096 0 1 11 Controls whether or not to generates a file knitro_solve
 0 (no) No solution information file is generated.
 1 (yes) The knitro_solve.csv solution file is generated.
out_csvname string 1106 "" 1 11 Use to specify a custom csv filename when using \ref KNITROout_csvinfo "out_csvinfo"
out_hints boolean 1115 1 1 11 Specifies whether to print diagnostic hints (e.g. about user option settings) after solving
 0 (no) Do not print any hints.
 1 (yes) Print diagnostic hints on occasion.
outappend boolean 1046 0 1 11 Specifies whether output should be started in a new file, or appended to existing files
 0 (no) Erase any existing files when opening for output.
 1 (yes) Append output to any existing files.
outdir string 1047 "" 1 11 Specifies a single directory as the location to write all output files
outlev enumint 1015 2 1 11 Controls the level of output produced by Knitro
 0 1 (none) Printing of all output is suppressed.
 1 1 (summary) Print only summary information.
 2 1 (iter_10) Print basic information every 10 iterations.
 3 1 (iter) Print basic information at each iteration.
 4 1 (iter_verbose) Print basic information and the function count at each iteration.
 5 1 (iter_x) Print all the above, and the values of the solution vector  x.
 6 1 (all) Print all the above, and the values of the constraints c at  x and the Lagrange multipliers lambda.
outmode enumint 1016 0 1 11 Specifies where to direct the output from Knitro
 0 1 (screen) Output is directed to standard out (e.g., screen).
 1 1 (file) Output is sent to a file named knitro.log.
 2 1 (both) Output is directed to both the screen and file knitro.log.
outname string 1105 "" 1 11 Use to specify a custom filename when output is written to a file using \ref KNITROoutmode "outmode"
tuner_optionsfile string 1071 "" 1 12 Can be used to specify the location of a Tuner options file
tuner_outsub enumint 1074 0 1 12 Enable writing additional Tuner subproblem solve output to files for the Knitro-Tuner procedure (\ref KNITROtuner "tuner"=1)
 0 1 Do not write detailed solve output to files.
 1 1 Write summary solve output to a file named knitro_tuner_summary.log.
 2 1 Write detailed individual solve output to files named knitro_tuner_*.log.
tuner_sub_maxtime double 1166 100000000 0 maxdouble 1 12 Specifies, in seconds, the maximum allowable real time for Knitro-Tuner subproblems (i.e. individual solves with a particular option setting)
tuner_terminate enumint 1075 0 1 12 Define the termination condition for the Knitro-Tuner procedure (\ref KNITROtuner "tuner"=1)
 0 1 Terminate after all solves have completed.
 1 1 Terminate at first locally optimal solution.
 2 1 Terminate at first feasible solution estimate.
 3 1 Terminate at first solution estimate of any type.
names boolean 0 0 1 1 Enable to pass variable and equation names to Knitro
newpoint_skip boolean 0 0 0 1 skip registering of newpoint callback: workaround for KNITRO bugs
option_file string 0 "" 1 1 additional option file name - read only by KNITRO solver lib
output_time boolean 0 0 1 1 print output on where time is used
qextractalg enumint 0 0 1 1 quadratic extraction algorithm in GAMS interface
 0 1 Automatic
 1 1 ThreePass: Uses a three-pass forward / backward / forward AD technique to compute function / gradient / Hessian values and a hybrid scheme for storage.
 2 1 DoubleForward: Uses forward-mode AD to compute and store function, gradient, and Hessian values at each node or stack level as required.  The gradients and Hessians are stored in linked lists.
 3 1 Concurrent: Uses ThreePass and DoubleForward in parallel. As soon as one finishes, the other one stops.
qextractdenseswitchfactor double 0 0.008 0 maxdouble 1 1 Sparse/dense factor for quadratic extraction algorithm in GAMS interface
qextractdenseswitchlog boolean 0 0 1 1 Enables additional information about sparse/dense factor choice in quadratic extraction algorithm in GAMS interface
threads integer 0 1 minint maxint 1 10 default thread count
useq boolean 0 1 0 1 consider quadratic equations as general nonlinear equations when disabled
uselsq boolean 0 0 0 1 use Knitro least-squares solver (CNS models only)
initvalues0 enumint 0 2 1 1 Enable use of initial guess for levels and marginals (first solve)
 0 1 Using no initial values
 1 1 Using all initial values
 2 1 Using only non-default initial values
initvalues enumint 0 1 1 1 Enable use of initial guess for levels and marginals (subsequent solves)
 0 1 Using no initial values
 1 1 Using all initial values
 2 1 Using only non-default initial values
*
* synonym section
*
feastol_abs synonym feastolabs
maxtime_cpu synonym maxtime
maxtime_real synonym maxtime
mip_maxtime_cpu synonym maxtime
mip_maxtime_real synonym maxtime
ma_maxtime_cpu synonym maxtime
ma_maxtime_real synonym maxtime
ms_maxtime_cpu synonym maxtime
ms_maxtime_real synonym maxtime
tuner_maxtime_cpu synonym maxtime
tuner_maxtime_real synonym maxtime
opttol_abs synonym opttolabs
bar_pencons synonym bar_penaltycons
bar_penrule synonym bar_penaltyrule
mip_integral_gap_abs synonym mip_opt_gap_abs
mip_integral_gap_rel synonym mip_opt_gap_rel
par_msnumthreads synonym ms_numthreads
par_blasnumthreads synonym blas_numthreads
par_lsnumthreads synonym linsolver_numthreads
par_numthreads synonym threads
numthreads synonym threads
iterlim synonym maxit
reslim synonym maxtime
nodlim synonym mip_maxnodes
optca synonym mip_opt_gap_abs
optcr synonym mip_opt_gap_rel
gthreads synonym threads
*
* deprecated section
*
synon deprecated
 par_numthreads
 bar_pencons
 bar_penrule
 mip_integral_gap_abs
 mip_integral_gap_rel
 par_msnumthreads
 par_blasnumthreads
 par_lsnumthreads
 maxtime_cpu
 maxtime_real
 mip_maxtime_cpu
 mip_maxtime_real
 ma_maxtime_cpu
 ma_maxtime_real
 ms_maxtime_cpu
 ms_maxtime_real
 tuner_maxtime_cpu
 tuner_maxtime_real
*
* Groups
* <group-ident> group <group-number <help-context> <help-text>
*
general group 1 1 General options
deriv group 2 1 Derivative options
terminate group 3 1 Termination options
presolve group 4 1 Presolve options
barrier group 5 1 Barrier options
activeset group 6 1 Active-set options
mip group 7 1 MIP options
ma group 8 1 Multi-algorithm options
ms group 9 1 Multi-start options
parallel group 10 1 Parallelism options
output group 11 1 Output options
tuner group 12 1 Tuner options
*** End of file
