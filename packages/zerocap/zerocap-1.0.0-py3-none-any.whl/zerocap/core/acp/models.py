# src/zerocap/core/acp/models.py
"""
Pydantic models for the Agent Communication Protocol (ACP).

This module defines the core data structures for agent-to-agent communication.
It includes models for Agent Runs, Messages, Parts, Artifacts, and the lifecycle
states of an agent execution, ensuring all interactions are validated and
structured according to the ACP specification.
"""
import uuid
from datetime import datetime
from typing import Any, Dict, List, Literal, Optional

from pydantic import BaseModel, Field, HttpUrl

# The defined states in the Agent Run Lifecycle
RunStatus = Literal[
    "created",
    "in-progress",
    "awaiting-input",
    "completed",
    "failed",
    "cancelled",
]


class Part(BaseModel):
    """
    Represents a single part of a multi-part message.
    This is the fundamental building block for all agent communication content.
    """
    content_type: str = Field(
        ...,
        description="The MIME type of the content (e.g., 'text/plain', 'image/png')."
    )
    content: Optional[Any] = Field(
        None,
        description="The inline content of the part (e.g., text, base64-encoded data)."
    )
    content_url: Optional[HttpUrl] = Field(
        None,
        description="A URL where the content can be retrieved."
    )
    # If 'name' is present, this Part is considered an Artifact.
    name: Optional[str] = Field(
        None,
        description="An optional name for this part, which designates it as an Artifact."
    )

    # A validator could be added here to ensure content or content_url is present.


class Message(BaseModel):
    """
    Represents a multi-part message exchanged between a client and an agent.
    """
    role: str = Field(
        ...,
        description="The role of the entity that produced the message (e.g., 'user', 'agent')."
    )
    parts: List[Part] = Field(
        default_factory=list,
        description="The list of parts that make up the message content."
    )
    metadata: Dict[str, Any] = Field(
        default_factory=dict,
        description="Optional metadata associated with the message."
    )


class AgentRun(BaseModel):
    """
    Represents a single, complete execution of an agent's capability.
    This is the central object in the ACP, tracking the task from start to finish.
    """
    id: uuid.UUID = Field(
        default_factory=uuid.uuid4,
        description="A unique identifier for this specific agent run."
    )
    agent_id: str = Field(
        ...,
        description="The unique identifier of the agent being run."
    )
    session_id: Optional[uuid.UUID] = Field(
        None,
        description="An optional identifier to group multiple runs into a single session."
    )
    status: RunStatus = Field(
        "created",
        description="The current status of the agent run in its lifecycle."
    )
    input: Message = Field(
        ...,
        description="The initial message from the client that started this run."
    )
    output: List[Message] = Field(
        default_factory=list,
        description="The final output messages generated by the agent upon completion."
    )
    created_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="The UTC timestamp when the run was created."
    )
    updated_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="The UTC timestamp when the run was last updated."
    )

    @property
    def artifacts(self) -> Dict[str, Part]:
        """
        A convenient property to access all named parts (artifacts) from the
        output messages.

        Returns:
            A dictionary mapping artifact names to their corresponding Part objects.
        """
        found_artifacts = {}
        for message in self.output:
            for part in message.parts:
                if part.name:
                    found_artifacts[part.name] = part
        return found_artifacts

    model_config = {
        "extra": "allow"  # Allow additional fields for custom agent implementations
    }


class AgentManifest(BaseModel):
    """
    Describes an agent's identity, capabilities, and technical details.
    This serves as the public "business card" for an agent.
    """
    agent_id: str = Field(
        ...,
        description="The unique, machine-readable identifier for the agent."
    )
    name: str = Field(
        ...,
        description="A human-readable name for the agent."
    )
    description: str = Field(
        ...,
        description="A detailed description of what the agent does."
    )
    version: str = "0.0.1"
    capabilities: List[str] = Field(
        default_factory=list,
        description="A list of tasks or capabilities the agent can perform."
    )
    # These schemas can be used for advanced validation and UI generation
    input_schema: Optional[Dict[str, Any]] = Field(
        None,
        description="A JSON Schema defining the expected structure of the input message."
    )
    output_schema: Optional[Dict[str, Any]] = Field(
        None,
        description="A JSON Schema defining the structure of the output messages."
    )