<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Polar Map Viewer</title>
    <script src="https://cdn.jsdelivr.net/npm/ol@10.2.1/dist/ol.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@10.2.1/ol.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.11.0/proj4.js"></script>
    <style>
        body { 
            margin: 0; 
            padding: 0;
            font-family: Arial, sans-serif;
        }
        #map { 
            width: 100%; 
            height: 600px;
        }
        .map-info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 12px;
            z-index: 1000;
        }
        .cors-status {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 11px;
            z-index: 1000;
            display: none;
        }
        .cors-status.visible { display: block; }
        .cors-status.success { border-left: 3px solid #28a745; }
        .cors-status.proxy { border-left: 3px solid #ffc107; }
        .cors-status.error { border-left: 3px solid #dc3545; }
    </style>
</head>
<body>
    <div id="map"></div>
    <div class="map-info" id="info">Click on features for details</div>
    <div class="cors-status" id="corsStatus"></div>
    
    <script type="module">
        // Load WASM modules from Google Cloud Storage to avoid path resolution issues
        // Local files are at: src/xopr/map/parquet_wasm.js and src/xopr/map/parquet_wasm_bg.wasm
        console.log('Loading WASM module from GCS');
        const { default: init, readParquet } = await import('https://storage.googleapis.com/opr_test_dataset_1/parquet_wasm.js');
        import * as arrow from 'https://cdn.jsdelivr.net/npm/apache-arrow@14.0.2/+esm';
        
        // Parse configuration from URL parameters
        function parseConfigFromURL() {
            const urlParams = new URLSearchParams(window.location.search);
            const config = {};
            
            // Get pole parameter
            if (urlParams.has('pole')) {
                config.pole = urlParams.get('pole');
            }
            
            // Get dataPath parameter (base URL for files)
            if (urlParams.has('dataPath')) {
                config.dataPath = urlParams.get('dataPath');
            }
            
            // Get parquetFiles parameter (JSON array of filenames)
            if (urlParams.has('parquetFiles')) {
                try {
                    const files = JSON.parse(urlParams.get('parquetFiles'));
                    // If dataPath is provided, prepend it to each filename
                    if (config.dataPath) {
                        config.parquetFiles = files.map(file => {
                            // If file is already a full URL, use as-is
                            if (file.startsWith('http://') || file.startsWith('https://')) {
                                return file;
                            }
                            // Otherwise, prepend the dataPath
                            const basePath = config.dataPath.endsWith('/') ? config.dataPath : config.dataPath + '/';
                            return basePath + file;
                        });
                    } else {
                        // No dataPath, use files as-is (they should be full URLs)
                        config.parquetFiles = files;
                    }
                } catch (e) {
                    console.error('Failed to parse parquetFiles from URL:', e);
                    config.parquetFiles = [];
                }
            }
            
            // Get defaultZoom parameter
            if (urlParams.has('defaultZoom')) {
                config.defaultZoom = parseInt(urlParams.get('defaultZoom'), 10) || 3;
            }
            
            return config;
        }
        
        // Make CONFIG settable even before the script runs (for backwards compatibility)
        if (typeof window.CONFIG === 'undefined') {
            window.CONFIG = null;
        }
        
        // Allow parent to set CONFIG even after initialization
        let configUsed = false;
        
        // Get CONFIG from URL params or parent window
        function getConfig() {
            // First, try to get config from URL parameters
            const urlConfig = parseConfigFromURL();
            if (urlConfig && Object.keys(urlConfig).length > 0) {
                console.log('Using URL parameter CONFIG:', urlConfig);
                window.CONFIG = urlConfig;
                configUsed = true;
                return urlConfig;
            }
            
            // Fallback: Check if CONFIG was set by parent window
            if (window.CONFIG && typeof window.CONFIG === 'object') {
                console.log('Using parent-provided CONFIG:', window.CONFIG);
                configUsed = true;
                return window.CONFIG;
            }
            
            // No defaults - CONFIG must be explicitly provided
            console.error('ERROR: No CONFIG provided. Map requires configuration.');
            document.getElementById('map').innerHTML = 
                '<div style="padding: 20px; text-align: center; color: #721c24; background: #f8d7da; border: 1px solid #f5c6cb; border-radius: 4px; margin: 20px;">' +
                '<strong>Configuration Required</strong><br>' +
                'CONFIG must be provided via URL parameters or parent window.<br>' +
                '<code style="font-size: 11px;">URL params: ?pole=south&parquetFiles=["file.parquet"]&defaultZoom=3</code>' +
                '</div>';
            return null;
        }
        
        // Simplified wait function since URL params are available immediately
        async function waitForConfig() {
            // Check URL params first (available immediately)
            const urlConfig = parseConfigFromURL();
            if (urlConfig && Object.keys(urlConfig).length > 0) {
                return urlConfig;
            }
            
            // Give parent window a brief chance to set CONFIG
            for (let i = 0; i < 5; i++) {
                if (window.CONFIG && typeof window.CONFIG === 'object') {
                    console.log(`Parent CONFIG found after ${i * 50}ms`);
                    return window.CONFIG;
                }
                await new Promise(resolve => setTimeout(resolve, 50));
            }
            
            // Final check
            return getConfig();
        }
        
        // Setup projections
        const PROJECTIONS = {
            south: {
                code: 'EPSG:3031',
                def: '+proj=stere +lat_0=-90 +lat_ts=-71 +lon_0=0 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs +type=crs',
                extent: [-3369955, -3369955, 3369955, 3369955],
                wmsUrl: 'https://gibs.earthdata.nasa.gov/wms/epsg3031/best/wms.cgi',
                wmsLayer: 'BlueMarble_ShadedRelief'
            },
            north: {
                code: 'EPSG:3413',
                def: '+proj=stere +lat_0=90 +lat_ts=70 +lon_0=-45 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs +type=crs',
                extent: [-4194304, -4194304, 4194304, 4194304],
                wmsUrl: 'https://gibs.earthdata.nasa.gov/wms/epsg3413/best/wms.cgi',
                wmsLayer: 'BlueMarble_ShadedRelief'
            }
        };
        
        // Initialize map and features after CONFIG is ready
        async function initializeMap() {
            const CONFIG = await waitForConfig();
            if (!CONFIG) {
                // CONFIG is required - error already displayed
                return null;
            }
            const projConfig = PROJECTIONS[CONFIG.pole];
            
            // Define projection
            proj4.defs(projConfig.code, projConfig.def);
            ol.proj.proj4.register(proj4);
            
            const projection = ol.proj.get(projConfig.code);
            projection.setExtent(projConfig.extent);
            
            // Create map
            const map = new ol.Map({
                target: 'map',
                layers: [
                    new ol.layer.Tile({
                        source: new ol.source.TileWMS({
                            url: projConfig.wmsUrl,
                            params: {
                                'LAYERS': projConfig.wmsLayer,
                                'FORMAT': 'image/jpeg',
                                'SRS': projConfig.code
                            },
                            projection: projection,
                            crossOrigin: 'anonymous'
                        })
                    })
                ],
                view: new ol.View({
                    projection: projection,
                    center: [0, 0],
                    zoom: CONFIG.defaultZoom
                })
            });
            
            return { map, projConfig, CONFIG };
        }
        
        // Initialize WKB format reader
        const wkbFormat = new ol.format.WKB();
        
        // Smart fetch with automatic CORS proxy fallback
        async function smartFetch(url, options = {}) {
            const statusEl = document.getElementById('corsStatus');
            
            // First, try direct fetch
            try {
                console.log('Attempting direct fetch:', url);
                const response = await fetch(url, {
                    ...options,
                    mode: 'cors',
                    credentials: 'omit'
                });
                
                if (response.ok) {
                    console.log('Direct fetch successful');
                    if (statusEl) {
                        statusEl.className = 'cors-status visible success';
                        statusEl.textContent = '✓ Direct';
                    }
                    return response;
                }
            } catch (error) {
                console.log('Direct fetch failed, trying proxy...', error.message);
            }
            
            // If direct fetch fails, try proxy
            try {
                const proxyUrl = 'https://corsproxy.io/?' + encodeURIComponent(url);
                console.log('Trying proxy:', proxyUrl);
                
                const response = await fetch(proxyUrl, options);
                
                if (response.ok) {
                    console.log('Proxy successful');
                    if (statusEl) {
                        statusEl.className = 'cors-status visible proxy';
                        statusEl.textContent = '⚡ Proxy';
                    }
                    return response;
                }
            } catch (error) {
                console.log('Proxy failed:', error.message);
            }
            
            // All attempts failed
            if (statusEl) {
                statusEl.className = 'cors-status visible error';
                statusEl.textContent = '✗ Failed';
            }
            throw new Error('Failed to fetch resource');
        }
        
        // Load parquet file with smart CORS handling
        async function loadParquetFile(filename, projConfig) {
            console.log(`Loading parquet file: ${filename}`);
            
            try {
                // For remote files, use smartFetch with fallback
                let response;
                if (filename.startsWith('http://') || filename.startsWith('https://')) {
                    response = await smartFetch(filename);
                } else {
                    // For local files, use regular fetch
                    response = await fetch(filename);
                }
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status} for ${filename}`);
                }
                
                const arrayBuffer = await response.arrayBuffer();
                console.log(`Successfully fetched ${filename}, size: ${arrayBuffer.byteLength} bytes`);
                const wasmTable = readParquet(new Uint8Array(arrayBuffer));
                
                const ipcStream = wasmTable.intoIPCStream();
                const arrowTable = arrow.tableFromIPC(ipcStream);
                
                const features = [];
                const geometryColumn = arrowTable.getChild('geometry');
                const idColumn = arrowTable.getChild('id');
                const collectionColumn = arrowTable.getChild('collection');
                const nameColumn = arrowTable.getChild('name');
                const descriptionColumn = arrowTable.getChild('description');
                
                for (let i = 0; i < arrowTable.numRows; i++) {
                const wkbData = geometryColumn?.get(i);
                if (wkbData) {
                    // Convert Arrow data to format OpenLayers can read
                    // OpenLayers accepts ArrayBuffer, ArrayBufferView (like Uint8Array), or string
                    let wkbInput = wkbData;
                    if (wkbData.toArray) {
                        // Handle Arrow-specific format
                        wkbInput = new Uint8Array(wkbData.toArray());
                    }
                    
                    // Use OpenLayers' built-in WKB reader with automatic projection transformation
                    const olGeometry = wkbFormat.readGeometry(wkbInput, {
                        dataProjection: 'EPSG:4326',
                        featureProjection: projConfig.code
                    });
                    
                    if (olGeometry) {
                        features.push(new ol.Feature({
                            geometry: olGeometry,
                            id: idColumn?.get(i) || `feature_${i}`,
                            collection: collectionColumn?.get(i) || '',
                            name: nameColumn?.get(i) || `Feature ${i}`,
                            description: descriptionColumn?.get(i) || '',
                            source_file: filename
                        }));
                    }
                }
                }
                
                return features;
            } catch (e) {
                console.error(`Error fetching ${filename}:`, e);
                throw e;
            }
        }
        
        // Initialize and load all parquet files
        async function initialize() {
            try {
                console.log('Initializing parquet-wasm...');
                // Load WASM binary from GCS (local file at: src/xopr/map/parquet_wasm_bg.wasm)
                const wasmPath = 'https://storage.googleapis.com/opr_test_dataset_1/parquet_wasm_bg.wasm';
                
                console.log('Loading WASM binary from GCS');
                await init(wasmPath);
                console.log('parquet-wasm initialized successfully');
                
                // Initialize map with CONFIG
                const mapResult = await initializeMap();
                if (!mapResult) {
                    // No CONFIG provided - error already displayed
                    return;
                }
                const { map, projConfig, CONFIG } = mapResult;
                console.log('Map initialized with CONFIG:', CONFIG);
                
                const allFeatures = [];
                for (const file of CONFIG.parquetFiles) {
                    try {
                        const features = await loadParquetFile(file, projConfig);
                        allFeatures.push(...features);
                    } catch (e) {
                        console.error(`Error loading ${file}:`, e);
                    }
                }
                
                // Track selected feature (define outside if block)
                let selectedFeature = null;
                let vectorSource = null;
                
                if (allFeatures.length > 0) {
                    vectorSource = new ol.source.Vector({ features: allFeatures });
                    
                    // Style function for different geometry types
                    const styleFunction = function(feature) {
                        const geomType = feature.getGeometry().getType();
                        const isSelected = feature === selectedFeature;
                        
                        // Use blue for selected features, red for normal
                        const color = isSelected ? 'rgba(0, 100, 255, 0.8)' : 'rgba(255, 0, 0, 0.8)';
                        const strokeColor = isSelected ? '#0064ff' : '#ff0000';
                        const fillColor = isSelected ? 'rgba(0, 100, 255, 0.2)' : 'rgba(255, 0, 0, 0.1)';
                        
                        const styles = {
                            'Point': new ol.style.Style({
                                image: new ol.style.Circle({
                                    radius: isSelected ? 8 : 6,
                                    fill: new ol.style.Fill({ color: color }),
                                    stroke: new ol.style.Stroke({ color: '#fff', width: isSelected ? 2 : 1.5 })
                                })
                            }),
                            'LineString': new ol.style.Style({
                                stroke: new ol.style.Stroke({
                                    color: strokeColor,
                                    width: isSelected ? 4 : 2
                                })
                            }),
                            'Polygon': new ol.style.Style({
                                stroke: new ol.style.Stroke({
                                    color: strokeColor,
                                    width: isSelected ? 3 : 2
                                }),
                                fill: new ol.style.Fill({
                                    color: fillColor
                                })
                            })
                        };
                        
                        return styles[geomType] || styles['Point'];
                    };
                    
                    const vectorLayer = new ol.layer.Vector({
                        source: vectorSource,
                        style: styleFunction
                    });
                    
                    map.addLayer(vectorLayer);
                    
                    // Fit to extent
                    const extent = vectorSource.getExtent();
                    if (!ol.extent.isEmpty(extent)) {
                        map.getView().fit(extent, {
                            padding: [50, 50, 50, 50],
                            duration: 1000
                        });
                    }
                }
                
                // Feature click handler
                map.on('click', function(evt) {
                    const feature = map.forEachFeatureAtPixel(evt.pixel, f => f);
                    if (feature) {
                        // Update selected feature and refresh styles
                        selectedFeature = feature;
                        vectorSource.changed();  // Trigger style refresh
                        
                        const props = feature.getProperties();
                        document.getElementById('info').innerHTML = 
                            `<strong>ID:</strong> ${props.id}<br><strong>Collection:</strong> ${props.collection}`;
                    } else {
                        // Clear selection when clicking empty space
                        selectedFeature = null;
                        vectorSource.changed();
                        const coords = evt.coordinate;
                        const lonlat = ol.proj.transform(coords, projConfig.code, 'EPSG:4326');
                        document.getElementById('info').innerHTML = 
                            `${lonlat[1].toFixed(4)}°, ${lonlat[0].toFixed(4)}°`;
                    }
                });
                
                // Hover cursor change
                map.on('pointermove', function(evt) {
                    const pixel = map.getEventPixel(evt.originalEvent);
                    const hit = map.hasFeatureAtPixel(pixel);
                    const targetElement = map.getTargetElement();
                    if (targetElement) {
                        targetElement.style.cursor = hit ? 'pointer' : '';
                    }
                });
                
            } catch (error) {
                console.error('Initialization error:', error);
                document.getElementById('info').innerHTML = 'Error loading data';
            }
        }
        
        // Start with error protection
        initialize().catch(error => {
            console.warn('Map initialization warning:', error.message);
            // Even if there's an error, the map might still work
        });
    </script>
</body>
</html>
