# =============================================================================
# secure_env/core.py
# =============================================================================
"""Core functionality for secure environment variables management."""

import os
import re
from typing import Dict, Optional, Any, Union
from cryptography.fernet import Fernet, InvalidToken

from .exceptions import (
    SecureEnvError, 
    InvalidKeyError, 
    DecryptionError, 
    FileAccessError
)
from .utils import (
    generate_key_from_password,
    generate_random_key,
    is_encrypted_value,
    extract_encrypted_content,
    wrap_encrypted_content,
    safe_file_write
)


class Secrets:
    """
    Secure environment variables manager using AES encryption.
    
    This class provides a simple interface to store and retrieve
    encrypted environment variables in .env files.
    """
    
    def __init__(
        self, 
        master_key: Optional[str] = None,
        env_file: str = '.env',
        auto_create: bool = True
    ):
        """
        Initialize Secrets manager.
        
        Args:
            master_key: Master password/key for encryption. If None, looks for
                       SECURE_ENV_MASTER_KEY environment variable.
            env_file: Path to the .env file (default: '.env')
            auto_create: Whether to create the env file if it doesn't exist
        
        Raises:
            InvalidKeyError: If no master key is provided
            FileAccessError: If env file cannot be accessed
        """
        self.env_file = env_file
        self.auto_create = auto_create
        
        # Get master key
        if master_key is None:
            master_key = os.environ.get('SECURE_ENV_MASTER_KEY')
        
        if not master_key:
            raise InvalidKeyError(
                "Master key is required. Provide it via master_key parameter "
                "or SECURE_ENV_MASTER_KEY environment variable."
            )
        
        # Initialize encryption
        try:
            key = generate_key_from_password(master_key)
            self.cipher = Fernet(key)
        except Exception as e:
            raise InvalidKeyError(f"Failed to initialize encryption: {e}")
        
        # Initialize environment dictionary
        self._env_vars: Dict[str, str] = {}
        self._load_env_file()
    
    def _load_env_file(self) -> None:
        """Load variables from the .env file."""
        if not os.path.exists(self.env_file):
            if self.auto_create:
                # Create empty .env file
                with open(self.env_file, 'w', encoding='utf-8') as f:
                    f.write("# Secure Environment Variables\n")
                    f.write("# Generated by secure-env package\n\n")
                self._env_vars = {}
                return
            else:
                raise FileAccessError(f"Environment file {self.env_file} not found")
        
        try:
            with open(self.env_file, 'r', encoding='utf-8') as f:
                content = f.read()
        except Exception as e:
            raise FileAccessError(f"Cannot read {self.env_file}: {e}")
        
        self._env_vars = self._parse_env_content(content)
    
    def _parse_env_content(self, content: str) -> Dict[str, str]:
        """Parse .env file content into dictionary."""
        env_vars = {}
        
        for line in content.splitlines():
            line = line.strip()
            
            # Skip comments and empty lines
            if not line or line.startswith('#'):
                continue
            
            # Parse KEY=VALUE format
            match = re.match(r'^([A-Za-z_][A-Za-z0-9_]*)\s*=\s*(.*)$', line)
            if match:
                key, value = match.groups()
                
                # Remove quotes if present
                if value.startswith('"') and value.endswith('"'):
                    value = value[1:-1]
                elif value.startswith("'") and value.endswith("'"):
                    value = value[1:-1]
                
                env_vars[key] = value
        
        return env_vars
    
    def _save_env_file(self) -> None:
        """Save current environment variables to file."""
        lines = [
            "# Secure Environment Variables",
            "# Generated by secure-env package",
            ""
        ]
        
        for key, value in sorted(self._env_vars.items()):
            # Quote values that contain spaces or special characters
            if ' ' in value or any(c in value for c in ['#', '"', "'"]):
                value = f'"{value}"'
            lines.append(f"{key}={value}")
        
        content = '\n'.join(lines) + '\n'
        
        try:
            safe_file_write(self.env_file, content)
        except Exception as e:
            raise FileAccessError(f"Cannot write to {self.env_file}: {e}")
    
    def encrypt(self, plaintext: str) -> str:
        """
        Encrypt a plaintext string.
        
        Args:
            plaintext: The string to encrypt
        
        Returns:
            str: Base64-encoded encrypted data
        
        Raises:
            SecureEnvError: If encryption fails
        """
        if not isinstance(plaintext, str):
            plaintext = str(plaintext)
        
        try:
            encrypted_bytes = self.cipher.encrypt(plaintext.encode('utf-8'))
            return encrypted_bytes.decode('utf-8')
        except Exception as e:
            raise SecureEnvError(f"Encryption failed: {e}")
    
    def decrypt(self, encrypted_data: str) -> str:
        """
        Decrypt encrypted data.
        
        Args:
            encrypted_data: Base64-encoded encrypted data
        
        Returns:
            str: Decrypted plaintext
        
        Raises:
            DecryptionError: If decryption fails
        """
        try:
            decrypted_bytes = self.cipher.decrypt(encrypted_data.encode('utf-8'))
            return decrypted_bytes.decode('utf-8')
        except InvalidToken:
            raise DecryptionError("Invalid encrypted data or wrong master key")
        except Exception as e:
            raise DecryptionError(f"Decryption failed: {e}")
    
    def set(self, key: str, value: Union[str, int, float, bool], encrypt: bool = True) -> None:
        """
        Set an environment variable.
        
        Args:
            key: Variable name
            value: Variable value
            encrypt: Whether to encrypt the value (default: True)
        
        Raises:
            SecureEnvError: If operation fails
        """
        if not isinstance(key, str) or not key:
            raise SecureEnvError("Key must be a non-empty string")
        
        # Convert value to string
        str_value = str(value)
        
        if encrypt:
            # Encrypt the value and wrap it
            encrypted_data = self.encrypt(str_value)
            stored_value = wrap_encrypted_content(encrypted_data)
        else:
            stored_value = str_value
        
        self._env_vars[key] = stored_value
        self._save_env_file()
    
    def get(self, key: str, default: Any = None, auto_decrypt: bool = True) -> Any:
        """
        Get an environment variable.
        
        Args:
            key: Variable name
            default: Default value if key not found
            auto_decrypt: Whether to automatically decrypt encrypted values
        
        Returns:
            The variable value (decrypted if encrypted and auto_decrypt=True)
        
        Raises:
            DecryptionError: If decryption fails
        """
        if key not in self._env_vars:
            return default
        
        value = self._env_vars[key]
        
        if auto_decrypt and is_encrypted_value(value):
            encrypted_content = extract_encrypted_content(value)
            return self.decrypt(encrypted_content)
        
        return value
    
    def delete(self, key: str) -> bool:
        """
        Delete an environment variable.
        
        Args:
            key: Variable name
        
        Returns:
            bool: True if key was deleted, False if key didn't exist
        """
        if key in self._env_vars:
            del self._env_vars[key]
            self._save_env_file()
            return True
        return False
    
    def list_keys(self, show_encrypted: bool = True) -> Dict[str, bool]:
        """
        List all environment variable keys.
        
        Args:
            show_encrypted: Whether to indicate which keys are encrypted
        
        Returns:
            dict: Keys and their encryption status if show_encrypted=True,
                  otherwise just a list of keys
        """
        if show_encrypted:
            return {
                key: is_encrypted_value(value)
                for key, value in self._env_vars.items()
            }
        else:
            return list(self._env_vars.keys())
    
    def export_to_os_environ(self, decrypt_all: bool = True) -> None:
        """
        Export variables to os.environ.
        
        Args:
            decrypt_all: Whether to decrypt encrypted values before export
        """
        for key, value in self._env_vars.items():
            if decrypt_all and is_encrypted_value(value):
                try:
                    decrypted_value = self.get(key, auto_decrypt=True)
                    os.environ[key] = decrypted_value
                except DecryptionError:
                    # Skip variables that cannot be decrypted
                    continue
            else:
                os.environ[key] = value
    
    def reload(self) -> None:
        """Reload environment variables from file."""
        self._load_env_file()
    
    def change_master_key(self, new_master_key: str) -> None:
        """
        Change the master key and re-encrypt all encrypted variables.
        
        Args:
            new_master_key: New master password/key
        
        Raises:
            InvalidKeyError: If new key is invalid
            DecryptionError: If current variables cannot be decrypted
            SecureEnvError: If re-encryption fails
        """
        # First, decrypt all encrypted variables with current key
        decrypted_vars = {}
        for key, value in self._env_vars.items():
            if is_encrypted_value(value):
                decrypted_vars[key] = self.get(key, auto_decrypt=True)
        
        # Create new cipher with new key
        try:
            new_key = generate_key_from_password(new_master_key)
            new_cipher = Fernet(new_key)
        except Exception as e:
            raise InvalidKeyError(f"Failed to create new encryption key: {e}")
        
        # Re-encrypt variables with new key
        self.cipher = new_cipher
        for key, decrypted_value in decrypted_vars.items():
            self.set(key, decrypted_value, encrypt=True)
    
    def __repr__(self) -> str:
        """String representation of Secrets object."""
        return f"Secrets(env_file='{self.env_file}', variables={len(self._env_vars)})"