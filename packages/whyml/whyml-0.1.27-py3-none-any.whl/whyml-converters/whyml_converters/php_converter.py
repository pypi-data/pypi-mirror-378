"""
WhyML Converters - PHP Converter Module

Advanced PHP converter with modern PHP patterns, class-based generation,
template integration, and secure code practices.

Copyright 2025 Tom Sapletta
Licensed under the Apache License, Version 2.0
"""

from typing import Dict, Any, List, Optional, Union
from pathlib import Path
import re

from whyml_core.utils import StringUtils
from whyml_core.exceptions import ProcessingError
from .base_converter import BaseConverter


class PHPConverter(BaseConverter):
    """Advanced PHP converter with modern PHP patterns and security."""
    
    def __init__(self, php_version="8.0", **kwargs):
        """Initialize PHP converter."""
        super().__init__(**kwargs)
        self.indent_size = 4
        self.current_indent = 0
        self.use_classes = True
        self.namespace = None
        self.use_strict_types = True
        self.php_version = php_version
    
    def _get_output_format(self) -> str:
        """Get output format identifier."""
        return "php"
    
    def _get_template_extension(self) -> str:
        """Get template file extension."""
        return ".php"
    
    def _supports_components(self) -> bool:
        """Check if converter supports components."""
        return True
    
    def convert(self, manifest: Dict[str, Any], **kwargs):
        """Convert manifest to PHP - synchronous wrapper for tests."""
        from .conversion_result import ConversionResult
        import asyncio
        
        # Run async conversion
        try:
            loop = asyncio.get_event_loop()
        except RuntimeError:
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
        
        php_content = loop.run_until_complete(self.convert_manifest(manifest, **kwargs))
        return ConversionResult(content=php_content, format="php")
    
    async def convert_manifest(self, 
                              manifest: Dict[str, Any],
                              output_path: Optional[Union[str, Path]] = None,
                              **options) -> str:
        """Convert WhyML manifest to PHP.
        
        Args:
            manifest: WhyML manifest dictionary
            output_path: Optional output file path
            **options: PHP-specific options
            
        Returns:
            Generated PHP content
        """
        # Configure options
        self.use_classes = options.get('use_classes', True)
        self.namespace = options.get('namespace')
        self.use_strict_types = options.get('strict_types', True)
        self.php_version = options.get('php_version', '8.0')
        
        # Reset indentation
        self.current_indent = 0
        
        # Extract manifest sections
        metadata = self._extract_metadata(manifest)
        structure = self._extract_structure(manifest)
        styles = self._extract_styles(manifest)
        scripts = self._extract_scripts(manifest)
        config = self._extract_config(manifest)
        
        # Build PHP content
        php_parts = []
        
        # PHP opening tag and declarations
        php_parts.append("<?php")
        
        if self.use_strict_types:
            php_parts.append("declare(strict_types=1);")
            php_parts.append("")
        
        # Namespace declaration
        if self.namespace:
            php_parts.append(f"namespace {self.namespace};")
            php_parts.append("")
        
        # Generate PHP content based on structure type
        if self.use_classes:
            class_content = await self._generate_php_class(
                metadata, structure, styles, scripts, config, **options
            )
            php_parts.append(class_content)
        else:
            procedural_content = await self._generate_php_procedural(
                metadata, structure, styles, scripts, config, **options
            )
            php_parts.append(procedural_content)
        
        return '\n'.join(filter(None, php_parts))
    
    async def _generate_php_class(self, 
                                 metadata: Dict[str, Any],
                                 structure: Dict[str, Any],
                                 styles: Dict[str, Any],
                                 scripts: Dict[str, Any],
                                 config: Dict[str, Any],
                                 **options) -> str:
        """Generate PHP class-based implementation."""
        class_name = options.get('class_name', 'WhyMLPage')
        extends_class = options.get('extends')
        implements = options.get('implements', [])
        
        class_lines = []
        
        # Class documentation
        class_lines.append("/**")
        class_lines.append(f" * {metadata.get('title', 'WhyML Generated Page')}")
        if metadata.get('description'):
            class_lines.append(f" * {metadata['description']}")
        class_lines.append(" * Generated by WhyML Converter")
        class_lines.append(" */")
        
        # Class declaration
        class_declaration = f"class {class_name}"
        if extends_class:
            class_declaration += f" extends {extends_class}"
        if implements:
            class_declaration += f" implements {', '.join(implements)}"
        
        class_lines.append(class_declaration)
        class_lines.append("{")
        
        self._increase_indent()
        
        # Class properties
        properties_content = self._generate_php_properties(metadata, config, **options)
        if properties_content:
            class_lines.append(properties_content)
            class_lines.append("")
        
        # Constructor
        constructor_content = self._generate_php_constructor(metadata, config, **options)
        if constructor_content:
            class_lines.append(constructor_content)
            class_lines.append("")
        
        # Render methods
        render_methods = await self._generate_php_render_methods(
            structure, styles, scripts, **options
        )
        class_lines.append(render_methods)
        
        # Utility methods
        utility_methods = self._generate_php_utility_methods(**options)
        if utility_methods:
            class_lines.append("")
            class_lines.append(utility_methods)
        
        self._decrease_indent()
        class_lines.append("}")
        
        # Usage example
        if options.get('include_usage', False):
            class_lines.append("")
            class_lines.append("// Usage example:")
            class_lines.append(f"// $page = new {class_name}();")
            class_lines.append("// echo $page->render();")
        
        return '\n'.join(class_lines)
    
    async def _generate_php_procedural(self, 
                                      metadata: Dict[str, Any],
                                      structure: Dict[str, Any],
                                      styles: Dict[str, Any],
                                      scripts: Dict[str, Any],
                                      config: Dict[str, Any],
                                      **options) -> str:
        """Generate PHP procedural implementation."""
        procedural_lines = []
        
        # Configuration array
        procedural_lines.append("// Configuration")
        config_content = self._generate_php_config_array(metadata, config)
        procedural_lines.append(config_content)
        procedural_lines.append("")
        
        # Render function
        procedural_lines.append("/**")
        procedural_lines.append(" * Render the complete page")
        procedural_lines.append(" * @return string HTML content")
        procedural_lines.append(" */")
        procedural_lines.append("function renderPage(): string")
        procedural_lines.append("{")
        
        self._increase_indent()
        
        # Function body
        render_content = await self._generate_php_render_logic(structure, styles, scripts)
        procedural_lines.append(render_content)
        
        self._decrease_indent()
        procedural_lines.append("}")
        
        # Helper functions
        helper_functions = self._generate_php_helper_functions(**options)
        if helper_functions:
            procedural_lines.append("")
            procedural_lines.append(helper_functions)
        
        # Main execution
        if options.get('auto_execute', True):
            procedural_lines.append("")
            procedural_lines.append("// Auto-execute")
            procedural_lines.append("if (basename($_SERVER['PHP_SELF']) === basename(__FILE__)) {")
            procedural_lines.append("    echo renderPage();")
            procedural_lines.append("}")
        
        return '\n'.join(procedural_lines)
    
    def _generate_php_properties(self, 
                                metadata: Dict[str, Any], 
                                config: Dict[str, Any], 
                                **options) -> str:
        """Generate PHP class properties."""
        properties = []
        
        # Metadata properties
        title = metadata.get('title', 'WhyML Page')
        properties.append(f'{self._indent()}private string $title = "{self._escape_php_string(title)}";')
        
        description = metadata.get('description', '')
        if description:
            properties.append(f'{self._indent()}private string $description = "{self._escape_php_string(description)}";')
        
        # Configuration properties
        if config:
            for key, value in config.items():
                php_value = self._format_php_value(value)
                properties.append(f'{self._indent()}private $config{key.title()} = {php_value};')
        
        # Data properties
        data_props = options.get('properties', {})
        for prop_name, prop_config in data_props.items():
            prop_type = prop_config.get('type', 'mixed')
            prop_default = prop_config.get('default')
            
            if prop_default is not None:
                php_default = self._format_php_value(prop_default)
                properties.append(f'{self._indent()}private {prop_type} ${prop_name} = {php_default};')
            else:
                properties.append(f'{self._indent()}private {prop_type} ${prop_name};')
        
        return '\n'.join(properties)
    
    def _generate_php_constructor(self, 
                                 metadata: Dict[str, Any], 
                                 config: Dict[str, Any], 
                                 **options) -> str:
        """Generate PHP constructor method."""
        constructor_lines = []
        
        # Constructor parameters
        constructor_params = options.get('constructor_params', [])
        param_list = []
        
        for param in constructor_params:
            if isinstance(param, str):
                param_list.append(f"${param} = null")
            elif isinstance(param, dict):
                param_type = param.get('type', '')
                param_name = param.get('name', '')
                param_default = param.get('default')
                
                param_str = f"{param_type} ${param_name}"
                if param_default is not None:
                    param_str += f" = {self._format_php_value(param_default)}"
                param_list.append(param_str)
        
        # Constructor declaration
        constructor_lines.append(f'{self._indent()}public function __construct({", ".join(param_list)})')
        constructor_lines.append(f'{self._indent()}{{')
        
        self._increase_indent()
        
        # Constructor body
        init_logic = options.get('constructor_logic', [])
        for logic in init_logic:
            constructor_lines.append(f'{self._indent()}{logic}')
        
        # Default initialization
        if not init_logic:
            constructor_lines.append(f'{self._indent()}// Initialize component')
        
        self._decrease_indent()
        constructor_lines.append(f'{self._indent()}}}')
        
        return '\n'.join(constructor_lines)
    
    async def _generate_php_render_methods(self, 
                                         structure: Dict[str, Any],
                                         styles: Dict[str, Any],
                                         scripts: Dict[str, Any],
                                         **options) -> str:
        """Generate PHP render methods."""
        render_methods = []
        
        # Main render method
        render_methods.append(f'{self._indent()}/**')
        render_methods.append(f'{self._indent()} * Render the complete HTML page')
        render_methods.append(f'{self._indent()} * @return string HTML content')
        render_methods.append(f'{self._indent()} */')
        render_methods.append(f'{self._indent()}public function render(): string')
        render_methods.append(f'{self._indent()}{{')
        
        self._increase_indent()
        
        # Render logic
        render_logic = await self._generate_php_render_logic(structure, styles, scripts)
        render_methods.append(render_logic)
        
        self._decrease_indent()
        render_methods.append(f'{self._indent()}}}')
        
        # Additional render methods
        if structure:
            additional_methods = await self._generate_php_component_methods(structure)
            if additional_methods:
                render_methods.append("")
                render_methods.append(additional_methods)
        
        return '\n'.join(render_methods)
    
    async def _generate_php_render_logic(self, 
                                       structure: Dict[str, Any],
                                       styles: Dict[str, Any],
                                       scripts: Dict[str, Any]) -> str:
        """Generate PHP render logic."""
        logic_lines = []
        
        # Start HTML output
        logic_lines.append(f'{self._indent()}$html = "<!DOCTYPE html>\\n";')
        logic_lines.append(f'{self._indent()}$html .= "<html lang=\\"en\\">\\n";')
        
        # Head section
        logic_lines.append(f'{self._indent()}$html .= $this->renderHead();')
        
        # Body section
        logic_lines.append(f'{self._indent()}$html .= "<body>\\n";')
        
        if structure:
            logic_lines.append(f'{self._indent()}$html .= $this->renderBody();')
        else:
            logic_lines.append(f'{self._indent()}$html .= "<div>No content</div>\\n";')
        
        # Scripts
        if scripts:
            logic_lines.append(f'{self._indent()}$html .= $this->renderScripts();')
        
        logic_lines.append(f'{self._indent()}$html .= "</body>\\n";')
        logic_lines.append(f'{self._indent()}$html .= "</html>\\n";')
        
        logic_lines.append("")
        logic_lines.append(f'{self._indent()}return $html;')
        
        return '\n'.join(logic_lines)
    
    async def _generate_php_component_methods(self, structure: Dict[str, Any]) -> str:
        """Generate PHP component methods."""
        methods = []
        
        # Head render method
        methods.append(f'{self._indent()}private function renderHead(): string')
        methods.append(f'{self._indent()}{{')
        self._increase_indent()
        
        methods.append(f'{self._indent()}$head = "<head>\\n";')
        methods.append(f'{self._indent()}$head .= "<meta charset=\\"UTF-8\\">\\n";')
        methods.append(f'{self._indent()}$head .= "<meta name=\\"viewport\\" content=\\"width=device-width, initial-scale=1.0\\">\\n";')
        methods.append(f'{self._indent()}$head .= "<title>" . htmlspecialchars($this->title) . "</title>\\n";')
        
        methods.append(f'{self._indent()}if (!empty($this->description)) {{')
        self._increase_indent()
        methods.append(f'{self._indent()}$head .= "<meta name=\\"description\\" content=\\"" . htmlspecialchars($this->description) . "\\">\\n";')
        self._decrease_indent()
        methods.append(f'{self._indent()}}}')
        
        methods.append(f'{self._indent()}$head .= $this->renderStyles();')
        methods.append(f'{self._indent()}$head .= "</head>\\n";')
        methods.append(f'{self._indent()}return $head;')
        
        self._decrease_indent()
        methods.append(f'{self._indent()}}}')
        
        methods.append("")
        
        # Body render method
        methods.append(f'{self._indent()}private function renderBody(): string')
        methods.append(f'{self._indent()}{{')
        self._increase_indent()
        
        body_content = await self._generate_php_structure_render(structure)
        methods.append(body_content)
        
        self._decrease_indent()
        methods.append(f'{self._indent()}}}')
        
        methods.append("")
        
        # Styles render method
        methods.append(f'{self._indent()}private function renderStyles(): string')
        methods.append(f'{self._indent()}{{')
        self._increase_indent()
        
        methods.append(f'{self._indent()}$styles = "";')
        methods.append(f'{self._indent()}// Add your CSS styles here')
        methods.append(f'{self._indent()}return $styles;')
        
        self._decrease_indent()
        methods.append(f'{self._indent()}}}')
        
        methods.append("")
        
        # Scripts render method
        methods.append(f'{self._indent()}private function renderScripts(): string')
        methods.append(f'{self._indent()}{{')
        self._increase_indent()
        
        methods.append(f'{self._indent()}$scripts = "";')
        methods.append(f'{self._indent()}// Add your JavaScript here')
        methods.append(f'{self._indent()}return $scripts;')
        
        self._decrease_indent()
        methods.append(f'{self._indent()}}}')
        
        return '\n'.join(methods)
    
    async def _generate_php_structure_render(self, structure: Dict[str, Any]) -> str:
        """Generate PHP structure rendering logic."""
        structure_lines = []
        
        structure_lines.append(f'{self._indent()}$body = "";')
        
        if 'tag' in structure:
            # Single element
            element_content = await self._generate_php_element_render(structure)
            structure_lines.append(element_content)
        elif 'children' in structure:
            # Multiple elements
            for child in structure['children']:
                element_content = await self._generate_php_element_render(child)
                structure_lines.append(element_content)
        else:
            # Process as container
            for key, value in structure.items():
                if isinstance(value, dict):
                    element_content = await self._generate_php_element_render(value)
                    structure_lines.append(element_content)
        
        structure_lines.append(f'{self._indent()}return $body;')
        
        return '\n'.join(structure_lines)
    
    async def _generate_php_element_render(self, element: Dict[str, Any]) -> str:
        """Generate PHP element rendering code."""
        tag = element.get('tag', 'div')
        attributes = element.get('attributes', {})
        content = element.get('content', '')
        children = element.get('children', [])
        
        # Build attributes string
        attr_parts = []
        for name, value in attributes.items():
            if value is not None and value is not False:
                if value is True:
                    attr_parts.append(name)
                else:
                    escaped_value = self._escape_php_string(str(value))
                    attr_parts.append(f'{name}=\\"{escaped_value}\\"')
        
        attrs_str = ' ' + ' '.join(attr_parts) if attr_parts else ''
        
        # Generate element
        if tag in ['img', 'br', 'hr', 'input', 'meta', 'link']:
            # Self-closing tag
            return f'{self._indent()}$body .= "<{tag}{attrs_str}>\\n";'
        
        # Opening tag
        result_lines = [f'{self._indent()}$body .= "<{tag}{attrs_str}>";']
        
        # Content
        if content:
            escaped_content = self._escape_php_string(content)
            result_lines.append(f'{self._indent()}$body .= "{escaped_content}";')
        
        # Children
        if children:
            for child in children:
                if isinstance(child, dict):
                    child_render = await self._generate_php_element_render(child)
                    result_lines.append(child_render)
                elif isinstance(child, str):
                    escaped_child = self._escape_php_string(child)
                    result_lines.append(f'{self._indent()}$body .= "{escaped_child}";')
        
        # Closing tag
        result_lines.append(f'{self._indent()}$body .= "</{tag}>\\n";')
        
        return '\n'.join(result_lines)
    
    def _generate_php_utility_methods(self, **options) -> str:
        """Generate PHP utility methods."""
        utility_methods = []
        
        # Escape HTML method
        utility_methods.append(f'{self._indent()}/**')
        utility_methods.append(f'{self._indent()} * Escape HTML special characters')
        utility_methods.append(f'{self._indent()} * @param string $text Text to escape')
        utility_methods.append(f'{self._indent()} * @return string Escaped text')
        utility_methods.append(f'{self._indent()} */')
        utility_methods.append(f'{self._indent()}protected function escapeHtml(string $text): string')
        utility_methods.append(f'{self._indent()}{{')
        self._increase_indent()
        utility_methods.append(f'{self._indent()}return htmlspecialchars($text, ENT_QUOTES, "UTF-8");')
        self._decrease_indent()
        utility_methods.append(f'{self._indent()}}}')
        
        utility_methods.append("")
        
        # Format attributes method
        utility_methods.append(f'{self._indent()}/**')
        utility_methods.append(f'{self._indent()} * Format HTML attributes')
        utility_methods.append(f'{self._indent()} * @param array $attributes Attributes array')
        utility_methods.append(f'{self._indent()} * @return string Formatted attributes')
        utility_methods.append(f'{self._indent()} */')
        utility_methods.append(f'{self._indent()}protected function formatAttributes(array $attributes): string')
        utility_methods.append(f'{self._indent()}{{')
        self._increase_indent()
        
        utility_methods.append(f'{self._indent()}$formatted = [];')
        utility_methods.append(f'{self._indent()}foreach ($attributes as $name => $value) {{')
        self._increase_indent()
        utility_methods.append(f'{self._indent()}if ($value === null || $value === false) continue;')
        utility_methods.append(f'{self._indent()}if ($value === true) {{')
        self._increase_indent()
        utility_methods.append(f'{self._indent()}$formatted[] = $name;')
        self._decrease_indent()
        utility_methods.append(f'{self._indent()}}} else {{')
        self._increase_indent()
        utility_methods.append(f'{self._indent()}$formatted[] = $name . \'="\' . $this->escapeHtml((string)$value) . \'"\';')
        self._decrease_indent()
        utility_methods.append(f'{self._indent()}}}')
        self._decrease_indent()
        utility_methods.append(f'{self._indent()}}}')
        utility_methods.append(f'{self._indent()}return empty($formatted) ? "" : " " . implode(" ", $formatted);')
        
        self._decrease_indent()
        utility_methods.append(f'{self._indent()}}}')
        
        return '\n'.join(utility_methods)
    
    def _generate_php_helper_functions(self, **options) -> str:
        """Generate PHP helper functions for procedural approach."""
        helper_functions = []
        
        # Escape function
        helper_functions.append("/**")
        helper_functions.append(" * Escape HTML special characters")
        helper_functions.append(" * @param string $text Text to escape")
        helper_functions.append(" * @return string Escaped text")
        helper_functions.append(" */")
        helper_functions.append("function escapeHtml(string $text): string")
        helper_functions.append("{")
        helper_functions.append("    return htmlspecialchars($text, ENT_QUOTES, 'UTF-8');")
        helper_functions.append("}")
        
        helper_functions.append("")
        
        # Format attributes function
        helper_functions.append("/**")
        helper_functions.append(" * Format HTML attributes")
        helper_functions.append(" * @param array $attributes Attributes array")
        helper_functions.append(" * @return string Formatted attributes")
        helper_functions.append(" */")
        helper_functions.append("function formatAttributes(array $attributes): string")
        helper_functions.append("{")
        helper_functions.append("    $formatted = [];")
        helper_functions.append("    foreach ($attributes as $name => $value) {")
        helper_functions.append("        if ($value === null || $value === false) continue;")
        helper_functions.append("        if ($value === true) {")
        helper_functions.append("            $formatted[] = $name;")
        helper_functions.append("        } else {")
        helper_functions.append("            $formatted[] = $name . '=\"' . escapeHtml((string)$value) . '\"';")
        helper_functions.append("        }")
        helper_functions.append("    }")
        helper_functions.append("    return empty($formatted) ? '' : ' ' . implode(' ', $formatted);")
        helper_functions.append("}")
        
        return '\n'.join(helper_functions)
    
    def _generate_php_config_array(self, metadata: Dict[str, Any], config: Dict[str, Any]) -> str:
        """Generate PHP configuration array."""
        config_lines = []
        
        config_lines.append("$config = [")
        
        # Metadata
        title = metadata.get('title', 'WhyML Page')
        config_lines.append(f'    "title" => "{self._escape_php_string(title)}",')
        
        description = metadata.get('description', '')
        if description:
            config_lines.append(f'    "description" => "{self._escape_php_string(description)}",')
        
        # Additional config
        for key, value in config.items():
            php_value = self._format_php_value(value)
            config_lines.append(f'    "{key}" => {php_value},')
        
        config_lines.append("];")
        
        return '\n'.join(config_lines)
    
    # Helper methods
    
    def _format_php_value(self, value: Any) -> str:
        """Format Python value for PHP."""
        if isinstance(value, str):
            return f'"{self._escape_php_string(value)}"'
        elif isinstance(value, bool):
            return 'true' if value else 'false'
        elif isinstance(value, (int, float)):
            return str(value)
        elif isinstance(value, list):
            items = [self._format_php_value(item) for item in value]
            return f"[{', '.join(items)}]"
        elif isinstance(value, dict):
            items = [f'"{key}" => {self._format_php_value(val)}' for key, val in value.items()]
            return f"[{', '.join(items)}]"
        elif value is None:
            return 'null'
        else:
            return f'"{self._escape_php_string(str(value))}"'
    
    def _escape_php_string(self, text: str) -> str:
        """Escape string for PHP."""
        return text.replace('\\', '\\\\').replace('"', '\\"').replace('\n', '\\n').replace('\r', '\\r').replace('\t', '\\t')
    
    def _indent(self) -> str:
        """Get current indentation string."""
        return ' ' * (self.current_indent * self.indent_size)
    
    def _increase_indent(self) -> None:
        """Increase indentation level."""
        self.current_indent += 1
    
    def _decrease_indent(self) -> None:
        """Decrease indentation level."""
        self.current_indent = max(0, self.current_indent - 1)
