"""This notebook presents augmentation techniques that combine multiple more than one sample: Mixup, CutMix, SpecMix and more"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/03_combination_augmentations.ipynb.

# %% auto 0
__all__ = ['mixup', 'cutmix']

# %% ../../nbs/03_combination_augmentations.ipynb 2
import warnings
from typing import TypeAlias, Sequence

import numpy as np
from numpy.typing import NDArray

from bioacoustics_augmentation.utils.audio import Spectrogram, AudioMetadata
from bioacoustics_augmentation.utils.image import BoundingBox

# %% ../../nbs/03_combination_augmentations.ipynb 5
FloatArray: TypeAlias = NDArray[np.floating]
IntArray: TypeAlias = NDArray[np.integer]

# %% ../../nbs/03_combination_augmentations.ipynb 6
def mixup(
    x: FloatArray,  # Batch of input values
    y: FloatArray,  # One-hot encoded labels
    alpha: float = 1.0,  # Hyperparameter for the Beta distribution
    *,
    per_sample: bool = True,  # Draw a different lambda for each sample if true, otherwise a single lambda for the whole batch
    random_generator: np.random.Generator | None = None,  # Random generator
) -> tuple[FloatArray, FloatArray, FloatArray, NDArray[np.int_]]:
    """
    Internal mixup implementation for raw arrays
    """
    if random_generator is None:
        random_generator = np.random.default_rng()

    num_batch_samples = int(x.shape[0])
    if num_batch_samples == 0:
        raise ValueError("Empty batch is invalid")

    if num_batch_samples == 1:
        index = np.array([0], dtype=np.int_)
    else:
        index = random_generator.permutation(num_batch_samples).astype(np.int_)

    if not (alpha and alpha > 0):
        lambda_ = np.array(1.0, dtype=x.dtype)
        warnings.warn("Mixup it's been used with invalid alpha. No Mixup will be applied.")
    else:
        if per_sample:
            # Sample a unique lambda for each sample in the batch
            lambda_ = random_generator.beta(alpha, alpha, size=num_batch_samples).astype(x.dtype)
        else:
            # Sample a single lambda for the entire batch
            lambda_ = np.array(random_generator.beta(alpha, alpha), dtype=x.dtype)

    # Prepare mixing weights for inputs
    if per_sample:
        # Reshape for element-wise multiplication with the input data `x`
        expand_shape = (num_batch_samples,) + (1,) * (x.ndim - 1)
        lambda_x = lam.reshape(expand_shape)

        # Reshape for element-wise multiplication with the labels `y`
        lambda_y = lam.reshape(num_batch_samples, 1)
    else:
        lambda_x = lambda_
        lambda_y = lambda_

    # Perform the Mixup operation
    mixed_x = lambda_x * x + (1.0 - lambda_x) * x[index]
    mixed_y = lambda_y * y + (1.0 - lambda_y) * y[index]

    return mixed_x, mixed_y, lambda_, index

# %% ../../nbs/03_combination_augmentations.ipynb 8
def _rand_bbox(
    size: tuple[int, ...],
    lambda_: float,
    random_generator: np.random.Generator
) -> BoundingBox:
    """
    Generate random bounding box coordinates for CutMix
    """
    width = size[-1]
    height = size[-2] if len(size) > 1 else 1

    cut_ratio = np.sqrt(1.0 - lambda_)
    cut_width = int(width * cut_ratio)
    cut_height = int(height * cut_ratio)

    # Uniformly sample the center of the patch
    center_x = random_generator.integers(0, width)
    center_y = random_generator.integers(0, height)

    x1 = np.clip(center_x - cut_width // 2, 0, width)
    y1 = np.clip(center_y - cut_height // 2, 0, height)
    x2 = np.clip(center_x + cut_width // 2, 0, width)
    y2 = np.clip(center_y + cut_height // 2, 0, height)

    return BoundingBox(x1=x1, y1=y1, x2=x2, y2=y2)

# %% ../../nbs/03_combination_augmentations.ipynb 9
def _paste_patch(
    source_sample: FloatArray,
    destination_sample: FloatArray,
    bbox: BoundingBox
) -> None:
    """
    Pastes a patch from the source sample to the destination sample.
    """
    if destination_sample.ndim == 1:
        # Handles 1D data like sequences (Batch, Features)
        destination_sample[bbox.x1:bbox.x2] = source_sample[bbox.x1:bbox.x2]
    else:
        # Handles 2D+ data like images (Batch, Channels, Height, Width)
        slicing = (..., slice(bbox.y1, bbox.y2), slice(bbox.x1, bbox.x2))
        destination_sample[slicing] = source_sample[slicing]

# %% ../../nbs/03_combination_augmentations.ipynb 10
def cutmix(
    x: FloatArray,  # Input data batch (e.g., images or features).
    y: FloatArray,  # One-hot encoded labels
    alpha: float = 1.0,  # Hyperparameter for the Beta distribution
    *,
    random_generator: np.random.Generator | None = None,
) -> tuple[FloatArray, FloatArray, float, NDArray[np.int_]]:
    """
    Internal CutMix implementation for raw arrays
    """
    if random_generator is None:
        random_generator = np.random.default_rng()

    num_samples = int(x.shape[0])
    if num_samples == 0:
        raise ValueError("Empty batch is invalid")

    if not (alpha and alpha > 0):
        warnings.warn("CutMix is used with an invalid alpha. No augmentation will be applied.")
        return x, y, 1.0, np.arange(num_samples, dtype=np.int_)

    # Generate a random permutation of indices to pair samples for mixing
    if num_samples == 1:
        source_indices = np.array([0], dtype=np.int_)
    else:
        source_indices = random_generator.permutation(num_samples).astype(np.int_)

    lambda_ = random_generator.beta(alpha, alpha)
    mixed_x = x.copy()
    mixed_y = y.copy()

    for dest_idx in range(num_samples):
        source_idx = source_indices[dest_idx]

        # Avoid mixing the same sample
        if dest_idx == source_idx:
            continue

        bbox = _rand_bbox(x[dest_idx].shape, lambda_, random_generator)

        if x.ndim == 2:
            total_area = x.shape[-1]
        else: # For data of shape (N, ..., H, W)
            total_area = x.shape[-1] * x.shape[-2]

        if total_area == 0:
            continue

        # Adjust lambda based on the actual (clipped) box size
        actual_lambda = 1.0 - (bbox.area() / total_area)

        _paste_patch(
            destination_sample=mixed_x[dest_idx],
            source_sample=x[source_idx],
            bbox=bbox    
        )

        # Mix the labels proportionally
        # according to the paper: \lambda y_A + (1 - \lambda) y_B
        mixed_y[dest_idx] = actual_lambda * y[dest_idx] + (1.0 - actual_lambda) * y[source_idx]

    return mixed_x, mixed_y, np.array(lambda_, dtype=x.dtype), source_indices
