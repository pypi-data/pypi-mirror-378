"""
ProServe Arduino Code Generator
Generates Arduino C++ service code from manifests for embedded devices
"""

from typing import List
from ...core.manifest import ServiceManifest


class ArduinoCodeGenerator:
    """Generates Arduino C++ service code from ProServe manifests"""
    
    def __init__(self, manifest: ServiceManifest, platform: str):
        self.manifest = manifest
        self.platform = platform
    
    async def generate_service_code(self) -> str:
        """Generate complete Arduino C++ service code from manifest"""
        lines = []
        
        # Add header
        lines.extend(self._generate_header())
        
        # Add includes
        lines.extend(self._generate_includes())
        
        # Add configuration
        lines.extend(self._generate_configuration())
        
        # Add global variables
        lines.extend(self._generate_globals())
        
        # Add function declarations
        lines.extend(self._generate_function_declarations())
        
        # Add setup function
        lines.extend(self._generate_setup_function())
        
        # Add loop function
        lines.extend(self._generate_loop_function())
        
        # Add helper functions
        lines.extend(self._generate_helper_functions())
        
        return '\n'.join(lines)
    
    def _generate_header(self) -> List[str]:
        """Generate file header with metadata"""
        return [
            "/*",
            " * ProServe Arduino Service",
            f" * Service: {self.manifest.name}",
            f" * Platform: {self.platform}",
            f" * Version: {getattr(self.manifest, 'version', '1.0.0')}",
            " * Generated by ProServe Framework",
            " */",
            ""
        ]
    
    def _generate_includes(self) -> List[str]:
        """Generate required includes for Arduino"""
        includes = [
            "#include <Arduino.h>"
        ]
        
        # Add platform-specific includes
        if self.platform in ['esp32dev', 'esp32']:
            includes.extend([
                "#include <WiFi.h>",
                "#include <WebServer.h>"
            ])
        elif self.platform in ['uno_r4_wifi', 'nano33iot']:
            includes.extend([
                "#include <WiFiNINA.h>",
                "#include <ArduinoHttpClient.h>"
            ])
        
        # Add feature-based includes
        if hasattr(self.manifest, 'endpoints') and self.manifest.endpoints:
            includes.append("#include <ArduinoJson.h>")
        
        includes.append("")
        return includes
    
    def _generate_configuration(self) -> List[str]:
        """Generate service configuration constants"""
        config_lines = [
            "// Service configuration",
            f"const char* SERVICE_NAME = \"{self.manifest.name}\";",
            f"const char* PLATFORM = \"{self.platform}\";"
        ]
        
        # Add port configuration
        if hasattr(self.manifest, 'port') and self.manifest.port:
            config_lines.append(f"const int SERVICE_PORT = {self.manifest.port};")
        else:
            config_lines.append("const int SERVICE_PORT = 80;")
        
        # Add timing constants
        config_lines.extend([
            "const unsigned long HEARTBEAT_INTERVAL = 1000;  // 1 second",
            "const unsigned long TASK_INTERVAL = 5000;       // 5 seconds"
        ])
        
        config_lines.append("")
        return config_lines
    
    def _generate_globals(self) -> List[str]:
        """Generate global variables"""
        globals_lines = [
            "// Global variables",
            "unsigned long lastHeartbeat = 0;",
            "unsigned long lastTaskExecution = 0;",
            "unsigned long serviceStartTime = 0;",
            "bool ledState = false;"
        ]
        
        # Add network-related globals
        if self.platform in ['esp32dev', 'esp32', 'uno_r4_wifi', 'nano33iot']:
            globals_lines.extend([
                "bool wifiConnected = false;",
                "// WiFi credentials (set via deployment)",
                "const char* wifi_ssid = \"ProServe-Network\";",
                "const char* wifi_password = \"proserve123\";"
            ])
            
            if self.platform in ['esp32dev', 'esp32']:
                globals_lines.append("WebServer server(SERVICE_PORT);")
        
        globals_lines.append("")
        return globals_lines
    
    def _generate_function_declarations(self) -> List[str]:
        """Generate function declarations"""
        declarations = [
            "// Function declarations",
            "void initializeService();",
            "void handleHeartbeat();",
            "void executeBackgroundTasks();",
            "void printServiceStatus();"
        ]
        
        # Add network function declarations
        if self.platform in ['esp32dev', 'esp32', 'uno_r4_wifi', 'nano33iot']:
            declarations.extend([
                "void initializeWiFi();",
                "void handleNetworkRequests();"
            ])
        
        # Add endpoint handlers
        if hasattr(self.manifest, 'endpoints') and self.manifest.endpoints:
            for endpoint in self.manifest.endpoints:
                handler_name = self._get_handler_name(endpoint.path)
                declarations.append(f"void {handler_name}();")
        
        declarations.append("")
        return declarations
    
    def _generate_setup_function(self) -> List[str]:
        """Generate Arduino setup function"""
        setup_lines = [
            "void setup() {",
            "  Serial.begin(115200);",
            "  while (!Serial) {",
            "    delay(10);",
            "  }",
            "  ",
            "  Serial.println(\"ProServe Arduino Service Starting...\");",
            "  Serial.print(\"Service: \");",
            "  Serial.println(SERVICE_NAME);",
            "  Serial.print(\"Platform: \");",
            "  Serial.println(PLATFORM);",
            "  ",
            "  // Initialize service",
            "  initializeService();",
            "  "
        ]
        
        # Add WiFi initialization
        if self.platform in ['esp32dev', 'esp32', 'uno_r4_wifi', 'nano33iot']:
            setup_lines.extend([
                "  // Initialize WiFi",
                "  initializeWiFi();",
                "  "
            ])
        
        setup_lines.extend([
            "  serviceStartTime = millis();",
            "  Serial.println(\"Service initialized successfully!\");",
            "  Serial.println(\"======================================\");",
            "}",
            ""
        ])
        
        return setup_lines
    
    def _generate_loop_function(self) -> List[str]:
        """Generate Arduino main loop function"""
        loop_lines = [
            "void loop() {",
            "  unsigned long currentTime = millis();",
            "  ",
            "  // Service heartbeat",
            "  if (currentTime - lastHeartbeat >= HEARTBEAT_INTERVAL) {",
            "    handleHeartbeat();",
            "    lastHeartbeat = currentTime;",
            "  }",
            "  ",
            "  // Execute background tasks",
            "  if (currentTime - lastTaskExecution >= TASK_INTERVAL) {",
            "    executeBackgroundTasks();",
            "    lastTaskExecution = currentTime;",
            "  }",
            "  "
        ]
        
        # Add network request handling
        if self.platform in ['esp32dev', 'esp32', 'uno_r4_wifi', 'nano33iot']:
            loop_lines.extend([
                "  // Handle network requests",
                "  if (wifiConnected) {",
                "    handleNetworkRequests();",
                "  }",
                "  "
            ])
        
        loop_lines.extend([
            "  // Small delay to prevent overwhelming",
            "  delay(100);",
            "}",
            ""
        ])
        
        return loop_lines
    
    def _generate_helper_functions(self) -> List[str]:
        """Generate helper functions"""
        helper_lines = [
            "void initializeService() {",
            "  // Initialize LED if available",
            "  #ifdef LED_BUILTIN",
            "  pinMode(LED_BUILTIN, OUTPUT);",
            "  digitalWrite(LED_BUILTIN, LOW);",
            "  #endif",
            "  ",
            "  Serial.println(\"Service components initialized\");",
            "}",
            "",
            "void handleHeartbeat() {",
            "  Serial.print(SERVICE_NAME);",
            "  Serial.print(\": Running... (uptime: \");",
            "  Serial.print((millis() - serviceStartTime) / 1000);",
            "  Serial.println(\" seconds)\");",
            "  ",
            "  // Toggle LED",
            "  #ifdef LED_BUILTIN",
            "  ledState = !ledState;",
            "  digitalWrite(LED_BUILTIN, ledState ? HIGH : LOW);",
            "  #endif",
            "}",
            "",
            "void executeBackgroundTasks() {",
            "  Serial.println(\"Executing background tasks...\");",
            "  ",
            "  // Add background task logic here",
            "  "
        ]
        
        # Add background tasks from manifest
        if hasattr(self.manifest, 'background_tasks') and self.manifest.background_tasks:
            helper_lines.extend([
                "  // Manifest-defined background tasks",
                "  // TODO: Implement specific background tasks"
            ])
        
        helper_lines.extend([
            "}",
            "",
            "void printServiceStatus() {",
            "  Serial.println(\"=== Service Status ===\");",
            "  Serial.print(\"Service: \");",
            "  Serial.println(SERVICE_NAME);",
            "  Serial.print(\"Platform: \");",
            "  Serial.println(PLATFORM);",
            "  Serial.print(\"Uptime: \");",
            "  Serial.print((millis() - serviceStartTime) / 1000);",
            "  Serial.println(\" seconds\");",
            "  Serial.print(\"Free RAM: \");",
            "  #ifdef ESP32",
            "  Serial.print(ESP.getFreeHeap());",
            "  #else",
            "  Serial.print(\"N/A\");",
            "  #endif",
            "  Serial.println(\" bytes\");",
            "  Serial.println(\"=====================\");",
            "}"
        ])
        
        # Add network functions if needed
        if self.platform in ['esp32dev', 'esp32', 'uno_r4_wifi', 'nano33iot']:
            helper_lines.extend(self._generate_network_functions())
        
        return helper_lines
    
    def _generate_network_functions(self) -> List[str]:
        """Generate network-related functions"""
        network_lines = [
            "",
            "void initializeWiFi() {",
            "  Serial.print(\"Connecting to WiFi...\");",
            "  WiFi.begin(wifi_ssid, wifi_password);",
            "  ",
            "  int attempts = 0;",
            "  while (WiFi.status() != WL_CONNECTED && attempts < 20) {",
            "    delay(500);",
            "    Serial.print(\".\");",
            "    attempts++;",
            "  }",
            "  ",
            "  if (WiFi.status() == WL_CONNECTED) {",
            "    wifiConnected = true;",
            "    Serial.println();",
            "    Serial.print(\"WiFi connected! IP: \");",
            "    Serial.println(WiFi.localIP());",
            "  } else {",
            "    Serial.println();",
            "    Serial.println(\"WiFi connection failed - running offline\");",
            "  }",
            "}",
            "",
            "void handleNetworkRequests() {",
            "  // Handle incoming network requests",
            "  // TODO: Implement network request handling",
            "}"
        ]
        
        return network_lines
    
    def _get_handler_name(self, path: str) -> str:
        """Convert endpoint path to valid C++ function name"""
        # Convert path to valid C++ identifier
        handler_name = path.replace('/', '_').replace('-', '_').replace('{', '').replace('}', '')
        if handler_name.startswith('_'):
            handler_name = handler_name[1:]
        if not handler_name:
            handler_name = "root"
        return f"handle_{handler_name}"
