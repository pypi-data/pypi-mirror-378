"""OSCAR Executor for command execution."""

import json
import logging
import os
import shlex
import shutil
import tempfile
import time
import uuid
from typing import List, Dict, Any, Optional

try:
    from constants import *
    from utils import create_oscar_client
    from context_utils import suppress_stdout_to_stderr
except ImportError:
    # Fallback for package import
    from .constants import *
    from .utils import create_oscar_client
    from .context_utils import suppress_stdout_to_stderr

log = logging.getLogger("oscar-backend")


class OSCARExecutor:
    """Modular executor interface for OSCAR command execution."""
    
    def __init__(self, oscar_endpoint, oscar_token, oscar_username, oscar_password, mount_path, service_manager=None, ssl=True):
        self.oscar_endpoint = oscar_endpoint
        self.oscar_token = oscar_token
        self.oscar_username = oscar_username
        self.oscar_password = oscar_password
        self.mount_path = mount_path
        self.service_manager = service_manager
        self.ssl = ssl
        self.client = None
        self.service_config = None
        
    def get_client(self):
        """Get or create OSCAR client."""
        if self.client is None:
            self.client = create_oscar_client(
                self.oscar_endpoint,
                self.oscar_token,
                self.oscar_username,
                self.oscar_password,
                self.ssl
            )
        return self.client
        
    def get_service_config(self):
        """Get service configuration from OSCAR."""
        if self.service_config is None:
            client = self.get_client()
            services = client.list_services()
            service_json = json.loads(services.text)
            
            # Find the target service
            for svc in service_json:
                if svc['name'] == self.service_name:
                    self.service_config = svc
                    break
            
            if not self.service_config:
                raise Exception(f"Service {self.service_name} not found")
                
        return self.service_config
        
    def create_command_script(self, command, environment, working_directory, stdout_file=None, output_dir=".", job_id=None, tool_spec=None):
        """Create a simplified script file with just the CWL command."""
        random_uuid = str(uuid.uuid4())
        job_id = job_id or random_uuid
        script_name = f"cwl_command_{job_id}.sh"
        script_path = os.path.join(output_dir, script_name)
        
        os.makedirs(output_dir, exist_ok=True)
        
        # Create simple bash script content
        script_content = "#!/bin/bash\n\n"
        script_content += "# CWL Command Script Generated by cwl-oscar\n\n"
        
        # Set environment variables including CWL_JOB_ID
        script_content += "# Set environment variables\n"
        script_content += f'export CWL_JOB_ID="{job_id}"\n'
        
        for key, value in environment.items():
            # Escape quotes and handle special characters
            escaped_value = str(value).replace('"', '\\"').replace('$', '\\$')
            script_content += f'export {key}="{escaped_value}"\n'
        
        # Use TMP_OUTPUT_DIR as workspace (available by default in OSCAR execution)
        script_content += "\n# Use TMP_OUTPUT_DIR as workspace\n"
        script_content += "cd \"$TMP_OUTPUT_DIR\"\n"
        script_content += "echo \"Working in: $TMP_OUTPUT_DIR\"\n\n"
        
        # * Handle InitialWorkDirRequirement for inline file creation
        if tool_spec:
            script_content += self._generate_initial_work_dir_commands(tool_spec)
        
        
        # Execute the main command (cwltool handles input/output file management)
        script_content += "# Execute CWL command\n"
        
        # Quote command arguments properly
        quoted_command = [shlex.quote(arg) for arg in command]
        command_line = ' '.join(quoted_command)
        
        # Handle stdout redirection if specified
        if stdout_file:
            script_content += f"{command_line} > {shlex.quote(stdout_file)} 2>&1\n"
        else:
            script_content += f"{command_line}\n"
        
        # Store the exit code
        script_content += "exit_code=$?\n\n"
        
        # Copy all output from TMP_OUTPUT_DIR to the mount path
        script_content += "# Copy output files to mount path\n"
        script_content += "OUTPUT_DIR=\"$CWL_MOUNT_PATH/$CWL_JOB_ID\"\n"
        script_content += "mkdir -p \"$OUTPUT_DIR\"\n"
        script_content += "cp -r \"$TMP_OUTPUT_DIR\"/* \"$OUTPUT_DIR\"/ 2>/dev/null || true\n"
        script_content += "echo \"SCRIPT: Files copied to $OUTPUT_DIR\"\n"
        script_content += "echo \"SCRIPT: Command completed with exit code: $exit_code\"\n"
        script_content += "exit $exit_code\n"
        
        # Write the script to file
        with open(script_path, 'w') as f:
            f.write(script_content)
        
        # Make script executable
        os.chmod(script_path, 0o755)
        
        log.debug("[job] Created command script: %s with command: %s", script_path, command_line)
        return script_path
    
    def _generate_initial_work_dir_commands(self, tool_spec):
        """Generate bash commands to create files specified in InitialWorkDirRequirement.
        
        Args:
            tool_spec: CWL tool specification dictionary
            
        Returns:
            String containing bash commands to create the required files
        """
        if not tool_spec or not isinstance(tool_spec, dict):
            return ""
            
        commands = ""
        requirements = tool_spec.get('requirements', {})
        
        # * Handle requirements as either dict or list format
        if isinstance(requirements, dict):
            # CWL v1.2+ format: requirements as dictionary
            if 'InitialWorkDirRequirement' in requirements:
                req = requirements['InitialWorkDirRequirement']
                commands += self._process_initial_work_dir_listing(req.get('listing', []))
        elif isinstance(requirements, list):
            # CWL v1.0 format: requirements as list of objects
            for req in requirements:
                if isinstance(req, dict) and req.get('class') == 'InitialWorkDirRequirement':
                    commands += self._process_initial_work_dir_listing(req.get('listing', []))
        
        # * Also check hints for InitialWorkDirRequirement
        hints = tool_spec.get('hints', [])
        if isinstance(hints, dict):
            # Hints as dictionary
            if 'InitialWorkDirRequirement' in hints:
                hint = hints['InitialWorkDirRequirement']
                commands += self._process_initial_work_dir_listing(hint.get('listing', []))
        elif isinstance(hints, list):
            # Hints as list
            for hint in hints:
                if isinstance(hint, dict) and hint.get('class') == 'InitialWorkDirRequirement':
                    commands += self._process_initial_work_dir_listing(hint.get('listing', []))
                
        return commands
    
    def _process_initial_work_dir_listing(self, listing):
        """Process the listing entries from InitialWorkDirRequirement.
        
        Args:
            listing: List of file/directory entries to create
            
        Returns:
            String containing bash commands to create the files
        """
        if not listing:
            return ""
            
        commands = "# Create files from InitialWorkDirRequirement\n"
        
        for entry in listing:
            if isinstance(entry, dict):
                # Handle inline file creation with entryname and entry
                if 'entryname' in entry and 'entry' in entry:
                    filename = entry['entryname']
                    content = entry['entry']
                    
                    # * Escape the content for safe inclusion in bash script
                    # Use here-document (heredoc) to handle multi-line content safely
                    commands += f"# Creating file: {filename}\n"
                    commands += f"cat > {shlex.quote(filename)} << 'EOF_CWL_OSCAR'\n"
                    commands += content
                    if not content.endswith('\n'):
                        commands += '\n'
                    commands += "EOF_CWL_OSCAR\n"
                    commands += f"echo \"Created file: {filename}\"\n\n"
                    
                # TODO: Handle other InitialWorkDirRequirement entry types like:
                # - File references: {"class": "File", "location": "..."}
                # - Directory references: {"class": "Directory", "location": "..."}
                # - Expression entries with valueFrom
                
        return commands
        
    def upload_and_wait_for_output(self, local_file_path, timeout_seconds=DEFAULT_UPLOAD_TIMEOUT, check_interval=DEFAULT_CHECK_INTERVAL):
        """Upload a file to OSCAR service and wait for the corresponding output file."""
        
        # Get service configuration
        service = self.get_service_config()
        storage_service = self.get_client().create_storage_client()
        
        # Extract service configuration
        in_provider = service['input'][0]['storage_provider']
        in_path = service['input'][0]['path']
        out_provider = service['output'][0]['storage_provider']
        out_path = service['output'][0]['path']
        
        file_name = os.path.basename(local_file_path)
        expected_output_name = file_name + EXIT_CODE_EXTENSION
        expected_output_path = out_path + "/" + expected_output_name
        
        log.info("Uploading %s to OSCAR service...", file_name)
        
        # Upload the input file
        try:
            with suppress_stdout_to_stderr():
                storage_service.upload_file(in_provider, local_file_path, in_path)
        except Exception as e:
            log.error("Upload failed: %s", e)
            return None
        
        log.info("Waiting for output file (max %ds)...", timeout_seconds)
        
        # Wait for the output file
        start_time = time.time()
        while time.time() - start_time < timeout_seconds:
            try:
                with suppress_stdout_to_stderr():
                    files = storage_service.list_files_from_path(out_provider, expected_output_path)
                
                if 'Contents' in files:
                    for file_entry in files['Contents']:
                        if file_entry['Key'] == expected_output_path or file_entry['Key'].endswith(expected_output_name):
                            log.info("Output file found: %s (%s bytes)", file_entry['Key'], file_entry['Size'])
                            return file_entry
                
                time.sleep(check_interval)
                
            except Exception as e:
                log.debug("Error checking for output: %s", e)
                time.sleep(check_interval)
        
        log.error("Timeout: Output file not found after %d seconds", timeout_seconds)
        return None
        
    def download_output_file(self, remote_output_path, local_download_path):
        """Download an output file from OSCAR service."""
        
        try:
            # Get service configuration
            service = self.get_service_config()
            storage_service = self.get_client().create_storage_client()
            out_provider = service['output'][0]['storage_provider']
            service_out_path = service['output'][0]['path']
            
            # Extract filename and prepare paths
            filename = os.path.basename(remote_output_path)
            temp_dir = os.path.dirname(local_download_path)
            
            # Create directories
            os.makedirs(temp_dir, exist_ok=True)
            
            # Construct full remote path (service_out_path + filename)
            if service_out_path and remote_output_path.startswith('out/'):
                file_only = remote_output_path[4:]  # Remove 'out/' prefix
                full_remote_path = service_out_path + '/' + file_only
            else:
                full_remote_path = service_out_path + '/' + remote_output_path
            
            log.debug("Downloading %s...", filename)
            
            # Download using correct parameter order: provider, local_directory, remote_path
            with suppress_stdout_to_stderr():
                storage_service.download_file(out_provider, temp_dir, full_remote_path)
            
            # Find downloaded file
            possible_paths = [
                os.path.join(temp_dir, 'out', filename),  # remote structure recreated
                os.path.join(temp_dir, filename),  # filename in temp directory
            ]
            
            downloaded_file_path = None
            for path in possible_paths:
                if os.path.exists(path):
                    downloaded_file_path = path
                    break
            
            if downloaded_file_path:
                # Move to desired location if needed
                if downloaded_file_path != local_download_path:
                    shutil.move(downloaded_file_path, local_download_path)
                
                log.debug("Download successful: %s", local_download_path)
                return True
            else:
                log.error("Downloaded file not found in expected locations")
                return False
                
        except Exception as e:
            log.error("Download failed: %s", e)
            return False

        
    def execute_command(self, command, environment, working_directory, job_name, tool_spec=None, stdout_file=None, job_id=None):
        """
        Execute a command using OSCAR service via file upload/download and return the exit code.
        
        Args:
            command: List of command and arguments to execute
            environment: Dictionary of environment variables
            working_directory: Directory to execute the command in
            job_name: Name of the job (for logging)
            tool_spec: CommandLineTool specification for dynamic service selection
            stdout_file: Optional stdout redirection file
            job_id: Optional job ID to use (if not provided, one will be generated)
            
        Returns:
            Exit code of the command (0 for success, non-zero for failure)
        """
        log.info(LOG_PREFIX_JOB + " Executing command via OSCAR: %s", job_name, " ".join(command))
        log.debug(LOG_PREFIX_JOB + " Working directory: %s", job_name, working_directory)
        log.debug(LOG_PREFIX_JOB + " Environment variables: %s", job_name, environment)
        
        # Determine service name dynamically
        if self.service_manager and tool_spec:
            log.debug("%s: " + LOG_PREFIX_JOB + " Using service manager to determine service for tool", LOG_PREFIX_EXECUTOR, job_name)
            service_name = self.service_manager.get_or_create_service(tool_spec, job_name)
            log.info("%s: " + LOG_PREFIX_JOB + " Service manager selected service: %s", LOG_PREFIX_EXECUTOR, job_name, service_name)
        else:
            # Fall back to default service
            service_name = "run-script-event2"
            log.warning("%s: " + LOG_PREFIX_JOB + " No service manager or tool spec, using default service: %s", LOG_PREFIX_EXECUTOR, job_name, service_name)
        
        # Temporarily set service_name for this execution
        original_service_name = getattr(self, 'service_name', None)
        self.service_name = service_name
        
        script_path = None
        output_path = None
        
        try:
            # Create a temporary directory for scripts
            temp_dir = tempfile.mkdtemp(prefix="cwl_oscar_")
            
            # Use provided job_id or create command script file with job-specific ID
            if job_id is None:
                job_id = f"{job_name}_{int(time.time())}"
            
            log.debug(LOG_PREFIX_JOB + " Using job_id: %s", job_name, job_id)
            script_path = self.create_command_script(
                command, environment, working_directory, stdout_file=stdout_file, output_dir=temp_dir, job_id=job_id, tool_spec=tool_spec
            )
            
            # Upload script and wait for output
            log.info(LOG_PREFIX_JOB + " Submitting job to OSCAR service: %s", job_name, self.service_name)
            output_file = self.upload_and_wait_for_output(script_path)
            
            if output_file is None:
                log.error(LOG_PREFIX_JOB + " Failed to get output file from OSCAR", job_name)
                return 1
            
            # Download the output file
            output_filename = os.path.basename(script_path) + OUTPUT_EXTENSION
            output_path = os.path.join(temp_dir, output_filename)
            
            success = self.download_output_file(output_file['Key'], output_path)
            if not success:
                log.error(LOG_PREFIX_JOB + " Failed to download output file", job_name)
                return 1
            
            # Read the exit code from the output file
            try:
                with open(output_path, 'r') as f:
                    output_content = f.read().strip()
                
                log.debug(LOG_PREFIX_JOB + " Exit code file content: '%s' (length: %d)", job_name, repr(output_content), len(output_content))
                log.debug(LOG_PREFIX_JOB + " Exit code isdigit(): %s", job_name, output_content.isdigit())
                
                # The output file should contain the exit code
                # For OSCAR script execution, it typically contains the exit code
                if output_content.isdigit():
                    exit_code = int(output_content)
                    log.debug(LOG_PREFIX_JOB + " Parsed exit code as integer: %d", job_name, exit_code)
                else:
                    log.warning(LOG_PREFIX_JOB + " Exit code content is not a digit, defaulting to 0. Content: '%s'", job_name, repr(output_content))
                    exit_code = 0
                
                if exit_code == 0:
                    log.info(LOG_PREFIX_JOB + " OSCAR job completed successfully", job_name)
                else:
                    log.warning(LOG_PREFIX_JOB + " OSCAR job completed with exit code %d", job_name, exit_code)
                
                # Note: All outputs (including stdout) are now available in mount_path/job_id
                # No need to download them separately as they're copied by the script
                log.info(LOG_PREFIX_JOB + " All outputs have been copied to mount path by the script", job_name)
                
                return exit_code
                
            except (ValueError, IOError) as e:
                log.warning(LOG_PREFIX_JOB + " Could not parse exit code from output: %s, assuming success", job_name, e)
                return 0
                
        except Exception as e:
            log.error(LOG_PREFIX_JOB + " Error executing command via OSCAR: %s", job_name, str(e))
            return 1
            
        finally:
            # Restore original service_name
            if original_service_name:
                self.service_name = original_service_name
            # Clean up temporary files
            try:
                if script_path and os.path.exists(script_path):
                    os.remove(script_path)
                if output_path and os.path.exists(output_path):
                    os.remove(output_path)
                # Clean up temp directory
                temp_dir_path = os.path.dirname(script_path) if script_path else None
                if temp_dir_path and os.path.exists(temp_dir_path):
                    shutil.rmtree(temp_dir_path, ignore_errors=True)
            except Exception as e:
                log.debug(LOG_PREFIX_JOB + " Error cleaning up temporary files: %s", job_name, e)
