# SPDX-FileCopyrightText: 2025 Eaton Corporation
# SPDX-License-Identifier: MIT
"""
Overview
--------

The Map File Parser is a module that parses linker map files and extracts
information about memory regions, sections, and symbols in a format compatible
with memtab's symbols dictionary.

Linker map files contain detailed information about how a program's code and
data are laid out in memory. The MapFileParser class analyzes these files to
extract this information in a structured way.

This tool was developed specifically for parsing GNU linker map files
generated by `arm-none-eabi-ld`, but it can be adapted for other linkers
with similar formats.

Usage
-----

To use the Map File Parser:

.. code-block:: python

   from memtab import MapFileParser

   # Parse a map file
   parser = MapFileParser("/path/to/your/map/file.map")

   # Access parsed data
   memory_regions = parser.get_memory_regions()
   sections = parser.get_sections()
   symbols = parser.get_symbols_dict()

Features
--------

- Parses memory regions with their origins, lengths, and attributes
- Extracts sections with their addresses and sizes
- Extracts symbols with their addresses, sizes, and memory types
- Assigns regions to symbols based on their addresses
- Provides data in a format compatible with memtab's symbols dictionary

Integration with memtab
------------------------

The MapFileParser class is designed to work seamlessly with memtab. The
symbols extracted by the parser can be used in the same way as the symbols
dictionary in memtab.py.

References:
------------------------
- GNU LD Map File Format: https://sourceware.org/binutils/docs/ld/Options.html#index-_002d_002dprint_002dmap
- LinkerMapViz: https://github.com/PromyLOPh/linkermapviz/blob/master/linkermapviz/__init__.py

"""

import re
from pathlib import Path
from typing import Any, Dict, List

from memtab.models import Section, Symbol
from memtab.parsers.base import MemtabParser


class MapFileParser(MemtabParser):
    """
    Parser for .map files generated by linkers like GNU LD.

    This class parses a .map file and extracts memory regions, sections,
    and symbols into a structure compatible with memtab's symbols dictionary.
    """

    command = "map"  # not used for execution, but helpful for identification

    def __process_archives(self, archive_lines: List[str]) -> None:
        """At the moment, we have no need for this section, so we just squirrel some basic data away for another day"""
        # self.archive_member_pattern = re.compile(r"^(\S+)\((\S+)\)\s+(\S+)")
        # for line in archive_lines:
        #     line = line.strip()
        #     match = self.archive_member_pattern.match(line)
        #     if match:
        #         archive = match.group(1)
        #         member = match.group(2)
        #         reference = match.group(3) if len(match.groups()) > 2 else ""
        #         self.archive_members[f"{archive}({member})"] = reference

    def __process_discarded(self, discarded_lines: List[str]) -> None:
        """At the moment, we have no need for this section, so this is a "do-nothing" method."""
        pass

    def __process_memory_config(self, memory_config_lines: List[str]) -> None:
        """currently we do nothing with this memory configuration info"""
        pass
        # self.memory_config_pattern = re.compile(r"^\s*(\S+)\s+0x([0-9a-fA-F]+)\s+0x([0-9a-fA-F]+)\s+([rwx]+)$")
        # for line in memory_config_lines:
        #     line = line.strip()
        #     if not line or line.startswith("Name") or line.startswith("----"):
        #         continue

        #     match = self.memory_config_pattern.match(line)
        #     if match:
        #         name = match.group(1)
        #         origin = int(match.group(2), 16)
        #         length = int(match.group(3), 16)
        #         attributes = match.group(4) if match.group(4) else ""

    def __should_skip_line(self, line: str) -> bool:
        """Determine if a line should be skipped."""
        if not line:
            return True

        skip_prefixes = ("LOAD", "/DISCARD/", "Linker", "OUTPUT(")
        return any(line.startswith(prefix) for prefix in skip_prefixes)

    def __get_sections(self, lines: str) -> None:
        # Section regex for processing map as a continuous stream
        section_regex = re.compile(r"\n(?P<section>[a-zA-Z._]+)(\s+|\n)0x(?P<offset>[0-9a-fA-F]+)\s+0x(?P<size>[0-9a-fA-F/]+)(?P<comment>.*)")

        for match in section_regex.finditer(lines):
            section = match.group("section").strip()
            offset = int(match.group("offset"), 16)
            size = int(match.group("size"), 16)
            if offset and size:
                self.result.sections.append(
                    Section(
                        name=section,
                        address=offset,
                        size=size,
                        flags=match.group("comment").strip() if match.group("comment") else "",
                    )
                )

    def __get_symbols(self, lines: str) -> None:
        """Get symbols from the map file lines.
        This method extracts symbols from the map file lines and appends them to the result.
        Args:
            lines (str): The lines of the map file to process.
        """

        subsection_regex = re.compile(
            r"\n\s.(?P<name>[0-9a-zA-Z._]+)(\s+|\n)0x(?P<offset>[0-9a-f]+)\s+0x(?P<size>[0-9a-f]+)(\s+|\n)(?P<path>[a-zA-Z:\\\/_.\-0-9]+)\(*(?P<file>[a-zA-Z._0-9\-]*)\)*"
        )

        for match in subsection_regex.finditer(lines):
            name = match.group("name").strip()
            offset = int(match.group("offset"), 16)
            size = int(match.group("size"), 16)
            path = match.group("path").strip()
            file = match.group("file").strip()

            words = name.split(".")
            section = words[0]

            if len(words) > 2:
                symbol_name = words[2]
            elif len(words) == 2:
                symbol_name = words[1]
            else:
                symbol_name = file.replace(".o", "")

            if not file:
                object_file = path
            else:
                object_file = file
            if offset and size:
                self.result.symbols.append(
                    Symbol(
                        name=symbol_name,
                        address=offset,
                        size=size,
                        type="function",
                        elf_section=section,
                        region="",
                        subregion="",
                        file=object_file,
                    )
                )

    def __process_map(self, map_lines: List[str]) -> None:
        """
        Process the memory map section of the file.

        This section contains information about sections and symbols.
        """
        # Filter out lines that should be skipped
        map_lines = [line.rstrip() for line in map_lines if not self.__should_skip_line(line)]
        lines = "\n".join(map_lines)

        self.__get_sections(lines)

        self.__get_symbols(lines)

    # these are the top level headers (at least so far) in arm-none-eabi-ld generated
    # memory maps.  We can key off of these to determine how the subsequent parsing
    # stages should proceed.  This is just a first cut. I don't think there is any guarantee
    # that other linkers will use the same headers, but this is a good start.
    gnu_map_file_headers = {
        "Archive member included to satisfy reference by file (symbol)": __process_archives,
        "Discarded input sections": __process_discarded,
        "Memory Configuration": __process_memory_config,
        "Linker script and memory map": __process_map,
    }

    def __init__(self, map_file_path: Path):
        """
        Initialize the parser with the path to a .map file.

        Args:
            map_file_path: Path to the .map file to parse
        """
        self.map_file_path = Path(map_file_path)

        self.archive_members: Dict[str, str] = {}  # Maps archive members to reference files

        super().__init__(file=map_file_path, cache=False)

    def run_system_command(self) -> None:
        with open(self.map_file_path, "r", encoding="utf-8", errors="ignore") as f:
            self.raw_data = f.read()

    def parse_output_into_results(self) -> None:
        """Parse the map file to extract memory regions, sections, and symbols."""

        # Find sections in the file based on headers
        def __chunk_lines_into_sections(content: str, headers: Dict[str, Any]) -> Dict[str, List[str]]:
            sections = {}
            current_header: str = ""
            current_lines: List[str] = []
            # Process the file content line by line to identify sections
            for line in content.splitlines():
                # Check if the line matches any of our known headers
                matched_header = None
                for header in headers:
                    if header in line:
                        matched_header = header
                        break

                if matched_header:
                    # If we found a new header, store the current section if any
                    if current_header:
                        sections[current_header] = current_lines

                    # Start a new section
                    current_header = matched_header
                    current_lines = [line]
                elif current_header:
                    # Add line to the current section
                    current_lines.append(line)

            # Don't forget to add the last section
            if current_header and current_lines:
                sections[current_header] = current_lines
            return sections

        sections = __chunk_lines_into_sections(self.raw_data, self.gnu_map_file_headers)

        # Process each section with its corresponding handler
        for header, lines in sections.items():
            handler_method = self.gnu_map_file_headers.get(header)
            if handler_method:
                handler_method(self, lines)
