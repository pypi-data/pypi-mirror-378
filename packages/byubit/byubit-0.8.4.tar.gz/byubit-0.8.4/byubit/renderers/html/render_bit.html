<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>%%TITLE%%</title>

    <!-- Include highlight.js for syntax highlighting -->
    <!--    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">-->
    <!--    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>-->
    <!--    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>-->

    <!-- Include CodeMirror CSS and JS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/codemirror.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/mode/python/python.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/theme/idea.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/addon/edit/closebrackets.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/addon/display/placeholder.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/addon/display/rulers.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/addon/selection/active-line.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/addon/edit/matchbrackets.min.js"></script>

    <style>
        .CodeMirror {
            border: 1px solid #ccc;
            height: 400px;
        }

        .highlighted-line {
            background-color: #f4e8aa;
        }
    </style>

    <script>
        let currentHighlightedLine = null;
        let editor = null;

        function highlightLine(lineNumber) {
            if (editor == null) {
                return;
            }
            if (currentHighlightedLine !== null) {
                editor.removeLineClass(currentHighlightedLine, 'background', 'highlighted-line');
            }
            currentHighlightedLine = lineNumber - 1; // CodeMirror line numbers are 0-based
            editor.addLineClass(currentHighlightedLine, 'background', 'highlighted-line');
            editor.scrollIntoView({line: currentHighlightedLine, ch: 0});
        }

        document.addEventListener('DOMContentLoaded', (event) => {
            editor = CodeMirror.fromTextArea(document.getElementById('code'), {
                mode: 'python',
                lineNumbers: true,
                readOnly: true,
                matchBrackets: true,
                autoCloseBrackets: true,
                styleActiveLine: true,
                theme: 'idea',
            });
        });


    </script>

    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            font-family: Arial, sans-serif;
        }

        h1 {
            font-size: 24pt;
            font-family: monospace, sans-serif;
            font-weight: bold;
        }

        h2 {
            font-size: 12pt;
        }

        .bit-viewer {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin: 0;
            font-family: Arial, sans-serif;
        }

        .bit-outer {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        #tabs {
            clear: both;
            margin-top: 20px;
        }

        .tab {
            display: inline-block;
            padding: 10px;
            border: 1px solid #ccc;
            cursor: pointer;
        }

        .tab-content {
            display: none;
            border: 1px solid #ccc;
            padding: 10px;
            margin-top: 10px;
        }

        .active-tab {
            background-color: #f0f0f0;
        }

        .active-content {
            display: block;
        }

        .grid {
            display: grid;
            gap: 1px;
        }

        .cell {
            width: 50px;
            height: 50px;
            border: 1px solid black;
            position: relative;
        }

        .triangle {
            width: 0;
            height: 0;
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-bottom: 20px solid cyan;
            position: absolute;
            top: 15px;
            left: 15px;
        }

        .triangle.right {
            transform: rotate(90deg);
        }

        .triangle.up {
            transform: rotate(0deg);
        }

        .triangle.left {
            transform: rotate(-90deg);
        }

        .triangle.down {
            transform: rotate(180deg);
        }

        .triangle.wrong {
            border-bottom: 20px solid #8bbab5;
        }

        .annotation {
            width: 20px;
            height: 30px;
            border-radius: 50%;
            position: absolute;
            top: 0;
            right: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white; /* Change text color as needed */
            font-weight: bold;
        }

        .record-info {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .error-message {
            color: red;
        }

        #button-container button, #tabs button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            background-color: #007BFF;
            color: white;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        #button-container button:hover {
            background-color: #0056b3;
        }

        #tabs button {
            background-color: #8cb590;
        }

        #tabs button.has-error {
            background-color: #cc3f42;
        }

        #tabs button:hover {
            background-color: #6e9176;
        }

        #tabs button.has-error:hover {
            background-color: rgb(166, 54, 57);
        }

        #tabs button.active {
            border: 2px solid #111211;
        }

        #record-info {
            font-size: large;
            padding: 10pt;
        }

    </style>
</head>
<body>

<h1>%%TITLE%%</h1>
<h2>Run at: %%TIMESTAMP%%</h2>

<div class="bit-outer">
    <div class="bit-viewer">
        <div id="tabs"></div>
        <div id="world-container"></div>
        <div id="button-container"></div>
        <div id="record-info"></div>
    </div>

    <div>
    <textarea id="code" name="code">
%%CODE%%
    </textarea>
    </div>
</div>

<script>
    let currentTab = null;
    let currentIndex = {};

    function hasError(history) {
        return history[history.length - 1].error_message != null;
    }

    function createTabs() {
        const tabsContainer = document.getElementById('tabs');
        tabsContainer.innerHTML = ''; // Clear existing tabs
        Object.keys(data).forEach(key => {
            const tabButton = document.createElement('button');
            tabButton.innerText = key;
            tabButton.className = 'tab-button';

            if (key === currentTab) {
                tabButton.classList.add('active');
            }

            if (hasError(data[key])) {
                tabButton.classList.add('has-error');
            }

            tabButton.onclick = () => switchTab(key);
            tabsContainer.appendChild(tabButton);
            currentIndex[key] = data[key].length - 1;
        });

        if (!currentTab) {
            currentTab = Object.keys(data)[0];
            switchTab(currentTab);
        }
    }


    function drawButtons() {
        const firstButton = document.createElement('button');
        firstButton.innerText = 'First';
        firstButton.classList.add('button');
        firstButton.onclick = () => {
            currentIndex[currentTab] = 0;
            renderWorld();
        };

        const prevButton = document.createElement('button');
        prevButton.innerText = 'Previous';
        prevButton.classList.add('button');
        prevButton.onclick = () => {
            if (currentIndex[currentTab] > 0) {
                currentIndex[currentTab]--;
                renderWorld();
            }
        };

        const nextButton = document.createElement('button');
        nextButton.innerText = 'Next';
        nextButton.classList.add('button');
        nextButton.onclick = () => {
            if (currentIndex[currentTab] < data[currentTab].length - 1) {
                currentIndex[currentTab]++;
                renderWorld();
            }
        };

        const lastButton = document.createElement('button');
        lastButton.innerText = 'Last';
        lastButton.classList.add('button');
        lastButton.onclick = () => {
            currentIndex[currentTab] = data[currentTab].length - 1;
            renderWorld();
        };


        let prevSnapButton = null;
        let nextSnapButton = null;

        const hasSnapshots = data[currentTab].some((event, pos) => event.name.startsWith('snapshot'));

        if (hasSnapshots) {
            prevSnapButton = document.createElement('button');
            prevSnapButton.innerText = '<< Jump';
            prevSnapButton.classList.add('button');
            prevSnapButton.onclick = () => {
                const snapshots = data[currentTab]
                    .slice(0, currentIndex[currentTab])
                    .map((event, pos) => {
                        if (event.name.startsWith('snapshot')) {
                            return pos;
                        }
                    })
                    .filter(pos => pos !== undefined);
                currentIndex[currentTab] = snapshots.length ? snapshots[snapshots.length - 1] : 0;
                renderWorld();
            };

            nextSnapButton = document.createElement('button');
            nextSnapButton.innerText = 'Jump >>';
            nextSnapButton.classList.add('button');
            nextSnapButton.onclick = () => {
                const snapshots = data[currentTab]
                    .slice(currentIndex[currentTab] + 1, data[currentTab].length)
                    .map((event, pos) => {
                        if (event.name.startsWith('snapshot')) {
                            return pos + currentIndex[currentTab] + 1;
                        }
                    })
                    .filter(pos => pos !== undefined);
                currentIndex[currentTab] = snapshots.length ? snapshots[0] : data[currentTab].length - 1;
                renderWorld();
            };
        }

        function debounce(func, wait) {
            let timeout;
            return function (...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), wait);
            };
        }

        document.addEventListener('keydown', debounce((event) => {
            switch (event.key) {
                case 'ArrowLeft':
                case 'p':
                    prevButton.click();
                    break;
                case 'ArrowRight':
                case 'n':
                    nextButton.click();
                    break;
                case 'ArrowUp':
                    nextSnapButton.click();
                    break;
                case 'ArrowDown':
                    prevSnapButton.click();
                    break;
                case 'f':
                    firstButton.click();
                    break;
                case 'l':
                    lastButton.click();
                    break;
            }
        }, 1));

        const buttonContainer = document.getElementById('button-container');
        buttonContainer.innerHTML = '';
        buttonContainer.appendChild(firstButton);
        if (hasSnapshots) {
            buttonContainer.appendChild(prevSnapButton);
        }
        buttonContainer.appendChild(prevButton);
        buttonContainer.appendChild(nextButton);
        if (hasSnapshots) {
            buttonContainer.appendChild(nextSnapButton);
        }
        buttonContainer.appendChild(lastButton);
    }

    function switchTab(tab) {
        currentTab = tab;
        const tabsContainer = document.getElementById('tabs');
        Array.from(tabsContainer.children).forEach(button => {
            button.classList.remove('active');
            if (button.innerText === tab) {
                button.classList.add('active');
            }
        });
        renderWorld();
    }

    const MAX_GRID_WIDTH = 600; // Maximum width in pixels
    const MAX_GRID_HEIGHT = 400; // Maximum height in pixels

    function renderWorld() {
        const record = data[currentTab][currentIndex[currentTab]];

        // Update record title
        const recordInfo = document.getElementById('record-info');
        recordInfo.innerHTML = `<div class="record-info">${record.name} (line ${record.line_number})`
        if (record.error_message != null) {
            recordInfo.innerHTML += ` <span class="error-message">${record.error_message}</span>`
        }
        recordInfo.innerHTML += '</div>'

        highlightLine(record.line_number);

        const worldData = record.world;
        const pos = record.pos;
        const orientation = record.orientation;

        if (worldData == null) {
            return;
        }

        // Calculate cell size
        const rows = worldData.length;
        const cols = worldData[0].length;
        const cellWidth = Math.min(MAX_GRID_WIDTH / cols, MAX_GRID_HEIGHT / rows);
        const cellHeight = cellWidth; // Keep cells square

        const triangleSize = cellWidth * 0.25; // Adjust the factor as needed

        // Draw world grid
        const worldContainer = document.getElementById('world-container');
        worldContainer.innerHTML = '';
        const grid = document.createElement('div');
        grid.className = 'grid';
        grid.style.gridTemplateColumns = `repeat(${cols}, ${cellWidth}px)`;
        grid.style.gridTemplateRows = `repeat(${rows}, ${cellHeight}px)`;
        for (let row = rows - 1; row >= 0; row--) {
            for (let col = 0; col < cols; col++) {
                const cellColor = worldData[row][col];
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.style.width = `${cellWidth}px`;
                cell.style.height = `${cellHeight}px`;
                cell.style.backgroundColor = cellColor;
                if (row === pos[0] && col === pos[1]) {
                    const triangle = document.createElement('div');
                    triangle.className = 'triangle';
                    triangle.style.borderLeft = `${triangleSize}px solid transparent`;
                    triangle.style.borderRight = `${triangleSize}px solid transparent`;
                    triangle.style.borderBottom = `${triangleSize * 2}px solid cyan`;
                    triangle.style.top = `${(cellHeight - triangleSize * 2) / 2}px`;
                    triangle.style.left = `${(cellWidth - triangleSize * 2) / 2}px`;
                    switch (orientation) {
                        case 0:
                            triangle.classList.add('right');
                            break;
                        case 1:
                            triangle.classList.add('up');
                            break;
                        case 2:
                            triangle.classList.add('left');
                            break;
                        case 3:
                            triangle.classList.add('down');
                            break;
                    }
                    cell.appendChild(triangle);
                }

                // Add annotation, if any
                if (record.annotations != null && record.annotations[0][row][col] !== cellColor) {
                    // Add color warning
                    const annotation = record.annotations[0][row][col];
                    const acell = document.createElement('div');
                    acell.textContent = '!';
                    acell.style.backgroundColor = annotation;
                    if (annotation === "white") {
                        acell.style.color = "black";
                    }
                    acell.className = 'annotation';
                    cell.appendChild(acell);
                }

                // Add bit-wrong-location warning
                if (
                    record.annotations != null
                    && record.annotations[1][0] === row
                    && record.annotations[1][1] === col
                    && (
                        record.annotations[1][0] !== pos[0]
                        || record.annotations[1][1] !== pos[1]
                    )
                ) {
                    const triangle = document.createElement('div');
                    triangle.className = 'triangle';
                    triangle.style.borderLeft = `${triangleSize}px solid transparent`;
                    triangle.style.borderRight = `${triangleSize}px solid transparent`;
                    triangle.style.borderBottom = `${triangleSize * 2}px solid #8bbab5`;
                    triangle.style.top = `${(cellHeight - triangleSize * 2) / 2}px`;
                    triangle.style.left = `${(cellWidth - triangleSize * 2) / 2}px`;
                    switch (orientation) {
                        case 0:
                            triangle.classList.add('right');
                            break;
                        case 1:
                            triangle.classList.add('up');
                            break;
                        case 2:
                            triangle.classList.add('left');
                            break;
                        case 3:
                            triangle.classList.add('down');
                            break;
                    }
                    triangle.classList.add('wrong');
                    cell.appendChild(triangle);
                }

                grid.appendChild(cell);
            }
        }
        worldContainer.appendChild(grid);
    }

    function render() {
        // data = JSON.parse(bit_results);
        if (Object.keys(data).length === 0) {
            return;
        }
        createTabs();
        renderWorld();
        drawButtons();
    }
</script>

<script>
    const data = "%%DATA%%";
    render();
</script>

</body>
</html>
