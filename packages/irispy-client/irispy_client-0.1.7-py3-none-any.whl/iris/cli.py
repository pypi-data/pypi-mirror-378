import argparse
import os
import sys
import getpass
import pathlib
import shutil # For checking python executable
import subprocess # To run systemctl commands
import tempfile # For writing service file with sudo

# Assuming PyKV is in iris.util.pykv
# This import relies on your package 'iris' being installed or on PYTHONPATH
try:
    from iris.util.pykv import PyKV
except ImportError:
    print("Error: Could not import PyKV. Make sure the 'iris' package is installed correctly.")
    print("You might need to run 'pip install .' or 'pip install -e .' in your package directory.")
    sys.exit(1)


# --- PyKV instance ---
# PyKV is a singleton. It will use "iris.db" in the CWD by default.
kv = PyKV()

# --- Content for irispy.py (to be created by 'init') ---
IRIS_PY_CONTENT = """
from iris import Bot, ChatContext, IrisLink
import sys

if len(sys.argv) < 2:
    print("Usage: python iris.py 172.30.10.66:3000")
    sys.exit(1)
iris_url = sys.argv[1]
bot = Bot(iris_url)
#bot.iris_url은 정제된 주소(IP:PORT 형식)
kl = IrisLink(bot.iris_url)

#메시지 감지
@bot.on_event("message")
def on_message(chat: ChatContext):
    match chat.message.command:
        case "!hi":
            chat.reply(f"Hello, {chat.sender.name}!")

#입장감지
@bot.on_event("new_member")
def on_newmem(chat: ChatContext):
    #chat.reply(f"Hello {chat.sender.name}")
    pass

#퇴장감지
@bot.on_event("del_member")
def on_delmem(chat: ChatContext):
    #chat.reply(f"Bye {chat.sender.name}")
    pass

@bot.on_event("error")
def on_error(err):
    print(f"{err.event} 이벤트에서 오류가 발생했습니다: {err.exception}")

if __name__ == "__main__":
    bot.run()
"""

# --- Content for systemd service file ---
SYSTEMD_SERVICE_TEMPLATE = """# generated by iris-cli
[Unit]
Description=iris-py Service
After=network.target

[Service]
User={user}
Group={group}
WorkingDirectory={cwd}
EnvironmentFile={env_file_path}
ExecStart={python_executable} {iris_py_script} {iris_endpoint}
Restart=always
RestartSec=3s

[Install]
WantedBy=multi-user.target
"""

DEFAULT_SERVICE_NAME = "iris.service"

def _get_service_name():
    """Reads the service name from .env or returns the default."""
    env_path = pathlib.Path.cwd() / ".env"
    service_name = DEFAULT_SERVICE_NAME
    if env_path.exists():
        try:
            with open(env_path, "r", encoding="utf-8") as f:
                for line in f:
                    line = line.strip()
                    if line.startswith("IRIS_SERVICE_NAME="):
                        parts = line.split("=", 1)
                        if len(parts) == 2:
                            # Basic stripping, handle potential quotes
                            name = parts[1].strip().strip("'\"")
                            if name:
                                service_name = name
                                print(f"Using service name '{service_name}' from .env")
                                return service_name
            print(f"Warning: IRIS_SERVICE_NAME not found in {env_path}. Using default: '{DEFAULT_SERVICE_NAME}'.")
        except Exception as e:
            print(f"Warning: Could not read .env file to find service name: {e}. Using default: '{DEFAULT_SERVICE_NAME}'.")
    else:
        print(f"Info: .env file not found in {pathlib.Path.cwd()}. Using default service name: '{DEFAULT_SERVICE_NAME}'.")
    return service_name

def _run_systemctl_command(action, service_name, use_sudo=True, capture_output=False):
    """Helper to run systemctl commands."""
    command = ["systemctl", action, service_name]
    if use_sudo:
        command.insert(0, "sudo")

    print(f"Running command: {' '.join(command)}")
    try:
        result = subprocess.run(
            command,
            check=False, # Don't raise exception on non-zero exit code
            capture_output=capture_output,
            text=True # Decode stdout/stderr as text
        )
        if capture_output:
            print(result.stdout)
            if result.stderr:
                 print("STDERR:")
                 print(result.stderr, file=sys.stderr)

        if result.returncode != 0:
            print(f"Error: Command failed with exit code {result.returncode}", file=sys.stderr)
            return False
        return True
    except FileNotFoundError:
        print("Error: 'systemctl' command not found. Are you on a system using systemd?", file=sys.stderr)
        return False
    except Exception as e:
        print(f"An error occurred while running systemctl command: {e}", file=sys.stderr)
        return False

def handle_init(args):
    cwd = pathlib.Path.cwd()
    iris_py_path = cwd / "irispy.py"
    db_filename = "iris.db" # PyKV default
    env_path = cwd / ".env"

    # Create irispy.py
    if iris_py_path.exists() and not args.force:
        print(f"'irispy.py' already exists in {cwd}. Use --force to overwrite.")
    else:
        try:
            with open(iris_py_path, "w", encoding="utf-8") as f:
                f.write(IRIS_PY_CONTENT)
            print(f"Created 'irispy.py' in {cwd}")
        except Exception as e:
            print(f"Error writing irispy.py: {e}", file=sys.stderr)


    # Initialize iris.db and admin/ban lists
    # PyKV's _get_db() will create the DB and table if not exists.
    # We use the default filename "iris.db" which will be in CWD.
    print(f"Ensuring '{db_filename}' exists and is initialized in {cwd}.")

    try:
        admins = kv.get("admin")
        if not isinstance(admins, list): # Covers False (not found) or wrong type
            kv.put("admin", [])
            print("Initialized 'admin' list in iris.db.")
        else:
            print("'admin' list already exists or is initialized.")

        banned_users = kv.get("ban")
        if not isinstance(banned_users, list):
            kv.put("ban", [])
            print("Initialized 'ban' list in iris.db.")
        else:
            print("'ban' list already exists or is initialized.")
    except Exception as e:
         print(f"Error initializing iris.db: {e}", file=sys.stderr)
         print("DB operations might fail.", file=sys.stderr)


    # Create .env file
    if env_path.exists() and not args.force:
        print(f"'.env' already exists in {cwd}. Use --force to overwrite.")
    else:
        try:
            with open(env_path, "w", encoding="utf-8") as f:
                f.write(f"# Environment variables for your iris project\n")
                f.write(f"# You can define your service name here: IRIS_SERVICE_NAME={DEFAULT_SERVICE_NAME}\n")
                f.write(f"# Add other variables your irispy.py script might need:\n")
                f.write("# SOME_API_KEY=your_key\n")
            print(f"Created '.env' file in {cwd}")
        except Exception as e:
             print(f"Error writing .env: {e}", file=sys.stderr)

    print("\nIris initialization complete.")
    print(f"Project files ({iris_py_path.name}, {db_filename}, {env_path.name}) are in: {cwd}")
    print(f"Note: Ensure the 'iris' Python package (with Bot, ChatContext, IrisLink)")
    print(f"is installed in the Python environment used to run '{iris_py_path.name}'.")
    print(f"You may need to adjust '{iris_py_path.name}' for specific 'IrisLink' setup.")


def handle_kakaolink(args):
    config = {"app_key": args.app_key, "origin": args.origin}
    try:
        kv.put("kakaolink_config", config)
        print(f"Kakaolink config stored in iris.db: app_key='{args.app_key}', origin='{args.origin}'")
    except Exception as e:
        print(f"Error storing Kakaolink config: {e}", file=sys.stderr)


def _manage_user_list(list_key, action, user_id=None):
    try:
        current_list = kv.get(list_key)
        if not isinstance(current_list, list): # Handles key not found (False) or incorrect type
            current_list = []

        if action == "add":
            if user_id is None: # Should be caught by argparse setup
                print(f"Error: User ID is required for the '{action}' action.", file=sys.stderr)
                return
            if user_id in current_list:
                print(f"User '{user_id}' is already in the {list_key} list.")
            else:
                current_list.append(user_id)
                kv.put(list_key, current_list)
                print(f"User '{user_id}' added to the {list_key} list.")
        elif action == "del":
            if user_id is None: # Should be caught by argparse setup
                print(f"Error: User ID is required for the '{action}' action.", file=sys.stderr)
                return
            if user_id in current_list:
                current_list.remove(user_id)
                kv.put(list_key, current_list)
                print(f"User '{user_id}' removed from the {list_key} list.")
            else:
                print(f"User '{user_id}' not found in the {list_key} list.")
        elif action == "list": # This is specifically for "admin list" (lists all admins)
            if current_list:
                print(f"{list_key.capitalize()} list:")
                for item in current_list:
                    print(f"- {item}")
            else:
                print(f"The {list_key} list is empty.")
    except Exception as e:
         print(f"Error managing {list_key} list: {e}", file=sys.stderr)


def handle_admin_commands(args):
    # getattr is used because 'user_id' is not present for 'list' action
    _manage_user_list("admin", args.admin_action, getattr(args, 'user_id', None))


def handle_ban_commands(args):
    if args.ban_action == "list":
        # This handles "iris ban list <user_id>" (check specific user)
        user_id_to_check = args.user_id # 'user_id' is a required arg for 'ban list'
        try:
            banned_list = kv.get("ban")
            if not isinstance(banned_list, list):
                banned_list = [] # Treat as empty if not found or invalid type

            if user_id_to_check in banned_list:
                print(f"User '{user_id_to_check}' IS in the ban list.")
            else:
                print(f"User '{user_id_to_check}' is NOT in the ban list.")
        except Exception as e:
            print(f"Error checking ban list: {e}", file=sys.stderr)

    else: # For 'add' and 'del' actions
        _manage_user_list("ban", args.ban_action, args.user_id)


# --- Service Handlers ---

def handle_service_create(args):
    cwd = pathlib.Path.cwd().resolve()
    default_iris_py_script = cwd / "irispy.py"
    default_env_file = cwd / ".env"
    # Adjust default python executable based on common venv location
    default_python_executable = cwd / "venv" / "bin" / "python"

    print("--- Systemd Service File Creation ---")
    print(f"Using current directory as WorkingDirectory: {cwd}")

    iris_endpoint = input(f"Enter Iris endpoint for irispy.py (e.g., '127.0.0.1:8000'): ").strip()
    if not iris_endpoint:
        print("Iris endpoint is required. Aborting.", file=sys.stderr)
        return

    service_name = input(f"Enter desired systemd service name [default: {DEFAULT_SERVICE_NAME}]: ").strip() or DEFAULT_SERVICE_NAME
    # Suggest saving the name to .env
    print(f"Suggestion: Add 'IRIS_SERVICE_NAME={service_name}' to your .env file for future use.")


    user = getpass.getuser()
    try:
        import grp
        group = grp.getgrgid(os.getgid()).gr_name
    except (ImportError, KeyError): # KeyError if GID not found
        group = user
        print(f"Warning: Could not determine primary group for user '{user}'. Using '{user}' as group.")
        print("This might need manual adjustment in the service file on some Linux systems.")

    python_executable = input(f"Python executable path [default: {default_python_executable}]: ").strip() or str(default_python_executable)
    iris_py_script_str = input(f"Path to irispy.py script [default: {default_iris_py_script}]: ").strip() or str(default_iris_py_script)
    env_file_path_str = input(f"Path to .env file [default: {default_env_file}]: ").strip() or str(default_env_file)

    iris_py_script = pathlib.Path(iris_py_script_str).resolve()
    env_file_path = pathlib.Path(env_file_path_str).resolve()

    # Basic validation of paths (warnings, not errors)
    if not shutil.which(str(python_executable)) and not python_executable.exists(): # Check PATH and direct existence
         print(f"Warning: Python executable not found or not executable at '{python_executable}'. The service may fail.")
    if not iris_py_script.exists():
        print(f"Warning: irispy.py script not found at '{iris_py_script}'. The service may fail.")
    if not env_file_path.exists():
        print(f"Warning: .env file not found at '{env_file_path}'. Consider running 'iris init'.")

    service_content = SYSTEMD_SERVICE_TEMPLATE.format(
        user=user,
        group=group,
        cwd=str(cwd),
        env_file_path=str(env_file_path),
        python_executable=str(python_executable),
        iris_py_script=str(iris_py_script),
        iris_endpoint=iris_endpoint
    )

    service_file_name = service_name # Use the chosen service name
    systemd_dir = pathlib.Path("/etc/systemd/system/")
    service_file_path = systemd_dir / service_file_name

    print("\n--- Generated service content ---")
    print(service_content.strip())
    print("--- End of content ---")

    print(f"\nAttempting to write service file to '{service_file_path}' (requires sudo).")

    # Write to a temporary file first, then use sudo to copy
    temp_file = None
    try:
        with tempfile.NamedTemporaryFile(mode='w', delete=False, encoding='utf-8') as temp_file:
             temp_file.write(service_content)
        temp_file_path = pathlib.Path(temp_file.name)

        # Use sudo cp to move the file into the systemd directory
        print(f"Using sudo to copy temporary file '{temp_file_path.name}' to '{service_file_path}'...")
        copy_cmd = ["sudo", "cp", str(temp_file_path), str(service_file_path)]
        copy_result = subprocess.run(copy_cmd, check=False, capture_output=True, text=True)

        if copy_result.returncode != 0:
            print(f"Error: Failed to copy service file using sudo.", file=sys.stderr)
            print(copy_result.stderr, file=sys.stderr)
            print("Please try running the command again with sudo, or manually copy the content.", file=sys.stderr)
            print(f"Manual copy command: sudo cp {temp_file_path} {service_file_path}", file=sys.stderr)
            # Don't delete temp file yet if manual copy is suggested
            # os.unlink(temp_file_path) # Clean up temp file on failure if not suggesting manual copy
            return False # Indicate failure
        else:
            print("Service file successfully copied with sudo.")
            os.unlink(temp_file_path) # Clean up temp file

    except PermissionError:
         print(f"Error: Permission denied to write to temporary file. This is unexpected.", file=sys.stderr)
         return False
    except Exception as e:
         print(f"An error occurred during temporary file handling or copy: {e}", file=sys.stderr)
         if temp_file and pathlib.Path(temp_file.name).exists():
              os.unlink(temp_file.name) # Clean up temp file if it exists
         return False


    # Daemon-reload
    print("\nReloading systemd manager configuration (requires sudo)...")
    if not _run_systemctl_command("daemon-reload", "", use_sudo=True): # daemon-reload doesn't take a service name
        print("Failed to reload systemd daemon. You may need to run 'sudo systemctl daemon-reload' manually.", file=sys.stderr)
        # Continue, but service won't be recognized until reload happens

    # Enable and Start
    print(f"\nService file '{service_file_name}' created at '{service_file_path}'.")
    enable_start_now = input(f"Do you want to enable and start the '{service_name}' service now? (yes/no): ").strip().lower()

    if enable_start_now == 'yes':
        print(f"\nEnabling service '{service_name}' (requires sudo)...")
        if _run_systemctl_command("enable", service_name, use_sudo=True):
            print(f"Service '{service_name}' enabled. It will start automatically on boot.")

            print(f"\nStarting service '{service_name}' (requires sudo)...")
            if _run_systemctl_command("start", service_name, use_sudo=True):
                print(f"Service '{service_name}' started successfully.")
                # Optional: show status immediately after successful start
                # print(f"\nStatus of service '{service_name}':")
                # _run_systemctl_command("status", service_name, use_sudo=True, capture_output=True)
            else:
                 print(f"Failed to start service '{service_name}'. Check status and logs for details.", file=sys.stderr)
                 print(f"  sudo systemctl status {service_name}", file=sys.stderr)
                 print(f"  journalctl -u {service_name}", file=sys.stderr)
        else:
            print(f"Failed to enable service '{service_name}'.", file=sys.stderr)
            print("You may need to run 'sudo systemctl enable {service_name}' manually.", file=sys.stderr)
    else:
        print("\nService not enabled or started automatically.")
        print(f"To enable: sudo systemctl enable {service_name}")
        print(f"To start: sudo systemctl start {service_name}")

    print(f"\nTo check status: sudo systemctl status {service_name}")
    print(f"To view logs: journalctl -u {service_name}")


def handle_service_start(args):
    service_name = _get_service_name()
    print(f"Attempting to start service '{service_name}'...")
    if _run_systemctl_command("start", service_name, use_sudo=True):
        print(f"Service '{service_name}' started successfully.")
    else:
        print(f"Failed to start service '{service_name}'. Check status for details.", file=sys.stderr)


def handle_service_stop(args):
    service_name = _get_service_name()
    print(f"Attempting to stop service '{service_name}'...")
    if _run_systemctl_command("stop", service_name, use_sudo=True):
        print(f"Service '{service_name}' stopped successfully.")
    else:
        print(f"Failed to stop service '{service_name}'. Check status for details.", file=sys.stderr)
        
def handle_service_restart(args):
    service_name = _get_service_name()
    print(f"Attempting to restart service '{service_name}'...")
    if _run_systemctl_command("restart", service_name, use_sudo=True):
        print(f"Service '{service_name}' restarted successfully.")
    else:
        print(f"Failed to restart service '{service_name}'. Check status for details.", file=sys.stderr)

def handle_service_status(args):
    service_name = _get_service_name()
    print(f"Getting status for service '{service_name}'...")
    # Status command output is usually what the user wants to see directly
    _run_systemctl_command("status", service_name, use_sudo=True, capture_output=True)


# --- Main Parser Setup ---

def main():
    parser = argparse.ArgumentParser(
        description="Iris CLI: Manage Iris configurations, project initialization, and services.",
        formatter_class=argparse.RawTextHelpFormatter
    )
    subparsers = parser.add_subparsers(dest="command", required=True, help="Top-level commands. Use <command> -h for more help.")

    # --- iris init ---
    parser_init = subparsers.add_parser("init", help="Initialize an Iris project in the current directory (creates irispy.py, iris.db, .env).")
    parser_init.add_argument("--force", action="store_true", help="Overwrite irispy.py and .env if they already exist.")
    parser_init.set_defaults(func=handle_init)

    # --- iris kakaolink ---
    parser_kakaolink = subparsers.add_parser("kakaolink", help="Configure Kakaolink settings in iris.db.")
    parser_kakaolink.add_argument("app_key", help="Your Kakaolink application key.")
    parser_kakaolink.add_argument("origin", help="Your Kakaolink service origin URL (e.g., https://example.com).")
    parser_kakaolink.set_defaults(func=handle_kakaolink)

    # --- iris admin ---
    parser_admin = subparsers.add_parser("admin", help="Manage admin user IDs stored in iris.db.")
    admin_subparsers = parser_admin.add_subparsers(dest="admin_action", required=True, help="Action for admin users.")

    admin_add = admin_subparsers.add_parser("add", help="Add a user to the admin list.")
    admin_add.add_argument("user_id", type=int, help="The ID of the user to add as admin.")
    admin_add.set_defaults(func=handle_admin_commands)

    admin_del = admin_subparsers.add_parser("del", help="Remove a user from the admin list.")
    admin_del.add_argument("user_id", type=int, help="The ID of the user to remove from admin.")
    admin_del.set_defaults(func=handle_admin_commands)

    admin_list = admin_subparsers.add_parser("list", help="List all admin user IDs.")
    admin_list.set_defaults(func=handle_admin_commands)

    # --- iris ban ---
    parser_ban = subparsers.add_parser("ban", help="Manage banned user IDs stored in iris.db.")
    ban_subparsers = parser_ban.add_subparsers(dest="ban_action", required=True, help="Action for banned users.")

    ban_add = ban_subparsers.add_parser("add", help="Add a user to the ban list.")
    ban_add.add_argument("user_id", type=int, help="The ID of the user to ban.")
    ban_add.set_defaults(func=handle_ban_commands)

    ban_del = ban_subparsers.add_parser("del", help="Remove a user from the ban list.")
    ban_del.add_argument("user_id", type=int, help="The ID of the user to unban.")
    ban_del.set_defaults(func=handle_ban_commands)

    # Per specification: "iris ban list <user_id>" checks a specific user
    ban_list = ban_subparsers.add_parser("list", help="Check if a specific user is in the ban list.")
    ban_list.add_argument("user_id", type=int, help="The ID of the user to check ban status for.")
    ban_list.set_defaults(func=handle_ban_commands)

    # --- iris service ---
    parser_service = subparsers.add_parser("service", help="Manage the systemd service for Iris.")
    service_subparsers = parser_service.add_subparsers(dest="service_action", required=True, help="Service operation.")

    service_create_parser = service_subparsers.add_parser("create", help="Create a systemd service file (requires sudo).")
    service_create_parser.set_defaults(func=handle_service_create)

    service_start_parser = service_subparsers.add_parser("start", help="Start the iris systemd service (requires sudo).")
    service_start_parser.set_defaults(func=handle_service_start)

    service_stop_parser = service_subparsers.add_parser("stop", help="Stop the iris systemd service (requires sudo).")
    service_stop_parser.set_defaults(func=handle_service_stop)
    
    service_stop_parser = service_subparsers.add_parser("restart", help="Restart the iris systemd service (requires sudo).")
    service_stop_parser.set_defaults(func=handle_service_restart)

    service_status_parser = service_subparsers.add_parser("status", help="Show the status of the iris systemd service (requires sudo).")
    service_status_parser.set_defaults(func=handle_service_status)


    args = parser.parse_args()

    if hasattr(args, 'func'):
        try:
            args.func(args)
        except Exception as e:
            print(f"An unexpected error occurred: {e}", file=sys.stderr)
            sys.exit(1)
    else:
        parser.print_help()